morphlines :[
  {
    id: VPN_ASA_CISCO_NoEventCodes
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [

      #2014-12-14T00:17:26.000+00:00|device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group <GeneralHybrid> User <tzurkan> IP <73.189.60.63> IPv4 Address <10.72.116.99> IPv6 address <2001:4998:effd:7801::1273> assigned to session
      {
        split {
          inputField : message
          outputFields : [date_time,messageData]
          separator : "|"
        }
      }

      {
        # filter only messages containing required strings in them,
        # all others will be discarded in the dropRecord command below
        grok {
          findSubstrings : true
          addEmptyStrings : true
          numRequiredMatches : all
          expressions : {
            messageData : """(?<type>(First TCP SVC connection established|assigned to session|Session disconnected|User authentication failed|user authentication Rejected))"""
          }
        }
      }

      {
        EmptyObjectFilter {
          filterFields: [date_time,type]
        }
      }

      {
        setValues {
          date_time_unix: "@{date_time}"
          reporting_server : "reporting_server"	# Currently we don't use different TZs for different hostnames. This field just shouldn't be null.
        }
      }

      {
        GetTimezone {
          sourceType: "vpn"
          hostnameField: reporting_server
          timezoneOutputField: timezone_output
        }
      }

      {
        convertTimestampFortscale {
          field: date_time_unix
          # 2014-12-23T00:00:03.000+00:00
          inputFormats: ["yyyy-MM-dd'T'HH:mm:ss.SSSXXX"]
          inputTimezoneField: timezone_output
          outputFormat: "unixTimeInSeconds"
        }
      }

      {
        convertTimestampFortscale {
          field : date_time
          # 2014-12-23T00:00:04.000+00:00
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ss.SSSXXX"]
          inputTimezoneField : timezone_output
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }


      # Handle 'First TCP SVC connection established' events, that indicate a new session is about to start.
      # We'll store the event keys in cache, and when the 'assigned to session' message arrive, will treat it as a new session
      # device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group <GeneralHybrid> User <poorman> IP <117.248.225.69> First TCP SVC connection established for SVC session.
      {
        if {
          conditions: [{equals {type : ["First TCP SVC connection established"]}}]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{START_USERNAME:username}|%{START_SOURCEIP:source_ip}"
                }
              }
            }

            { toString { field : username, trim : true } }

            {
              EmptyObjectFilter {
                filterFields: [username,source_ip]
              }
            }

            {
              setValues {
                fake_session: "@{type}"
              }
            }

            # keep in the cache
            {
              EventsJoiner {
                keys: ["username", "source_ip"]
                mergeFields: []
                cacheName: "vpn"
                timeThreshold: -1
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
                processRecord: false
              }
            }

          ]
        }
      }



      # device-id=gi-0-1.rav1-1-gci.corp.sg3.fortscale.com Group <FinanceHybrid> User <mgoldin> IP <122.107.212.60> IPv4 Address <10.80.230.6> IPv6 address <2406:2000:efa6:7a02::1001> assigned to session
      {
        if {
          conditions: [{equals {type : ["assigned to session"]}}]
          then: [

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{START_USERNAME:username}|%{START_SOURCEIP:source_ip}|%{START_LOCALIP:local_ip}"
                }
              }
            }

            { toString { field : username, trim : true } }

            {
              EmptyObjectFilter {
                filterFields: [username,source_ip,local_ip]
              }
            }

            # Retrieve from cache
            {
              EventsJoinerMerge {
                keys: ["username", "source_ip"]
                mergeFields: []
                timeField : date_time_unix
                timeToCacheMiliSec : 60
                dropFromCache: true
                dropWhenNoMatch: true
                cacheName: "vpn"
              }
            }

            {
              setValues {
                status: ["SUCCESS"]
              }
            }

          ]
        }
      }



      # device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group = GeneralHybrid, Username = chetd, IP = 12.189.100.233, Session disconnected. Session Type: SSL, Duration: 1h:27m:43s, Bytes xmt: 138239099, Bytes rcv: 3071059, Reason: Idle Timeout
      {
        if {
          conditions: [{equals {type : ["Session disconnected"]}}]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{END_USERNAME:username}|%{END_SOURCEIP:source_ip}|%{END_DURATION:durationStr}|%{END_READBYTES:readbytes}|%{END_WRITEBYTES:writebytes}"
                }
              }
            }

            { toString { field : username, trim : true } }

            {
              EmptyObjectFilter {
                filterFields: [source_ip, username]
              }
            }

            {
              if {
                conditions: [
                  { equals {readbytes:  ["0"]}}
                  { equals {writebytes: ["0"]}}
                ]
                then: [
                  { dropRecord {} }
                ]
              }
            }

            {
              setValues {
                status: ["CLOSED"]
              }
            }
          ]
        }
      }



      # device-id=rav1-1-gci.corp.ne1.fortscale.com AAA user authentication Rejected : reason = AAA failure : server = 67.195.88.201 : user = kmcandrew
      {
        if {
          conditions: [{equals {type : ["user authentication Rejected"]}}]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{REJECT_USERNAME:username}|%{REJECT_SOURCEIP:source_ip}"
                }
              }
            }

            { toString { field : username, trim : true } }

            {
              setValues {
                status: ["FAIL"]
              }
            }

            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }
          ]
        }
      }



      # device-id=rav2-1-gci.corp.bf1.fortscale.com User authentication failed: Uname: jsummers
      {
        if {
          conditions: [{equals {type : ["User authentication failed"]}}]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{FAIL_USERNAME:username}"
                }
              }
            }

            { toString { field : username, trim : true } }

            {
              setValues {
                status: ["FAIL"]
              }
            }

            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }
          ]
        }
      }



      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }

      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }

      {
        if {
          conditions : [{equals {status: ["CLOSED"]}}]
          then : [
            {
              EmptyObjectFilter {
                filterFields: [source_ip,readbytes, writebytes]
              }
            }

            {
              java {
                imports : ""
                code: """
					String durationStr = (String)record.getFirstValue("durationStr");
					try{
					if (durationStr != null) {
						long duration = 0;
						int startInd = 0;
						int endInd = durationStr.indexOf("d", startInd);
						if(endInd > -1){
							duration += 24*3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+1;
						}
						endInd = durationStr.indexOf("h:", startInd);
						if(endInd > -1){
							duration += 3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+2;
						}
						endInd = durationStr.indexOf("m:", startInd);
						if(endInd > -1){
							duration += 60*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+2;
						}
						endInd = durationStr.indexOf("s", startInd);
						if(endInd > -1){
							duration += Long.parseLong(durationStr.substring(startInd, endInd).trim());
						}
						if(duration > 0){
							record.replaceValues("duration", duration);
						}
					}
					} catch(Exception e){}
					return child.process(record);
					"""
              }
            }



          ]
        }
      }

    ]
  }
]
