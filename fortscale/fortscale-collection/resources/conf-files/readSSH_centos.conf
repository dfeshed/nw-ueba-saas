morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [ 
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<status>(Accepted|Failed(?= \w+ for \w+ from )))"""
										}
									}
								}
							]
						}
						{
							commands : [
								{	logDebug	{	format : "Record doesn't meet legitimate ssh format. Dropping record: {}", args : ["@{}"] } }
								{	dropRecord {} }
							]
						}
					]
				}
			}	
		
			{
				grok {
					dictionaryFiles : [resources/grok-dictionaries/ssh.sshd.conf]
					expressions : {
						message : "%{DHCP_IP:source_ip}|%{TARGET_MACHINE:target_machine}|%{DHCP_DATE:date_time}|%{USERNAME:username}|%{AUTH_METHOD:auth_method}|%{TIMEZONE:timezone}"
					}
					findSubstrings : true
					numRequiredMatches : all				
				}
			}

			{
				EmptyObjectFilter {
					filterFields : [username,source_ip,target_machine,date_time]
				}
			}

			#the first overflow filter command insures that the overflow is not caused by a single user in the system
			{
				OverFlowFilter {
					eventsType : ssh
					criteria : [username]
					threshold : 100000
				}

			}
			{
				OverFlowFilter {
					eventsType : ssh
					criteria : []
					threshold : 1000000
				}
			}

			
			{
                tryRules {
                    catchExceptions : true
                    throwExceptionIfAllRulesFailed : false
                    rules : [
                    {
                        commands : [
                        {
                            findReplace {
                                field : source_ip
                                pattern : "::ffff:"
                                isRegex : false
                                replacement : ""
                                replaceFirst : false
                            }
                        }
                        {
                            findReplace {
                                field : source_ip
                                pattern : "::1"
                                isRegex : false
                                replacement : "@{target_machine}"
                                replaceFirst : false
                            }
                        }
                        {
                            findReplace {
                                field : source_ip
                                pattern : "127.0.0.1"
                                isRegex : false
                                replacement : "@{target_machine}"
                                replaceFirst : false
                            }
                        }
                        ]
                    }
                    ]
                }
            }
			
			{
				if {
				  conditions : [
					{ equals { timezone : [] }}
				  ]
				  then : [
					{
						GetTimezone {
							sourceType : "ssh"
							hostnameField : reporting_server
							timezoneOutputField : timezone_input
						}
					}
				  ]
				  else : [
					{
						addValues {
							timezone_input : "@{timezone}"
						}
					}
				  ]
				}
			}

		
			{
				tryRules {
					catchExceptions : false
					throwExceptionIfAllRulesFailed : false
					rules : [
            {
              commands: [

								# Adding year from the system current date to the date_time.
								{
									AddYearToDatetime {
										dateFormat :  "yyyy MMM d HH:mm:ss"
										timezone : timezone_input
									}
								}


                {
                  convertTimestampFortscale {
                    field: date_time
                    inputFormats: ["yyyy MMM dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                  }
                }


                {
                  setValues {
                    date_time_unix: "@{date_time}"
                  }
                }

                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputFormats: ["yyyy-MM-dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }

              ]
            }
					]
				}
			}


			

			
			{
		  		# test if the ip address used is a vpn or any other nat address
		  		MatchIP {
		  			ipAddress : "source_ip"
		  			cidr : "192.168.0.22"
		  			output : "is_nat"
		  		}
		  	}
		  	


		]
	}
]
