morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [                    
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<status>(Accepted|Failed(?= \w+ for \w+ from )))"""
										}
									}
								}
							]
						}
						{
							commands : [
								{	logDebug	{	format : "Record doesn't meet legitimate ssh format. Dropping record: {}", args : ["@{}"] } }
								{	dropRecord {} }
							]
						}
					]
				}
			}	
		
			{
				grok {
					dictionaryFiles : [resources/grok-dictionaries/ssh.sshd.conf]
					expressions : {
						message : "%{DHCP_IP:source_ip}|%{TARGET_MACHINE:target_machine}|%{DHCP_DATE:date_time}|%{USERNAME:username}|%{AUTH_METHOD:auth_method} |%{TARGET_MACHINE_AS_IP:target_machine_ip}"
					}
					findSubstrings : true
					numRequiredMatches : all				
				}
			}

			# handle case that the target machine contain ip
			{
			    if {
			        conditions : [
			                {not {equals : {target_machine_ip : [] }}}
			        ]
			        then : [
                                {
                                    IpToHostname {
                                        ipAddress : target_machine
                                        timeStamp: date_time_unix
                                        outputRecordName : target_machine
                                        remove_last_dot : true
                                        resolvers = ["logins", "dns"]
                                    }
                                }
			        ]
			    }
			 }

			{
				GetTimezone {
					sourceType : "ssh"
					hostnameField : target_machine
					timezoneOutputField : timezone_output
				}
			}
			# Adding year from the system current date to the date_time.
			{
				java {
					imports : "import java.util.*;import java.text.SimpleDateFormat;"
					code:
						"""
						try {
							Object date_time = record.getFirstValue("date_time");
							if (date_time==null)
								return false;
	
							int year = Calendar.getInstance().get(Calendar.YEAR);
							int currentMonth = Calendar.getInstance().get(Calendar.MONTH);
							
							SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
							Date parsedDate = sdf.parse(date_time.toString().substring(0,3));
							if (parsedDate==null)
								return false;
							int parsedMonth = parsedDate.getMonth();
							
							// If the month is later than current month, we'll assign the previous year to the event
							if (parsedMonth > currentMonth) {
								year--;
							}
						
							record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
						} catch (Exception e) {
							System.out.println(e);
							return false;
						}
						
						return child.process(record);
						"""
				}
			}
		
			{
				tryRules {
					catchExceptions : false
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									addValues {				
										date_time_unix : "@{date_time}"
									}
								}	
					
								{
									convertTimestampFortscale {
										field : date_time_unix
										inputFormats : [ "yyyy MMM d HH:mm:ss"]
										inputTimezoneField : timezone_output
										outputFormat : "unixTimeInSeconds"
										# default outputTimezone : UTC
									}
								}
		        
								{
									convertTimestampFortscale {
										field : date_time
										inputFormats : [ "yyyy MMM d HH:mm:ss"]
										inputTimezoneField : timezone_output
										outputFormat : "yyyy-MM-dd HH:mm:ss"
										outputTimezoneField : timezone_output
									}
								}						
							]
						}		
					]
				}
			}
			{
				IpToHostname {
			    	ipAddress : source_ip
					timeStamp: date_time_unix
					outputRecordName : hostname
			        remove_last_dot : true
			        resolvers = ["logins", "dns"]
				}
	      	}
			
	      	{
				SSHNormalizeUsername {
					usernameField : username
					normalizedUsernameField : normalized_username
				}
			}
			{
				ClassifyHost {
					hostnameField : hostname
					classificationField = src_class
				}
			}
			{
				ClassifyHost {
					hostnameField : target_machine
					classificationField : dst_class
				}
			}
			{
				GetComputerClusterName {
					hostnameField : hostname
					clusterField : normalized_src_machine
				}
			}
			{
				GetComputerClusterName {
					hostnameField : target_machine
					clusterField : normalized_dst_machine
				}
			}
			
			{
		  		# test if the ip address used is a vpn or any other nat address
		  		MatchIP {
		  			ipAddress : "source_ip"
		  			cidr : "192.168.0.22"
		  			output : "is_nat"
		  		}
		  	}
		  	
		  	{
				if {
					conditions : [
						{ equals { status : ["Accepted"]  } }
					]
					then : [
					  	{
							UserLastActivityUpdate {
								logEventsType : ssh
								normalizedUsernameField : normalized_username
								epochtimestampField : date_time_unix
							}
						}
					]
				}
			}
			
			{
				IsSensitiveMachine {
					machineNameField : target_machine
					isSensitiveMachineField : is_sensitive_machine
				}		
			}
			
			{
				IsUserServiceAccount {
					usernameField : normalized_username
					isUserServiceAccountField : isUserServiceAccount
				}
			}
			
			{
				IsUserAdministrator {
					usernameField : normalized_username
					isUserAdministratorField : isUserAdministrator
				}
			}
			
			{
				IsUserExecutive {
					usernameField : normalized_username
					isUserExecutiveField : isUserExecutive
				}
			} 
		]
	}
]