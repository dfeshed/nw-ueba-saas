morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [ 
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<status>(Accepted|Failed(?= \w+ for \w+ from )))"""
										}
									}
								}
							]
						}
						{
							commands : [
								{	logDebug	{	format : "Record doesn't meet legitimate ssh format. Dropping record: {}", args : ["@{}"] } }
								{	dropRecord {} }
							]
						}
					]
				}
			}	
		
			{
				grok {
					dictionaryFiles : [resources/grok-dictionaries/ssh.sshd.conf]
					expressions : {
						message : "%{DHCP_IP:source_ip}|%{TARGET_MACHINE_AS_IP:target_machine_ip}|%{TARGET_MACHINE:target_machine}|%{DHCP_DATE:date_time}|%{USERNAME:username}|%{AUTH_METHOD:auth_method} "
					}
					findSubstrings : true
					numRequiredMatches : all				
				}
			}




			# handle case that the target machine contain ip
            {
                if {
                    conditions : [
                            {not {equals : {target_machine_ip : [] }}}
                    ]
                    then : [

                            {
                                setValues {
                                    target_machine : []
                                }
                            }


                    ]
                }
             }


			{
				EmptyObjectFilter {
					filterFields : [username,source_ip,target_machine,date_time]
				}
			}

			#the first overflow filter command insures that the overflow is not caused by a single user in the system
			{
				OverFlowFilter {
					eventsType : ssh
					criteria : [username]
					threshold : 100000
				}

			}
			{
				OverFlowFilter {
					eventsType : ssh
					criteria : []
					threshold : 1000000
				}
			}
			{
				SSHNormalizeUsername {
					usernameField : username
					normalizedUsernameField : normalized_username
				}
			}
			
			{
                tryRules {
                    catchExceptions : true
                    throwExceptionIfAllRulesFailed : false
                    rules : [
                    {
                        commands : [
                        {
                            findReplace {
                                field : source_ip
                                pattern : "::ffff:"
                                isRegex : false
                                replacement : ""
                                replaceFirst : false
                            }
                        }
                        {
                            findReplace {
                                field : source_ip
                                pattern : "::1"
                                isRegex : false
                                replacement : "@{target_machine}"
                                replaceFirst : false
                            }
                        }
                        {
                            findReplace {
                                field : source_ip
                                pattern : "127.0.0.1"
                                isRegex : false
                                replacement : "@{target_machine}"
                                replaceFirst : false
                            }
                        }
                        ]
                    }
                    ]
                }
            }
			
			{
				GetTimezone {
					sourceType : "ssh"
					hostnameField : target_machine
					timezoneOutputField : timezone_output
				}
			}

		
			{
				tryRules {
					catchExceptions : false
					throwExceptionIfAllRulesFailed : false
					rules : [
            {
              commands: [

                # Adding year from the system current date to the date_time.
                {
                  java {
                    imports: "import java.util.*;import java.text.SimpleDateFormat;"
                    code:
                      """
                                            try {
                                                Object date_time = record.getFirstValue("date_time");
                                                if (date_time==null)
                                                    return false;

                                                int year = Calendar.getInstance().get(Calendar.YEAR);


                                                record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
                                            } catch (Exception e) {
                                                System.out.println(e);
                                                return false;
                                            }

                                            return child.process(record);
                                            """
                  }
                }


                {
                  convertTimestampFortscale {
                    field: date_time
                    inputFormats: ["yyyy MMM dd HH:mm:ss"]
                    inputTimezoneField: timezone_output
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                    #outputTimezoneField : timezone_output
                  }
                }


                # Adding year from the system current date to the date_time.
                {
                  java {
                    imports: "import java.util.*;import java.text.SimpleDateFormat;"
                    code:
                      """
                      try {
                          Object date_time = record.getFirstValue("date_time");
                          String tz = record.getFirstValue("timezone_output").toString();

                          TimeZone outputTimeZone = TimeZone.getTimeZone(tz == null ? "UTC" : tz);

                          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                          sdf.setTimeZone(outputTimeZone);

                          Date parsedDate = sdf.parse(date_time.toString());

                          Calendar cal = Calendar.getInstance(outputTimeZone);

                          Date currentDate = cal.getTime();


                          if (parsedDate.compareTo(currentDate)>0)
                              parsedDate.setYear(parsedDate.getYear()-1);



                          record.replaceValues("date_time", sdf.format(parsedDate));


                      } catch (Exception e) {
                          System.out.println(e);
                          return false;
                      }

                      return child.process(record);
                      """
                  }
                }

                {
                  setValues {
                    date_time_unix: "@{date_time}"
                  }
                }

                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputFormats: ["yyyy-MM-dd HH:mm:ss"]
                    inputTimezoneField: timezone_output
                    outputFormat: "unixTimeInSeconds"
                    # default outputTimezone : UTC
                  }
                }

              ]
            }
					]
				}
			}

			{
				IpToHostname {
			    	ipAddress : source_ip
					timeStamp: date_time_unix
					outputFieldName : hostname
					restrictToADName : false
				}
	      	}
			
			{
				ClassifyHost {
					hostnameField : hostname
					classificationField = src_class
				}
			}
			{
				ClassifyHost {
					hostnameField : target_machine
					classificationField : dst_class
				}
			}

			
			{
		  		# test if the ip address used is a vpn or any other nat address
		  		MatchIP {
		  			ipAddress : "source_ip"
		  			cidr : "192.168.0.22"
		  			output : "is_nat"
		  		}
		  	}
		  	


		]
	}
]
