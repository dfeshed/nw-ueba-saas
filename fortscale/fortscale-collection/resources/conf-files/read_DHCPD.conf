morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [
			
			{
				grok {
					dictionaryFiles : [resources/grok-dictionaries/dhcp.dhcpd.conf]
					expressions : {
						message : "%{DHCP_IP:ipaddress}|%{HOSTNAME:hostname}|%{DHCP_DATE:date_time}|%{MAC:macAddress}"
					}
					findSubstrings : true
				}
			}
			
			{
	    		if {
	          		conditions : [
	            		{ equals { hostname : [] } }
	          		]
	          		then : [
	          			{ logDebug { format : "Record does not contain hostname field, Drop the record. Original message was: {}", args : ["@{message}"] } }
	           			{ dropRecord {} }
	          		]
	        	}
			}
			{
				GetTimezone {
					sourceType : "dhcp"
					hostnameField : reporting_server
					timezoneOutputField : timezone_output
				}
			}
			
			# Adding year from the system current date to the date_time.
			{
				java {
					imports : "import java.util.*;import java.text.SimpleDateFormat;"
					code:
						"""
                  try {
                    Object date_time = record.getFirstValue("date_time");
                    String tz = record.getFirstValue("timezone_output").toString();

                    TimeZone outputTimeZone = TimeZone.getTimeZone(tz == null ? "UTC" : tz);

                    if (date_time==null)
                      return false;




                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM dd HH:mm:ss");
                    sdf.setTimeZone(outputTimeZone);
                    int year = Calendar.getInstance().get(Calendar.YEAR);



                    Date parsedDate = sdf.parse(Integer.toString(year) + " " + date_time.toString());


                    Calendar cal = Calendar.getInstance(outputTimeZone);

                    Date currentDate = cal.getTime();



                    if (parsedDate.compareTo(currentDate)>0)
                        parsedDate.setYear(parsedDate.getYear()-1);

                    record.replaceValues("date_time", sdf.format(parsedDate));


                  } catch (Exception e) {
                      System.out.println(e);
                      return false;
                  }

                  return child.process(record);

                  """
				}
			}

			{
				tryRules {
					catchExceptions : false
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									addValues {				
										timestampepoch : "@{date_time}"
									}
								}	
								
								{
									convertTimestamp {
										field : timestampepoch
										inputFormats : [ "yyyy MMM d HH:mm:ss"]
										inputTimezone : Asia/Jerusalem
										outputFormat : "unixTimeInSeconds"
										outputTimezone : UTC
									}
								}

							]
						}

						{
							commands : [
								{ logInfo { format : "Timestamps addition and conversion could not be completed on record: {}", args : ["@{}"] } }
								{ dropRecord {} }
							]
						}
					]
				}
			}			
		]
	}
]