morphlines: [
  {
    id: Parsing_SecurityEvents
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]

    commands: [
      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}
      {
        split {
          inputField: message
          outputFields: ["", "", recordNumber, "", win2003EventCode, "", date_time_unix, "", reporting_server, ""]
          separator: "||"
          isRegex: false
          addEmptyStrings: false
          trim: true
        }
      }
      {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}
      {toString {field: reporting_server, trim: true}}
      {
        if {
          conditions: [
            {equals {win2003EventCode: ["528"]}}
          ]
          then: [
            {
              addValues {
                eventCode: "4624"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {win2003EventCode: ["540"]}}
          ]
          then: [
            {
              addValues {
                eventCode: "4624"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {win2003EventCode: ["672"]}}
          ]
          then: [
            {
              addValues {
                eventCode: "4768"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {win2003EventCode: ["673"]}}
          ]
          then: [
            {
              addValues {
                eventCode: "4769"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {win2003EventCode: ["675"]}}
          ]
          then: [
            {
              addValues {
                eventCode: "4771"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {not {equals {eventCode: ["4624"]}}}
          ]
          then: [
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}
                      {
                        grok {
                          dictionaryFiles: [resources/grok-dictionaries/win2003secevents.conf]
                          findSubstrings: true
                          addEmptyStrings: true
                          numRequiredMatches: all
                          expressions: {
                            message: "%{ACCOUNT_NAME:account_name}|%{CLIENT_ADDRESS:client_address}|%{TIMEZONE:timezone}"
                          }
                        }
                      }
                      {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}
                      {toString {field: client_address, trim: true}}
                      {toString {field: account_name, trim: true}}
                      {toString {field: timezone, trim: true}}
                    ]
                  }
                ]
              }
            }
            {logDebug {format: "Debug -10 : {}", args: ["@{}"]}}
            {
              EmptyObjectFilter {
                filterFields: [eventCode, account_name, client_address]
              }
            }
            {logDebug {format: "Debug -11 : {}", args: ["@{}"]}}
            #the first overflow filter command insures that the overflow is not caused by a single user in the system
            {
              OverFlowFilter {
                eventsType: securityEvents
                criteria: [eventCode, account_name]
                threshold: 100000
              }
            }
            {
              OverFlowFilter {
                eventsType: securityEvents
                criteria: [eventCode]
                threshold: 2000000
              }
            }
            {logDebug {format: "Debug -12 : {}", args: ["@{}"]}}
            {
              setValues {
                date_time: "@{date_time_unix}"
              }
            }
            {logDebug {format: "Debug -13 : {}", args: ["@{}"]}}
            {
              convertTimestamp {
                field: date_time
                inputFormats: ["unixTimeInSeconds"]
                outputFormat: "yyyy-MM-dd'T'HH:mm:ss"
              }
            }
            {logDebug {format: "Debug -14 : {}", args: ["@{}"]}}
            {
              setValues {
                timeGeneratedRaw: "@{date_time_unix}"
              }
            }
            {
              convertTimestamp {
                field: timeGeneratedRaw
                inputFormats: ["unixTimeInSeconds"]
                outputFormat: "yyyy-MM-dd'T'HH:mm:ss.SSS"
              }
            }
            {logDebug {format: "Debug -15 : {}", args: ["@{}"]}}
            {
              if {
                conditions: [
                  {equals {timezone: []}}
                ]
                then: [
                  {
                    GetTimezone {
                      sourceType: "sec"
                      hostnameField: reporting_server
                      timezoneOutputField: timezone_input
                    }
                  }
                ]
                else: [
                  {
                    addValues {
                      timezone_input: "@{timezone}"
                    }
                  }
                ]
              }
            }
            {logDebug {format: "Debug -16 : {}", args: ["@{}"]}}
            {
              convertTimestampFortscale {
                field: date_time
                inputTimezoneField: timezone_input
                outputFormat: "yyyy-MM-dd HH:mm:ss"
              }
            }
            {logDebug {format: "Debug -17 : {}", args: ["@{}"]}}
            {
              convertTimestampFortscale {
                field: date_time_unix
                inputTimezoneField: timezone_input
                outputFormat: "unixTimeInSeconds"
              }
            }
            {logDebug {format: "Debug -18 : {}", args: ["@{}"]}}
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {
                        findReplace {
                          field: client_address
                          pattern: "::1"
                          isRegex: false
                          replacement: "127.0.0.1"
                          replaceFirst: false
                        }
                      }
                      {
                        findReplace {
                          field: client_address
                          pattern: "::ffff:"
                          isRegex: false
                          replacement: ""
                          replaceFirst: false
                        }
                      }
                    ]
                  }
                ]
              }
            }
            {logDebug {format: "Debug -19 : {}", args: ["@{}"]}}
            # test if the ip address used is a vpn or any other nat address
            # to use it comment out the set value command and un-comment the MatchIP command and set it with
            # the appropriate cidr
            {
              addValues {
                is_nat: false
              }
            }
            {logDebug {format: "Debug -20 : {}", args: ["@{}"]}}
          ]
        }
      }
    ]
  }
]