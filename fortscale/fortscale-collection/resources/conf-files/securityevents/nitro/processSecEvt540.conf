#144116287956583680,10830961599,ELM,1437870767,,,11.176.91.253||Security||1489839827||Security||540||52||1437865378||4||STAP0024||NT AUTHORITY\SYSTEM||Logon/Logoff||15||STAP0024$||RBSRES07||(0x4,0xEAF9B9CF)||3||Kerberos||Kerberos||||{1204f6a7-306b-a34f-27f9-639a055534e6}||-||-||-||-||-||11.176.91.245||44280||Successful Network Logon:%0D %0D %09User Name:%09STAP0024$%0D %0D %09Domain:%09%09RBSRES07%0D %0D %09Logon ID:%09%09(0x4,0xEAF9B9CF)%0D %0D %09Logon Type:%093%0D %0D %09Logon Process:%09Kerberos%0D %0D %09Authentication Package:%09Kerberos%0D %0D %09Workstation Name:%09%0D %0D %09Logon GUID:%09{1204f6a7-306b-a34f-27f9-639a055534e6}%0D %0D %09Caller User Name:%09-%0D %0D %09Caller Domain:%09-%0D %0D %09Caller Logon ID:%09-%0D %0D %09Caller Process ID: -%0D %0D %09Transited Services: -%0D %0D %09Source Network Address:%0911.176.91.245%0D %0D %09Source Port:%0944280%0D %0D

morphlines: [
  {
    id: 540SecEvent
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]

    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    dictionaryFiles: [resources/grok-dictionaries/sec.540.conf]
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{ACCOUNT_NAME:account_name}|%{ACCOUNT_DOMAIN:account_domain}|%{SOURCE_IP:source_ip}|%{LOGON_PROCESS:logon_process}"
                    }
                  }
                }
              ]
            }
          ]
        }
      }
      {toString {field: account_name, trim: true}}
      {toString {field: source_ip, trim: true}}
      {toString {field: logon_process, trim: true}}
      {toString {field: account_domain, trim: true}}
      {toString {field: timezone, trim: true}}
      {
        EmptyObjectFilter {
          filterFields: [account_name, source_ip, logon_process, reporting_server]
        }
      }
      # filter non kerberos events
      {
        if {
          conditions: [
            {not {equals {logon_process: [Kerberos]}}}
          ]
          then: [
            {LogFilterEvent { errorMessage: "Non Kerberos Event"}}
            {dropRecord {}}
          ]
        }
      }
      # filter local ip6v ip address
      {
        if {
          conditions: [
            {equals {source_ip: ["::1"]}}
          ]
          then: [
            {LogFilterEvent { errorMessage: "Local IPv6 Address"}}
            {dropRecord {}}
          ]
        }
      }
      # filter local ipv4 address
      {
        if {
          conditions: [
            {equals {source_ip: ["127.0.0.1"]}}
          ]
          then: [
            {LogFilterEvent { errorMessage: "Local IPv4 Address"}}
            {dropRecord {}}
          ]
        }
      }
      # filter non computer accounts
      {
        setValues {
          isComputer: "false"
        }
      }
      {
        java {
          imports: "import java.util.*;"
          code:
            """
            String account_name = (String)record.get("account_name").get(0);
            Boolean isComputer = account_name.contains("$") ? true : false;
            if (isComputer){
              record.replaceValues("isComputer", isComputer);
              record.replaceValues("account_name", account_name);
              String account_domain = (String)record.get("account_domain").get(0);
              record.replaceValues("account_domain", account_domain);
              return child.process(record);
            } else{
              return true;
            }
            """
        }
      }
      # filter machines not in the desired ou
      {
        FilterOUMachine {
          hostnameField: account_name
          regex: "(.+)\\$$# #$1"
        }
      }
      # setup timestamp according to timezone of the reporting server
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "sec"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }
      {
        setValues {
          date_time: "@{date_time_unix}"
        }
      }
      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["unixTimeInSeconds"]
          inputTimezoneField : timezone_input
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }
      {
        setValues {
          timeGeneratedRaw: "@{date_time_unix}"
        }
      }
      {
        convertTimestampFortscale {
          field: timeGeneratedRaw
          inputFormats: ["unixTimeInSeconds"]
          inputTimezoneField: timezone_input
          outputFormat: "yyyy-MM-dd'T'HH:mm:ss.SSS"
        }
      }
      # add the computer ip resolve to the cache and drop the record
      {
        ComputerLoginUpdate {
          timestampepoch_field: date_time_unix
          ipaddress_field: source_ip
          hostname_field: account_name
          domain_field: account_domain
        }
      }

    ]
  }
]