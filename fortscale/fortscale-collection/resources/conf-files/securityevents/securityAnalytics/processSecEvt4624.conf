morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    dictionaryFiles: [resources/grok-dictionaries/secevents.sa.conf]
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{TIME_GENERATED_TYPE_B:timeGeneratedTypeB}|%{TIME_GENERATED:timeGenerated}|%{ACCOUNT_NAME:account_name}|%{CLIENT_ADDRESS:client_address}|%{ACCOUNT_DOMAIN:account_domain}"
                    }
                  }
                }
                {toString {field: client_address, trim: true}}
                {toString {field: account_name, trim: true}}
                {toString {field: account_domain, trim: true}}
              ]
            }
          ]
        }
      }
      {
        EmptyObjectFilter {
          filterFields: [account_name, client_address]
        }
      }
      # filter non computer accounts
      { FilterAccountNameIsNotComputer {indexOfAccountName: 1} }
      {
        FilterOUMachine {
          hostnameField: account_name
          regex: "(.+)\\$$# #$1"
        }
      }
      {
        addValues {
          timezone_input: "UTC"
        }
      }
      {
        if {
          conditions: [
            {equals {timeGeneratedTypeB: []}}
          ]
          then: [
            # Adding year from the system current date to the timeGenerated.
            {
              java {
                imports: "import java.util.*;import java.text.SimpleDateFormat;import fortscale.collection.monitoring.MorphlineCommandMonitoringHelper;"
                code:
                  """
                  try {
                    Object timeGenerated = record.getFirstValue("timeGenerated");
                    if (timeGenerated==null){
                      MorphlineCommandMonitoringHelper commandMonitoringHelper = new MorphlineCommandMonitoringHelper();
                      commandMonitoringHelper.addFilteredEventToMonitoring(record, "Time Generated is Null");
                      return false;
                    }

                    int year = Calendar.getInstance().get(Calendar.YEAR);
                    int currentMonth = Calendar.getInstance().get(Calendar.MONTH);

                    int parsedMonth;
                    SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
                    parsedMonth = sdf.parse(timeGenerated.toString().substring(0,3)).getMonth();

                    // If the month is later than current month, we'll assign the previous year to the event
                    if (parsedMonth > currentMonth) {
                      year--;
                    }

                    record.replaceValues("timeGenerated", Integer.toString(year) + " " + timeGenerated.toString());
                  }
                  catch (Exception e) {
                    System.out.println(e);
                  }

                  return child.process(record);
                  """
              }
            }
          ]
          else: [
            {
              setValues {
                timeGenerated: "@{timeGeneratedTypeB}"
              }
            }
            {
              convertTimestampFortscale {
                field: timeGenerated
                #Mar 17 15:49:28 2014
                inputFormats: ["MMM dd HH:mm:ss yyyy", "MMM  dd HH:mm:ss yyyy"]
                inputTimezoneField: timezone_input
                outputFormat: "yyyy MMM dd HH:mm:ss"
              }
            }
          ]
        }
      }
      {
        addValues {
          timeGeneratedUnixTime: "@{timeGenerated}"
        }
      }
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  convertTimestampFortscale {
                    field: timeGeneratedUnixTime
                    inputFormats: ["yyyy MMM dd HH:mm:ss", "yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }
              ]
            }
          ]
        }
      }
      {
        addValues {
          date_time_unix: "@{timeGeneratedUnixTime}"
        }
      }
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  findReplace {
                    field: client_address
                    pattern: "::1"
                    isRegex: false
                    replacement: "127.0.0.1"
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: client_address
                    pattern: "::ffff:"
                    isRegex: false
                    replacement: ""
                    replaceFirst: false
                  }
                }
              ]
            }
          ]
        }
      }
      {
        ComputerLoginUpdate {
          timestampepoch_field: timeGeneratedUnixTime
          ipaddress_field: client_address
          hostname_field: account_name
          domain_field: account_domain
          max_batch_size: 10000
        }
      }
    ]
  }
]