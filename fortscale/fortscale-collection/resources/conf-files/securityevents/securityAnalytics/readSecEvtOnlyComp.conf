morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]

    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    dictionaryFiles: [resources/grok-dictionaries/secevents.sa.conf]
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{TIME_GENERATED_TYPE_B:date_timeTypeB}|%{TIME_GENERATED:date_time}|%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_NAME:account_name}|%{EVENT_CODE:eventCode}|%{CLIENT_ADDRESS:client_address}|%{TICKET_OPTIONS:ticket_options}|%{TIMEZONE:timezone}"
                    }
                  }
                }
                {toString {field: client_address, trim: true}}
                {toString {field: ticket_options, trim: true}}
                {toString {field: account_name, trim: true}}
              ]
            }
          ]
        }
      }
      {
        addValues {
          ticket_options : "0x0"
        }
      }
      {
        EmptyObjectFilter {
          filterFields: [eventCode, account_name, client_address, ticket_options]
        }
      }
      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType: securityEvents
          criteria: [eventCode, account_name]
          threshold: 100000
        }
      }
      {
        OverFlowFilter {
          eventsType: securityEvents
          criteria: [eventCode]
          threshold: 2000000
        }
      }
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "sec"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }
      {
        if {
          conditions: [
            {equals {date_timeTypeB: []}}
          ]
          then: [
            # Adding year from the system current date to the date_time.
            {
              AddYearToDatetime {
                dateFormat: "yyyy MMM d HH:mm:ss"
                timezone: timezone_input
              }
            }
          ]
          else: [
            {
              setValues {
                date_time: "@{date_timeTypeB}"
              }
            }
            {
              convertTimestampFortscale {
                field: date_time
                #Mar 17 15:49:28 2014
                inputTimezoneField: timezone_input
                outputFormat: "yyyy MMM dd HH:mm:ss"
              }
            }
          ]
        }
      }


      {
        findReplace {
          field: account_name
          isRegex: false
          pattern: "'"
          replacement: ""
        }
      }

      {
        addValues {
          timeGeneratedRaw: "@{date_time}"
          date_time_unix: "@{date_time}"
        }
      }

      # Adding isComputer.
      {
        java {
          imports: "import java.util.*;"
          code:
            """
            String account_name = (String)record.get("account_name").get(1);
            Boolean isComputer = account_name.contains("$") ? true : false;
            record.replaceValues("isComputer", isComputer);
            return child.process(record);
            """
        }
      }

      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  convertTimestampFortscale {
                    field: timeGeneratedRaw
                    #2014 Mar 17 15:49:28
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
                  }
                }
                {
                  convertTimestampFortscale {
                    field: date_time
                    #2014 Mar 17 15:49:28
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                  }
                }
                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }
              ]
            }
          ]
        }
      }

      {logDebug {format: "current record is  -  {}", args: ["@{}"]}}


      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  findReplace {
                    field: client_address
                    pattern: "::1"
                    isRegex: false
                    replacement: "127.0.0.1"
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: client_address
                    pattern: "::ffff:"
                    isRegex: false
                    replacement: ""
                    replaceFirst: false
                  }
                }
              ]
            }
          ]
        }
      }
      {
        # test if the ip address used is a vpn or any other nat address
        MatchIP {
          ipAddress: "client_address"
          cidr: "192.168.0.22"
          output: "is_nat"
        }
      }
      {
        ParseKerberosTicketOptions {
          ticketOptionsField: ticket_options
          forwardableField: forwardable
          forwardedField: forwarded
          proxiedField: proxied
          postdatedField: postdated
          renewRequestField: renew_request
          constraintDelegationField: constraint_delegation
        }
      }
      ##################################################################
      ##################################################################
      #
      #
      #	 comment enrichement commands after moving them into streaming
      #	 transition haven't been verified for this morphline.
      #									please test before using.
      #
      #
      ##################################################################
      ##################################################################
      #		{
      #			if {
      #				conditions : [
      #					{ equals { isComputer : [false] } }
      #				]
      #				then : [
      #					{
      #						IpToHostname {
      #					    	ipAddress : client_address
      #					        timeStamp: date_time_unix
      #					        outputFieldName : machine_name
      #					        restrictToADName : true
      #						}
      #			      	}
      #			      	{
      #						FilterUnresolvedMachine{
      #							machineNameField : machine_name
      #						}
      #					}
      #					{
      #						ClassifyHost {
      #							hostnameField : machine_name
      #							classificationField : src_class
      #						}
      #					}
      #					{
      #						GetComputerClusterName {
      #							hostnameField : machine_name
      #							clusterField : normalized_src_machine
      #						}
      #					}
      #
      #					{
      #						SECNormalizeUsername {
      #							usernameField : account_name
      #							normalizedUsernameField : normalized_username
      #						}
      #					}
      #
      #					{
      #						UserLastActivityUpdate {
      #							logEventsType : login
      #							normalizedUsernameField : normalized_username
      #							epochtimestampField : date_time_unix
      #						}
      #					}
      #					{
      #						IsUserServiceAccount {
      #							usernameField : normalized_username
      #							isUserServiceAccountField : isUserServiceAccount
      #						}
      #					}
      #					{
      #						IsUserAdministrator {
      #							usernameField : normalized_username
      #							isUserAdministratorField : isUserAdministrator
      #						}
      #					}
      #					{
      #						IsUserExecutive {
      #							usernameField : normalized_username
      #							isUserExecutiveField : isUserExecutive
      #						}
      #					}
      #				]
      #			}
      #		}
    ]
  }
]
