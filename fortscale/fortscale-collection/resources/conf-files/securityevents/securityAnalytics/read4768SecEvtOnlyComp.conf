morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]

    commands: [

      {
           setValues {
              data_source : ["login4768"]
              last_state : ["etl"]
           }
      }

      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    dictionaryFiles: [resources/grok-dictionaries/secevents.sa.conf]
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{TIME_GENERATED_TYPE_B:timeGeneratedTypeB}|%{TIME_GENERATED:timeGenerated}|%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_NAME:account_name}|%{CLIENT_ADDRESS:client_address}|%{TIMEZONE:timezone}"
                    }
                  }
                }
                {toString {field: client_address, trim: true}}
                {toString {field: account_name, trim: true}}
              ]
            }
          ]
        }
      }
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "sec"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }
      {
        if {
          conditions: [
            {equals {timeGeneratedTypeB: []}}
          ]
          then: [
            # Adding year from the system current date to the timeGenerated.
            {
              java {
                imports: "import java.util.*;import java.text.SimpleDateFormat;"
                code:
                  """
                  try {
                    Object timeGenerated = record.getFirstValue("timeGenerated");
                    if (timeGenerated==null)
                      return false;

                    int year = Calendar.getInstance().get(Calendar.YEAR);
                    int currentMonth = Calendar.getInstance().get(Calendar.MONTH);

                    int parsedMonth;
                    SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
                    parsedMonth = sdf.parse(timeGenerated.toString().substring(0,3)).getMonth();

                    // If the month is later than current month, we'll assign the previous year to the event
                    if (parsedMonth > currentMonth) {
                      year--;
                    }

                    record.replaceValues("timeGenerated", Integer.toString(year) + " " + timeGenerated.toString());
                  }
                  catch (Exception e) {
                    System.out.println(e);
                  }

                  return child.process(record);
                  """
              }
            }
          ]
          else: [
            {
              setValues {
                timeGenerated: "@{timeGeneratedTypeB}"
              }
            }
            {
              convertTimestampFortscale {
                field: timeGenerated
                #Mar 17 15:49:28 2014
                inputFormats: ["MMM dd HH:mm:ss yyyy", "MMM  dd HH:mm:ss yyyy"]
                inputTimezoneField: timezone_input
                outputFormat: "yyyy MMM dd HH:mm:ss"
              }
            }
          ]
        }
      }


      {
        if {
          conditions: [
            {equals {account_name: []}}
          ]
          then: [
            {logWarn {format: "Record does not contain account_name field, Drop the record. Original message was: {}", args: ["@{message}"]}}
            {LogFilterEvent { errorMessage: "Record does not contain account_name field"}}
            {dropRecord {}}
          ]
        }
      }

      {
        if {
          conditions: [
            {equals {client_address: []}}
          ]
          then: [
            {logError {format: "Record does not contain client_address field, Drop the record. Original message was: {}", args: ["@{message}"]}}
            {LogFilterEvent { errorMessage: "Record does not contain client_address"}}
            {
              dropRecord {}
            }
          ]
        }
      }

      {
        addValues {
          timeGeneratedUnixTime: "@{timeGenerated}"
        }
      }

      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  convertTimestampFortscale {
                    field: timeGeneratedUnixTime
                    inputFormats: ["yyyy MMM dd HH:mm:ss", "yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }
              ]
            }
          ]
        }
      }
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  findReplace {
                    field: client_address
                    pattern: "::1"
                    isRegex: false
                    replacement: "127.0.0.1"
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: client_address
                    pattern: "::ffff:"
                    isRegex: false
                    replacement: ""
                    replaceFirst: false
                  }
                }
              ]
            }
          ]
        }
      }

      {
        FilterOUMachine {
          hostnameField: account_name
          regex: "(.+)\\$$# #$1"
        }

      }

      {
        ComputerLoginUpdate {
          timestampepoch_field: timeGeneratedUnixTime
          ipaddress_field: client_address
          hostname_field: account_name
          domain_field: account_domain
          max_batch_size: 10000
        }
      }
    ]
  }
]
