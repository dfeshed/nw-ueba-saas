morphlines : [
{
    id : sec4624
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

	commands : [
	{
		grok {
			dictionaryString : """
			  	ACCOUNT_NAME (?<=Account Name:).+?(?=Account Domain:)
			  	ACCOUNT_DOMAIN (?<=Account Domain:).+?(?=Logon ID:)
			  	SOURCE_IP (?<=Source Network Address:).+?(?=Source Port:)
			  	LOGON_PROCESS (?<=Logon Process:).+?(?=Authentication Package:)
			  	REPORTING_SERVER (?<=ComputerName=).+?(?=TaskCategory=)
			  	TIMEZONE (?<=timezone )\S+
				 """
			findSubstrings : true
		  	addEmptyStrings : true
		  	numRequiredMatches : all
		  	expressions : {
				messageData : "%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_DOMAIN:account_domain}|%{ACCOUNT_NAME:account_name}|%{SOURCE_IP:source_ip}|%{LOGON_PROCESS:logon_process}|%{TIMEZONE:timezone}"
		  	}
		}
	}
	{ toString { field : account_name, trim : true } }
	{ toString { field : source_ip, trim : true } }
	{ toString { field : logon_process, trim : true } }
	{ toString { field : account_domain, trim : true } }
	{ toString { field : reporting_server, trim : true } }
	{ toString { field : timezone, trim : true } }

	{
		EmptyObjectFilter {
			filterFields : [account_name,source_ip,logon_process,reporting_server]
		}
	}
	# filter non kerberos events
	{
		if {
			conditions : [
				{ not { equals { logon_process : [Kerberos] } } }
			]
			then : [
			    { LogFilterEvent { errorMessage: "Non Kerberos Event"}}
				{ dropRecord {} }
			]
		}
	}
	# filter local ip6v ip address
	{
		if {
			conditions : [
				{ equals { source_ip : ["::1"] } }
			]
			then : [
				{ LogFilterEvent { errorMessage: "Local IPv6 Event"}}
				{ dropRecord {} }
			]
		}
	}
	# filter local ipv4 address
	{
		if {
			conditions : [
				{ equals { source_ip : ["127.0.0.1"] } }
			]
			then : [
				{ LogFilterEvent { errorMessage: "Local IPv4 Event"}}
				{ dropRecord {} }
			]
		}
	}
	# Set account name and account domain.
	{
		java {
			imports : "import java.util.*;"
			code:
				"""
				String account_name = (String)record.get("account_name").get(1);
				record.replaceValues("account_name", account_name);
				String account_domain = (String)record.get("account_domain").get(1);
				record.replaceValues("account_domain", account_domain);
				return child.process(record);
				"""
		}
	}
	# filter domain servers



	# filter machines not in the desired ou
	{
		FilterOUMachine {
			hostnameField : account_name
			regex : "(.+)\\$$# #$1"
		}
	}
	
	# setup timestamp according to timezone of the reporting server
	{
		if {
          conditions : [
          	{ equals { timezone : [] }}
          ]
          then : [
			{
				GetTimezone {
            		sourceType : "sec"
            		hostnameField : reporting_server
            		timezoneOutputField : timezone_input
            	}
            }
          ]
          else : [
          	{
          		addValues {
            		timezone_input : "@{timezone}"
            	}
            }
          ]
        }
	}
	{
		addValues {
			date_time_unix : "@{date_time}"
		}
	}
	{
		java {
			imports : "import java.util.*;"
			code: """
				Object rec = record.getFirstValue("date_time_unix");
				String tmp = String.valueOf(rec).substring(0,19);
				record.replaceValues("date_time_unix",tmp);
				return child.process(record);
				"""
		}
	} 
	{
		convertTimestampFortscale {
  			field : date_time_unix
  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
  			inputTimezoneField : timezone_input
  			outputFormat : "unixTimeInSeconds"
		}
	}


	# add the computer ip resolve to the cache and drop the record
	{
		ComputerLoginUpdate {
	    	timestampepoch_field : date_time_unix
	        ipaddress_field: source_ip
	        hostname_field : account_name
	        domain_field : account_domain
	        max_batch_size : 10000
		}
	}

  {
    addValues {
      isADHostName : true
    }
  }


	]
}]
