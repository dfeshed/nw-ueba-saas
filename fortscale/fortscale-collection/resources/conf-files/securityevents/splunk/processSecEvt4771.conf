morphlines : [
	{
	    id : process4771
	    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

    	commands : [
    	{ 
			if { 
				conditions : [ 
					{ equals { isComputer : [true] } } 
				] 
				then : [
					{ logWarn { format : "Record is 4771 for machine_account, Drop the record. Original message was: {}", args : ["@{message}"] } }
					{ LogFilterEvent { errorMessage: "Record is 4771 for machine_account"}}
					{ dropRecord {} } 
				] 
			} 
		}
    	{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
	  				{
			grok {
					dictionaryString : """
					SECURITY_ID (?<=Security ID:).+?(?=Account Name:)
					ACCOUNT_DOMAIN (?<=Service Name:).+?(?=Network Information:)
					FAILURE_CODE (?<=Failure Code:).+?(?=Pre-Authentication Type:)
					PRE_AUTHENTICATION_TYPE (?<=Pre-Authentication Type:).+?(?=Certificate Information:)
					 """
					findSubstrings : true
			  	addEmptyStrings : true
			  	numRequiredMatches : all
			  	expressions : {
					messageData : "%{SECURITY_ID:security_id}|%{ACCOUNT_DOMAIN:account_domain}|%{FAILURE_CODE:failure_code}|%{PRE_AUTHENTICATION_TYPE:authentication_type}"
			  	}
			}
					}
							{ toString { field : account_domain, trim : true } }
      				{ toString { field : security_id, trim : true } }
      				{ toString { field : account_name, trim : true } }
      				{ toString { field : authentication_type, trim : true } }
      				{ toString { field : failure_code, trim : true } }
							{
								FortscaleExtractDomainName{
									field: account_domain
								}
							}

			  		]
				}
				{
					# fallback rule when grok failed to match properties
					commands : [
						{ logWarn { format : "Record does not contain proper grok fields, Drop the record. Original message was: {}", args : ["@{message}"] } }
						{ LogFilterEvent { errorMessage: "Record does not contain proper grok fields"}}
						{ dropRecord {} }  
					]
				}
		  	]
			}
		}
		{ 
			if { 
				conditions : [ 
					{ equals { security_id : [] } } 
				] 
				then : [
					{ logWarn { format : "Record does not contain security_id field, Drop the record. Original message was: {}", args : ["@{message}"] } }
					{ LogFilterEvent { errorMessage: "Record does not contain security_id"}}
					{ dropRecord {} }
				] 
			} 
		}
		{ 
			if { 
				conditions : [ 
					{ equals { failure_code : [] } } 
				] 
				then : [
					{ logWarn { format : "Record does not contain failure_code field, Drop the record. Original message was: {}", args : ["@{message}"] } }
					{ LogFilterEvent { errorMessage: "Record does not contain failure_code field"}}
					{ dropRecord {} }
				] 
			} 
		}
		{
			setValues {
				status : ["FAILURE"]
				data_source : ["kerberos_tgt"]
				last_state : ["etl"]
			}
		}

# Is written to the same kafka topic as 4768 and will be enriched by the samza tasks.
#		{
#			IsSensitiveMachine {
#				machineNameField : machine_name
#				isSensitiveMachineField : is_sensitive_machine
#			}
#		}
    	]
  	}
]
