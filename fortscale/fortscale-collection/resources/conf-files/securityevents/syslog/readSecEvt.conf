morphlines : [
  {
    id : Parsing_SecurityEvents
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

    commands : [
      {
        grok {
          dictionaryString: """
								DATE .+(?<= \d\d:\d\d:\d\d)
								TEXT .+
								 """
          findSubstrings: true
          addEmptyStrings: true
          numRequiredMatches: all
          expressions: {
            message: """%{DATE:date_time}\s%{TEXT:messageData}"""
          }
        }
      }
      {
        grok {
          dictionaryString : """
					EVENT_CODE (?<=\[success\]\040)[0-9]+|(?<=\[failure\]\040)[0-9]+
					 """
          findSubstrings : true
          addEmptyStrings : true
          numRequiredMatches : all
          expressions : {
            messageData : "%{EVENT_CODE:eventCode}"
          }
        }
      }
      {
        if {
          conditions: [
            {not {equals {eventCode: ["4624"]}}}
          ]
          then: [
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {
                        grok {
                          dictionaryString: """
                          REPORTING_SERVER (?<= \d\d:\d\d:\d\d )\S+(?= )
				  		  CLIENT_ADDRESS (?<=Client Address:).+?(?=Client Port:)
				  		  TICKET_OPTIONS (?<=Ticket Options:)[\s0-9x]+
				  		  ACCOUNT_NAME (?<=Account Name:).+?(?=Supplied Realm Name)|(?<=Account Name:).+?(?=Account Domain)|(?<=Account Name:).+?(?=Service Information)
			  	          TIMEZONE (?<=timezone )\S+
										 """
                          findSubstrings: true
                          addEmptyStrings: true
                          numRequiredMatches: all
                          expressions: {
                            messageData: "%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_NAME:account_name}|%{CLIENT_ADDRESS:client_address}|%{TICKET_OPTIONS:ticket_options}|%{TIMEZONE:timezone}"
                          }
                        }
                      }
                      {toString {field: client_address, trim: true}}
                      {toString {field: ticket_options, trim: true}}
                      {toString {field: account_name, trim: true}}
                      {toString {field: reporting_server, trim: true}}
	                  {toString {field: timezone, trim: true}}
                    ]
                  }
                ]
              }
            }
            {
              EmptyObjectFilter {
                filterFields: [eventCode, account_name, client_address, ticket_options]
              }
            }
            #the first overflow filter command insures that the overflow is not caused by a single user in the system
            {
              OverFlowFilter {
                eventsType: securityEvents
                criteria: [eventCode, account_name]
                threshold: 100000
              }
            }
            {
              OverFlowFilter {
                eventsType: securityEvents
                criteria: [eventCode]
                threshold: 2000000
              }
            }
            {
              if {
                conditions : [
                  { equals { timezone : [] }}
                ]
                then : [
                  {
                      GetTimezone {
                          sourceType : "sec"
                          hostnameField : reporting_server
                          timezoneOutputField : timezone_input
                      }
                  }
                ]
                else : [
                  {
                      addValues {
                          timezone_input : "@{timezone}"
                      }
                  }
                ]
              }
            }
            {
              findReplace {
                field: account_name
                isRegex: false
                pattern: "'"
                replacement: ""
              }
            }

            {
              addValues {
                timeGeneratedRaw: "@{date_time}"
                date_time_unix: "@{date_time}"
              }
            }
            # Adding isComputer.
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
							String account_name = (String)record.getFirstValue("account_name");
							Boolean isComputer = account_name.contains("$") ? true : false;
							record.replaceValues("isComputer", isComputer);
							return child.process(record);
							"""
              }
            }
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {
                        AddYearToDatetime {
                          dateFormat :  "yyyy MMM dd HH:mm:ss"
                          timezone : timezone_input
                        }
                      }
                      {
                        setValues {
                          date_time_unix: "@{date_time}"
                        }
                      }
                      {
                        convertTimestampFortscale {
                          field: date_time
                          inputFormats: ["yyyy MMM dd HH:mm:ss"]
                          inputTimezoneField: timezone_input
                          outputFormat: "yyyy-MM-dd HH:mm:ss"
                        }
                      }
                      {
                        convertTimestampFortscale {
                          field: date_time_unix
                          inputFormats: ["yyyy MMM dd HH:mm:ss"]
                          inputTimezoneField: timezone_input
                          outputFormat: "unixTimeInSeconds"
                        }
                      }
                    ]
                  }
                ]
              }
            }
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {
                        findReplace {
                          field: client_address
                          pattern: "::1"
                          isRegex: false
                          replacement: "127.0.0.1"
                          replaceFirst: false
                        }
                      }
                      {
                        findReplace {
                          field: client_address
                          pattern: "::ffff:"
                          isRegex: false
                          replacement: ""
                          replaceFirst: false
                        }
                      }
                    ]
                  }
                ]
              }
            }

            # test if the ip address used is a vpn or any other nat address
            # to use it comment out the set value command and un-comment the MatchIP command and set it with
            # the appropriate cidr
            {
              addValues {
                is_nat : false
              }
            }
            #{
            #  MatchIP {
            #    ipAddress: "client_address"
            #    cidr: "192.168.0.22"
            #    output: "is_nat"
            #  }
            #}
          ]
        }
      }
    ]
  }
]
