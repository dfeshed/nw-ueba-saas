morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}
                {
                  # filter only message containing "login succeeded" or "session started" in message,
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: """(?<type>(login succeeded|Login succeeded|Session started for user with IP|Login failed using auth server|Closed connection to))"""
                    }
                  }
                }
                {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}
              ]
            }

            {
              commands: [
                {logDebug {format: "Record is not one of the expected juniper vpn event types. Dropping record: {}", args: ["@{}"]}}
                {LogFilterEvent {errorMessage: "Record is not one of the expected juniper vpn event types"}}
                {
                  dropRecord {}
                }
              ]
            }
            {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}
          ]
        }
      }

      {
        if {
          conditions: [
            # if closed connection then
            {equals {type: [Closed connection to]}}
          ]
          then: [
            {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.juniper.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{CLOSE_SESSION_LOCALIPORIPV6:local_ip}|%{DATESTAMPFULLYEAR:date_time}|%{DURATION:duration}|%{READBYTES:readbytes}|%{WRITEBYTES:writebytes}"
                }
              }
            }
            {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["CLOSED"]
                date_time_unix: "@{date_time}"
              }
            }

            # Adding total bytes.
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
                  String readbytes = (String)record.getFirstValue("readbytes");
                  String writebytes = (String)record.getFirstValue("writebytes");
                  Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                  record.replaceValues("totalbytes", totalbytes);
                  return child.process(record);
                  """
              }
            }

          ]
        }
      }
      {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}

      {
        if {
          conditions: [
            # if auth failed then
            {equals {type: [Login failed using auth server]}}
          ]
          then: [
            {logDebug {format: "AUTH_FAILED: {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.juniper.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{DATESTAMPFULLYEAR:date_time}"
                }
              }
            }
            {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["FAIL"]
                date_time_unix: "@{date_time}"
              }
            }
          ]
        }
      }

      {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}


      {
        if {
          conditions: [
            # if auth success then
            {contains {type: [login succeeded, Login succeeded]}}
          ]
          then: [
            # handle agent login succeeded message and extract fields from it
            # get the source ip, time and user name from the login event
            # based on these we can get the hostname later on
            {logDebug {format: "Debug -10 : {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.juniper.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME_LOGINSUCCEEDED:username}|%{SOURCEIPORIPV6_LOGINSUCCEEDED:source_ip}|%{DATESTAMPFULLYEAR:date_time}|%{TIMEZONE:timezone}"
                }
              }
            }

            {logDebug {format: "Debug -11 : {}", args: ["@{}"]}}


            {
              setValues {
                status: ["SUCCESS"]
                date_time_unix: "@{date_time}"
              }
            }

            #Prepare the date_time_unix for the event joiner
            {
              if {
                conditions: [
                  {equals {timezone: []}}
                ]
                then: [
                  {
                    GetTimezone {
                      sourceType: "vpn"
                      hostnameField: reporting_server
                      timezoneOutputField: timezone_input
                    }
                  }
                ]
                else: [
                  {
                    addValues {
                      timezone_input: "@{timezone}"
                    }
                  }
                ]
              }
            }
            {logDebug {format: "Debug -12 : {}", args: ["@{}"]}}

            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {logDebug {format: "Debug -13 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time
                          inputTimezoneField: timezone_input
                          outputFormat: "yyyy-MM-dd HH:mm:ss"
                        }
                      }
                      {logDebug {format: "Debug -14 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time_unix
                          inputTimezoneField: timezone_input
                          outputFormat: "unixTimeInSeconds"
                        }
                      }
                      {logDebug {format: "Debug -15 : {}", args: ["@{}"]}}
                    ]
                  }

                  {
                    commands: [
                      {logWarn {format: "Problem timeGenerated: {}", args: ["@{timeGenerated}"]}}
                    ]
                  }
                ]
              }
            }


            {logDebug {format: "Debug -16 : {}", args: ["@{}"]}}
            {
              EventsJoiner {
                keys: ["source_ip", "username"]
                mergeFields: ["local_ip", "hostname"]
                cacheName: "vpn"
                timeThreshold: 86400
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
              }
            }

            {logDebug {format: "Debug -17 : {}", args: ["@{}"]}}


          ]
        }
      }
      {logDebug {format: "Debug -18 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {type: [Session started for user with IP]}}
          ]
          then: [
            # handle session started events, get the hostname from it
            # and correlated it to previous saved login succeeded event
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.juniper.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{LOCALIPORIPV6:local_ip}|%{HOSTNAME:hostname}|%{DATESTAMPFULLYEAR:date_time}|%{TIMEZONE:timezone}"
                }
              }
            }
            {
              SubString {
                field: hostname
                endCharacter: "."
              }
            }

            {
              setValues {
                status: ["SUCCESS"]
                date_time_unix: "@{date_time}"
              }
            }


            #Prepare the date_time_unix for the event joiner
            {
              if {
                conditions: [
                  {equals {timezone: []}}
                ]
                then: [
                  {
                    GetTimezone {
                      sourceType: "vpn"
                      hostnameField: reporting_server
                      timezoneOutputField: timezone_input
                    }
                  }
                ]
                else: [
                  {
                    addValues {
                      timezone_input: "@{timezone}"
                    }
                  }
                ]
              }
            }

            {logDebug {format: "Debug -19 : {}", args: ["@{}"]}}
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {logDebug {format: "Debug -20 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time
                          inputTimezoneField: timezone_input
                          outputFormat: "yyyy-MM-dd HH:mm:ss"
                        }
                      }
                      {logDebug {format: "Debug -21 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time_unix
                          inputTimezoneField: timezone_input
                          outputFormat: "unixTimeInSeconds"
                        }
                      }
                      {logDebug {format: "Debug -22 : {}", args: ["@{}"]}}
                    ]
                  }

                  {
                    commands: [
                      {logWarn {format: "Problem timeGenerated: {}", args: ["@{timeGenerated}"]}}
                    ]
                  }
                ]
              }
            }


            {logDebug {format: "Befor Join current record is :  {}", args: ["@{}"]}}
            {
              EventsJoiner {
                keys: ["source_ip", "username"]
                mergeFields: ["date_time", "date_time_unix"]
                cacheName: "vpn"
                timeThreshold: 86400
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
              }
            }

            {logDebug {format: "After Join current record is :  {}", args: ["@{}"]}}


          ]
        }
      }

      {logDebug {format: "Debug -23 : {}", args: ["@{}"]}}
      #in case that the record is not "Session started for user with IP" or "login succeeded"
      {
        if {
          conditions: [
            {not {contains {type: [Session started for user with IP, login succeeded]}}}
          ]
          then: [


            #Prepare the date_time_unix for the event joiner
            {
              if {
                conditions: [
                  {equals {timezone: []}}
                ]
                then: [
                  {
                    GetTimezone {
                      sourceType: "sec"
                      hostnameField: reporting_server
                      timezoneOutputField: timezone_input
                    }
                  }
                ]
                else: [
                  {
                    addValues {
                      timezone_input: "@{timezone}"
                    }
                  }
                ]
              }
            }

            {logDebug {format: "Debug -24 : {}", args: ["@{}"]}}
            {
              tryRules {
                catchExceptions: true
                throwExceptionIfAllRulesFailed: false
                rules: [
                  {
                    commands: [
                      {logDebug {format: "Debug -25 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time
                          inputTimezoneField: timezone_input
                          outputFormat: "yyyy-MM-dd HH:mm:ss"
                        }
                      }
                      {logDebug {format: "Debug -26 : {}", args: ["@{}"]}}
                      {
                        convertTimestampFortscale {
                          field: date_time_unix
                          inputTimezoneField: timezone_input
                          outputFormat: "unixTimeInSeconds"
                        }
                      }
                      {logDebug {format: "Debug -27 : {}", args: ["@{}"]}}
                    ]
                  }

                  {
                    commands: [
                      {logWarn {format: "Problem timeGenerated: {}", args: ["@{timeGenerated}"]}}
                    ]
                  }
                ]
              }
            }

          ]
        }

      }
      {logDebug {format: "Debug -28 : {}", args: ["@{}"]}}
      {
        EmptyObjectFilter {
          filterFields: [username]
        }
      }
      {logDebug {format: "Debug -29 : {}", args: ["@{}"]}}
      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: [username]
          threshold: 100000
        }
      }
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: []
          threshold: 1000000
        }
      }


      {
        setValues {
          addsessiondata: true
        }
      }
      {logDebug {format: "Debug -30 : {}", args: ["@{}"]}}
    ]
  }
]
