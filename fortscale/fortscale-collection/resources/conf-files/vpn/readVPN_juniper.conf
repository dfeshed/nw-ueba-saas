morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [	
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [	    
								{
									# filter only message containing "login succeeded" or "session started" in message, 
									# all other will be discarded in the dropRecord command bellow
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<type>(login succeeded|Login succeeded|Session started for user with IP|Login failed using auth server|Closed connection to))"""
										}
									}		  
								}			 
							]
						}
						
						{
							commands : [
								{	logDebug	{	format : "Record is not one of the expected juniper vpn event types. Dropping record: {}", args : ["@{}"] } }
								{   LogFilterEvent { errorMessage: "Record is not one of the expected juniper vpn event types"}}
								{
									dropRecord {}
								}				
							]
						}						
					]
				}
			}
			
			{
				if {
					conditions : [
						# if closed connection then		  
						{ equals  { type : [Closed connection to] } }
					]
					then : [
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{CLOSE_SESSION_LOCALIPORIPV6:local_ip}|%{DATESTAMPFULLYEAR:date_time}|%{DURATION:duration}|%{READBYTES:readbytes}|%{WRITEBYTES:writebytes}"
								}
							}		  
						}
						
						{
							setValues {
								status : ["CLOSED"]
								date_time_unix: "@{date_time}"
							}
						}
						
						# Adding total bytes.
						{
							java {
								imports : "import java.util.*;"
								code:
									"""
									String readbytes = (String)record.getFirstValue("readbytes");
									String writebytes = (String)record.getFirstValue("writebytes");
									Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
									record.replaceValues("totalbytes", totalbytes);
									return child.process(record);
									"""
							}
						}
						
					]
				}
			}
	
			
			{
				if {
					conditions : [
						# if auth failed then		  
						{ equals  { type : [Login failed using auth server] } }
					]
					then : [
						{ logDebug { format : "AUTH_FAILED: {}", args : ["@{}"] } }    	  
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{DATESTAMPFULLYEAR:date_time}"
								}
							}		  
						}
						
						{
							setValues {
								status : ["FAIL"]
								date_time_unix: "@{date_time}"
							}
						}
					]					 
				}
			}



	
			{
				if {
					conditions : [
						# if auth success then
						{ contains { type : [login succeeded,Login succeeded] }}
					]
					then : [
						# handle agent login succeeded message and extract fields from it
						# get the source ip, time and user name from the login event
						# based on these we can get the hostname later on
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME_LOGINSUCCEEDED:username}|%{SOURCEIPORIPV6_LOGINSUCCEEDED:source_ip}|%{DATESTAMPFULLYEAR:date_time}|%{TIMEZONE:timezone}"
								}
							}
						}





                        {
                            setValues {
                                status : ["SUCCESS"]
                                date_time_unix: "@{date_time}"
                            }
                        }

                        #Prepare the date_time_unix for the event joiner
                        {
							if {
							  conditions : [
								{ equals { timezone : [] }}
							  ]
							  then : [
								{
									GetTimezone {
										sourceType : "vpn"
										hostnameField : reporting_server
										timezoneOutputField : timezone_input
									}
								}
							  ]
							  else : [
								{
									addValues {
										timezone_input : "@{timezone}"
									}
								}
							  ]
							}
                        }


                        {
                            tryRules {
                                catchExceptions : true
                                throwExceptionIfAllRulesFailed : false
                                rules : [
                                    {
                                        commands : [
                                            {
                                                convertTimestampFortscale {
                                                    field : date_time
                                                    inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                    inputTimezoneField : timezone_input
                                                    outputFormat : "yyyy-MM-dd HH:mm:ss"
                                                }
                                            }

                                            {
                                                convertTimestampFortscale {
                                                    field : date_time_unix
                                                    inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                    inputTimezoneField : timezone_input
                                                    outputFormat : "unixTimeInSeconds"
                                                }
                                            }
                                        ]
                                    }

                                    {
                                        commands : [
                                            { logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
                                        ]
                                    }
                                ]
                            }
                        }



						{
							EventsJoiner {
								keys : [ "source_ip", "username" ]
								mergeFields : [ "local_ip","hostname" ]
								cacheName : "vpn"
                                timeThreshold : 86400
                                currentRecordDateField : date_time_unix
                                cachedRecordDateField :  date_time_unix
                                dropFromCache : true
							}
						}





					]
				}
			}
			
			{
				if {
					conditions : [
						{ equals { type : [Session started for user with IP] }}
					]
					then : [
						# handle session started events, get the hostname from it
						# and correlated it to previous saved login succeeded event
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
								message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{LOCALIPORIPV6:local_ip}|%{HOSTNAME:hostname}|%{DATESTAMPFULLYEAR:date_time}|%{TIMEZONE:timezone}"
								}
							}
						}
						{
							SubString {
								field : hostname
								endCharacter : "."
							}
						}

                        {
                            setValues {
                                status : ["SUCCESS"]
                                date_time_unix: "@{date_time}"
                            }
                        }


                        #Prepare the date_time_unix for the event joiner
                        {
							if {
							   conditions : [
								{ equals { timezone : [] }}
							   ]
							   then : [
								{
									GetTimezone {
										sourceType : "vpn"
										hostnameField : reporting_server
										timezoneOutputField : timezone_input
									}
								 }
							   ]
							   else : [
								{
									addValues {
										timezone_input : "@{timezone}"
									}
								 }
							   ]
							 }
                        }


			            {
                            tryRules {
                                catchExceptions : true
                                throwExceptionIfAllRulesFailed : false
                                rules : [
                                    {
                                        commands : [
                                            {
                                                convertTimestampFortscale {
                                                    field : date_time
                                                    inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                    inputTimezoneField : timezone_input
                                                    outputFormat : "yyyy-MM-dd HH:mm:ss"
                                                }
                                            }

                                            {
                                                convertTimestampFortscale {
                                                    field : date_time_unix
                                                    inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                    inputTimezoneField : timezone_input
                                                    outputFormat : "unixTimeInSeconds"
                                                }
                                            }
                                        ]
                                    }

                                    {
                                        commands : [
                                            { logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
                                        ]
                                    }
                                ]
				            }
			            }


            {logDebug {format: "Befor Join current record is :  {}", args: ["@{}"]}}
						{
							EventsJoiner {
								keys : [ "source_ip", "username" ]
								mergeFields : [ "date_time","date_time_unix" ]
								cacheName : "vpn"
                                timeThreshold : 86400
                                currentRecordDateField : date_time_unix
                                cachedRecordDateField :  date_time_unix
                                dropFromCache : true
							}
						}

						{logDebug {format: "After Join current record is :  {}", args: ["@{}"]}}





					]
				}
			}


			#in case that the record is not "Session started for user with IP" or "login succeeded"
			{
			    if{
			        conditions : [
			            {not {contains {type : [Session started for user with IP,login succeeded] } } }
			        ]
			        then : [


			                #Prepare the date_time_unix for the event joiner
                            {
								if {
								  conditions : [
									{ equals { timezone : [] }}
								  ]
								  then : [
									{
										GetTimezone {
											sourceType : "sec"
											hostnameField : reporting_server
											timezoneOutputField : timezone_input
										}
									}
								  ]
								  else : [
									{
										addValues {
											timezone_input : "@{timezone}"
										}
									}
								  ]
								}
                            }


                            {
                                tryRules {
                                    catchExceptions : true
                                    throwExceptionIfAllRulesFailed : false
                                    rules : [
                                        {
                                            commands : [
                                                {
                                                    convertTimestampFortscale {
                                                        field : date_time
                                                        inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                        inputTimezoneField : timezone_input
                                                        outputFormat : "yyyy-MM-dd HH:mm:ss"
                                                    }
                                                }

                                                {
                                                    convertTimestampFortscale {
                                                        field : date_time_unix
                                                        inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
                                                        inputTimezoneField : timezone_input
                                                        outputFormat : "unixTimeInSeconds"
                                                    }
                                                }
                                            ]
                                        }

                                        {
                                            commands : [
                                                { logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
                                            ]
                                        }
                                    ]
                                }
                            }

			        ]
			    }

			}
	
			{
				EmptyObjectFilter {
					filterFields : [username]
				}
			}
			#the first overflow filter command insures that the overflow is not caused by a single user in the system
			{
				OverFlowFilter {
					eventsType : vpn
					criteria : [username]
					threshold : 100000
				}
			}
			{
				OverFlowFilter {
					eventsType : vpn
					criteria : []
					threshold : 1000000
				}
			}

	

			
			{
				setValues {
					addsessiondata: true
				}
			}
		]
	}
]
