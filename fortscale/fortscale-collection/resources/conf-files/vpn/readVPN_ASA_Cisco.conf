morphlines: [
  {
    id: VPN_ASA_CISCO
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  # filter  message by specific groups "Group <AnyConnect_policy>", "Group = Everyone" or "Group=ciscovpn4cluster" or "Group=ciscovpncluster" or "Group=crdc_webex_employee" or "Group=CRDC_users"  or "Group <apple_short>" or "Group:AnyConnect_IPSec_policy"
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {message: """(?<group>(<AnyConnect_policy>|AnyConnect_profile|Everyone|ciscovpn4cluster|ciscovpncluster|crdc_webex_employee|CRDC_users|<apple_short>|<apple_long>|apple_short|apple_long|%ASA-6-11|AnyConnect_IPSec_policy|DefaultWEBVPNGroup)|<AppleiOS>|AppleiOS|<DX>|DX|<Android>|Android)|BLD23"""}
                  }
                }
              ]
            }
            {
              commands: [
                {logDebug {format: "Record doesn't meet the specific groups we parse. Dropping record: {}", args: ["@{}"]}}
                {LogFilterEvent {errorMessage: "Record doesn't meet the specific groups we parse"}}
                {
                  dropRecord {}
                }
              ]
            }
          ]
        }
      }


      {
        grok {
          dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
          findSubstrings: true
          addEmptyStrings: true
          numRequiredMatches: all
          expressions: {
            message: "%{DATESTAMP:date_time}|%{REPORTERSERVER:reporting_server}|%{EVENTTYPE:EventType}|%{TIMEZONE:timezone}"
          }
        }
      }


      {
        EmptyObjectFilter {
          filterFields: [date_time, EventType]
        }
      }

      {
        setValues {
          date_time_unix: "@{date_time}"
        }

      }




      #Hnadle case that the time zone is explicit with the event (from flume)
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "vpn"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }

      {
        convertTimestampFortscale {
          field: date_time_unix
          inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField: timezone_input
          outputFormat: "unixTimeInSeconds"

        }
      }

      #Handle session replace/resumed (help us to ignore the seesion start that related to that type)
      {
        if {
          conditions: [{contains {EventType: ["ASA-6-716059", "ASA-5-722032"]}}]
          then: [

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{USERNAMEAnyConnect:username}"
                }
              }
            }

            {
              findReplace {
                field: username
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                pattern: """%{REGEX_TO_REMOVE}"""
                isRegex: true
                replacement: ""
                replaceFirst: false
              }
            }


            {
              setValues {
                fake_session: "@{EventType}"
              }
            }


            #keep in the cahce
            {
              EventsJoiner {
                keys: ["username", "date_time"]
                mergeFields: []
                cacheName: "vpn"
                timeThreshold: -1
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
              }
            }


          ]
        }
      }

      #In case of Group = AnyConnect_IPSec_policy
      {
        if {
          conditions: [{contains {EventType: ["ASA-5-751025"]}}]
          then: [

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{USERNAME751025:username}|%{REMOTEIP751025:source_ip}|%{LOCALIPV4751025:local_ip}"
                }
              }
            }

            {
              findReplace {
                field: username
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                pattern: """%{REGEX_TO_REMOVE}"""
                isRegex: true
                replacement: ""
                replaceFirst: false
              }
            }
          ]
        }
      }



      {
        #In case of close event
        if {
          conditions: [{contains {EventType: ["ASA-4-113019"]}}]
          then: [
            {
              if {
                #Apple short and long
                conditions: [{contains {group: ["apple_short", "apple_long"]}}]
                then: [
                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{USERNAMECloseApple:username}|%{SOURCEIPOther:source_ip}|%{DURATION:durationStr}|%{READBYTESOther:readbytes}|%{WRITEBYTESOther:writebytes}"
                      }
                    }
                  }

                  {
                    EmptyObjectFilter {
                      filterFields: [username]
                    }
                  }


                  {
                    findReplace {
                      field: username
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      pattern: """%{REGEX_TO_REMOVE}"""
                      isRegex: true
                      replacement: ""
                      replaceFirst: false
                    }
                  }


                ]

                #All others group
                else: [
                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{USERNAMEOther:username}|%{SOURCEIPOther:source_ip}|%{DURATION:durationStr}|%{READBYTESOther:readbytes}|%{WRITEBYTESOther:writebytes}"
                      }
                    }
                  }

                  {
                    findReplace {
                      field: username
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      pattern: """%{REGEX_TO_REMOVE}"""
                      isRegex: true
                      replacement: ""
                      replaceFirst: false
                    }
                  }

                ]
              }
            }
            {
              EmptyObjectFilter {
                filterFields: [source_ip, username]
              }
            }
            {
              setValues {
                status: ["CLOSED"]
              }
            }
          ]

          else: [
            {
              #Fail without the group sign
              if {
                conditions: [{contains {EventType: ["ASA-6-113013", "ASA-6-113005"]}}]
                then: [


                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{USERNAMEFailsWIthoutGroups:username}|%{SOURCEIP_GLOBALFAIL:source_ip}"
                      }
                    }
                  }

                  {
                    findReplace {
                      field: username
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      pattern: """%{REGEX_TO_REMOVE}"""
                      isRegex: true
                      replacement: ""
                      replaceFirst: false
                    }
                  }

                  {
                    setValues {
                      status: ["FAIL"]
                    }
                  }


                ]

                #handle the groups type + mark session type
                else: [
                  #handle the groups type
                  {

                    #case of group is AnyConnect:
                    if {
                      #case that its session start or fail - type = Group <AnyConnect_policy> (status = success or fail)
                      conditions: [{equals {group: ["<AnyConnect_policy>"]}}]
                      then: [


                        # handle Start Session event
                        # extract source IP field,datetime,user name,local_ip
                        # set values- geoip, date_time_unix , status

                        {
                          grok {
                            dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                            findSubstrings: true
                            addEmptyStrings: true
                            numRequiredMatches: all
                            expressions: {
                              message: "%{USERNAMEAnyConnect:username}|%{SOURCEIPAnyConnect:source_ip}|%{LOCALIPAnyConnect:local_ip}"
                            }
                          }
                        }

                        {
                          findReplace {
                            field: username
                            dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                            pattern: """%{REGEX_TO_REMOVE}"""
                            isRegex: true
                            replacement: ""
                            replaceFirst: false
                          }
                        }


                      ]

                      #other groups (status = success/fail)
                      else: [
                        {
                          #case the session is Everyone
                          if {
                            conditions: [{equals {group: ["Everyone"]}}]
                            then: [
                              # handle Start Session events
                              # extract datetime,user,source IP ,local_ip(optional in case of dtart)
                              # set values- geoip, date_time_unix ,
                              {
                                grok {
                                  dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                  findSubstrings: true
                                  addEmptyStrings: true
                                  numRequiredMatches: all
                                  expressions: {
                                    message: "%{USERNAMEEveryone:username}|%{SOURCEIPEveryone:source_ip}|%{LOCALIPEveryone:local_ip}"
                                  }
                                }


                              }

                              {
                                findReplace {
                                  field: username
                                  dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                  pattern: """%{REGEX_TO_REMOVE}"""
                                  isRegex: true
                                  replacement: ""
                                  replaceFirst: false
                                }
                              }


                            ]
                            else: [
                              #Other group
                              {
                                if {
                                  conditions: [{contains {group: ["ciscovpn4cluster", "ciscovpncluster", "crdc_webex_employee", "CRDC_users",]}}]
                                  then: [
                                    # handle Start Session events
                                    # extract datetime,user,source IP ,local_ip(optional in case of dtart)
                                    # set values- geoip, date_time_unix , status

                                    {
                                      grok {
                                        dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                        findSubstrings: true
                                        addEmptyStrings: true
                                        numRequiredMatches: all
                                        expressions: {
                                          message: "%{USERNAMEOther:username}|%{SOURCEIPOther:source_ip}|%{LOCALIPOther:local_ip}"
                                        }
                                      }


                                    }

                                    {
                                      findReplace {
                                        field: username
                                        dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                        pattern: """%{REGEX_TO_REMOVE}"""
                                        isRegex: true
                                        replacement: ""
                                        replaceFirst: false
                                      }
                                    }

                                  ]

                                  #case of Apple
                                  else: [
                                    {
                                      if {
                                        conditions: [{contains {group: ["<apple_short>", "<apple_long>", "<AppleiOS>", "<DX>", "<Android>", "<AnyConnect_policy>", "<BLD23>"]}}]
                                        then: [


                                          # handle Start Session events
                                          # extract datetime,user,source IP ,local_ip(optional in case of dtart)
                                          # set values- geoip, date_time_unix , status

                                          {
                                            grok {
                                              dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                              findSubstrings: true
                                              addEmptyStrings: true
                                              numRequiredMatches: all
                                              expressions: {
                                                message: "%{USERNAMETEMPApple:username}|%{SOURCEIPApple:source_ip}|%{LOCALIPApple:local_ip}"
                                              }
                                            }

                                          }


                                          {
                                            EmptyObjectFilter {
                                              filterFields: [username]
                                            }
                                          }


                                          {
                                            findReplace {
                                              field: username
                                              dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                              pattern: """%{REGEX_TO_REMOVE}"""
                                              isRegex: true
                                              replacement: ""
                                              replaceFirst: false
                                            }
                                          }


                                        ]
                                      }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  }
                  {logDebug {format: "After parsing current record is : {}", args: ["@{}"]}}

                  {
                    EmptyObjectFilter {
                      filterFields: [username]
                    }
                  }

                  {logDebug {format: "After validation current record is : {}", args: ["@{}"]}}


                  #resolving status

                  {
                    #ssesion fail ?
                    if {
                      conditions: [{contains {EventType: ["ASA-6-716002", "ASA-6-713905", "ASA-5-713068", "ASA-4-717037", "ASA-4-713903", "ASA-4-713251", "ASA-3-713218", "ASA-3-713167", "ASA-6-716039"]}}]
                      then: [


                        {
                          setValues {
                            status: ["FAIL"]
                          }
                        }


                        {
                          EmptyObjectFilter {
                            filterFields: [source_ip]
                          }
                        }

                      ]
                      else: [
                        {
                          #Session start
                          if {
                            conditions: [{contains {EventType: ["ASA-4-713228", "ASA-4-722051", "ASA-7-722051", "ASA-5-751025"]}}]
                            then: [


                              {
                                EmptyObjectFilter {
                                  filterFields: [source_ip, local_ip]
                                }
                              }


                              #Retrive from cahce
                              {
                                EventsJoinerMerge {
                                  keys: ["username", "date_time"]
                                  mergeFields: ["fake_session"]
                                  dropWhenNoMatch: false
                                  dropFromCache: true
                                  cacheName: "vpn"
                                }
                              }

                              #In case that the current start session is related to prev resume\replace events drop it (fake session)
                              {
                                if {
                                  conditions: [{not {equals {fake_session: []}}}]
                                  then: [
                                    {LogFilterEvent {errorMessage: "Session is related to prev events"}}
                                    {
                                      dropRecord {}
                                    }

                                  ]
                                }
                              }


                              {
                                setValues {
                                  status: ["SUCCESS"]
                                }
                              }

                            ]
                            else: [
                              {LogFilterEvent {errorMessage: "Event type is not match to list of types"}}
                              {
                                dropRecord {}
                              }
                            ]
                          }
                        }

                      ]
                    }
                  }
                ]
              }
            }
          ]
        }
      }




      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case of status = CLOSE
      {

        if {
          conditions: [{equals {status: ["CLOSED"]}}]
          then: [

            {
              EmptyObjectFilter {
                filterFields: [source_ip, readbytes, writebytes]
              }
            }

            {
              java {
                imports: ""
                code: """
                          String durationStr = (String)record.getFirstValue("durationStr");
                          try{
                          if (durationStr != null) {
                            long duration = 0;
                            int startInd = 0;
                            int endInd = durationStr.indexOf("d", startInd);
                            if(endInd > -1){
                              duration += 24*3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
                              startInd = endInd+1;
                            }
                            endInd = durationStr.indexOf("h:", startInd);
                            if(endInd > -1){
                              duration += 3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
                              startInd = endInd+2;
                            }
                            endInd = durationStr.indexOf("m:", startInd);
                            if(endInd > -1){
                              duration += 60*Long.parseLong(durationStr.substring(startInd, endInd).trim());
                              startInd = endInd+2;
                            }
                            endInd = durationStr.indexOf("s", startInd);
                            if(endInd > -1){
                              duration += Long.parseLong(durationStr.substring(startInd, endInd).trim());
                            }
                            if(duration > 0){
                              record.replaceValues("duration", duration);
                            }
                          }
                          } catch(Exception e){}
                          return child.process(record);
                 """
              }
            }

            # Adding total bytes.
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
                                   String readbytes = (String)record.getFirstValue("readbytes");
                                   String writebytes = (String)record.getFirstValue("writebytes");
                                   Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                   record.replaceValues("totalbytes", totalbytes);
                                   return child.process(record);
                                   """
              }
            }

            #TODO- add the calculation of the duration here

          ]
        }
      }

      {
        OverFlowFilter {
          eventsType: vpn
          criteria: [username]
          threshold: 100000
        }
      }
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: []
          threshold: 1000000
        }
      }


      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case of status = SUCCESS

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      {
        convertTimestampFortscale {
          field: date_time
          inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField: timezone_input
          outputFormat: "yyyy-MM-dd HH:mm:ss"
        }
      }


      {
        setValues {
          addsessiondata: false
        }

      }

    ]

  }
]
