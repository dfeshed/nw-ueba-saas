morphlines :[
  {
    id : VPN_CISCO_ZURICH
    importCommands : ["org.kitesdk.morphline.**","org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [

      # parse the raw message, extract all fields from the message, assuming the following format:
      # Date,Time,User-Name,Group-Name,Calling-Station-Id,Acct-Status-Type,Acct-Session-Id,Acct-Session-Time,Service-Type,Framed-Protocol,Acct-Input-Octets,Acct-Output-Octets,Acct-Input-Packets,Acct-Output-Packets,Framed-IP-Address,NAS-Port,NAS-IP-Address
      # 10/11/2014,9:19:00,uswh90d,Default Group,82.166.88.97,Stop,C835EF40,86411,Framed,PPP,1695516365,57523813,2185880,1275031,10.128.61.42,195923968,10.148.1.72

      {
       tryRules {
            catchExceptions : true
            throwExceptionIfAllRulesFailed : false
            rules : [
              {
                  commands : [
                        {
                          grok {
                          	  dictionaryString : """
                          	    ORIGINAL_MESSAGE .+(?= Flume enrichment)
                          	    TIMEZONE (?<=timezone )\S+
                                """
                          	  findSubstrings : true
                            	  addEmptyStrings : true
                            	  expressions : {
                          	    	message : "%{ORIGINAL_MESSAGE:original_message}|%{TIMEZONE:timezone}"
                            	  }
                          }
                        }
                        {
                            split {
                              inputField : original_message
                              outputFields : [date,time,username,groupName,source_ip,type,sessionId,duration,serviceType,protocol,readbytes,writebytes,inputPackets,outputPackets,local_ip,NASPort,reporting_server]
                              separator : ","
                            }
                        }
                  ]
              }

              {
                      commands : [
                              {
                                split {
                                  inputField : message
                                  outputFields : [date,time,username,groupName,source_ip,type,sessionId,duration,serviceType,protocol,readbytes,writebytes,inputPackets,outputPackets,local_ip,NASPort,reporting_server]
                                  separator : ","
                                }
                              }
                      ]
              }
            ]
       }
    }



      # Drop record if the following fields are empty
      {
        EmptyObjectFilter {
          filterFields : [date,time,username,source_ip,type]
        }
      }

      # Create dateTime field
      {
        java {
          imports : "import java.util.*;"
          code:
            """

            record.put("date_time", record.getFirstValue("date") + " " + record.getFirstValue("time"));

            return child.process(record);
            """
        }
      }


      #print the tag value at debug
      { logDebug { format : "tag value is -  {}",args: ["@{type}"] } }

      {
        #Case that the record is Session Start
        if {
          conditions : [{ equals { type : ["Start"] }}]
          then : [


            {
              setValues {
                status : ["SUCCESS"]
              }
            }

            {

              setValues {
                date_time_unix: "@{date_time}"
              }
            }

            {

			if {
			  conditions : [
				{ equals { timezone : [] }}
			  ]
			  then : [
				{
					GetTimezone {
						sourceType : "vpn"
						hostnameField : reporting_server
						timezoneOutputField : timezone_input
					}
				}
			  ]
			  else : [
				{
					addValues {
						timezone_input : "@{timezone}"
					}
				}
			  ]
			}
            }


            {
              convertTimestampFortscale {
                field : date_time_unix
                inputTimezoneField : timezone_input
                outputFormat : "unixTimeInSeconds"
              }
            }


          ]
        }
      }

      #for debug
      {	logDebug	{	format : "current record is :  {}", args : ["@{}"] } }


      {
        ##Case that the record is Session disconnect
        if {
          conditions : [{ equals { type : ["Stop"] }}]
          then: [

            {
              EmptyObjectFilter {
                filterFields : [writebytes,readbytes]
              }
            }

            {
              setValues {
                status : ["CLOSED"]
              }
            }

            # Adding total bytes.
            {
              java {
                imports : "import java.util.*;"
                code:
                  """
                  String readbytes = (String)record.getFirstValue("readbytes");
                  String writebytes = (String)record.getFirstValue("writebytes");
                  Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                  record.replaceValues("totalbytes", totalbytes);
                  return child.process(record);
                  """
              }
            }

          ]
        }
      }

      #for debug
      {	logDebug	{	format : "current record is :  {}", args : ["@{}"] } }



      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }
      {
    	if {
    	  conditions : [
    		{ equals { timezone : [] }}
    	  ]
    	  then : [
    		{
    			GetTimezone {
    				sourceType : "vpn"
    				hostnameField : reporting_server
    				timezoneOutputField : timezone_input
    			}
    		}
    	  ]
    	  else : [
    		{
    			addValues {
    				timezone_input : "@{timezone}"
    			}
    		}
    	  ]
    	}
      }


      {
        # in case that this is not SUCCESS record insert the normalized_username and the date_time_unix
        if {
          conditions : [
            { not { equals {status: ["SUCCESS"]}}}
          ]
          then : [

            {

              setValues {
                date_time_unix: "@{date_time}"
              }


            }

            {
              if {
                conditions : [
                  { equals { timezone : [] }}
                ]
                then : [
                  {
                      GetTimezone {
                          sourceType : "vpn"
                          hostnameField : reporting_server
                          timezoneOutputField : timezone_input
                      }
                  }
                ]
                else : [
                  {
                      addValues {
                          timezone_input : "@{timezone}"
                      }
                  }
                ]
              }
            }

            {
              convertTimestampFortscale {
                field : date_time_unix
                inputTimezoneField : timezone_input
                outputFormat : "unixTimeInSeconds"
              }
            }

          ]
        }
      }

      {
        convertTimestampFortscale {
          field : date_time
          inputTimezoneField : timezone_input
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }



      {
        setValues {
          addsessiondata: false
        }
      }

    ]

  }
]
