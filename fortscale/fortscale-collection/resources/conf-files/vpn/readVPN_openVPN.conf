morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: """(?<status>(SIGTERM\[soft,remote-exit\]|TLS: soft reset|primary virtual IP for|'AUTH_FAILED'))"""
                    }
                  }
                }
              ]
            }
            {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}
            {
              commands: [
                {logDebug {format: "Record is not one of the expected openvpn event types. Dropping record: {}", args: ["@{}"]}}
                {LogFilterEvent {errorMessage: "Record is not one of the expected openvpn event types"}}
                {dropRecord {}}
              ]
            }
          ]
        }
      }
      {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            # if session closed
            {contains {status: ["TLS: soft reset", "SIGTERM[soft,remote-exit]"]}}
          ]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.openvpn.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME_CLOSE:username}|%{SOURCEIPORIPV6:source_ip}|%{DATE_TIME:date_time}|%{TOTALBYTES:totalbytes}"
                }
              }
            }
            {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["CLOSED"]
                date_time_unix: "@{date_time}"
                readbytes: "@{totalbytes}"
                writebytes: ""
                duration: ""
              }
            }

          ]
        }
      }
      {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            # if auth failed then
            {equals {status: ['"AUTH_FAILED'"]}}
          ]
          then: [
            {logDebug {format: "AUTH_FAILED: {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.openvpn.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME_FAIL:username}|%{IPORIPV6:source_ip}|%{DATE_TIME:date_time}"
                }
              }
            }
            {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["FAIL"]
                date_time_unix: "@{date_time}"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            # if auth success then
            {equals {status: [primary virtual IP for]}}
          ]
          then: [
            {logDebug {format: "AUTH SUCCESS: {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.openvpn.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{REPORTING_SERVER:reporting_server}|%{USERNAME_SUCCESS:username}|%{SOURCEIPORIPV6:source_ip}|%{DATE_TIME:date_time}|%{LOCALIPORIPV6:local_ip}|%{TIMEZONE:timezone}"
                }
              }
            }
            {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["SUCCESS"]
                date_time_unix: "@{date_time}"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}
      {
        EmptyObjectFilter {
          filterFields: [username]
        }
      }
      {logDebug {format: "Debug -10 : {}", args: ["@{}"]}}
      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: [username]
          threshold: 100000
        }
      }
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: []
          threshold: 1000000
        }
      }
      {logDebug {format: "Debug -11 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "sec"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -12 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {logDebug {format: "Debug -13 : {}", args: ["@{}"]}}
                {
                  convertTimestampFortscale {
                    field: date_time
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                  }
                }
                {logDebug {format: "Debug -14 : {}", args: ["@{}"]}}
                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }
                {logDebug {format: "Debug -15 : {}", args: ["@{}"]}}
              ]
            }

            {
              commands: [
                {logWarn {format: "Problem timeGenerated: {}", args: ["@{timeGenerated}"]}}
              ]
            }
          ]
        }
      }


      {
        setValues {
          addsessiondata: true
        }
      }
      {logDebug {format: "Debug -16 : {}", args: ["@{}"]}}
    ]
  }
]
