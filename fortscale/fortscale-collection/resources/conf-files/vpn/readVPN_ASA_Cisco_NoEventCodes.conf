morphlines: [
  {
    id: VPN_ASA_CISCO_NoEventCodes
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}
      #2014-12-14T00:17:26.000+00:00|device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group <GeneralHybrid> User <tzurkan> IP <73.189.60.63> IPv4 Address <10.72.116.99> IPv6 address <2001:4998:effd:7801::1273> assigned to session
      {
        split {
          inputField: message
          outputFields: [date_time, messageData]
          separator: "|"
        }
      }
      {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}
      {
        # filter only messages containing required strings in them,
        # all others will be discarded in the dropRecord command below
        grok {
          dictionaryString: """
            	TIMEZONE (?<=timezone )\S+
          	 """
          findSubstrings: true
          addEmptyStrings: true
          numRequiredMatches: all
          expressions: {
            messageData: """(?<type>(First TCP SVC connection established|assigned to session|Session disconnected|User authentication failed|user authentication Rejected))|%{TIMEZONE:timezone}"""
          }
        }
      }
      {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}
      {
        EmptyObjectFilter {
          filterFields: [date_time, type]
        }
      }
      {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}
      {
        setValues {
          date_time_unix: "@{date_time}"
          reporting_server: "reporting_server"  # Currently we don't use different TZs for different hostnames. This field just shouldn't be null.
        }
      }

      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "sec"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}
      {
        convertTimestampFortscale {
          field: date_time_unix
          inputTimezoneField: timezone_input
          outputFormat: "unixTimeInSeconds"
        }
      }
      {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}
      {
        convertTimestampFortscale {
          field: date_time
          inputTimezoneField: timezone_input
          outputFormat: "yyyy-MM-dd HH:mm:ss"
        }
      }
      {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}

      # Handle 'First TCP SVC connection established' events, that indicate a new session is about to start.
      # We'll store the event keys in cache, and when the 'assigned to session' message arrive, will treat it as a new session
      # device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group <GeneralHybrid> User <poorman> IP <117.248.225.69> First TCP SVC connection established for SVC session.
      {
        if {
          conditions: [{equals {type: ["First TCP SVC connection established"]}}]
          then: [
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{START_USERNAME:username}|%{START_SOURCEIP:source_ip}"
                }
              }
            }

            {toString {field: username, trim: true}}
            {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}
            {
              EmptyObjectFilter {
                filterFields: [username, source_ip]
              }
            }
            {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}
            {
              setValues {
                fake_session: "@{type}"
              }
            }

            # keep in the cache
            {
              EventsJoiner {
                keys: ["username", "source_ip"]
                mergeFields: []
                cacheName: "vpn"
                timeThreshold: -1
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
                processRecord: false
              }
            }
            {logDebug {format: "Debug -10 : {}", args: ["@{}"]}}
          ]
        }
      }


      # device-id=gi-0-1.rav1-1-gci.corp.sg3.fortscale.com Group <FinanceHybrid> User <mgoldin> IP <122.107.212.60> IPv4 Address <10.80.230.6> IPv6 address <2406:2000:efa6:7a02::1001> assigned to session
      {
        if {
          conditions: [{equals {type: ["assigned to session"]}}]
          then: [

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{START_USERNAME:username}|%{START_SOURCEIP:source_ip}|%{START_LOCALIP:local_ip}"
                }
              }
            }
            {logDebug {format: "Debug -11 : {}", args: ["@{}"]}}
            {toString {field: username, trim: true}}

            {
              EmptyObjectFilter {
                filterFields: [username, source_ip, local_ip]
              }
            }
            {logDebug {format: "Debug -12 : {}", args: ["@{}"]}}
            # Retrieve from cache
            {
              EventsJoinerMerge {
                keys: ["username", "source_ip"]
                mergeFields: []
                timeField: date_time_unix
                timeToCacheMiliSec: 60
                dropFromCache: true
                dropWhenNoMatch: true
                cacheName: "vpn"
              }
            }
            {logDebug {format: "Debug -13 : {}", args: ["@{}"]}}
            {
              setValues {
                status: ["SUCCESS"]
              }
            }

          ]
        }
      }


      # device-id=gi-0-1.rav1-1-gci.corp.fortscale.com Group = GeneralHybrid, Username = chetd, IP = 12.189.100.233, Session disconnected. Session Type: SSL, Duration: 1h:27m:43s, Bytes xmt: 138239099, Bytes rcv: 3071059, Reason: Idle Timeout
      {
        if {
          conditions: [{equals {type: ["Session disconnected"]}}]
          then: [
            {logDebug {format: "Debug -14 : {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{END_USERNAME:username}|%{END_SOURCEIP:source_ip}|%{END_DURATION:durationStr}|%{END_READBYTES:readbytes}|%{END_WRITEBYTES:writebytes}"
                }
              }
            }
            {logDebug {format: "Debug -15 : {}", args: ["@{}"]}}
            {toString {field: username, trim: true}}

            {
              EmptyObjectFilter {
                filterFields: [source_ip, username]
              }
            }
            {logDebug {format: "Debug -16 : {}", args: ["@{}"]}}
            {
              if {
                conditions: [
                  {equals {readbytes: ["0"]}}
                  {equals {writebytes: ["0"]}}
                ]
                then: [
                  {LogFilterEvent {errorMessage: "No read / write bytes"}}
                  {dropRecord {}}
                ]
              }
            }

            {
              setValues {
                status: ["CLOSED"]
              }
            }
          ]
        }
      }


      # device-id=rav1-1-gci.corp.ne1.fortscale.com AAA user authentication Rejected : reason = AAA failure : server = 67.195.88.201 : user = kmcandrew
      {
        if {
          conditions: [{equals {type: ["user authentication Rejected"]}}]
          then: [
            {logDebug {format: "Debug -17 : {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{REJECT_USERNAME:username}|%{REJECT_SOURCEIP:source_ip}"
                }
              }
            }
            {logDebug {format: "Debug -18 : {}", args: ["@{}"]}}
            {toString {field: username, trim: true}}

            {
              setValues {
                status: ["FAIL"]
              }
            }
            {logDebug {format: "Debug -19 : {}", args: ["@{}"]}}
            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }
            {logDebug {format: "Debug -20 : {}", args: ["@{}"]}}
          ]
        }
      }


      # device-id=rav2-1-gci.corp.bf1.fortscale.com User authentication failed: Uname: jsummers
      {
        if {
          conditions: [{equals {type: ["User authentication failed"]}}]
          then: [
            {logDebug {format: "Debug -21 : {}", args: ["@{}"]}}
            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.NoEventCodes.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  messageData: "%{FAIL_USERNAME:username}"
                }
              }
            }
            {logDebug {format: "Debug -22 : {}", args: ["@{}"]}}
            {toString {field: username, trim: true}}

            {
              setValues {
                status: ["FAIL"]
              }
            }
            {logDebug {format: "Debug -23 : {}", args: ["@{}"]}}
            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }
            {logDebug {format: "Debug -24 : {}", args: ["@{}"]}}
          ]
        }
      }


      {logDebug {format: "Debug -25 : {}", args: ["@{}"]}}
      {
        OverFlowFilter {
          eventsType: vpn
          criteria: [username]
          threshold: 100000
        }
      }

      {
        OverFlowFilter {
          eventsType: vpn
          criteria: []
          threshold: 1000000
        }
      }

      {logDebug {format: "Debug -26 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [{equals {status: ["CLOSED"]}}]
          then: [
            {logDebug {format: "Debug -27 : {}", args: ["@{}"]}}
            {
              EmptyObjectFilter {
                filterFields: [source_ip, readbytes, writebytes]
              }
            }
            {logDebug {format: "Debug -28 : {}", args: ["@{}"]}}
            {
              java {
                imports: ""
                code: """
					String durationStr = (String)record.getFirstValue("durationStr");
					try{
					if (durationStr != null) {
						long duration = 0;
						int startInd = 0;
						int endInd = durationStr.indexOf("d", startInd);
						if(endInd > -1){
							duration += 24*3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+1;
						}
						endInd = durationStr.indexOf("h:", startInd);
						if(endInd > -1){
							duration += 3600*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+2;
						}
						endInd = durationStr.indexOf("m:", startInd);
						if(endInd > -1){
							duration += 60*Long.parseLong(durationStr.substring(startInd, endInd).trim());
							startInd = endInd+2;
						}
						endInd = durationStr.indexOf("s", startInd);
						if(endInd > -1){
							duration += Long.parseLong(durationStr.substring(startInd, endInd).trim());
						}
						if(duration > 0){
							record.replaceValues("duration", duration);
						}
					}
					} catch(Exception e){}
					return child.process(record);
					"""
              }
            }

            {logDebug {format: "Debug -29 : {}", args: ["@{}"]}}

          ]
        }
      }
      {logDebug {format: "Debug -30 : {}", args: ["@{}"]}}
    ]
  }
]
