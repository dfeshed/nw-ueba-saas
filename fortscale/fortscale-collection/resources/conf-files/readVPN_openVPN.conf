morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<status>(TLS: soft reset|primary virtual IP for|'AUTH_FAILED'))"""
										}
									}
								}
							]
						}
						
						{
							commands : [
								{	dropRecord {} }
							]
						}
					]
				}
			}
			
			{
				if {
					conditions : [
						# if session closed
						{ equals  { status : ['"TLS: soft reset'"] } }
					]
					then : [
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.openvpn.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{USERNAME_CLOSE:username}|%{SOURCEIPORIPV6:source_ip}|%{DATE_TIME:date_time}|%{TOTALBYTES:totalbytes}"
								}
							}
						}
						
						{
							setValues {
								status : ["CLOSE"]
								date_time_unix: "@{date_time}"
								readbytes:""
								writebytes:""
								duration:""
							}
						}
						
						#Adding data bucket
						{
							VpnDataBucket {
								totalbytesFieldName : totalbytes
								readbytesFieldName : readbytes
								durationFieldName : duration
								databucketFieldName : databucket
								bucketDefinition : ["50","100","200","400"]
							}
						}
					]
				}
			}
			
			{
				if {
					conditions : [
						# if auth failed then
						{ equals  { status : ['"AUTH_FAILED'"] } }
					]
					then : [
						{ logDebug { format : "AUTH_FAILED: {}", args : ["@{}"] } }
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.openvpn.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{USERNAME_FAIL:username}|%{IPORIPV6:source_ip}|%{DATE_TIME:date_time}"
								}
							}
						}
						
						{
							setValues {
								status : ["FAIL"]
								date_time_unix: "@{date_time}"
							}
						}
					]
				}
			}

			{
				if {
					conditions : [
						# if auth success then
						{ equals  { status : [primary virtual IP for] } }
					]
					then : [
						{ logDebug { format : "AUTH SUCCESS: {}", args : ["@{}"] } }
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.openvpn.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{USERNAME_SUCCESS:username}|%{SOURCEIPORIPV6:source_ip}|%{DATE_TIME:date_time}|%{LOCALIPORIPV6:local_ip}"
								}
							}
						}
						
						{
							setValues {
								status : ["SUCCESS"]
								date_time_unix: "@{date_time}"
							}
						}
					]
				}
			}

			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									convertTimestamp {
										field : date_time
										inputFormats : ["EEE MMM dd HH:mm:ss yyyy"]
										inputTimezone : UTC
										outputFormat : "yyyy-MM-dd HH:mm:ss"
										outputTimezone : Asia/Jerusalem
									}
								}
								
								{
									convertTimestamp {
										field : date_time_unix
										inputFormats : ["EEE MMM dd HH:mm:ss yyyy"]
										inputTimezone : UTC
										outputFormat : "unixTimeInSeconds"
										outputTimezone : UTC
                                    }
								}
							]
                        }
                        
						{
							commands : [
								{ logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
							]
                        }
					]
                }
			}
			
			{
				Geolocation {
					ip_field : source_ip
					country_field : country
					region_field : region
					city_field : city
					isp_field : isp
					usage_type_field : ipusage
				}
			}
			
			{
				VPNNormalizeUsername {
					usernameField : username
					normalizedUsernameField : normalized_username
				}
			}
			
			{
				if {
					conditions : [
						# if closed connection then		  
						{ equals  { status : [CLOSED] } }
					]
					then : [
						{
							HDFSPartitionsWrite {
								timestampField : "${impala.data.table.fields.epochtime}"
								hadoopPath : "${hdfs.user.data.vpn.session.path}"
								hadoopFilename : "vpnCloseSessionETL.csv"
								impalaTableName : "${impala.data.vpn.session.table.name}"
								partitionType : "${impala.data.vpn.session.table.partition.type}"
								fileSplitStrategyType : "${impala.data.vpn.session.table.filesplit.type}"
								outputFields : "${impala.data.vpn.session.table.fields}"
								outputSeparator :"${impala.data.vpn.session.table.delimiter}"
							}
						}
						{ dropRecord {} }
					]
				}
			}
			
			{ logDebug { format : "output record: {}", args : ["@{}"] } }
		]
	}
]