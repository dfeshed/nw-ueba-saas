morphlines : [
{
    id : sec4624
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

	commands : [
	{
		grok {
			dictionaryString : """
			  	ACCOUNT_NAME (?<=Account Name:).+?(?=Account Domain:)
			  	ACCOUNT_DOMAIN (?<=Account Domain:).+?(?=Logon ID:)
			  	SOURCE_IP (?<=Source Network Address:).+?(?=Source Port:)
			  	LOGON_PROCESS (?<=Logon Process:).+?(?=Authentication Package:)
			  	REPORTING_SERVER (?<=ComputerName=).+?(?=TaskCategory=)
				 """
			findSubstrings : true
		  	addEmptyStrings : true
		  	numRequiredMatches : all
		  	expressions : {
				messageData : "%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_DOMAIN:account_domain}|%{ACCOUNT_NAME:account_name}|%{SOURCE_IP:source_ip}|%{LOGON_PROCESS:logon_process}"
		  	}
		}
	}
	{ toString { field : account_name, trim : true } }
	{ toString { field : source_ip, trim : true } }
	{ toString { field : logon_process, trim : true } }
	{ toString { field : account_domain, trim : true } }
	{ toString { field : reporting_server, trim : true } }
	
	{
		EmptyObjectFilter {
			filterFields : [account_name,source_ip,logon_process,reporting_server]
		}
	}
	# filter non kerberos events
	{
		if {
			conditions : [
				{ not { equals { logon_process : [Kerberos] } } }
			]
			then : [
				{ dropRecord {} }
			]
		}
	}
	# filter local ip6v ip address
	{
		if {
			conditions : [
				{ equals { source_ip : ["::1"] } }
			]
			then : [
				{ dropRecord {} }
			]
		}
	}
	# filter local ipv4 address
	{
		if {
			conditions : [
				{ equals { source_ip : ["127.0.0.1"] } }
			]
			then : [
				{ dropRecord {} }
			]
		}
	}
	# filter non computer accounts
	{
		java {
			imports : "import java.util.*;"
			code:
				"""
				String account_name = (String)record.get("account_name").get(1);
				Boolean isComputer = account_name.contains("$") ? true : false;
				if (isComputer){
					record.replaceValues("isComputer", isComputer);
					record.replaceValues("account_name", account_name);
					String account_domain = (String)record.get("account_domain").get(1);
					record.replaceValues("account_domain", account_domain);
					return child.process(record);
				} else{
					return true;
				}
				"""
		}
	}
	# filter domain servers



	# filter machines not in the desired ou
	{
		FilterOUMachine {
			hostnameField : account_name
			regex : "(.+)\\$$# #$1"
		}
	}
	
	# setup timestamp according to timezone of the reporting server
	{
		GetTimezone {
			sourceType : "sec"
			hostnameField : reporting_server
			timezoneOutputField : timezone_output
		}
	}
	{
		addValues {
			date_time_unix : "@{date_time}"
		}
	}
	{
		java {
			imports : "import java.util.*;"
			code: """
				Object rec = record.getFirstValue("date_time_unix");
				String tmp = String.valueOf(rec).substring(0,19);
				record.replaceValues("date_time_unix",tmp);
				return child.process(record);
				"""
		}
	} 
	{
		convertTimestampFortscale {
  			field : date_time_unix
  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
  			inputTimezoneField : timezone_output
  			outputFormat : "unixTimeInSeconds"
		}
	}


	# add the computer ip resolve to the cache and drop the record
	{
		ComputerLoginUpdate {
	    	timestampepoch_field : date_time_unix
	        ipaddress_field: source_ip
	        hostname_field : account_name
	        domain_field : account_domain
		}
	}
	]
}]
