morphlines : [
{
    id : sec4624
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

	commands : [
	{
		grok {
			dictionaryString : """
			  	ACCOUNT_NAME (?<=Account Name:).+?(?=Account Domain:)
			  	ACCOUNT_DOMAIN (?<=Account Domain:).+?(?=Logon ID:)
			  	SOURCE_IP (?<=Source Network Address:).+?(?=Source Port:)
			  	LOGON_PROCESS (?<=Logon Process:).+?(?=Authentication Package:)
			  	REPORTING_SERVER (?<=^.{16})\S+
				 """
			findSubstrings : true
		  	addEmptyStrings : true
		  	numRequiredMatches : all
		  	expressions : {
				messageData : "%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_DOMAIN:account_domain}|%{ACCOUNT_NAME:account_name}|%{SOURCE_IP:source_ip}|%{LOGON_PROCESS:logon_process}"
		  	}
		}
	}
	{ toString { field : account_name, trim : true } }
	{ toString { field : source_ip, trim : true } }
	{ toString { field : logon_process, trim : true } }
	{ toString { field : account_domain, trim : true } }
	
	{
		EmptyObjectFilter {
			filterFields : [account_name,source_ip,logon_process]
		}
	}
	# filter non kerberos events
	{
		if {
			condition : [
				{ not { equals { logon_process : [Kerberos] } } }
			]
			then : [
				{ dropRecord {} }
			]
		}
	}
	# filter local ip6v ip address
	{
		if {
			condition : [
				{ equals { source_ip : [::1] } }
			]
			then : [
				{ dropRecord {} }
			]
		}
	}
	# filter non computer accounts or "-" account
	{
		java {
			imports : "import java.util.*;"
			code:
				"""
				String account_name = (String)record.getFirstValue("account_name");
				Boolean isComputer = account_name.contains("$") || account_name.equals("-") ? true : false;
				if (isComputer)
					return child.process(record);
				else
					return true;
				"""
		}
	}
	# filter domain servers



	# filter machines not in the desired ou
	{
		FilterOUMachine {
			hostnameField : account_name
			regex : "(.+)\\$$# #$1"
		}
	}
	
	# setup timestamp according to timezone of the reporting server
	{
		GetTimezone {
			sourceType : "sec"
			hostnameField : reporting_server
			timezoneOutputField : timezone_output
		}
	}
	{
		addValues {
			timeGeneratedUnixTime : "@{timeGenerated}"
		}
	}
	{
		java {
			imports : "import java.util.*;"
			code: """
				Object rec = record.getFirstValue("timeGeneratedUnixTime");
				String tmp = String.valueOf(rec).substring(0,19);
				record.replaceValues("timeGeneratedUnixTime",tmp);
				return child.process(record);
				"""
		}
	} 
	{
		convertTimestampFortscale {
  			field : timeGeneratedUnixTime 
  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
  			inputTimezoneField : timezone_output
  			outputFormat : "unixTimeInSeconds"
  			# default outputTimezone : UTC
		}
	}


	# add the computer ip resolve to the cache and drop the record
	{
		ComputerLoginUpdate {
	    	timestampepoch_field : timeGeneratedUnixTime
	        ipaddress_field: source_ip
	        hostname_field : account_name
	        domain_field : account_domain
		}
	}
	{ dropRecord { } }
	]
}