morphlines : [
	{
		id : VPN_F5
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									# filter only message containing "New session from client", "authenticate with" or "bytes in" in message,
									# all other will be discarded in the dropRecord command bellow
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<type>(New session from client|\): authenticate with|bytes in))"""
										}
									}
								}
							]
						}
						
						{
							commands : [
								{	logDebug	{	format : "Record doesn't meet legitimate f5 vpn event. Dropping record: {}", args : ["@{}"] } }
								{
									dropRecord {}
								}
							]
						}
					]
				}
			}


			{
				if {
					conditions : [
						{ equals { type : [New session from client] }}
					]
					then : [
						# handle new session events (first event of new sessions)
						# extract source IP, local IP fields
						# Store the data in mongo to be later correlated with following event
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{SESSION_ID_1:session_id}|%{SOURCEIPORIPV6:source_ip}|%{LOCALIPORIPV6:local_ip}|%{DATESTAMP:date_time}"
								}
							}
						}
						
						# Adding year from the system current date to the date_time.
						{
							java {
								imports : "import java.util.*;import java.text.SimpleDateFormat;"
								code:
									"""
									try {
										Object date_time = record.getFirstValue("date_time");
										if (date_time==null)
											return false;
											
										int year = Calendar.getInstance().get(Calendar.YEAR);
										int currentMonth = Calendar.getInstance().get(Calendar.MONTH);
										
										int parsedMonth;
										SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
										parsedMonth = sdf.parse(date_time.toString().substring(0,3)).getMonth();
										
										// If the month is later than current month, we'll assign the previous year to the event
										if (parsedMonth > currentMonth) {
											year--;
										}

										record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
									}
									catch (Exception e) {
										System.out.println(e);
									}

									return child.process(record);
									"""
							}
						}
						
						{
							setValues {
								date_time_unix: "@{date_time}"
							}
						}
						
						{
							convertTimestamp {
								field : date_time_unix
								inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
								inputTimezone : EST
								outputFormat : "unixTimeInSeconds"
								outputTimezone : UTC
							}
						}
						
						{
							Geolocation {
								ip_field : source_ip
								country_field : country
								region_field : region
								city_field : city
								isp_field : isp
								usage_type_field : ipusage
								country_code_field : countrycode
								longtitude_field : longtitude
								latitude_field : latitude
							}
						}
						
						{
							EventsJoiner {
								keys : [ "session_id" ]
								mergeFields : [ "username", "date_time", "date_time_unix", "status", "normalized_username"  ]
								cacheName : "vpn"
								timeThreshold : 86400  
								currentRecordDateField : date_time_unix
								cachedRecordDateField : date_time_unix
								dropFromCache : false
							}
						}
					]
				}
			}			
			
			
			{
				if {
					conditions : [
						{ equals  { type : [)":" authenticate with] } }
					]
					then : [
						# handle authentication events (second event of sessions)
						# extract the time, username, status fields from the event
						# correlate this event to stored event based on the session_id
						# adds geolocation and normalize the username 
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{SESSION_ID_2:session_id}|%{USERNAME:username}|%{DATESTAMP:date_time}|%{STATUS:status}"
								}
							}
						}
												
						{
							if {
								conditions : [
									{ equals { username : []  } }
								]
								then : [
									{ logWarn { format : "No username, Drop the record. Original message was: {}", args : ["@{message}"] } }
									{ dropRecord {} }
								]
							}
						}
						
						# Adding year from the system current date to the date_time.
						{
							java {
								imports : "import java.util.*;import java.text.SimpleDateFormat;"
								code:
									"""
									try {
										Object date_time = record.getFirstValue("date_time");
										if (date_time==null)
											return false;
											
										int year = Calendar.getInstance().get(Calendar.YEAR);
										int currentMonth = Calendar.getInstance().get(Calendar.MONTH);
										
										int parsedMonth;
										SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
										parsedMonth = sdf.parse(date_time.toString().substring(0,3)).getMonth();
										
										// If the month is later than current month, we'll assign the previous year to the event
										if (parsedMonth > currentMonth) {
											year--;
										}

										record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
									}
									catch (Exception e) {
										System.out.println(e);
									}

									return child.process(record);
									"""
							}
						}
						
						{
							setValues {
								date_time_unix: "@{date_time}"
							}
						}
						
						{
							convertTimestamp {
								field : date_time_unix
								inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
								inputTimezone : EST
								outputFormat : "unixTimeInSeconds"
								outputTimezone : UTC
							}
						}
						
						{						
							translate {
								field : status
								dictionary : {
									successful : SUCCESS
									failed : FAIL
								}
							}
						}

						{
							VPNNormalizeUsername {
								usernameField : username
								normalizedUsernameField : normalized_username
							}
						}
						
						{
							EventsJoiner {
								keys : [ "session_id" ]
								mergeFields : [ "source_ip", "local_ip", "country", "region", "city", "isp", "ipusage", "countryCode", "longtitude", "latitude" ]
								cacheName : "vpn"
								timeThreshold : 86400  
								currentRecordDateField : date_time_unix
								cachedRecordDateField : date_time_unix
								dropFromCache : false
							}
						}
						
					
						{
							if {
								conditions : [
									{ equals { status : [SUCCESS] }}
								]
								then : [
									# drop session start record from the cache in case of successful authentication
									# keep it in the cache in case of failure as there might be more authentication 
									# events that will follow
									{
										EventsJoinerCacheDrop {
											keys : [ "session_id" ]
											cacheName : "vpn"
										}
									}
								]
							}
						}
					]
				}
			}


			{
				if {
					conditions : [
						{ equals { type : [bytes in] }}
					]
					then : [
						# handle session statistics events (appear in closing sessions)
						# extract time, session id, bytes in, bytes out fields
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{DATESTAMP:date_time}|%{SESSION_ID_3:session_id}|%{WRITEBYTES:writebytes}|%{READBYTES:readbytes}"
								}
							}		  
						}

						# Adding year from the system current date to the date_time.
						{
							java {
								imports : "import java.util.*;import java.text.SimpleDateFormat;"
								code:
									"""
									try {
										Object date_time = record.getFirstValue("date_time");
										if (date_time==null)
											return false;
										int year = Calendar.getInstance().get(Calendar.YEAR);
										int currentMonth = Calendar.getInstance().get(Calendar.MONTH);

										int parsedMonth;
										SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
										parsedMonth = sdf.parse(date_time.toString().substring(0,3)).getMonth();
										
										// If the month is later than current month, we'll assign the previous year to the event
										if (parsedMonth > currentMonth) {
											year--;
										}

										record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
									}
									catch (Exception e) {
										System.out.println(e);
									}

									return child.process(record);
									"""
							}
						}
						
						{
							setValues {
								status : ["CLOSED"]
								date_time_unix: "@{date_time}"
							}
						}
						
						{
							convertTimestamp {
								field : date_time_unix
								inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
								inputTimezone : EST
								outputFormat : "unixTimeInSeconds"
								outputTimezone : UTC
							}
						}
						
						# Adding total bytes.
						{
							java {
								imports : "import java.util.*;"
								code:
									"""
									String readbytes = (String)record.getFirstValue("readbytes");
									String writebytes = (String)record.getFirstValue("writebytes");
									Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
									record.replaceValues("totalbytes", totalbytes);
									return child.process(record);
									"""
							}
						}
						
						#Adding data bucket
						{
							VpnDataBucket {
								totalbytesFieldName : totalbytes
								readbytesFieldName : readbytes
								durationFieldName : duration
								databucketFieldName : databucket
								bucketDefinition : ["50","100","200","400"]
							}
						}
						
						{
							EventsJoinerCacheDrop {
								keys : [ "session_id" ]
								cacheName : "vpn"
							}
						}
 					]
				}
			}
			
			

			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									convertTimestamp {
										field : date_time
										inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
										inputTimezone : EST
										outputFormat : "yyyy-MM-dd HH:mm:ss"
										outputTimezone : EST
									}
								}
							]
						}
						
						{
							commands : [
								{ logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
							]
						}
					]
				}
			}

			{
				VpnSessionUpdate {
					country_code_field : countrycode
					longtitude_field : longtitude
					latitude_field : latitude
					geo_hopping_open_session_threshold : 6
					geo_hopping_close_session_threshold : 1
					session_id_field : session_id
				}
			}

		]
	}
]
