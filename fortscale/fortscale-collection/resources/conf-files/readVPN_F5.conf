morphlines : [
  {
    id : VPN_F5
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [
      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                {
                  # filter only message containing "New session from client", "authenticate with" or "bytes in" in message,
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings : true
                    addEmptyStrings : true
                    numRequiredMatches : all
                    expressions : {
                      message : """(?<type>(New session from client|\): authenticate with|bytes in))"""
                    }
                  }
                }
              ]
            }

            {
              commands : [
                {	logDebug	{	format : "Record doesn't meet legitimate f5 vpn event. Dropping record: {}", args : ["@{}"] } }
                {
                  dropRecord {}
                }
              ]
            }
          ]
        }
      }


      {
        if {
          conditions : [
            { equals { type : [New session from client] }}
          ]
          then : [
            # handle new session events (first event of new sessions)
            # extract source IP field
            # Store the data in mongo to be later correlated with following event
            {
              grok {
                dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
                findSubstrings : true
                addEmptyStrings : true
                numRequiredMatches : all
                expressions : {
                  message : "%{SESSION_ID_1:session_id}|%{SOURCEIPORIPV6:source_ip}|%{DATESTAMP:date_time}"
                }
              }
            }
            {
              GetTimezone {
                sourceType : "vpn"
                hostnameField : reporting_server
                timezoneOutputField : timezone_output
              }
            }
            # Adding year from the system current date to the date_time.
            {
              java {
                imports : "import java.util.*;import java.text.SimpleDateFormat;"
                code:
                  """
                  try {
                    Object date_time = record.getFirstValue("date_time");
                    String tz = record.getFirstValue("timezone_output").toString();

                    TimeZone outputTimeZone = TimeZone.getTimeZone(tz == null ? "UTC" : tz);

                    if (date_time==null)
                      return false;




                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM dd HH:mm:ss");
                    sdf.setTimeZone(outputTimeZone);
                    int year = Calendar.getInstance().get(Calendar.YEAR);



                    Date parsedDate = sdf.parse(Integer.toString(year) + " " + date_time.toString());


                    Calendar cal = Calendar.getInstance(outputTimeZone);

                    Date currentDate = cal.getTime();



                    if (parsedDate.compareTo(currentDate)>0)
                        parsedDate.setYear(parsedDate.getYear()-1);

                    record.replaceValues("date_time", sdf.format(parsedDate));


                  } catch (Exception e) {
                      System.out.println(e);
                      return false;
                  }

                  return child.process(record);

                  """
              }
            }





            {
              setValues {
                date_time_unix: "@{date_time}"
              }
            }

            {
              convertTimestampFortscale {
                field : date_time_unix
                inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
                inputTimezoneField : timezone_output
                outputFormat : "unixTimeInSeconds"
                # default outputTimezone : UTC
              }
            }

            {
              Geolocation {
                ip_field : source_ip
                country_field : country
                region_field : region
                city_field : city
                isp_field : isp
                usage_type_field : ipusage
                country_code_field : countrycode
                longtitude_field : longtitude
                latitude_field : latitude
              }
            }

            {
              EventsJoiner {
                keys : [ "session_id" ]
                mergeFields : [ "username", "date_time", "date_time_unix", "status", "normalized_username"  ]
                cacheName : "vpn"
                timeThreshold : 86400
                currentRecordDateField : date_time_unix
                cachedRecordDateField : date_time_unix
                dropFromCache : false
              }
            }

            {
              if {
                conditions : [
                  { equals { status : [] } }
                ]
                then : [
                  { dropRecord {} }
                ]
              }
            }

            {
              if {
                conditions : [
                  { equals { status : [SUCCESS] }}
                ]
                then : [
                  # drop session start record from the cache in case of successful authentication
                  # keep it in the cache in case of failure as there might be more authentication
                  # events that will follow
                  {
                    EventsJoinerCacheDrop {
                      keys : [ "session_id" ]
                      cacheName : "vpn"
                    }
                  }
                ]
              }
            }

          ]
        }
      }


      {
        if {
          conditions : [
            { equals  { type : [)":" authenticate with] } }
          ]
          then : [
            # handle authentication events (second event of sessions)
            # extract the time, username, status fields from the event
            # correlate this event to stored event based on the session_id
            # adds geolocation and normalize the username
            {
              grok {
                dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
                findSubstrings : true
                addEmptyStrings : true
                numRequiredMatches : all
                expressions : {
                  message : "%{REPORTING_SERVER:reporting_server}|%{SESSION_ID_2:session_id}|%{USERNAME:username}|%{DATESTAMP:date_time}|%{STATUS:status}"
                }
              }
            }
            {
              EmptyObjectFilter {
                filterFields : [username]
              }
            }
            {
              GetTimezone {
                sourceType : "vpn"
                hostnameField : reporting_server
                timezoneOutputField : timezone_output
              }
            }

            # Adding year from the system current date to the date_time.
            {
              java {
                imports : "import java.util.*;import java.text.SimpleDateFormat;"
                code:
                  """
                  try {
                    Object date_time = record.getFirstValue("date_time");
                    String tz = record.getFirstValue("timezone_output").toString();

                    TimeZone outputTimeZone = TimeZone.getTimeZone(tz == null ? "UTC" : tz);

                    if (date_time==null)
                      return false;




                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM dd HH:mm:ss");
                    sdf.setTimeZone(outputTimeZone);
                    int year = Calendar.getInstance().get(Calendar.YEAR);



                    Date parsedDate = sdf.parse(Integer.toString(year) + " " + date_time.toString());


                    Calendar cal = Calendar.getInstance(outputTimeZone);

                    Date currentDate = cal.getTime();



                    if (parsedDate.compareTo(currentDate)>0)
                        parsedDate.setYear(parsedDate.getYear()-1);

                    record.replaceValues("date_time", sdf.format(parsedDate));


                  } catch (Exception e) {
                      System.out.println(e);
                      return false;
                  }

                  return child.process(record);

                  """
              }
            }



            {
              setValues {
                date_time_unix: "@{date_time}"
              }
            }



            {
              convertTimestampFortscale {
                field : date_time_unix
                inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
                inputTimezoneField : timezone_output
                outputFormat : "unixTimeInSeconds"
                # default outputTimezone : UTC
              }
            }





            {
              translate {
                field : status
                dictionary : {
                  successful : SUCCESS
                  failed : FAIL
                }
              }
            }

            {
              VPNNormalizeUsername {
                usernameField : username
                normalizedUsernameField : normalized_username
              }
            }





            {
              EventsJoiner {
                keys : [ "session_id" ]
                mergeFields : [ "source_ip", "country", "region", "city", "isp", "ipusage", "countrycode", "longtitude", "latitude" ]
                cacheName : "vpn"
                timeThreshold : 86400
                currentRecordDateField : date_time_unix
                cachedRecordDateField : date_time_unix
                dropFromCache : false
              }
            }



            {
              if {
                conditions : [
                  { equals { source_ip : [] } }
                ]
                then : [
                  { dropRecord {} }
                ]
              }
            }


            {
              if {
                conditions : [
                  { equals { status : [SUCCESS] }}
                ]
                then : [
                  # drop session start record from the cache in case of successful authentication
                  # keep it in the cache in case of failure as there might be more authentication
                  # events that will follow
                  {
                    EventsJoinerCacheDrop {
                      keys : [ "session_id" ]
                      cacheName : "vpn"
                    }
                  }
                ]
              }
            }
          ]
        }
      }


      {
        if {
          conditions : [
            { equals { type : [bytes in] }}
          ]
          then : [
            # handle session statistics events (appear in closing sessions)
            # extract time, session id, bytes in, bytes out fields
            {
              grok {
                dictionaryFiles : [resources/grok-dictionaries/vpn.F5.conf]
                findSubstrings : true
                addEmptyStrings : true
                numRequiredMatches : all
                expressions : {
                  message : "%{REPORTING_SERVER:reporting_server}|%{DATESTAMP:date_time}|%{SESSION_ID_3:session_id}|%{WRITEBYTES:writebytes}|%{READBYTES:readbytes}"
                }
              }
            }
            {
              GetTimezone {
                sourceType : "vpn"
                hostnameField : reporting_server
                timezoneOutputField : timezone_output
              }
            }
            # Adding year from the system current date to the date_time.
            {
              java {
                imports : "import java.util.*;import java.text.SimpleDateFormat;"
                code:
                  """
                  try {
                    Object date_time = record.getFirstValue("date_time");
                    String tz = record.getFirstValue("timezone_output").toString();

                    TimeZone outputTimeZone = TimeZone.getTimeZone(tz == null ? "UTC" : tz);

                    if (date_time==null)
                      return false;




                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy MMM dd HH:mm:ss");
                    sdf.setTimeZone(outputTimeZone);
                    int year = Calendar.getInstance().get(Calendar.YEAR);



                    Date parsedDate = sdf.parse(Integer.toString(year) + " " + date_time.toString());



                    Calendar cal = Calendar.getInstance(outputTimeZone);

                    Date currentDate = cal.getTime();



                    if (parsedDate.compareTo(currentDate)>0)
                        parsedDate.setYear(parsedDate.getYear()-1);

                    record.replaceValues("date_time", sdf.format(parsedDate));


                  } catch (Exception e) {
                      System.out.println(e);
                      return false;
                  }

                  return child.process(record);

                  """
              }
            }

            {
              setValues {
                status : ["CLOSED"]
                date_time_unix: "@{date_time}"
              }
            }

            {
              convertTimestampFortscale {
                field : date_time_unix
                inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
                inputTimezoneField : timezone_output
                outputFormat : "unixTimeInSeconds"
                # default outputTimezone : UTC
              }
            }

            # Adding total bytes.
            {
              java {
                imports : "import java.util.*;"
                code:
                  """
                  String readbytes = (String)record.getFirstValue("readbytes");
                  String writebytes = (String)record.getFirstValue("writebytes");
                  Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                  record.replaceValues("totalbytes", totalbytes);
                  return child.process(record);
                  """
              }
            }

            #Adding data bucket
            {
              VpnDataBucket {
                totalbytesFieldName : totalbytes
                readbytesFieldName : readbytes
                durationFieldName : duration
                databucketFieldName : databucket
                bucketDefinition : ["50","100","200","400"]
              }
            }

            {
              EventsJoinerCacheDrop {
                keys : [ "session_id" ]
                cacheName : "vpn"
              }
            }
          ]
        }
      }

      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }

      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }

      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                {
                  convertTimestampFortscale {
                    field : date_time
                    inputFormats : ["yyyy MMM dd HH:mm:ss","yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField : timezone_output
                    outputFormat : "yyyy-MM-dd HH:mm:ss"
                    outputTimezoneField : timezone_output
                  }
                }
              ]
            }

            {
              commands : [
                { logWarn { format : "Problem with covertTimestamp: {}", args : ["@{date_time}"] } }
              ]
            }
          ]
        }
      }

      {
        if {
          conditions : [
            { not { equals { status : [FAIL] }}}
          ]
          then : [
            {
              VpnSessionUpdate {
                country_code_field : countrycode
                longtitude_field : longtitude
                latitude_field : latitude
                geo_hopping_open_session_threshold : 6
                geo_hopping_close_session_threshold : 1
                session_id_field : session_id
              }
            }
          ]
        }
      }

      {
        if {
          conditions : [
            { equals { status : ["SUCCESS"]  } }
          ]
          then : [
            {
              UserLastActivityUpdate {
                logEventsType : vpn
                normalizedUsernameField : normalized_username
                epochtimestampField : date_time_unix
              }
            }
          ]
        }
      }
      {
        IsUserAdministrator {
          usernameField : normalized_username
          isUserAdministratorField : isUserAdministrator
        }
      }
      {
        IsUserExecutive {
          usernameField : normalized_username
          isUserExecutiveField : isUserExecutive
        }
      }
    ]
  }
]
