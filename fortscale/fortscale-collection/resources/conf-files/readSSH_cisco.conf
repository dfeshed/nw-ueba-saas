morphlines : [
  {
    id : morphline1
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [
      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                # parse ssh lines in the format:
                # 2014-09-09T17:00:00+00:00 dev-gever sshd[2552]: Accepted publickey for root from 171.70.163.169 port 47952 ssh2
                {
                  grok {
                    dictionaryFiles : [resources/grok-dictionaries/ssh.cisco.conf]
                    expressions : {
                      message : """[\"]?%{DHCP_DATE:date_time} %{TARGET_MACHINE:target_machine} sshd\[\d+\]:(\s|\s\[[^\]]+\]\s)(?<status>(Accepted|Failed)) %{AUTH_METHOD:auth_method} for (?<username>(.+?)) from %{DHCP_IP:source_ip} port \d+ ssh2[\"]?"""
                    }
                  }
                }
              ]
            }
            {
              commands : [
                {	logDebug	{	format : "Record doesn't meet legitimate ssh format. Dropping record: {}", args : ["@{}"] } }
                {	dropRecord {} }
              ]
            }
          ]
        }
      }



      {
        EmptyObjectFilter {
          filterFields : [username,source_ip,target_machine]
        }
      }

      




      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : [username]
          threshold : 100000
        }

      }
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : []
          threshold : 1000000
        }
      }



      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                {
                  findReplace {
                    field : source_ip
                    pattern : "::ffff:"
                    isRegex : false
                    replacement : ""
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "::1"
                    isRegex : false
                    replacement :  "target_machine"
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "127.0.0.1"
                    isRegex : false
                    replacement : "target_machine"
                    replaceFirst : false
                  }
                }
              ]
            }
          ]
        }
      }

      {
        if {
          conditions : [{equals{source_ip :"target_machine"} }]
          then:[
            {
              setValues {
                source_ip : "@{target_machine}"
              }
            }
          ]
        }
      }


      {
        setValues {
          date_time_unix : "@{date_time}"
        }
      }

      {
        convertTimestampFortscale {
          field : date_time_unix
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ssXXX"]
          outputFormat : "unixTimeInSeconds"
        }
      }

      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ssXXX"]
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }




      # seems like we are not using it, might as well put here a fixed value
      {
        addValues {
          is_nat : "false"
        }
      }
      #			{
      #		  		# test if the ip address used is a vpn or any other nat address
      #		  		MatchIP {
      #		  			ipAddress : "source_ip"
      #		  			cidr : "192.168.0.22"
      #		  			output : "is_nat"
      #		  		}
      #		  	}




    ]
  }
]

