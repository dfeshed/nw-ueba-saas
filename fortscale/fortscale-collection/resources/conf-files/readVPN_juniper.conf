morphlines : [
	{
		id : morphline1
		importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
		commands : [
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [	    
								{
									# filter only message containing "login succeeded" or "session started" in message, 
									# all other will be discarded in the dropRecord command bellow
									grok {
										findSubstrings : true
										addEmptyStrings : true
										numRequiredMatches : all
										expressions : {
											message : """(?<status>(login succeeded|Session started for user with IP|Login failed using auth server|Closed connection to))"""
										}
									}		  
								}			 
							]
						}
						
						{
							commands : [
								{	logDebug	{	format : "Record is not one of the expected juniper vpn event types. Dropping record: {}", args : ["@{}"] } }
								{
									dropRecord {}
								}				
							]
						}						
					]
				}
			}
			
			{
				if {
					conditions : [
						# if closed connection then		  
						{ equals  { status : [Closed connection to] } }
					]
					then : [
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{CLOSE_SESSION_LOCALIPORIPV6:local_ip}|%{DATESTAMPFULLYEAR:date_time}|%{DURATION:duration}|%{READBYTES:readbytes}|%{WRITEBYTES:writebytes}"
								}
							}		  
						}
						
						{
							setValues {
								status : ["CLOSED"]
								date_time_unix: "@{date_time}"
							}
						}
						
						# Adding total bytes.
						{
							java {
								imports : "import java.util.*;"
								code:
									"""
									String readbytes = (String)record.getFirstValue("readbytes");
									String writebytes = (String)record.getFirstValue("writebytes");
									Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
									record.replaceValues("totalbytes", totalbytes);
									return child.process(record);
									"""
							}
						}
						
						#Adding data bucket
						{
							VpnDataBucket {
								totalbytesFieldName : totalbytes
								readbytesFieldName : readbytes
								durationFieldName : duration
								databucketFieldName : databucket
								bucketDefinition : ["50","100","200","400"]
							}
						}
					]					 
				}
			}
	
			
			{
				if {
					conditions : [
						# if auth failed then		  
						{ equals  { status : [Login failed using auth server] } }
					]
					then : [
						{ logDebug { format : "AUTH_FAILED: {}", args : ["@{}"] } }    	  
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{DATESTAMPFULLYEAR:date_time}"
								}
							}		  
						}
						
						{
							setValues {
								status : ["FAIL"]
								date_time_unix: "@{date_time}"
							}
						}
					]					 
				}
			}
	
	
			{
				if {
					conditions : [
						# if auth success then
						{ equals { status : [login succeeded] }}
					]
					then : [
						# handle agent login succeeded message and extract fields from it
						# get the source ip, time and user name from the login event
						# based on these we can get the hostname later on
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{DATESTAMPFULLYEAR:date_time}"
								}
							}
						}
						{
							EventsJoinerStore {
								keys : [ "source_ip", "username" ]
								cacheName : "vpn"
							}
						}
					]
				}
			}
			
			{
				if {
					conditions : [
						{ equals { status : [Session started for user with IP] }}
					]
					then : [
						# handle session started events, get the hostname from it
						# and correlated it to previous saved login succeeded event
						{
							grok {
								dictionaryFiles : [resources/grok-dictionaries/vpn.juniper.conf]
								findSubstrings : true
								addEmptyStrings : true
								numRequiredMatches : all
								expressions : {
									message : "%{REPORTING_SERVER:reporting_server}|%{USERNAME:username}|%{SOURCEIPORIPV6:source_ip}|%{LOCALIPORIPV6:local_ip}|%{HOSTNAME:hostname}|%{DATESTAMPFULLYEAR:date_time}"
								}
							}
						}
						{
							SubString {
								field : hostname
								endCharacter : "."
							}
						}
						{
							EventsJoinerMerge {
								keys : [ "source_ip", "username" ]
								mergeFields : [ "date_time" ]
								dropWhenNoMatch : true
								cacheName : "vpn"
							}
						}
						{
							setValues {
								status : ["SUCCESS"]
								date_time_unix: "@{date_time}"
							}
						}
					]
				}
			}
	
			{
				if {
					conditions : [
						{ equals { username : []  } }
					]
					then : [
						{ logDebug { format : "No username, Drop the record. Original message was: {}", args : ["@{message}"] } }
						{ dropRecord {} }
					]
				}
			}
			{
				GetTimezone {
					sourceType : "vpn"
					hostnameField : reporting_server
					timezoneOutputField : timezone_output
				}
			}			
			{
				tryRules {
					catchExceptions : true
					throwExceptionIfAllRulesFailed : false
					rules : [
						{
							commands : [
								{
									convertTimestampFortscale {
										field : date_time
										inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
										inputTimezoneField : timezone_output
										outputFormat : "yyyy-MM-dd HH:mm:ss"
										outputTimezoneField : timezone_output
									}
								}
								
								{
									convertTimestampFortscale {
										field : date_time_unix
										inputFormats : ["yyyy-MM-dd HH:mm:ss","yyyy/MM/dd HH:mm:ss"]
										inputTimezoneField : timezone_output
										outputFormat : "unixTimeInSeconds"
										# default outputTimezone : UTC
									}
								}
							]
						}
						
						{
							commands : [
								{ logWarn { format : "Problem timeGenerated: {}", args : ["@{timeGenerated}"] } }
							]
						}
					]
				}
			}
	
			{
				Geolocation {
					ip_field : source_ip
					country_field : country
					region_field : region
					city_field : city
					isp_field : isp
					usage_type_field : ipusage
					country_code_field : countrycode
					longtitude_field : longtitude
					latitude_field : latitude
				}
			}
			
			{
				VPNNormalizeUsername {
					usernameField : username
					normalizedUsernameField : normalized_username
				}
			}
			
			{
				VpnSessionUpdate {
					country_code_field : countrycode
					longtitude_field : longtitude
					latitude_field : latitude
					geo_hopping_open_session_threshold : 6
					geo_hopping_close_session_threshold : 1
					session_id_field : sessionId
				}
			}
			
			{
				if {
					conditions : [
						{ equals { status : ["SUCCESS"]  } }
					]
					then : [
						{
							UserLastActivityUpdate {
								logEventsType : vpn
								normalizedUsernameField : normalized_username
								epochtimestampField : date_time_unix
							}
						}
					]
				}
			}
		]
	}
]