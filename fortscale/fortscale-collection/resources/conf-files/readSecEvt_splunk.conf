morphlines : [
{
	id : morphline1
	importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

    commands : [
		{
	  		split {
	  			inputField : message
				outputFields : [date_time,messageData]
				separator : "|"
	  		}
	  	}
	  	{
	  		grok {
	  			dictionaryString : """
					EVENT_CODE (?<=EventCode\=)[0-9]+
					 """
				findSubstrings : true
			  	addEmptyStrings : true
			  	numRequiredMatches : all
			  	expressions : {
					messageData : "%{EVENT_CODE:eventCode}"
			  	}
			}
	  	}
	  	{
		  	if {
		  		conditions : [
		  			{ not { equals { eventCode : ["4624"] } } }
		  		]
		  		then : [
		  		
			  	{
					tryRules {
				  		catchExceptions : true
				  		throwExceptionIfAllRulesFailed : false
				  		rules : [
						{
					  		commands : [
			  				{
								grok {
				  					dictionaryString : """
				  						CLIENT_ADDRESS (?<=Client Address:).+?(?=Client Port:)
				  						TICKET_OPTIONS (?<=Ticket Options:)[\s0-9x]+
				  						ACCOUNT_NAME (?<=Account Name:).+?(?=Supplied Realm Name)|(?<=Account Name:).+?(?=Account Domain)|(?<=Account Name:).+?(?=Service Information)
										REPORTING_SERVER (?<=ComputerName=).+?(?=TaskCategory=)
										 """
				  					findSubstrings : true
								  	addEmptyStrings : true
								  	numRequiredMatches : all
								  	expressions : {
										messageData : "%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_NAME:account_name}|%{CLIENT_ADDRESS:client_address}|%{TICKET_OPTIONS:ticket_options}"
								  	}
								}
		      				}
		      				{ toString { field : client_address, trim : true } }
		      				{ toString { field : ticket_options, trim : true } }
		      				{ toString { field : account_name, trim : true } }
		      				{ toString { field : reporting_server, trim : true } }
					  		]
						}
				  	]
					}
				}
				{
					EmptyObjectFilter {
						filterFields : [eventCode,account_name,client_address,ticket_options]
					}
				}
				#the first overflow filter command insures that the overflow is not caused by a single user in the system
				{
					OverFlowFilter {
						eventsType : securityEvents
						criteria : [eventCode, account_name]
						threshold : 100000
					}
				}
				{
					OverFlowFilter {
						eventsType : securityEvents
						criteria : [eventCode]
						threshold : 2000000
					}
				}
				{
					GetTimezone {
						sourceType : "sec"
						hostnameField : reporting_server
						timezoneOutputField : timezone_output
					}
				}
				
		
				{
					findReplace {
						field : account_name
						isRegex : false
						pattern : "'"
						replacement : ""
					}
				}
				
				{
					addValues {
						timeGeneratedRaw : "@{date_time}"
						date_time_unix : "@{date_time}"
					}
				}

				
				# Adding isComputer.
				{
					java {
						imports : "import java.util.*;"
						code:
							"""
							String account_name = (String)record.getFirstValue("account_name");
							Boolean isComputer = account_name.contains("$") ? true : false;
							record.replaceValues("isComputer", isComputer);
							return child.process(record);
							"""
					}
				}
		
				{
					tryRules {
				  		catchExceptions : true
				  		throwExceptionIfAllRulesFailed : false
				  		rules : [
						{
					  		commands : [
		      					{
		        					java {
		          						imports : "import java.util.*;"
		          						code: """
		                					Object rec = record.getFirstValue("date_time");
		                					String tmp = String.valueOf(rec).substring(0,19);
		                					record.replaceValues("date_time",tmp);
		                					return child.process(record);
		                					"""
		        					}
		      					}
		      					{
		        					java {
		          						imports : "import java.util.*;"
		          						code: """
		                					Object rec = record.getFirstValue("date_time_unix");
		                					String tmp = String.valueOf(rec).substring(0,19);
		                					record.replaceValues("date_time_unix",tmp);
		                					return child.process(record);
		                					"""
		        					}
		      					}              
		                  		{
					    			convertTimestampFortscale {
					    	  			field : date_time
		                      			#2013-11-05T17:59:57.000+02:00
					    	  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
					    	  			inputTimezoneField : timezone_output
					    	  			outputFormat : "yyyy-MM-dd HH:mm:ss"
				    	  				#outputTimezoneField : timezone_output
					    			}
						  		}
						  		{
									convertTimestampFortscale {
							  			field : date_time_unix
					    	  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
							  			inputTimezoneField : timezone_output
							  			outputFormat : "unixTimeInSeconds"
							  			# default outputTimezone : UTC
									}
						  		}
					  		]
						}
				  		]
					}
			  	}




			  	{
					tryRules {
				  		catchExceptions : true
				  		throwExceptionIfAllRulesFailed : false
				  		rules : [
						{
					  		commands : [
						  		{
									findReplace {
							  			field : client_address
							  			pattern : "::1"
							  			isRegex : false
							  			replacement : "127.0.0.1"
							  			replaceFirst : false
									}
						  		}
						  		{
									findReplace {
							  			field : client_address
							  			pattern : "::ffff:"
							  			isRegex : false
							  			replacement : ""
						  				replaceFirst : false
									}
						  		}
							]
						}
				  		]
					}
			  	}
			  	{
			  		# test if the ip address used is a vpn or any other nat address
			  		MatchIP {
			  			ipAddress : "client_address"
			  			cidr : "192.168.0.22"
			  			output : "is_nat"
			  		}
			  	}
	  	
			  	{
					ParseKerberosTicketOptions {
						ticketOptionsField : ticket_options
						forwardableField : forwardable
						forwardedField : forwarded
						proxiedField : proxied
						postdatedField : postdated
						renewRequestField : renew_request
						constraintDelegationField : constraint_delegation
					}
				}
		
				{ 
					if { 
						conditions : [ 
							{ equals { isComputer : [false] } } 
						] 
						then : [
							{
								IpToHostname {
							    	ipAddress : client_address
							        timeStamp: date_time_unix
							        outputRecordName : machine_name
							        remove_last_dot : true
							        resolvers = ["logins", "file"]
								}
					      	}
					      	{
								FilterUnresolvedMachine{
									machineNameField : machine_name
								}
							}
							{
								ClassifyHost {
									hostnameField : machine_name
									classificationField : src_class
								}
							}
							{
								GetComputerClusterName {
									hostnameField : machine_name
									clusterField : normalized_src_machine
								}
							}
							
							{
								SECNormalizeUsername {
									usernameField : account_name
									normalizedUsernameField : normalized_username
								}
							}					
							{
								IsUserServiceAccount {
									usernameField : normalized_username
									isUserServiceAccountField : isUserServiceAccount
								}
							}
							{
								IsUserAdministrator {
									usernameField : normalized_username
									isUserAdministratorField : isUserAdministrator
								}
							}
							{
								IsUserExecutive {
									usernameField : normalized_username
									isUserExecutiveField : isUserExecutive
								}
							}
						]
					}
				}
			]
		  	}
		}
	]
  }
]
