morphlines : [
{
	id : morphline1
	importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

    commands : [
		{
	  		split {
	  			inputField : message
				outputFields : [timeGenerated,messageData]
				separator : "|"
	  		}
	  	}
	  	{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
	  				{
						grok {
		  					dictionaryString : """
		  						EVENT_CODE (?<=EventCode\=)[0-9]+
		  						CLIENT_ADDRESS (?<=Client Address:).+(?=Client Port:)
		  						TICKET_OPTIONS (?<=Ticket Options:)[\s0-9x]+
								 """
		  					findSubstrings : true
						  	addEmptyStrings : true
						  	numRequiredMatches : all
						  	expressions : {
								messageData : "%{EVENT_CODE:eventCode}|%{CLIENT_ADDRESS:client_address}|%{TICKET_OPTIONS:ticket_options}"
						  	}
						}
      				}
      				{ toString { field : client_address, trim : true } }
      				{ toString { field : ticket_options, trim : true } }
			  		]
				}
		  	]
			}
		}

		{
			if {
				conditions : [
					{ equals { eventCode : [] } }
				]
				then : [
					{ logError { format : "Record does not contain EventCode field, Drop the record. Original message was: {}", args : ["@{message}"] } }
					{ dropRecord {} }
				]
			}
		}
		{ 
			if { 
				conditions : [ 
					{ equals { client_address : [] } } 
				] 
				then : [
				{ logError { format : "Record does not contain client_address field, Drop the record. Original message was: {}", args : ["@{message}"] } }
				{ 
					dropRecord{} 
				}
				] 
			} 
		}
		{ 
			if { 
				conditions : [ 
					{ equals { ticket_options : [] } } 
				] 
				then : [
				{ logError { format : "Record does not contain ticket_options field, Drop the record. Original message was: {}", args : ["@{message}"] } }
				{ 
					dropRecord{} 
				}
				] 
			} 
		}
		
		{
			addValues {
				timeGeneratedRaw : "@{timeGenerated}"
				timeGeneratedUnixTime : "@{timeGenerated}"
			}
		}
		{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
      					{
        					java {
          						imports : "import java.util.*;"
          						code: """
                					Object rec = record.getFirstValue("timeGenerated");
                					String tmp = String.valueOf(rec).substring(0,19);
                					record.replaceValues("timeGenerated",tmp);
                					return child.process(record);
                					"""
        					}
      					}
      					{
        					java {
          						imports : "import java.util.*;"
          						code: """
                					Object rec = record.getFirstValue("timeGeneratedUnixTime");
                					String tmp = String.valueOf(rec).substring(0,19);
                					record.replaceValues("timeGeneratedUnixTime",tmp);
                					return child.process(record);
                					"""
        					}
      					}              
                  		{
			    			convertTimestamp {
			    	  			field : timeGenerated
                      			#2013-11-05T17:59:57.000+02:00
			    	  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
			    	  			inputTimezone : Asia/Jerusalem
			    	  			outputFormat : "yyyy-MM-dd HH:mm:ss"
		    	  				outputTimezone : Asia/Jerusalem
			    			}
				  		}
				  		{
							convertTimestamp {
					  			field : timeGeneratedUnixTime 
			    	  			inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
					  			inputTimezone : Asia/Jerusalem
					  			outputFormat : "unixTimeInSeconds"
					  			outputTimezone : UTC
							}
				  		}
			  		]
				}
		  		]
			}
	  	}
	  	{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
				  		{
							findReplace {
					  			field : client_address
					  			pattern : "::1"
					  			isRegex : false
					  			replacement : "127.0.0.1"
					  			replaceFirst : false
							}
				  		}
				  		{
							findReplace {
					  			field : client_address
					  			pattern : "::ffff:"
					  			isRegex : false
					  			replacement : ""
				  				replaceFirst : false
							}
				  		}
					]
				}
		  		]
			}
	  	}
	  	{
	  		# test if the ip address used is a vpn or any other nat address
	  		MatchIP {
	  			ipAddress : "client_address"
	  			cidr : "192.168.0.22"
	  			output : "is_nat"
	  		}
	  	}
	  	{
			GetHostnameFromDHCP {
		    	ipAddress : client_address
		        timeStamp: timeGeneratedUnixTime
		        outputRecordName : machine_name
		        host : "127.0.0.1"
		        port : 27017
		        db: "fortscale"
		        collection : "dhcp_log"
		        leaseTimeInMins : 2880
		        graceTimeInMins : 1
			}
      	}
	  	{
			if {
		  		conditions : [
		  			# if machine_name emtpy then
					{ equals  { machine_name : [""] } }
		  		]
		  		then : [
				{
					GetHostnameFromDNS {
						ip_address : client_address
						output_record_name : machine_name
			            short_name : true
						max_queries : 1000
					}
				}
				]
			}
	  	}
	  	{
			ParseKerberosTicketOptions {
				ticketOptionsField : ticket_options
				forwardableField : forwardable
				forwardedField : forwarded
				proxiedField : proxied
				postdatedField : postdated
				renewRequestField : renew_request
				constraintDelegationField : constraint_delegation
			}
		}
		{
			ClassifyHost {
				hostnameField : machine_name
				classificationField : src_class
			}
		}
	]
  }
]
