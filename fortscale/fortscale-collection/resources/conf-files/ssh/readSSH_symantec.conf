morphlines: [
  # Event sample:
  #Dec 01 00:38:07 3.3.3.3 vsftpd: pam_unix(vsftpd:session): session opened for user username by (uid=0)" (service map: <eventmap version="2"><field name="vendor_severity">info</field><field name="TimeOffset">0</field><field name="facility">security</field><field name="event_dt">1448923087452</field><field name="reporting_sensor">sensorname</field><field name="proxy_machine_ip">3.3.3.3</field><field name="proxy_machine">hostname</field></eventmap>)
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    dictionaryString: """
							  	STATUS Accepted publickey
								 """
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{STATUS:status}"
                    }
                  }
                }
              ]
            }
            {
              commands: [
                {
                  grok {
                    dictionaryString: """
							  	STATUS Failed password
								 """
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: "%{STATUS:status}"
                    }
                  }
                }
              ]
            }
            {
              # fallback rule when grok failed to match properties
              commands: [
                {logDebug {format: "Record doesn't meet legitimate ssh format. Dropping record: {}", args: ["@{}"]}}
                {LogFilterEvent { errorMessage: "Record doesn't meet legitimate ssh format"}}
                {dropRecord {}}
              ]
            }
          ]
        }
      }
      {
        if {
          conditions: [
            {equals {status: ["Accepted publickey"]}}
          ]
          then: [
            {
              setValues {
                status: "Accepted"
              }
            }
          ]
          else: [
            {
              if {
                conditions: [
                  {equals  {status: ["Failed password"]}}
                ]
                then: [
                  {
                    setValues {
                      status: "Failed"
                    }
                  }
                ]
                else: [
                  {logDebug {format: "Record doesn't meet legitimate ssh format. Dropping record: {}", args: ["@{}"]}}
                  {LogFilterEvent { errorMessage: "Record doesn't meet legitimate ssh format"}}
                  {dropRecord {}}
                ]
              }
            }
          ]
        }
      }

      {
        grok {
          dictionaryFiles: [resources/grok-dictionaries/ssh.symantec.conf]
          expressions: {
            message: "%{IP:source_ip}|%{TARGET_MACHINE:target_machine}|%{DHCP_DATE:date_time}|%{USERNAME:username}|%{AUTH_METHOD:auth_method}|%{TIMEZONE:timezone}"
          }
          findSubstrings: true
          numRequiredMatches: all
        }
      }


      {
        EmptyObjectFilter {
          filterFields: [username, source_ip, target_machine, date_time]
        }
      }
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  findReplace {
                    field: source_ip
                    pattern: "::ffff:"
                    isRegex: false
                    replacement: ""
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: source_ip
                    pattern: "::1"
                    isRegex: false
                    replacement: "@{target_machine}"
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: source_ip
                    pattern: "127.0.0.1"
                    isRegex: false
                    replacement: "@{target_machine}"
                    replaceFirst: false
                  }
                }
              ]
            }
          ]
        }
      }

      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "ssh"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }


      {
        tryRules {
          catchExceptions: false
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [

                # Adding year from the system current date to the date_time.
                {
                  AddYearToDatetime {
                    dateFormat: "yyyy MMM d HH:mm:ss"
                    timezone: timezone_input
                  }
                }


                {
                  convertTimestampFortscale {
                    field: date_time
                    inputFormats: ["yyyy MMM dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                  }
                }


                {
                  setValues {
                    date_time_unix: "@{date_time}"
                  }
                }

                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputFormats: ["yyyy-MM-dd HH:mm:ss"]
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }

              ]
            }
          ]
        }
      }
    ]
  }
]
