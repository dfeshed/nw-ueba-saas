morphlines: [
  {
    id: morphline1
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {
                      message: """(?<status>(Accepted|Failed(?= \w+ for \w+ from )))"""
                    }
                  }
                }
              ]
            }
            {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}
            {
              commands: [
                {logDebug {format: "Record doesn't meet legitimate ssh format. Dropping record: {}", args: ["@{}"]}}
                {LogFilterEvent {errorMessage: "Record doesn't meet legitimate ssh format"}}
                {dropRecord {}}
              ]
            }
            {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}
          ]
        }
      }
      {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}
      {
        grok {
          dictionaryFiles: [resources/grok-dictionaries/ssh.sshd.conf]
          expressions: {
            message: "%{DHCP_IP:source_ip}|%{TARGET_MACHINE:target_machine}|%{DHCP_DATE:date_time}|%{USERNAME:username}|%{AUTH_METHOD:auth_method}|%{TIMEZONE:timezone}"
          }
          findSubstrings: true
          numRequiredMatches: all
        }
      }

      {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}
      {
        EmptyObjectFilter {
          filterFields: [username, source_ip, target_machine, date_time]
        }
      }
      {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}
      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType: ssh
          criteria: [username]
          threshold: 100000
        }

      }
      {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}
      {
        OverFlowFilter {
          eventsType: ssh
          criteria: []
          threshold: 1000000
        }
      }

      {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  findReplace {
                    field: source_ip
                    pattern: "::ffff:"
                    isRegex: false
                    replacement: ""
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: source_ip
                    pattern: "^::1$"
                    isRegex: true
                    replacement: "target_machine"
                    replaceFirst: false
                  }
                }
                {
                  findReplace {
                    field: source_ip
                    pattern: "127.0.0.1"
                    isRegex: false
                    replacement: "target_machine"
                    replaceFirst: false
                  }
                }
              ]
            }
          ]
        }
      }
      {
        if {
          conditions: [{equals {source_ip: "target_machine"}}]
          then: [
            {
              setValues {
                source_ip: "@{target_machine}"
              }
            }
          ]
        }
      }
      {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}
      {
        if {
          conditions: [
            {equals {timezone: []}}
          ]
          then: [
            {
              GetTimezone {
                sourceType: "ssh"
                hostnameField: reporting_server
                timezoneOutputField: timezone_input
              }
            }
          ]
          else: [
            {
              addValues {
                timezone_input: "@{timezone}"
              }
            }
          ]
        }
      }

      {logDebug {format: "Debug -10 : {}", args: ["@{}"]}}
      {
        tryRules {
          catchExceptions: false
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {logDebug {format: "Debug -11 : {}", args: ["@{}"]}}
                # Adding year from the system current date to the date_time.
                {
                  AddYearToDatetime {
                    dateFormat: "yyyy MMM d HH:mm:ss"
                    timezone: timezone_input
                  }
                }
                {logDebug {format: "Debug -12 : {}", args: ["@{}"]}}

                {
                  convertTimestampFortscale {
                    field: date_time
                    inputTimezoneField: timezone_input
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                  }
                }

                {logDebug {format: "Debug -13 : {}", args: ["@{}"]}}
                {
                  setValues {
                    date_time_unix: "@{date_time}"
                  }
                }

                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputTimezoneField: timezone_input
                    outputFormat: "unixTimeInSeconds"
                  }
                }
                {logDebug {format: "Debug -14 : {}", args: ["@{}"]}}
              ]
            }
          ]
        }
      }


      {logDebug {format: "Debug -15 : {}", args: ["@{}"]}}


      {
        # test if the ip address usedSpace is a vpn or any other nat address
        MatchIP {
          ipAddress: "source_ip"
          cidr: "192.168.0.22"
          output: "is_nat"
        }
      }

      {logDebug {format: "Debug -16 : {}", args: ["@{}"]}}

    ]
  }
]
