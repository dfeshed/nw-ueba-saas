morphlines : [
  {
    id : SSH_TelcomItalia
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [
      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                # parse ssh lines in the format:
                # 1409522849 2014-09-01T00:07:26+02:00 FAC=auth npatas1/npatas1 PROG=sshd PID=271913 LEV=[info] Accepted publickey for logarc from 10.41.152.66 port 63935 ssh2
                {
                  grok {
                    dictionaryFiles : [resources/grok-dictionaries/ssh.telcomItalia.conf]
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions : {
                      message : "%{DATE_TIME:date_time}|%{TARGET_MACHINE_AS_IP:target_machine_ip}|%{TARGET_MACHINE:target_machine}|(?<status>(Accepted|Failed))|%{AUTH_METHOD:auth_method} |%{USERNAME:username}|%{DHCP_IP:source_ip}"
                    }
                  }
                }
              ]
            }
            {
              commands : [
                {	logDebug	{	format : "Record doesn't meet legitimate ssh format. Dropping record: {}", args : ["@{}"] } }
                {   LogFilterEvent { errorMessage: "Record doesn't meet legitimate ssh format"}}
                {	dropRecord {} }
              ]
            }
          ]
        }
      }

      # handle case that the target machine contain ip
      {
        if {
          conditions : [
            {not {equals : {target_machine_ip : [] }}}
          ]
          then : [

            {
              setValues {
                target_machine : []
              }
            }


          ]
        }
      }





      {
        EmptyObjectFilter {
          filterFields : [username,source_ip,target_machine]
        }
      }

      # handle case that the target machine contain ip
      #{
      #  regexMatch {
      #    field : "target_machine"
      #    regex : "\\d+[.]\\d+[.]\\d+[.]\\d+"
      #  }
      #}
#



      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : [username]
          threshold : 100000
        }

      }
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : []
          threshold : 1000000
        }
      }



      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                {
                  findReplace {
                    field : source_ip
                    pattern : "::ffff:"
                    isRegex : false
                    replacement : ""
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "::1"
                    isRegex : false
                    replacement :  "target_machine"
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "127.0.0.1"
                    isRegex : false
                    replacement : "target_machine"
                    replaceFirst : false
                  }
                }
              ]
            }
          ]
        }
      }

      {
        if {
          conditions : [{equals{source_ip :"target_machine"} }]
          then:[
            {
              setValues {
                source_ip : "@{target_machine}"
              }
            }
          ]
        }
      }


      {
        setValues {
          date_time_unix : "@{date_time}"
        }
      }

      {
        convertTimestampFortscale {
          field : date_time_unix
          outputFormat : "unixTimeInSeconds"
        }
      }

      {
        convertTimestampFortscale {
          field : date_time
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }




      # seems like we are not using it, might as well put here a fixed value
      {
        addValues {
          is_nat : "false"
        }
      }
      #			{
      #		  		# test if the ip address used is a vpn or any other nat address
      #		  		MatchIP {
      #		  			ipAddress : "source_ip"
      #		  			cidr : "192.168.0.22"
      #		  			output : "is_nat"
      #		  		}
      #		  	}




    ]
  }
]

