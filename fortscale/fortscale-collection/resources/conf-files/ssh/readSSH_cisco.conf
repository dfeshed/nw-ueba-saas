morphlines : [
  {
    id : readSSH_cisco
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [
      {
        split {
          inputField: message
          outputFields: [date_time, target_machine, status, auth_method, username, source_ip]
          separator: ","
        }
      }
      {toString {field: date_time, trim: true}}
      {toString {field: target_machine, trim: true}}
      {toString {field: status, trim: true}}
      {toString {field: auth_method, trim: true}}
      {toString {field: username, trim: true}}
      {toString {field: source_ip, trim: true}}
      {
        EmptyObjectFilter {
          filterFields : [username,source_ip,target_machine]
        }
      }
      #the first overflow filter command insures that the overflow is not caused by a single user in the system
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : [username]
          threshold : 100000
        }
      }
      {
        OverFlowFilter {
          eventsType : ssh
          criteria : []
          threshold : 1000000
        }
      }
      {
        java {
          imports: "import java.util.*;import java.text.SimpleDateFormat;import fortscale.collection.monitoring.MorphlineCommandMonitoringHelper;"
          code: """
            String fieldVal = (String)record.getFirstValue("auth_method");
            record.replaceValues("auth_method", fieldVal.replaceAll("\"", ""));
            fieldVal = (String)record.getFirstValue("username");
            record.replaceValues("username", fieldVal.replaceAll("\"", ""));
            fieldVal = (String)record.getFirstValue("target_machine");
            record.replaceValues("target_machine", fieldVal.replaceAll("\"", ""));
            fieldVal = (String)record.getFirstValue("date_time");
            record.replaceValues("date_time", fieldVal.replaceAll("\"", ""));
            fieldVal = (String)record.getFirstValue("source_ip");
            record.replaceValues("source_ip", fieldVal.replaceAll("\"", ""));
            fieldVal = (String)record.getFirstValue("status");
            record.replaceValues("status", fieldVal.replaceAll("\"", ""));
            return child.process(record);
            """
        }
      }
      {
        tryRules {
          catchExceptions : true
          throwExceptionIfAllRulesFailed : false
          rules : [
            {
              commands : [
                {
                  findReplace {
                    field : source_ip
                    pattern : "::ffff:"
                    isRegex : false
                    replacement : ""
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "::1"
                    isRegex : false
                    replacement :  "target_machine"
                    replaceFirst : false
                  }
                }
                {
                  findReplace {
                    field : source_ip
                    pattern : "127.0.0.1"
                    isRegex : false
                    replacement : "target_machine"
                    replaceFirst : false
                  }
                }
              ]
            }
          ]
        }
      }
      {
        if {
          conditions : [{equals{source_ip :"target_machine"} }]
          then:[
            {
              setValues {
                source_ip : "@{target_machine}"
              }
            }
          ]
        }
      }
      {
        setValues {
          date_time_unix : "@{date_time}"
        }
      }
      {
        convertTimestampFortscale {
          field : date_time_unix
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ss+00:00"]
          outputFormat : "unixTimeInSeconds"
        }
      }
      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ss+00:00"]
          outputFormat : "yyyy-MM-dd HH:mm:ss"
        }
      }
      # seems like we are not using it, might as well put here a fixed value
      {
        addValues {
          is_nat : "false"
        }
      }
      #			{
      #		  		# test if the ip address used is a vpn or any other nat address
      #		  		MatchIP {
      #		  			ipAddress : "source_ip"
      #		  			cidr : "192.168.0.22"
      #		  			output : "is_nat"
      #		  		}
      #		  	}
    ]
  }
]