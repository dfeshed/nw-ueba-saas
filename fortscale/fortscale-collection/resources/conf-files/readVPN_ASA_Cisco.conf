morphlines :[
  {
    id: VPN_ASA_CISCO
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  # filter  message by specific groups "Group <AnyConnect_policy>", "Group = Everyone" or "Group=ciscovpn4cluster" or "Group=ciscovpncluster" or "Group=crdc_webex_employee" or "Group=CRDC_users"  or "Group <apple_short>"
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {message: """(?<group>(<AnyConnect_policy>|AnyConnect_profile|Everyone|ciscovpn4cluster|ciscovpncluster|crdc_webex_employee|CRDC_users|<apple_short>|<apple_long>|%ASA-6-11))"""}
                  }
                }


              ]
            }
            {
              commands: [
                {logDebug {format: "Record doesn't meet the specific groups we parse. Dropping record: {}", args: ["@{}"]}}
                {
                  dropRecord {}
                }
              ]
            }
          ]
        }
      }


      {
        grok {
          dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
          findSubstrings: true
          addEmptyStrings: true
          numRequiredMatches: all
          expressions: {
            message: "%{DATESTAMP:date_time}|%{REPORTERSERVER:reporting_server}|%{EVENTTYPE:EventType}"
          }
        }
      }



      {
        EmptyObjectFilter {
          filterFields: [date_time, EventType]
        }
      }

      {
        setValues {
          date_time_unix: "@{date_time}"
        }

      }

      {
        GetTimezone {
          sourceType: "vpn"
          hostnameField: reporting_server
          timezoneOutputField: timezone_output
        }
      }


      {
        convertTimestampFortscale {
          field: date_time_unix
          inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField: timezone_output
          outputFormat: "unixTimeInSeconds"

        }
      }




      #Handle session replace/resumed (help us to ignore the seesion start that related to that type)
      {
        if {
          conditions : [{contains  {EventType : ["ASA-6-716059","ASA-5-722032"]}}]
          then : [

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{USERNAMEAnyConnect:username}"
                }
              }
            }

            {
              if {
                conditions : [{contains {group : ["<apple_short>","<apple_long>"]}}]
                then : [

                  #parse the username
                  {
                    java {
                      imports:"import java.util.*;import org.apache.commons.lang.StringUtils;"
                      code:
                        """

                              String userNameToParse = (String)record.getFirstValue("username");
                              String result = userNameToParse.substring(0,userNameToParse.indexOf('-'));
                              record.replaceValues("username",result);
                              return child.process(record);


                        """
                    }
                  }

                ]
              }
            }



            {
              setValues {
                fake_session: "@{EventType}"
              }
            }






            #keep in the cahce
            {
              EventsJoiner {
                keys : [ "username","date_time"]
                mergeFields : []
                cacheName : "vpn"
                timeThreshold : 0
                currentRecordDateField : date_time_unix
                cachedRecordDateField : date_time_unix
                dropFromCache : true
              }
            }




          ]
        }
      }


      {
        #Fail without group sign
        if {
          conditions : [{contains  {EventType:["ASA-6-113013","ASA-6-113005"]}}]
          then : [



            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{USERNAMEFailsWIthoutGroups:username}"
                }
              }
            }


            {
              setValues {
                status: ["FAIL"]
              }
            }


          ]

          #handle the groups type + mark session type
          else : [


            #handle the groups type
            {


              #case of group is AnyConnect:
              if {
                #case that its session start or fail - type = Group <AnyConnect_policy> (status = success or fail)
                conditions: [{equals {group: ["<AnyConnect_policy>"]}}]
                then: [


                  # handle Start Session event
                  # extract source IP field,datetime,user name,local_ip
                  # set values- geoip, date_time_unix , status

                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{USERNAMEAnyConnect:username}|%{SOURCEIPAnyConnect:source_ip}|%{LOCALIPAnyConnect:local_ip}"
                      }
                    }
                  }



                ]

                else: [
                  {
                    #case that its session AnyConnect end - type = Group = AnyConnect_profile (status = close)
                    if {
                      conditions: [{equals {group: ["AnyConnect_profile"]}}]
                      then: [
                        # handle End Session event
                        # extract source IP field,datetime,user name,read /write bytes
                        # set values- geoip, date_time_unix , status

                        {
                          grok {
                            dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                            findSubstrings: true
                            addEmptyStrings: true
                            numRequiredMatches: all
                            expressions: {
                              message: "%{USERNAMEENDAnyConnect:username}|%{SOURCEIPENDAnyConnect:source_ip}|%{READBYTESAnyConnect:readbytes}|%{WRITEBYTESAnyConnect:writebytes}"
                            }
                          }


                        }

                      ]

                      #other groups (status = success/close/fail)
                      else: [
                        {
                          #case the session is Everyone
                          if {
                            conditions: [{equals {group: ["Everyone"]}}]
                            then: [
                              # handle Start and End Session events
                              # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                              # set values- geoip, date_time_unix ,
                              {
                                grok {
                                  dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                  findSubstrings: true
                                  addEmptyStrings: true
                                  numRequiredMatches: all
                                  expressions: {
                                    message: "%{USERNAMEEveryone:username}|%{SOURCEIPEveryone:source_ip}|%{LOCALIPEveryone:local_ip}|%{READBYTESEveryone:readbytes}|%{WRITEBYTESEveryone:writebytes}"
                                  }
                                }


                              }







                            ]
                            else: [
                              #Other group
                              {
                                if {
                                  conditions: [{contains {group: ["ciscovpn4cluster", "ciscovpncluster", "crdc_webex_employee", "CRDC_users",]}}]
                                  then: [
                                    # handle Start and End Session events
                                    # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                                    # set values- geoip, date_time_unix , status

                                    {
                                      grok {
                                        dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                        findSubstrings: true
                                        addEmptyStrings: true
                                        numRequiredMatches: all
                                        expressions: {
                                          message: "%{USERNAMEOther:username}|%{SOURCEIPOther:source_ip}|%{LOCALIPOther:local_ip}|%{READBYTESOther:readbytes}|%{WRITEBYTESOther:writebytes}"
                                        }
                                      }


                                    }

                                  ]

                                  #case of Apple
                                  else :[
                                    {
                                      if {
                                        conditions: [{contains {group: ["<apple_short>","<apple_long>"]}}]
                                        then: [




                                          # handle Start and End Session events
                                          # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                                          # set values- geoip, date_time_unix , status

                                          {
                                            grok {
                                              dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                              findSubstrings: true
                                              addEmptyStrings: true
                                              numRequiredMatches: all
                                              expressions: {
                                                message: "%{USERNAMETEMPApple:username}|%{SOURCEIPApple:source_ip}|%{LOCALIPApple:local_ip}|%{READBYTESApple:readbytes}|%{WRITEBYTESApple:writebytes}"
                                              }
                                            }

                                          }



                                          {
                                            EmptyObjectFilter {
                                              filterFields: [username]
                                            }
                                          }





                                          #parse the username
                                          {
                                            java {
                                              imports:"import java.util.*;import org.apache.commons.lang.StringUtils;"
                                              code:
                                                """

                                                      String userNameToParse = (String)record.getFirstValue("username");
                                                      String result = userNameToParse.substring(0,userNameToParse.indexOf('-'));
                                                      record.replaceValues("username",result);
                                                      return child.process(record);


                                                """
                                            }
                                          }


                                        ]
                                      }
                                    }
                                  ]
                                }
                              }
                            ]
                          }
                        }




                      ]
                    }
                  }
                ]
              }
            }


            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }


            #resolving status

            {
              #ssesion fail ?
              if {
                conditions: [{contains  {EventType: ["ASA-6-716002","ASA-6-713905","ASA-5-713068","ASA-4-722037","ASA-4-717037","ASA-4-713903","ASA-4-713251","ASA-3-713218","ASA-3-713167","ASA-6-716039"]}}]
                then: [





                  {
                    setValues {
                      status: ["FAIL"]
                    }
                  }



                  {
                    EmptyObjectFilter {
                      filterFields: [source_ip]
                    }
                  }

                ]
                else : [
                  {
                    #Session start
                    if{
                      conditions: [{contains {EventType : ["ASA-4-713228","ASA-4-722051"]}}]
                      then : [


                        {
                          EmptyObjectFilter {
                            filterFields: [source_ip, local_ip]
                          }
                        }



                        #Retrive from cahce
                        {
                          EventsJoinerMerge {
                            keys: ["username", "date_time"]
                            mergeFields: ["fake_session"]
                            dropWhenNoMatch : false
                            cacheName: "vpn"
                          }
                        }

                        #In case that the current start session is related to prev resume\replace events drop it (fake session)
                        {
                          if {
                            conditions : [{not {equals{fake_session:[]}}}]
                            then : [
                              {
                                dropRecord {}
                              }

                            ]
                          }
                        }


                        {
                          setValues {
                            status: ["SUCCESS"]
                          }
                        }

                      ]
                      else : [
                        {
                          #Session close
                          if {
                            conditions: [{contains {EventType: ["ASA-4-113019", "ASA-7-722031", "ASA-7-722030"]}}]
                            then: [
                              #case of apple end session
                              {
                                if {
                                  conditions: [{equals {group: ["<apple_short>"]}}]
                                  then: [

                                    #merge the 2 end session events
                                    {
                                      EventsJoiner {
                                        keys: ["username", "date_time_unix"]
                                        mergeFields: ["username", "date_time", "readbytes", "writebytes"]
                                        cacheName: "vpn"
                                        timeThreshold: 86400
                                        currentRecordDateField: date_time_unix
                                        cachedRecordDateField: date_time_unix
                                        dropFromCache: true
                                      }
                                    }


                                  ]

                                }
                              }


                              {
                                setValues {
                                  status: ["CLOSED"]
                                }
                              }

                            ]
                            else: [
                              {
                                dropRecord {}
                              }

                            ]

                          }
                        }
                      ]
                    }
                  }

                ]
              }
            }
          ]
        }
      }




      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case of status = CLOSE
      {

        if {
          conditions : [{equals {status: ["CLOSED"]}}]
          then : [

            {
              EmptyObjectFilter {
                filterFields: [source_ip,readbytes, writebytes]
              }
            }



            # Adding total bytes.
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
                                   String readbytes = (String)record.getFirstValue("readbytes");
                                   String writebytes = (String)record.getFirstValue("writebytes");
                                   Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                   record.replaceValues("totalbytes", totalbytes);
                                   return child.process(record);
                                   """
              }
            }

            #TODO- add the calculation of the duration here

            #Adding data bucket
            {
              VpnDataBucket {
                totalbytesFieldName: totalbytes
                readbytesFieldName: readbytes
                durationFieldName: duration
                databucketFieldName: databucket
                bucketDefinition: ["50", "100", "200", "400"]
              }
            }



          ]
        }
      }


      {
        VPNNormalizeUsername {
          usernameField: username
          normalizedUsernameField: normalized_username
        }
      }



      #for debug
      {logDebug{format: "current record is :  {}", args: ["@{}"]}}

      #case of status = SUCCESS

      {
        if {
          conditions: [{equals {status: ["SUCCESS"]}}]
          then: [


            {
              UserLastActivityUpdate {
                logEventsType: vpn
                normalizedUsernameField: normalized_username
                epochtimestampField: date_time_unix
              }

            }

          ]
        }
      }


      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField : timezone_output
          outputFormat : "yyyy-MM-dd HH:mm:ss"
          outputTimezoneField : timezone_output
        }
      }



      {
        IsUserAdministrator {
          usernameField : normalized_username
          isUserAdministratorField : isUserAdministrator
        }
      }

      {
        IsUserExecutive {
          usernameField : normalized_username
          isUserExecutiveField : isUserExecutive
        }
      }


      {
        Geolocation {
          ip_field : source_ip
          country_field : country
          region_field : region
          city_field : city
          isp_field : isp
          usage_type_field : ipusage
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
        }
      }


      {
        VpnSessionUpdate {
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
          geo_hopping_open_session_threshold : 6
          geo_hopping_close_session_threshold : 1
          session_id_field : sessionId
          add_session_data: false
        }
      }

    ]

  }
]
