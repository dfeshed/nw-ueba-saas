morphlines :[
  {
    id: VPN_ASA_CISCO
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  # filter  message by specific groups "Group <AnyConnect_policy>", "Group = Everyone" or "Group=ciscovpn4cluster" or "Group=ciscovpncluster" or "Group=crdc_webex_employee" or "Group=CRDC_users"  or "Group <apple_short>"
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {message: """(?<group>(Group <AnyConnect_policy>|Group = AnyConnect_profile|Group = Everyone|Group = ciscovpn4cluster|Group = ciscovpncluster|Group = crdc_webex_employee|Group = CRDC_users|Group <apple_short>|AAA user authentication Rejected))"""}
                  }
                }


              ]
            }
            {
              commands: [
                {logDebug {format: "Record doesn't meet the specific groups we parse. Dropping record: {}", args: ["@{}"]}}
                {
                  dropRecord {}
                }
              ]
            }
          ]
        }
      }

      #handle the groups type
      {
        #case of group is AnyConnect:
        if {
          #case that its session start or fail - type = Group <AnyConnect_policy> (status = success or fail)
          conditions: [{equals {group: ["Group <AnyConnect_policy>"]}}]
          then: [


            # handle Start Session event
            # extract source IP field,datetime,user name,local_ip
            # set values- geoip, date_time_unix , status

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{DATESTAMP:date_time}|%{USERNAMEAnyConnect:username}|%{SOURCEIPAnyConnect:source_ip}|%{LOCALIPAnyConnect:local_ip}|%{FAILMARKAnyConnect:FailMark}"
                }
              }


            }

            {
              EmptyObjectFilter {
                filterFields: [date_time, username]
              }
            }

            {
              if {
                conditions: [{equals {FailMark: []}}]
                then: [
                  {
                    setValues {
                      status: ["SUCCESS"]
                    }
                  }
                ]

                else: [
                  {
                    setValues {
                      status: ["FAIL"]
                    }
                  }
                ]
              }
            }
          ]
          else: [
            {
              #case that its session AnyConnect end - type = Group = AnyConnect_profile (status = close)
              if {
                conditions: [{equals {group: ["Group = AnyConnect_profile"]}}]
                then: [
                  # handle End Session event
                  # extract source IP field,datetime,user name,read /write bytes
                  # set values- geoip, date_time_unix , status

                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{DATESTAMP:date_time}|%{USERNAMEENDAnyConnect:username}|%{SOURCEIPENDAnyConnect:source_ip}|%{ENDMARKAnyConnectOtherEvryOne:EndMark}|%{READBYTESAnyConnect:readbytes}|%{WRITEBYTESAnyConnect:writebytes}"
                      }
                    }


                  }

                  {
                    EmptyObjectFilter {
                      filterFields: [date_time, username]
                    }
                  }


                  {
                    setValues {
                      status: ["CLOSED"]
                    }
                  }

                ]

                #other groups (status = success/close/fail)
                else: [
                  {
                    #case the session is Everyone
                    if {
                      conditions: [{equals {group: ["Group = Everyone"]}}]
                      then: [
                        # handle Start and End Session events
                        # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                        # set values- geoip, date_time_unix , status

                        {
                          grok {
                            dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                            findSubstrings: true
                            addEmptyStrings: true
                            numRequiredMatches: all
                            expressions: {
                              message: "%{DATESTAMP:date_time}|%{USERNAMEEveryone:username}|%{SOURCEIPEveryone:source_ip}|%{ENDMARKAnyConnectOtherEvryOne:EndMark}|%{SOURCEIPFAILEveryone:source_ip_fail}|%{LOCALIPEveryone:local_ip}|%{READBYTESEveryone:readbytes}|%{WRITEBYTESEveryone:writebytes}|%{FAILMARKEveryone:FailMark}"
                            }
                          }


                        }

                      ]
                      else: [
                        #Other group
                        {
                          if {
                            conditions: [{contains {group: ["Group = ciscovpn4cluster", "Group = ciscovpncluster", "Group = crdc_webex_employee", "Group = CRDC_users", "AAA user authentication Rejected"]}}]
                            then: [
                              # handle Start and End Session events
                              # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                              # set values- geoip, date_time_unix , status

                              {
                                grok {
                                  dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                  findSubstrings: true
                                  addEmptyStrings: true
                                  numRequiredMatches: all
                                  expressions: {
                                    message: "%{DATESTAMP:date_time}|%{USERNAMEOther:username}|%{USERNAMEFAILOther:username_fail}|%{SOURCEIPOther:source_ip}|%{ENDMARKAnyConnectOtherEvryOne:EndMark}|%{LOCALIPOther:local_ip}|%{READBYTESOther:readbytes}|%{WRITEBYTESOther:writebytes}"
                                  }
                                }


                              }

                            ]

                            #case of Apple
                            else :[
                              {
                                if {
                                  conditions: [{equals {group: ["Group <apple_short>"]}}]
                                  then: [


                                    # handle Start and End Session events
                                    # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
                                    # set values- geoip, date_time_unix , status

                                    {
                                      grok {
                                        dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                                        findSubstrings: true
                                        addEmptyStrings: true
                                        numRequiredMatches: all
                                        expressions: {
                                          message: "%{DATESTAMP:date_time}|%{USERNAMETEMPApple:username}|%{SOURCEIPApple:source_ip}|%{LOCALIPApple:local_ip}|%{ENDSESSIONMARKApple:EndMark}|%{READBYTESApple:readbytes}|%{WRITEBYTESApple:writebytes}|%{FAILMARKApple:FailMark}"
                                        }
                                      }


                                    }

                                    {
                                      EmptyObjectFilter {
                                        filterFields: [date_time,username]
                                      }
                                    }



                                    #parse the username
                                    {
                                      java {
                                        imports:"import java.util.*;import org.apache.commons.lang.StringUtils;"
                                        code:
                                          """

                                                String userNameToParse = (String)record.getFirstValue("username");
                                                String result = userNameToParse.substring(0,userNameToParse.indexOf('-'));
                                                record.replaceValues("username",result);
                                                return child.process(record);


                                          """
                                      }
                                    }


                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  }


                  #resolving status
                  #ssesion fail ?
                  {
                    if {
                      conditions: [{equals {FailMark: ["failed"]}}]
                      then: [

                        {
                          EmptyObjectFilter {
                            filterFields: [source_ip_fail]
                          }
                        }

                        {
                          setValues {
                            status: ["FAIL"]
                          }
                        }

                        {
                          setValues {
                            source_ip: "@{source_ip_fail}"
                          }
                        }

                        {
                          EmptyObjectFilter {
                            filterFields: [date_time, username, source_ip]
                          }
                        }

                      ]
                      else : [
                        {
                          if {
                            conditions: [{equals {group: ["AAA user authentication Rejected"]}}]
                            then: [
                              {
                                EmptyObjectFilter {
                                  filterFields: [username_fail]
                                }
                              }
                              {
                                setValues {
                                  status: ["FAIL"]
                                }
                              }
                              {
                                setValues {
                                  username: "@{username_fail}"
                                }
                              }

                              {
                                EmptyObjectFilter {
                                  filterFields: [date_time, username]
                                }
                              }

                            ]
                            else : [
                              {
                                if {
                                  conditions: [{equals {FailMark: ["failure"]}}]
                                  then: [
                                    {
                                      setValues {
                                        status: ["FAIL"]
                                      }
                                    }

                                    {
                                      EmptyObjectFilter {
                                        filterFields: [date_time, username, source_ip]
                                      }
                                    }
                                  ]
                                  else : [

                                    {logInfo {format: "Before Mark current record is :  {}", args: ["@{}"]}}



                                    #Mark the event (start? or end?)
                                    {
                                      java {
                                        imports: "import java.util.*;import org.apache.commons.lang.StringUtils;"
                                        code:
                                          """
                                                                 String resField = "eventType";
                                                                 String EndMark =  (String)record.getFirstValue("EndMark");



                                                                 System.out.println(EndMark);

                                                                 if (EndMark != null)
                                                                    record.put(resField,"End");
                                                                 else
                                                                    record.put(resField,"Start");



                                                                 return child.process(record);
                                          """
                                      }
                                    }
                                    {logInfo {format: "After Mark current record is :  {}", args: ["@{}"]}}

                                    {
                                      if {
                                        conditions: [{equals {eventType: ["Start"]}}]
                                        then: [



                                          {
                                            EmptyObjectFilter {
                                              filterFields: [date_time, username, source_ip,local_ip]
                                            }
                                          }


                                          {
                                            setValues {
                                              status: ["SUCCESS"]
                                            }
                                          }

                                        ]
                                        else: [
                                          #case of apple end session
                                          {
                                            if {
                                              conditions : [{equals {group: ["Group <apple_short>"]}}]
                                              then :[
                                                {

                                                  setValues {
                                                    date_time_unix: "@{date_time}"
                                                  }

                                                }

                                                {

                                                  GetTimezone {
                                                    sourceType: "vpn"
                                                    hostnameField: reporting_server
                                                    timezoneOutputField: timezone_output
                                                  }
                                                }


                                                {
                                                  convertTimestampFortscale {
                                                    field: date_time_unix
                                                    inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
                                                    inputTimezoneField: timezone_output
                                                    outputFormat: "unixTimeInSeconds"

                                                  }
                                                }

                                                {logInfo {format: "Before join current record is :  {}", args: ["@{}"]}}

                                                #merge the 2 end session events
                                                {
                                                  EventsJoiner {
                                                    keys : [ "username","date_time_unix" ]
                                                    mergeFields : [ "username", "date_time","readbytes","writebytes"]
                                                    cacheName : "vpn"
                                                    timeThreshold : 86400
                                                    currentRecordDateField : date_time_unix
                                                    cachedRecordDateField : date_time_unix
                                                    dropFromCache : true
                                                  }
                                                }

                                                {logInfo {format: "After join current record is :  {}", args: ["@{}"]}}

                                              ]

                                            }
                                          }


                                          {
                                            setValues {
                                              status: ["CLOSED"]
                                            }
                                          }

                                        ]
                                      }
                                    }

                                  ]
                                }
                              }
                            ]
                          }
                        }
                      ]
                    }
                  }

                  {
                    EmptyObjectFilter {
                      filterFields: [date_time, username]
                    }
                  }

                ]
              }
            }
          ]
        }
      }


      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case of status = CLOSE
      {

        if {
          conditions : [{equals {status: ["CLOSED"]}}]
          then : [

            {
              EmptyObjectFilter {
                filterFields: [date_time, username, source_ip, readbytes, writebytes]
              }
            }



            # Adding total bytes.
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
                                   String readbytes = (String)record.getFirstValue("readbytes");
                                   String writebytes = (String)record.getFirstValue("writebytes");
                                   Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                   record.replaceValues("totalbytes", totalbytes);
                                   return child.process(record);
                                   """
              }
            }

            #TODO- add the calculation of the duration here

            #Adding data bucket
            {
              VpnDataBucket {
                totalbytesFieldName: totalbytes
                readbytesFieldName: readbytes
                durationFieldName: duration
                databucketFieldName: databucket
                bucketDefinition: ["50", "100", "200", "400"]
              }
            }



          ]
        }
      }

      #event filter for success status
      {
        if {
          conditions :[{equals {status: ["SUCCESS"]}}]
          then : [
            {
              EmptyObjectFilter {
                filterFields: [date_time, username, source_ip]
              }
            }
          ]
        }
      }

      {
        VPNNormalizeUsername {
          usernameField: username
          normalizedUsernameField: normalized_username
        }
      }

      {

        setValues {
          date_time_unix: "@{date_time}"
        }

      }

      {

        GetTimezone {
          sourceType: "vpn"
          hostnameField: reporting_server
          timezoneOutputField: timezone_output
        }
      }


      {
        convertTimestampFortscale {
          field: date_time_unix
          inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField: timezone_output
          outputFormat: "unixTimeInSeconds"

        }
      }

      #for debug
      {logDebug{format: "current record is :  {}", args: ["@{}"]}}

      #case of status = SUCCESS

      {
        if {
          conditions: [{equals {status: ["SUCCESS"]}}]
          then: [


            {
              UserLastActivityUpdate {
                logEventsType: vpn
                normalizedUsernameField: normalized_username
                epochtimestampField: date_time_unix
              }

            }

          ]
        }
      }


      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField : timezone_output
          outputFormat : "yyyy-MM-dd HH:mm:ss"
          outputTimezoneField : timezone_output
        }
      }







      {
        IsUserAdministrator {
          usernameField : normalized_username
          isUserAdministratorField : isUserAdministrator
        }
      }

      {
        IsUserExecutive {
          usernameField : normalized_username
          isUserExecutiveField : isUserExecutive
        }
      }


      {
        Geolocation {
          ip_field : source_ip
          country_field : country
          region_field : region
          city_field : city
          isp_field : isp
          usage_type_field : ipusage
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
        }
      }


      {
        VpnSessionUpdate {
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
          geo_hopping_open_session_threshold : 6
          geo_hopping_close_session_threshold : 1
          session_id_field : sessionId
          add_session_data: false
        }
      }

    ]

  }
]
