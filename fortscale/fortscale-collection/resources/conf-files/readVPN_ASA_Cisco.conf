morphlines :[
  {
    id: VPN_ASA_CISCO
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [
      {

        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  # filter  message by specific groups "Group <AnyConnect_policy>", "Group = Everyone" or "Group=ciscovpn4cluster" or "Group=ciscovpncluster" or "Group=crdc_webex_employee" or "Group=CRDC_users"  or "Group <apple_short>"
                  # all other will be discarded in the dropRecord command bellow
                  grok {
                    findSubstrings: true
                    addEmptyStrings: true
                    numRequiredMatches: all
                    expressions: {message: """(?<group>(Group <AnyConnect_policy>|Group = AnyConnect_profile|Group = Everyone|Group = ciscovpn4cluster|Group = ciscovpncluster|Group = crdc_webex_employee|Group = CRDC_users|Group <apple_short>|AAA user authentication Rejected))"""}
                  }
                }
              ]
            }
            {
              commands: [
                {logDebug {format: "Record doesn't meet the specific groups we parse. Dropping record: {}", args: ["@{}"]}}
                {
                  dropRecord {}
                }
              ]
            }


          ]
        }
      }

      #case of group is AnyConnect:
      {

        if {
          conditions: [{contains {group: ["Group <AnyConnect_policy>", "Group = AnyConnect_profile"]}}]
          then: [
            {
              if {
                #case that its session start or fail - type = Group <AnyConnect_policy>
                conditions: [{equals {group: ["Group <AnyConnect_policy>"]}}]
                then: [


                  # handle Start Session event
                  # extract source IP field,datetime,user name,local_ip
                  # set values- geoip, date_time_unix , status

                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{DATESTAMP:date_time}|%{USERNAMEAnyConnect:username}|%{SOURCEIPAnyConnect:source_ip}|%{LOCALIPAnyConnect:local_ip}|%{FAILMARKAnyConnect:FailMark}"
                      }
                    }


                  }

                  {
                    EmptyObjectFilter {
                      filterFields: [date_time, username, source_ip]
                    }
                  }

                  {
                    if {
                      conditions:[{equals {FailMark : []}}]
                      then : [
                        {
                          setValues {
                            status: ["SUCCESS"]
                          }
                        }
                      ]

                      else : [
                        {
                          setValues {
                            status: ["FAIL"]
                          }
                        }
                      ]
                    }
                  }


                ]

                #case that its session end - type = Group = AnyConnect_profile
                else: [
                  # handle End Session event
                  # extract source IP field,datetime,user name,read /write bytes
                  # set values- geoip, date_time_unix , status

                  {
                    grok {
                      dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                      findSubstrings: true
                      addEmptyStrings: true
                      numRequiredMatches: all
                      expressions: {
                        message: "%{DATESTAMP:date_time}|%{USERNAMEENDAnyConnect:username}|%{SOURCEIPENDAnyConnect:source_ip}|%{READBYTESAnyConnect:readbytes}|%{WRITEBYTESAnyConnect:writebytes}"
                      }
                    }


                  }
                  {
                    EmptyObjectFilter {
                      filterFields: [date_time, username, source_ip, readbytes, writebytes]
                    }
                  }

                  {
                    setValues {
                      status: ["CLOSED"]
                    }
                  }

                  # Adding total bytes.
                  {
                    java {
                      imports: "import java.util.*;"
                      code:
                        """
                                         String readbytes = (String)record.getFirstValue("readbytes");
                                         String writebytes = (String)record.getFirstValue("writebytes");
                                         Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                         record.replaceValues("totalbytes", totalbytes);
                                         return child.process(record);
                                         """
                    }
                  }

                  #TODO- add the calculation of the duration here

                  #Adding data bucket
                  {
                    VpnDataBucket {
                      totalbytesFieldName: totalbytes
                      readbytesFieldName: readbytes
                      durationFieldName: duration
                      databucketFieldName: databucket
                      bucketDefinition: ["50", "100", "200", "400"]
                    }
                  }
                ]

              }
            }




          ]
        }
      }

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case of group is Everyone:
      {

        if {
          conditions: [{equals {group: ["Group = Everyone"]}}]
          then: [
            # handle Start and End Session events
            # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
            # set values- geoip, date_time_unix , status

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{DATESTAMP:date_time}|%{USERNAMEEveryone:username}|%{SOURCEIPEveryone:source_ip}|%{SOURCEIPFAILEveryone:source_ip_fail}|%{LOCALIPEveryone:local_ip}|%{READBYTESEveryone:readbytes}|%{WRITEBYTESEveryone:writebytes}|%{FAILMARKEveryone:FailMark}"
                }
              }


            }


            {
              EmptyObjectFilter {
                filterFields: [date_time, username]
              }
            }

            #Mark the event (start? or end?)
            {
              java {
                imports: "import java.util.*;import org.apache.commons.lang.StringUtils;"
                code:
                  """
                                         String resField = "eventType";
                                         String readbytes =  (String)record.getFirstValue("readbytes");
                                         String writebytes = (String)record.getFirstValue("writebytes");
                                         String local_ip =   (String)record.getFirstValue("local_ip");
                                         if (StringUtils.isEmpty(local_ip) && StringUtils.isEmpty(writebytes) && StringUtils.isEmpty(readbytes) )
                                            record.put(resField,"Drop");
                                         if (!StringUtils.isEmpty(local_ip))
                                            record.put(resField,"Start");
                                         else
                                            record.put(resField,"End");

                                         return child.process(record);
                                         """
              }
            }


            #session start?
            {
              if {
                conditions: [{equals {eventType: ["Start"]}}]
                then: [

                  {
                    EmptyObjectFilter {
                      filterFields: [source_ip]
                    }
                  }

                  {
                    setValues {
                      status: ["SUCCESS"]
                    }
                  }

                ]

                else: [
                  #ssesion fail ?
                  {
                    if {
                      conditions : [{equals {FailMark:["failed"]}}]
                      then : [

                        {
                          EmptyObjectFilter {
                            filterFields: [source_ip_fail]
                          }
                        }

                        {
                          setValues {
                            status: ["FAIL"]
                          }
                        }

                        {
                          setValues {
                            source_ip: "@{source_ip_fail}"
                          }
                        }

                      ]
                      else : [
                        #ssesion end?
                        {
                          if {
                            conditions: [{equals {eventType: ["End"]}}]
                            then: [

                              {
                                EmptyObjectFilter {
                                  filterFields: [date_time, username, source_ip, readbytes, writebytes]
                                }
                              }

                              {
                                setValues {
                                  status: ["CLOSED"]
                                }
                              }
                              # Adding total bytes.
                              {
                                java {
                                  imports: "import java.util.*;"
                                  code:
                                    """
                                              String readbytes = (String)record.getFirstValue("readbytes");
                                              String writebytes = (String)record.getFirstValue("writebytes");
                                              Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                              record.replaceValues("totalbytes", totalbytes);
                                              return child.process(record);
                                              """
                                }
                              }

                              #TODO- add the calculation of the duration here

                              #Adding data bucket
                              {
                                VpnDataBucket {
                                  totalbytesFieldName: totalbytes
                                  readbytesFieldName: readbytes
                                  durationFieldName: duration
                                  databucketFieldName: databucket
                                  bucketDefinition: ["50", "100", "200", "400"]
                                }
                              }

                              

                            ]

                            #drop the record (doesn't contain not local ip and not read write )
                            else: [


                              {logDebug {format: "Record doesn't meet the data require. Dropping record: {}", args: ["@{}"]}}
                              {
                                dropRecord {}
                              }


                            ]
                          }
                        }

                      ]

                    }
                  }


                ]
              }
            }




          ]
        }
      }

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}


      #case that Group = ciscovpn4cluster / ciscovpncluster / crdc_webex_employee / CRDC_users:
      {

        if {
          conditions: [{contains {group: ["Group = ciscovpn4cluster", "Group = ciscovpncluster", "Group = crdc_webex_employee", "Group = CRDC_users","AAA user authentication Rejected"]}}]
          then: [
            # handle Start and End Session events
            # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
            # set values- geoip, date_time_unix , status

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{DATESTAMP:date_time}|%{USERNAMEOther:username}|%{USERNAMEFAILOther:username_fail}|%{SOURCEIPOther:source_ip}|%{LOCALIPOther:local_ip}|%{READBYTESOther:readbytes}|%{WRITEBYTESOther:writebytes}"
                }
              }


            }


            {
              EmptyObjectFilter {
                filterFields: [date_time]
              }
            }

            #Mark the event (start? or end?)
            {
              java {
                imports: "import java.util.*;import org.apache.commons.lang.StringUtils;"
                code:
                  """
                                         String resField = "eventType";
                                         String readbytes =  (String)record.getFirstValue("readbytes");
                                         String writebytes = (String)record.getFirstValue("writebytes");
                                         String local_ip =   (String)record.getFirstValue("local_ip");
                                         if (StringUtils.isEmpty(local_ip) && StringUtils.isEmpty(writebytes) && StringUtils.isEmpty(readbytes) )
                                            record.put(resField,"Drop");
                                         if (!StringUtils.isEmpty(local_ip))
                                            record.put(resField,"Start");
                                         else
                                            record.put(resField,"End");

                                         return child.process(record);
                                         """
              }
            }

            #session start?
            {
              if {
                conditions: [{equals {eventType: ["Start"]}}]
                then: [

                  {
                    EmptyObjectFilter {
                      filterFields: [username,source_ip, local_ip]
                    }
                  }

                  {
                    setValues {
                      status: ["SUCCESS"]
                    }
                  }

                ]
                else: [
                  #ssesion fail ?
                  {
                    if {
                      conditions: [{equals {group: ["AAA user authentication Rejected"]}}]
                      then: [
                        {
                          EmptyObjectFilter {
                            filterFields: [username_fail]
                          }
                        }
                        {
                          setValues {
                            status: ["FAIL"]
                          }
                        }
                        {
                          setValues {
                            username: "@{username_fail}"
                          }
                        }

                      ]
                      else: [


                        #ssesion end?
                        {
                          if {
                            conditions: [{equals {eventType: ["End"]}}]
                            then: [

                              {
                                EmptyObjectFilter {
                                  filterFields: [date_time, username, source_ip, readbytes, writebytes]
                                }
                              }

                              {
                                setValues {
                                  status: ["CLOSED"]
                                }
                              }
                              # Adding total bytes.
                              {
                                java {
                                  imports: "import java.util.*;"
                                  code:
                                    """
                                              String readbytes = (String)record.getFirstValue("readbytes");
                                              String writebytes = (String)record.getFirstValue("writebytes");
                                              Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                              record.replaceValues("totalbytes", totalbytes);
                                              return child.process(record);
                                              """
                                }
                              }

                              #TODO- add the calculation of the duration here

                              #Adding data bucket
                              {
                                VpnDataBucket {
                                  totalbytesFieldName: totalbytes
                                  readbytesFieldName: readbytes
                                  durationFieldName: duration
                                  databucketFieldName: databucket
                                  bucketDefinition: ["50", "100", "200", "400"]
                                }
                              }

                            ]

                            #drop the record (doesn't contain not local ip and not read write )
                            else: [


                              {logDebug {format: "Record doesn't meet the data require. Dropping record: {}", args: ["@{}"]}}

                              {
                                dropRecord {}
                              }


                            ]
                          }
                        }
                      ]


                    }
                  }
                ]
              }
            }





          ]
        }
      }

      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}

      #case that Group = apple_short
      {

        if {
          conditions: [{equals {group: ["Group <apple_short>"]}}]
          then: [


            # handle Start and End Session events
            # extract datetime,user,source IP ,local_ip(optional in case of dtart),writebutes(optional in case of end),readbytes(optional in case of end)
            # set values- geoip, date_time_unix , status

            {
              grok {
                dictionaryFiles: [resources/grok-dictionaries/vpn.Cisco.ASA.conf]
                findSubstrings: true
                addEmptyStrings: true
                numRequiredMatches: all
                expressions: {
                  message: "%{DATESTAMP:date_time}|%{USERNAMETEMPApple:username}|%{SOURCEIPApple:source_ip}|%{LOCALIPApple:local_ip}|%{READBYTESApple:readbytes}|%{WRITEBYTESApple:writebytes}|%{FAILMARKApple:FailMark}"
                }
              }


            }



            {
              EmptyObjectFilter {
                filterFields: [date_time, username, source_ip]
              }
            }





            #parse the username
            {
              java {
                imports:"import java.util.*;import org.apache.commons.lang.StringUtils;"
                code:
                  """

                  String userNameToParse = (String)record.getFirstValue("username");
                  String result = userNameToParse.substring(0,userNameToParse.indexOf('-'));
                  record.replaceValues("username",result);
                  return child.process(record);

                  """
              }
            }

            {
              EmptyObjectFilter {
                filterFields: [username]
              }
            }

            #Mark the event (start? or end?)
            {
              java {
                imports: "import java.util.*;import org.apache.commons.lang.StringUtils;"
                code:
                  """
                   String resField = "eventType";
                   String readbytes =  (String)record.getFirstValue("readbytes");
                   String writebytes = (String)record.getFirstValue("writebytes");
                   String local_ip =   (String)record.getFirstValue("local_ip");
                   if (StringUtils.isEmpty(local_ip) && StringUtils.isEmpty(writebytes) && StringUtils.isEmpty(readbytes) )
                      record.put(resField,"Drop");
                   if (!StringUtils.isEmpty(local_ip))
                      record.put(resField,"Start");
                   else
                      record.put(resField,"End");

                   return child.process(record);
                  """
              }
            }


            #session start?
            {
              if {
                conditions: [{equals {eventType: ["Start"]}}]
                then: [

                  {
                    setValues {
                      status: ["SUCCESS"]
                    }
                  }

                ]

                else: [
                  { if {
                    conditions : [{equals {FailMark:["failure"] }}]
                    then : [
                      {
                        setValues {
                          status: ["FAIL"]
                        }
                      }
                    ]
                    else : [
                      #ssesion end?
                      {
                        if {
                          conditions: [{equals {eventType: ["End"]}}]
                          then: [


                            {
                              setValues {
                                status: ["CLOSED"]
                              }
                            }

                            {

                              setValues {
                                date_time_unix: "@{date_time}"
                              }

                            }

                            {

                              GetTimezone {
                                sourceType: "vpn"
                                hostnameField: reporting_server
                                timezoneOutputField: timezone_output
                              }
                            }


                            {
                              convertTimestampFortscale {
                                field: date_time_unix
                                inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
                                inputTimezoneField: timezone_output
                                outputFormat: "unixTimeInSeconds"

                              }
                            }


                            #merge the 2 end session events
                            {
                              EventsJoiner {
                                keys : [ "username","date_time_unix" ]
                                mergeFields : [ "username", "date_time", "status","readbytes","writebytes"]
                                cacheName : "vpn"
                                timeThreshold : 86400
                                currentRecordDateField : date_time_unix
                                cachedRecordDateField : date_time_unix
                                dropFromCache : true
                              }
                            }


                            {
                              EmptyObjectFilter {
                                filterFields: [date_time, username, source_ip,readbytes,writebytes]
                              }
                            }


                            {
                              java {
                                imports: "import java.util.*;"
                                code:
                                  """
                                            String readbytes = (String)record.getFirstValue("readbytes");
                                            String writebytes = (String)record.getFirstValue("writebytes");
                                            Long totalbytes = Long.valueOf(readbytes) + Long.valueOf(writebytes);
                                            record.replaceValues("totalbytes", totalbytes);
                                            return child.process(record);
                                            """
                              }
                            }

                            #TODO- add the calculation of the duration here

                            #Adding data bucket
                            {
                              VpnDataBucket {
                                totalbytesFieldName: totalbytes
                                readbytesFieldName: readbytes
                                durationFieldName: duration
                                databucketFieldName: databucket
                                bucketDefinition: ["50", "100", "200", "400"]
                              }
                            }



                          ]

                          #drop the record (doesn't contain not local ip and not read write )
                          else: [

                            {logDebug {format: "Record doesn't meet the data require. Dropping record: {}", args: ["@{}"]}}
                            {
                              dropRecord {}
                            }


                          ]
                        }
                      }
                    ]

                  }
                  }


                ]
              }
            }


          ]
        }
      }


      {
        if {
          conditions : [{equals {status:["SUCCESS"]}}]
          then : [

            {
              VPNNormalizeUsername {
                usernameField: username
                normalizedUsernameField: normalized_username
              }
            }

            {

              setValues {
                date_time_unix: "@{date_time}"
              }

            }

            {

              GetTimezone {
                sourceType: "vpn"
                hostnameField: reporting_server
                timezoneOutputField: timezone_output
              }
            }


            {
              convertTimestampFortscale {
                field: date_time_unix
                inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
                inputTimezoneField: timezone_output
                outputFormat: "unixTimeInSeconds"

              }
            }

            {
              UserLastActivityUpdate {
                logEventsType: vpn
                normalizedUsernameField: normalized_username
                epochtimestampField: date_time_unix
              }

            }

          ]

          else : [
            # do this for all the events type
            {
              VPNNormalizeUsername {
                usernameField: username
                normalizedUsernameField: normalized_username
              }
            }

            {

              setValues {
                date_time_unix: "@{date_time}"
              }

            }

            {

              GetTimezone {
                sourceType: "vpn"
                hostnameField: reporting_server
                timezoneOutputField: timezone_output
              }
            }


            {
              convertTimestampFortscale {
                field: date_time_unix
                inputFormats: ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
                inputTimezoneField: timezone_output
                outputFormat: "unixTimeInSeconds"

              }
            }

          ]
        }

      }



      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["MMM dd yyyy HH:mm:ss", "MMM dd yyyy  HH:mm:ss"]
          inputTimezoneField : timezone_output
          outputFormat : "yyyy-MM-dd HH:mm:ss"
          outputTimezoneField : timezone_output
        }
      }



      {
        OverFlowFilter {
          eventsType : vpn
          criteria : [username]
          threshold : 100000
        }
      }
      {
        OverFlowFilter {
          eventsType : vpn
          criteria : []
          threshold : 1000000
        }
      }



      {
        IsUserAdministrator {
          usernameField : normalized_username
          isUserAdministratorField : isUserAdministrator
        }
      }

      {
        IsUserExecutive {
          usernameField : normalized_username
          isUserExecutiveField : isUserExecutive
        }
      }


      {
        Geolocation {
          ip_field : source_ip
          country_field : country
          region_field : region
          city_field : city
          isp_field : isp
          usage_type_field : ipusage
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
        }
      }


      {
        VpnSessionUpdate {
          country_code_field : countrycode
          longtitude_field : longtitude
          latitude_field : latitude
          geo_hopping_open_session_threshold : 6
          geo_hopping_close_session_threshold : 1
          session_id_field : sessionId
          add_session_data: false
        }
      }


      #for debug
      {logDebug {format: "current record is :  {}", args: ["@{}"]}}


    ]

  }
]
