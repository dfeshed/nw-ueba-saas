morphlines : [
{
	id : morphline1
	importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]

    commands : [
	  	{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
	  				{
						grok {
							dictionaryFiles : [resources/grok-dictionaries/secevents.sa.conf]
		  					findSubstrings : true
						  	addEmptyStrings : true
						  	numRequiredMatches : all
						  	expressions : {
								message : "%{TIME_GENERATED_TYPE_B:date_timeTypeB}|%{TIME_GENERATED:date_time}|%{REPORTING_SERVER:reporting_server}|%{ACCOUNT_NAME:account_name}|%{EVENT_CODE:eventCode}|%{CLIENT_ADDRESS:client_address}|%{TICKET_OPTIONS:ticket_options}"
						  	}
						}
      				}
      				{ toString { field : client_address, trim : true } }
      				{ toString { field : ticket_options, trim : true } }
      				{ toString { field : account_name, trim : true } }
			  		]
				}
		  	]
			}
		}
		{
			EmptyObjectFilter {
				filterFields : [eventCode,account_name,client_address,ticket_options]
			}
		}
		#the first overflow filter command insures that the overflow is not caused by a single user in the system
		{
			OverFlowFilter {
				eventsType : securityEvents
				criteria : [eventCode, account_name]
				threshold : 100000
			}
		}
		{
			OverFlowFilter {
				eventsType : securityEvents
				criteria : [eventCode]
				threshold : 2000000
			}
		}
		{
			GetTimezone {
				sourceType : "sec"
				hostnameField : reporting_server
				timezoneOutputField : timezone_output
			}
		}
		{ 
			if { 
				conditions : [ 
					{ equals { date_timeTypeB : [] } }
				] 
				then : [
					# Adding year from the system current date to the date_time.
					{
						java {
							imports : "import java.util.*;import java.text.SimpleDateFormat;"
							code:
								"""
								try {
									Object date_time = record.getFirstValue("date_time");
									if (date_time==null)
										return false;
										
									int year = Calendar.getInstance().get(Calendar.YEAR);
									int currentMonth = Calendar.getInstance().get(Calendar.MONTH);
									
									int parsedMonth;
									SimpleDateFormat sdf = new SimpleDateFormat("MMM", Locale.ENGLISH);
									parsedMonth = sdf.parse(date_time.toString().substring(0,3)).getMonth();
									
									// If the month is later than current month, we'll assign the previous year to the event
									if (parsedMonth > currentMonth) {
										year--;
									}

									record.replaceValues("date_time", Integer.toString(year) + " " + date_time.toString());
								}
								catch (Exception e) {
									System.out.println(e);
								}

								return child.process(record);
								"""
						}
					}				
				] 
				else : [
					{
						setValues {
							date_time: "@{date_timeTypeB}"
						}
					}
					{
						convertTimestampFortscale {
							field : date_time
							#Mar 17 15:49:28 2014
							inputFormats : ["MMM dd HH:mm:ss yyyy","MMM  dd HH:mm:ss yyyy"]
							inputTimezoneField : timezone_output
							outputFormat : "yyyy MMM dd HH:mm:ss"
							#outputTimezoneField : timezone_output
						}
					}
				]
			} 
		}



		{
			findReplace {
				field : account_name
				isRegex : false
				pattern : "'"
				replacement : ""
			}
		}
		
		{
			addValues {
				timeGeneratedRaw : "@{date_time}"
				date_time_unix : "@{date_time}"
			}
		}
		
		# Adding isComputer.
		{
			java {
				imports : "import java.util.*;"
				code:
					"""
					String account_name = (String)record.getFirstValue("account_name");
					Boolean isComputer = account_name.contains("$") ? true : false;
					record.replaceValues("isComputer", isComputer);
					return child.process(record);
					"""
			}
		}

      {
        tryRules {
          catchExceptions: true
          throwExceptionIfAllRulesFailed: false
          rules: [
            {
              commands: [
                {
                  convertTimestampFortscale {
                    field: timeGeneratedRaw
                    #2014 Mar 17 15:49:28
                    inputFormats: ["yyyy MMM dd HH:mm:ss", "yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField: timezone_output
                    outputFormat: "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
                    outputTimezoneField: timezone_output
                  }
                }
                {
                  convertTimestampFortscale {
                    field: date_time
                    #2014 Mar 17 15:49:28
                    inputFormats: ["yyyy MMM dd HH:mm:ss", "yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField: timezone_output
                    outputFormat: "yyyy-MM-dd HH:mm:ss"
                    #outputTimezoneField : timezone_output
                  }
                }
                {
                  convertTimestampFortscale {
                    field: date_time_unix
                    inputFormats: ["yyyy MMM dd HH:mm:ss", "yyyy MMM  dd HH:mm:ss"]
                    inputTimezoneField: timezone_output
                    outputFormat: "unixTimeInSeconds"
                    # default outputTimezone : UTC
                  }
                }
              ]
            }
          ]
        }
      }

      { logDebug { format : "current record is  -  {}",args: ["@{}"] } }


	  	{
			tryRules {
		  		catchExceptions : true
		  		throwExceptionIfAllRulesFailed : false
		  		rules : [
				{
			  		commands : [
				  		{
							findReplace {
					  			field : client_address
					  			pattern : "::1"
					  			isRegex : false
					  			replacement : "127.0.0.1"
					  			replaceFirst : false
							}
				  		}
				  		{
							findReplace {
					  			field : client_address
					  			pattern : "::ffff:"
					  			isRegex : false
					  			replacement : ""
				  				replaceFirst : false
							}
				  		}
					]
				}
		  		]
			}
	  	}
	  	{
	  		# test if the ip address used is a vpn or any other nat address
	  		MatchIP {
	  			ipAddress : "client_address"
	  			cidr : "192.168.0.22"
	  			output : "is_nat"
	  		}
	  	}
	  	{
			ParseKerberosTicketOptions {
				ticketOptionsField : ticket_options
				forwardableField : forwardable
				forwardedField : forwarded
				proxiedField : proxied
				postdatedField : postdated
				renewRequestField : renew_request
				constraintDelegationField : constraint_delegation
			}
		}
		{ 
			if { 
				conditions : [ 
					{ equals { isComputer : [false] } } 
				] 
				then : [
					{
						IpToHostname {
					    	ipAddress : client_address
					        timeStamp: date_time_unix
					        outputRecordName : machine_name
					        remove_last_dot : true
					        resolvers = ["logins", "dns"]
						}
			      	}
			      	{
						FilterUnresolvedMachine{
							machineNameField : machine_name
						}
					}
					{
						ClassifyHost {
							hostnameField : machine_name
							classificationField : src_class
						}
					}
					{
						GetComputerClusterName {
							hostnameField : machine_name
							clusterField : normalized_src_machine
						}
					}
					
					{
						SECNormalizeUsername {
							usernameField : account_name
							normalizedUsernameField : normalized_username
						}
					}
								
					{
						UserLastActivityUpdate {
							logEventsType : login
							normalizedUsernameField : normalized_username
							epochtimestampField : date_time_unix
						}
					}
					{
						IsUserServiceAccount {
							usernameField : normalized_username
							isUserServiceAccountField : isUserServiceAccount
						}
					}
					{
						IsUserAdministrator {
							usernameField : normalized_username
							isUserAdministratorField : isUserAdministrator
						}
					}
					{
						IsUserExecutive {
							usernameField : normalized_username
							isUserExecutiveField : isUserExecutive
						}
					}
				] 
			} 
		}
	]
  }
]
