morphlines : [
  {
    id : processAMT_enrich
    importCommands : ["org.kitesdk.morphline.**", "org.apache.solr.**","fortscale.collection.morphlines.**"]
    commands : [





      # Retrieve the yid from the yid column
      # 'yid = statefun48' or 'yid ='
      {
        java {
          imports : "import java.util.*;"
          code:
            """
            String yid_col = record.getFirstValue("yid") != null ? record.getFirstValue("yid").toString() : "";

            String yid="";
            String searchString = "yid =";

            if (yid_col.contains(searchString)){
                yid = yid_col.substring(yid_col.indexOf(searchString)+searchString.length(),yid_col.length()).trim();

                if (yid.contains(","))
                   yid = yid.substring(0,yid.indexOf(","));

                record.replaceValues("yid",yid);
            }


            return child.process(record);
            """
        }
      }


      {
        EmptyObjectFilter {
          filterFields : [logdate,target_ip,source_ip,username]
        }
      }





      # match yid with external file of vip accounts
      # re-use the sensitive machine field to cut corners in implementation
      #{
      #  IsSensitiveMachine {
      #    machineNameField : "yid"
      #    isSensitiveMachineField : "is_sensitive_machine"
      #  }
      #}
      { toString { field : is_sensitive_machine, trim : false } }

      # normalize timezone according to server - all data from the same timezone
      # parse logdate time and calculate the epoch time
      {
        SubString {
          field : "logdate"
          endIndex : 19
        }
      }
      {
        addValues {
          date_time : "@{logdate}"
          date_time_unix : "@{logdate}"
          timezone_output : "UTC"
        }
      }
      {
        convertTimestampFortscale {
          field : date_time
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
          inputTimezoneField : "timezone_output"
          outputFormat : "yyyy-MM-dd HH:mm:ss"
          outputTimezoneField : "timezone_output"
        }
      }
      {
        convertTimestampFortscale {
          field : date_time_unix
          inputFormats : ["yyyy-MM-dd'T'HH:mm:ss"]
          inputTimezoneField : "timezone_output"
          outputFormat : "unixTimeInSeconds"
          outputTimezoneField : "UTC"
        }
      }

      # resolve client ip address
     # {
     #   IpToHostname {
     #     ipAddress : source_ip
     #     timeStamp: date_time_unix
     #     outputFieldName : hostname
     #     restrictToADName : false
     #     short_name : false
     #     remove_last_dot : true
     #   }
     # }
#
     # # resolve server ip address
     # {
     #   IpToHostname {
     #     ipAddress: target_ip
     #     timeStamp: date_time_unix
     #     outputFieldName: target_machine
     #     restrictToADName: false
     #     short_name : false
     #     remove_last_dot : true
     #   }
     # }

      # resolve the source country
     # {
     #   Geolocation {
     #     ip_field : source_ip
     #     country_field : src_country
     #     region_field : src_region
     #     city_field : src_city
     #     isp_field : src_isp
     #     usage_type_field : src_ipusage
     #     country_code_field : src_countrycode
     #     longtitude_field : src_longtitude
     #     latitude_field : src_latitude
     #   }
     # }
#
     # # resolve the dest country
     # {
     #   Geolocation {
     #     ip_field : target_ip
     #     country_field : dst_country
     #     region_field : dst_region
     #     city_field : dst_city
     #     isp_field : dst_isp
     #     usage_type_field : dst_ipusage
     #     country_code_field : dst_countrycode
     #     longtitude_field : dst_longtitude
     #     latitude_field : dst_latitude
     #   }
     # }



      # normalize user name
     #{
     #  AMTNormalizeUsername {
     #    usernameField : username
     #    normalizedUsernameField : normalized_username
     #  }
     #}



      # set fixed fields values
      {
        addValues {
          status : "SUCCESS"
          src_class : "UNKNOWN"
          is_sensitive_machine : "false"
          is_nat : "false"
          isUserExecutive : "false"
          isUserAdministrator : "false"
          normalized_dst_machine : "@{target_machine}"
          normalized_src_machine : "@{hostname}"
        }
      }



      # filter events for change password with the password hash
      {
        java {
          imports: "import java.util.*;"
          code:
            """
			if ("CHANGEPW".equals(record.getFirstValue("action_code"))) {
				String action_string = (record.getFirstValue("action_string")!=null)? record.getFirstValue("action_string").toString() : "";

				if (!action_string.startsWith("Emailed To")) {
					return true;
				}
			}
			return child.process(record);
			"""
        }
      }

      # Create a cache sign for  preciding events of CHANGEPWD and LOGINAS
      {
        java {
          imports: "import java.util.*;"
          code:
            """
            Object value = record.getFirstValue("action_code");
            String action_code = value != null ? value.toString() : "";
            String cacheSign = "0";

            if (action_code.equals("VIEWFOR") || action_code.equals("VIEWAVINFO") || action_code.equals("VIEWAMT") || action_code.equals("VIEWSBC") || action_code.equals("VIEWBT") || action_code.equals("VIEWATT") || action_code.equals("VIEWROGERS") || action_code.equals("VIEWVZ") || action_code.equals("VIEWPWQ") || action_code.equals("VIEWAMTDATA") || action_code.equals("VIEWYCORP") || action_code.equals("VIEWHSBC") || (action_code.length()>=5 &&  action_code.substring(0,5).equals("TOKEN")) )
              cacheSign = "1";


            record.put("cacheSign",cacheSign);

            return child.process(record);
            """
        }
      }



      {
        if {
          conditions: [{equals {cacheSign: ["1"]}}]
          then: [


            #Add fake field to trace if the change password join success
            {
              addValues {
                FakeField: "1"
              }
            }

            #keep in the cahce
            {
              EventsJoiner {
                keys: ["username", "yid"]
                mergeFields: []
                cacheName: "amtActionCode"
                timeThreshold: -1
                cacheRecordTtlPropertyName: "${amt.EventsJoiner.ttl}"
                currentRecordDateField: date_time_unix
                cachedRecordDateField: date_time_unix
                dropFromCache: true
                processRecord: true
              }
            }
          ]
          else: [
            {
              if {
                conditions: [{equals {action_code: ["CHANGEPW"]}}]
                # in case of change password
                then: [
                  #Retrive from cahce
                  {
                    EventsJoinerMerge {
                      keys: ["username", "yid"]
                      mergeFields: ["FakeField"]
                      dropWhenNoMatch: false
                      cacheName: "amtActionCode"
                      timeToCacheMiliSec : 43200000 #12 houers in milisec
                      timeField : "date_time_unix"
                    }
                  }


                  #trace CHANGEPW without preciding event
                  {
                    if {
                      conditions: [{equals {FakeField: []}}]
                      then: [
                        #add to notifications
                        {
                          SendNotification {
                            notificationType: "AmtPwdReset"
                          }

                        }

                      ]
                    }
                  }

                ]
                else: [
                  # create notification for loginasmail without preciding event
                  {
                    if {
                      conditions: [{equals {action_code: ["LOGINASMAIL"]}}]
                      then: [
                        #Retrive from cahce
                        {
                          EventsJoinerMerge {
                            keys: ["username", "yid"]
                            mergeFields: ["FakeField"]
                            dropWhenNoMatch: false
                            cacheName: "amtActionCode"
                            timeToCacheMiliSec : 43200000 #12 houers in milisec
                            timeField : "date_time_unix"
                          }
                        }

                        {
                          if {
                            conditions: [{equals {FakeField: []}}]
                            then: [
                              #add to notifications
                              {
                                SendNotification {
                                  notificationType: "AmtLoginAsMail"
                                }
                              }
                            ]
                          }
                        }

                      ]
                    }
                  }

                ]
              }
            }
          ]
        }
      }

    ]
  }
]

