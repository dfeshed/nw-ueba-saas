morphlines: [
  {
    id: dlpmailEnrich
    importCommands: ["org.kitesdk.morphline.**", "org.apache.solr.**", "fortscale.collection.morphlines.**"]
    commands: [

      {logDebug {format: "Debug -1 : {}", args: ["@{}"]}}

      {
        if {
          conditions: [
            {not {equals {event_id: ["Fortscale Control"]}}}
          ]
          then: [
            # normalized_src_machine should be like username
            {
              setValues {
                normalized_src_machine: "@{hostname}"
              }
            }

            {logDebug {format: "Debug -2 : {}", args: ["@{}"]}}


            # calculate is_attachment_extension_blacklisted
            {
              java {
                imports: "import java.util.*;"
                code:
                  """
                    String attachmentFileExtension = (String)record.getFirstValue("attachment_file_extension");

                    boolean isExtensionBlacklisted = false;

                    HashSet<String> listOfBlacklistedAttachmentExtensions = new HashSet<String>(Arrays.asList("jar,db,_db,mdb,accdb,wdb,sqlite,sdf,myd,dbf,db3,sql,dbs,mdf,cpp,7z,gzip,zip,rar,tar,war,dmg,taz,tbz,tbz2".split(",")));
                    isExtensionBlacklisted = listOfBlacklistedAttachmentExtensions.contains(attachmentFileExtension.toLowerCase());

                    record.replaceValues("is_attachment_extension_blacklisted", isExtensionBlacklisted);

                    return child.process(record);
                  """
              }
            }

            {logDebug {format: "Debug -3 : {}", args: ["@{}"]}}

            # set metadata
            {
              setValues {
                data_source: ["dlpmail"]
                last_state: ["etl"]
                date_time_unix: "@{date_time}"
              }
            }

            {logDebug {format: "Debug -4 : {}", args: ["@{}"]}}

            # normalize date_time_unix format
            {
              convertTimestampFortscale {
                field: date_time_unix
                inputFormats: ["MM/dd/yyyy HH:mm", "MM/dd/yyyy h:mm:ss a", "M/dd/yyyy h:mm:ss a", "MM/dd/yyyy HH:mm:ss", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss", "MM/dd/yyyy hh:mm:ss aaa"]
                outputFormat: "unixTimeInSeconds"
              }
            }

            {logDebug {format: "Debug -5 : {}", args: ["@{}"]}}

            # normalize date_time format
            {
              convertTimestampFortscale {
                field: date_time
                inputFormats: ["MM/dd/yyyy HH:mm", "MM/dd/yyyy h:mm:ss a", "M/dd/yyyy h:mm:ss a", "MM/dd/yyyy HH:mm:ss", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd HH:mm:ss", "MM/dd/yyyy hh:mm:ss aaa"]
                outputFormat: "yyyy-MM-dd HH:mm:ss"
              }
            }

            {logDebug {format: "Debug -6 : {}", args: ["@{}"]}}

            # identify DEVICE entities
            {
              if {
                conditions: [{contains {username: ["NT AUTHORITY\\LOCAL SERVICE", "NT AUTHORITY\\SYSTEM", "NT AUTHORITY\\LOCAL SERVICE", "NT AUTHORITY\\NETWORK SERVICE", "NT AUTHORITY\\SYSTEM"]}}]
                then: [
                  { # filter if empty
                    EmptyObjectFilter {
                      filterFields: [normalized_src_machine]
                    }
                  }

                  { # add DEVICE if needed
                    java {
                      imports: "import java.util.*;"
                      code:
                        """
                           String hostname = (String)record.getFirstValue("hostname");
                           String username = (String)record.getFirstValue("username");
                           record.replaceValues("username","Device\\"+hostname);

                           return child.process(record);
                        """
                    }
                  }

                  { # set normalized_src_machine to empty
                    setValues {
                      normalized_src_machine: [""]
                    }
                  }
                ]
              }
            }

            {logDebug {format: "Debug -7 : {}", args: ["@{}"]}}

            # set event_type field to attachment (if not already set to something else) if attachment_file_name isn't "" OR "message body"  and event_description is "Send Mail" OR "Attach Mail"
            {
              if {
                conditions: [
                  {contains {event_description: ["Send Mail", "Attach Mail"]}}
                  {equals {event_type: [""]}}
                ]
                then: [
                  {
                    if {
                      conditions: [
                        {not {contains {attachment_file_name: ["message body", ""]}}}
                      ]
                      then: [
                        {
                          setValues {
                            event_type: ["attachment"]
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          ]
        }
      }


      {logDebug {format: "Debug -8 : {}", args: ["@{}"]}}

      # Calculate num of recipients
      {
        if {
          conditions:[
            {contains {event_type: ["message_body","recipient", "fortscale control"]}}
          ]
          then: [
            {
              EventsCounter {
                keys: ["event_id"]
                processRecord: true
              }
            }
          ]
        }
      }


      {logDebug {format: "Debug -9 : {}", args: ["@{}"]}}


    ]
  }
]
