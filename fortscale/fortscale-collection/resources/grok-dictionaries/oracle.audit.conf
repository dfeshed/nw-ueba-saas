# grok dictionary to support oracle audit events, E.g.:
# "{"format":1,"raw_log":"Dec  7 16:05:37 tar1310.crossperf.ptec Oracle Audit[11970]: [ID 748625 local7.warning] LENGTH: \"357\" SESSIONID:[8] \"20924830\" ENTRYID:[1] \"1\" STATEMENT:[1] \"1\" USERID:[8] \"MAILQAPP\" USERHOST:[38] \"cppums1-mailq-privil-01.crossperf.ptec\" ACTION:[3] \"100\" RETURNCODE:[1] \"0\" COMMENT$TEXT:[100] \"Authenticated by: DATABASE; Client address: (ADDRESS=(PROTOCOL=tcp)(HOST=10.143.70.216)(PORT=43678))\" OS$USERID:[6] \"apache\" DBID:[9] \"131437128\" PRIV$USED:[1] \"5\""}

# (?<=OS\$USERID:\[[0-9]{1,3}\]\s\") - look behind expression to check if the text is preceded with OS$USERID:[<LENGTH>]. Length is the range of number of characters in the value so we the boundaries are 1-3 to support
# values lengths from 1 to 999 characters. We use static range and not dynamic since the look-behind expression must be defined with a maximum value.
# .*? - we extract any value and on the first occurence we stop (non-greedy)
#
USERNAME (?<=OS\$USERID:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")
DB_USERNAME (?<=USERID:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")
SOURCE_MACHINE (?<=USERHOST:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")
DB_ID (?<=DBID:\[[0-9]{0,10}\]\s\\\").*?(?=\\\")
ACTION_TYPE (?<=ACTION:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")
RETURN_CODE (?<=RETURNCODE:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")
DB_OBJECT (?<=OBJ\$NAME:\[[0-9]{1,3}\]\s\\\").*?(?=\\\")

# find the first timestamp value after the {"format":1,"raw_log":" prefix and stop. The value is the text from the beginning until the timestamp (inclusive).
DATE_TIME (?<=\{\"format\":1,\"raw_log\":\").+?(?<=\d\d\:\d\d\:\d\d)

# the value is between the timestamp and the 'Oracle Audit' key label
TARGET_MACHINE (?<=\d\d\:\d\d\:\d\d\s).+?(?=\sOracle Audit\[)

SOURCE_IP (?<=\(HOST=).+?(?=\))