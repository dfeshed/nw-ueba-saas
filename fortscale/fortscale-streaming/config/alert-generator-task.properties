# Job
job.factory.class=fortscale.streaming.GracefulShutdownLocalJobFactory
job.name=alert-generator-task

# Task
task.class=fortscale.streaming.task.AlertGeneratorTask
task.inputs=kafka.fortscale-evidences,kafka.user-tag-service-cache-updates,kafka.fortscale-session-time-updates,kafka.fortscale-entity-event-score

# calling the window function every 15 minutes (15*60*1000=900000ms) (currently not in use)
task.window.ms=900000

### Fortscale specific task config parameters

# Spring Context
fortscale.context=classpath*:META-INF/spring/streaming-AlertGeneratorTask-context.xml
# esper config
fortscale.esper.config.file.path=config/Esper/EsperConfig.xml


fortscale.input.info.topic.evidence=fortscale-evidences
fortscale.input.info.class.evidence=fortscale.domain.core.Evidence

fortscale.input.info.topic.user-tags=user-tag-service-cache-updates
fortscale.input.info.event-wrapper.user-tags=entityTagsWrapper
fortscale.input.info.cache-name.user-tags=entity-tags-cache

fortscale.input.info.topic.session-time-update=fortscale-session-time-updates
fortscale.input.info.event-wrapper.session-time-update=sessionTimeUpdateWrapper
fortscale.input.info.dynamic-statements.session-time-update=_0_5_createSessionVariable,_0_6_updateSessionVariable,_2_2_suspiciousSessionByCount

fortscale.input.info.topic.entity-event-score=fortscale-entity-event-score
fortscale.input.info.class.entity-event-score=fortscale.domain.core.EntityEvent

# Metric report every 60 seconds to a kafka topic called metrics and as a monitor report
metrics.reporter.snapshot.class=org.apache.samza.metrics.reporter.MetricsSnapshotReporterFactory
metrics.reporter.snapshot.stream=kafka.metrics
systems.kafka.streams.metrics.samza.msg.serde=metrics
metrics.reporters=snapshot

# Serializers
serializers.registry.json.class=org.apache.samza.serializers.JsonSerdeFactory
serializers.registry.string.class=org.apache.samza.serializers.StringSerdeFactory
serializers.registry.integer.class=org.apache.samza.serializers.IntegerSerdeFactory
serializers.registry.jsonmodel.class=fortscale.streaming.serialization.PrevalanceModelSerdeFactory
serializers.registry.long.class=fortscale.streaming.serialization.LongSerdeFactory
serializers.registry.metrics.class=org.apache.samza.serializers.MetricsSnapshotSerdeFactory
serializers.registry.timebarrier.class=fortscale.streaming.serialization.UserTimeBarrierModelSerdeFactory
serializers.registry.entitytags.class=fortscale.streaming.serialization.EntityTagsSerdeFactory

# Systems
systems.kafka.samza.factory=org.apache.samza.system.kafka.KafkaSystemFactory
systems.kafka.samza.key.serde=string
systems.kafka.samza.msg.serde=string
systems.kafka.samza.offset.default=oldest
systems.kafka.consumer.zookeeper.connect=localhost:2181
systems.kafka.consumer.auto.offset.reset=smallest
systems.kafka.producer.metadata.broker.list=localhost:9092
systems.kafka.producer.producer.type=sync
systems.kafka.producer.retry.backoff.ms = 10000
systems.kafka.producer.acks = 1
systems.kafka.producer.reconnect.backoff.ms = 10000
systems.kafka.producer.queue.buffering.max.ms=2000
systems.kafka.producer.batch.num.messages=1000

# Declare that we want our job's checkpoints to be enabled and written to Kafka
task.checkpoint.factory=org.apache.samza.checkpoint.kafka.KafkaCheckpointManagerFactory
task.checkpoint.replication.factor=1
task.checkpoint.system=kafka

#Esper beans and statements

# create variable for holding the current system timestamp
fortscale.esper.rule.name._0_1_createCurrentTimestampVariable=Create current timestamp variable
fortscale.esper.rule.statement._0_1_createCurrentTimestampVariable=create variable Long currentTimestamp = current_timestamp()
fortscale.esper.rule.auto-create._0_1_createCurrentTimestampVariable=true
fortscale.esper.rule.subscriberBean._0_1_createCurrentTimestampVariable=none

# update currentTimestamp variable with current system timestamp
fortscale.esper.rule.name._0_2_updateVariableWithCurrentTimestamp=Update variable with current timestamp
fortscale.esper.rule.statement._0_2_updateVariableWithCurrentTimestamp=on pattern[every timer:interval(1 min)] set currentTimestamp = current_timestamp()
fortscale.esper.rule.auto-create._0_2_updateVariableWithCurrentTimestamp=true
fortscale.esper.rule.subscriberBean._0_2_updateVariableWithCurrentTimestamp=none

# create variable for holding the last event timestamp
fortscale.esper.rule.name._0_3_createCurrentTimestampVariable=Create current timestamp variable
fortscale.esper.rule.statement._0_3_createCurrentTimestampVariable=create variable Long lastEventTimestamp = 0
fortscale.esper.rule.auto-create._0_3_createCurrentTimestampVariable=true
fortscale.esper.rule.subscriberBean._0_3_createCurrentTimestampVariable=none

# update current_timestamp variable with current system timestamp
fortscale.esper.rule.name._0_4_updateVariableWithLastEventTimestamp=Update variable with last event timestamp
fortscale.esper.rule.statement._0_4_updateVariableWithLastEventTimestamp=on Evidence as e set lastEventTimestamp = e.startDate
fortscale.esper.rule.auto-create._0_4_updateVariableWithLastEventTimestamp=true
fortscale.esper.rule.subscriberBean._0_4_updateVariableWithLastEventTimestamp=none

# create variable for holding the last event timestamp
fortscale.esper.rule.name._0_5_createSessionVariable=Create session variable
fortscale.esper.rule.statement._0_5_createSessionVariable=create variable SessionTimeUpdate sessionTimeUpdate##sessionId##
fortscale.esper.rule.auto-create._0_5_createSessionVariable=false
fortscale.esper.rule.subscriberBean._0_5_createSessionVariable=destroyVariableCreateStatementSubscriber

# update session variable for each new session
fortscale.esper.rule.name._0_6_updateSessionVariable=Update session variable
fortscale.esper.rule.statement._0_6_updateSessionVariable=on SessionTimeUpdate(sessionId = '##sessionId##') as su set sessionTimeUpdate##sessionId## = su
fortscale.esper.rule.auto-create._0_6_updateSessionVariable=false
fortscale.esper.rule.subscriberBean._0_6_updateSessionVariable=destroyVariableUpdateStatementSubscriber


#######------------Create Enriched elements (Evidence, SMART)--------------######

# compute for each Evidence the related hourly,daily frame
# when new time period will be needed in the future, need to add them first in here
fortscale.esper.rule.name._1_0_enrichedEvidence=Enriched evidence with time frames
fortscale.esper.rule.statement._1_0_enrichedEvidence=insert into EnrichedEvidence select id, entityType, entityName, score, hourStartTimestamp(startDate) as hourlyStartDate, dayStartTimestamp(startDate) as dailyStartDate from Evidence
fortscale.esper.rule.auto-create._1_0_enrichedEvidence=true
fortscale.esper.rule.subscriberBean._1_0_enrichedEvidence=none

# compute for each Evidence the related hourly,daily frame
fortscale.esper.rule.name._1_1_enrichedEntityEvent=Enriched entity event with time entityName and entityType
fortscale.esper.rule.statement._1_1_enrichedEntityEvent=insert into EnrichedEntityEvent select EntityType.User as entityType, extractNormalizedUsernameFromContextId(contextId) as entityName, score, aggregated_feature_events, start_time_unix, end_time_unix from EntityEvent
fortscale.esper.rule.auto-create._1_1_enrichedEntityEvent=true
fortscale.esper.rule.subscriberBean._1_1_enrichedEntityEvent=none


# create enriched entity event, to include hourlystartdate and entity type
fortscale.esper.rule.name._1_1_enrichedEntityEvent=Enriched smart event with time frames
fortscale.esper.rule.statement._1_1_enrichedEntityEvent=insert into EnrichedEntityEvent select EntityType.User as entityType, extractNormalizedUsernameFromContextId(contextId) as entityName, score, hourStartTimestamp(start_time_unix) as hourlyStartDate, dayStartTimestamp(start_time_unix) as dailyStartDate, aggregated_feature_events, start_time_unix, end_time_unix from EntityEvent
fortscale.esper.rule.auto-create._1_1_enrichedEntityEvent=true
fortscale.esper.rule.subscriberBean._1_1_enrichedEntityEvent=none


#######---------------Contexts--------------------------#####

# create context for hourly activity for entity - will used for all hourly rules
fortscale.esper.rule.name._1_2_createHourlyContext=Create hourly context for entity
fortscale.esper.rule.statement._1_2_createHourlyContext=create context HourlyTimeFrame partition by entityType,entityName,hourlyStartDate from EnrichedEvidence
fortscale.esper.rule.auto-create._1_2_createHourlyContext=true
fortscale.esper.rule.subscriberBean._1_2_createHourlyContext=none

# create context for daily activity for entity - will used for all daily rules
fortscale.esper.rule.name._1_3_createDailyContext=Create daily context for entity
fortscale.esper.rule.statement._1_3_createDailyContext=create context DailyTimeFrame partition by entityType,entityName,dailyStartDate from EnrichedEvidence
fortscale.esper.rule.auto-create._1_3_createDailyContext=true
fortscale.esper.rule.subscriberBean._1_3_createDailyContext=none

# create context for hourly activity for entity, with smart (joker) events and notification

#######-------------Rules that create alerts------------#######


#Suspicious activity Alert EPL (according to Joker Evidence and the existent of tagging and Notification(The notification is not mandatory its effect the severity))
#group Joker evidence according to contextId.
#Join it with the tags for which also group according to entity.
#set the severity according to score: 50/65/75/90 - Low/ Medium/ High/ Critical respectively
fortscale.esper.rule.name._2_3_SmartEventWithSensitiveAccount=Suspicious Activity For Sensitive Account
fortscale.esper.rule.statement._2_3_SmartEventWithSensitiveAccount=select 'Suspicious Activity For Sensitive Account' as title,case when (Notification.entityName is null and SmartEvent.score in [50:65)) or (Notification.entityName is not null and SmartEvent.score in [50:60)) then 'Low' when (Notification.entityName is null and SmartEvent.score in [65:75)) or (Notification.entityName is not null and SmartEvent.score in [60:70)) then 'Medium' when (Notification.entityName is null and SmartEvent.score in [75:90)) or (Notification.entityName is not null and SmartEvent.score in [70:85)) then 'High' when (Notification.entityName is null and SmartEvent.score >= 90 ) or (Notification.entityName is not null and SmartEvent.score >= 85) then 'Critical' end as severity , Tags.entityType as entityType, Tags.entityName as entityName, aggregated_feature_events, start_time_unix, end_time_unix, SmartEvent.score * 1.0 as score, Tags.tags as tags from  EnrichedEntityEvent(score >= 50).std:groupwin(entityName,entityType).std:lastevent() as SmartEvent inner join EntityTags('admin' = any(Tags.tags) or 'executive' = any(Tags.tags) or 'service' = any(Tags.tags) ).std:groupwin(entityType,entityName).std:lastevent() as Tags  on SmartEvent.entityName = Tags.entityName and SmartEvent.entityType = Tags.entityType  left outer join EnrichedEvidence(evidenceType = EvidenceType.Notification).win:expr_batch(oldest_timestamp+(60*60*1000+30*60*1000) < currentTimestamp or (oldest_event.hourlyStartDate is not null and lastEventTimestamp > 30*60*1000+hourEndTimestamp(oldest_event.hourlyStartDate))).std:lastevent() as Notification on SmartEvent.entityName = Notification.entityName and SmartEvent.entityType = Notification.entityType
fortscale.esper.rule.auto-create._2_3_SmartEventWithSensitiveAccount=true
fortscale.esper.rule.subscriberBean._2_3_SmartEventWithSensitiveAccount=smartAlertCreationSubscriber


#Suspicious activity Alert EPL (according to Joker Evidence and the non existent of tagging)
#set the severity according to score: 50/70/85/95 - Low/ Medium/ High/ Critical respectively
fortscale.esper.rule.name._2_4_SmartEventWithNormalAccount=Suspicious Activity For User Account
fortscale.esper.rule.statement._2_4_SmartEventWithhNormalAccount= select 'Suspicious Activity For User Account' as title , case when  ((Notification.entityName is null and SmartEvent.score >= 50 and  SmartEvent.score < 70) or (Notification.entityName is not null and SmartEvent.score >= 50 and  SmartEvent.score < 60)) then 'Low'  when  ((Notification.entityName is null and SmartEvent.score >= 70 and  SmartEvent.score < 80) or (Notification.entityName is not null and SmartEvent.score >= 60 and  SmartEvent.score < 70)) then 'Medium'  when  ((Notification.entityName is null and SmartEvent.score >= 80 and  SmartEvent.score < 95) or (Notification.entityName is not null and SmartEvent.score >= 70 and  SmartEvent.score < 85)) then 'High'  when  ((Notification.entityName is null and SmartEvent.score >= 95) or (Notification.entityName is not null and SmartEvent.score >= 85)) then 'Critical' end as severity , SmartEvent.entityType as entityType, SmartEvent.entityName as entityName, aggregated_feature_events, start_time_unix, end_time_unix, SmartEvent.score * 1.0 as score from EnrichedEntityEvent(score >= 50).std:groupwin(entityType,entityName).std:lastevent() as SmartEvent  left outer join  EntityTags('admin' = any(Tags.tags) or 'executive' = any(Tags.tags) or 'service' = any(Tags.tags) ).std:groupwin(entityType,entityName).std:lastevent() as Tags on Tags.entityName = SmartEvent.entityName   left outer join EnrichedEvidence(evidenceType = EvidenceType.Notification).win:expr_batch(oldest_timestamp+(60*60*1000+30*60*1000) < currentTimestamp or (oldest_event.hourlyStartDate is not null and lastEventTimestamp > 30*60*1000+hourEndTimestamp(oldest_event.hourlyStartDate))).std:lastevent() as Notification on SmartEvent.entityName = Notification.entityName and SmartEvent.entityType = Notification.entityType where Tags.tags is null
fortscale.esper.rule.auto-create._2_4_SmartEventWithhNormalAccount=true
fortscale.esper.rule.subscriberBean._2_4_SmartEventWithhNormalAccount=smartAlertCreationSubscriber





# Key-value storage for user-tag-cache
stores.entity-tags-cache.factory=org.apache.samza.storage.kv.KeyValueStorageEngineFactory
stores.entity-tags-cache.changelog=kafka.entity-tags-cache-changelog
stores.entity-tags-cache.key.serde=string
stores.entity-tags-cache.msg.serde=entitytags
stores.entity-tags-cache.write.batch.size=25
stores.entity-tags-cache.object.cache.size=200000
stores.entity-tags-cache.container.cache.size.bytes=52428800
stores.entity-tags-cache.container.write.buffer.size.bytes=102400
