(function () {
    'use strict';
    angular.module("Page", []).factory("page", function () {
        return {
            setPageTitle: function (title) {
                document.title = "Fortscale - " + title;
            }
        };
    });
})();

(function () {
    "use strict";
    var config = {
        dateFormat: "MMM DD, YYYY",
        hourFormat: "HH:mm:ss",
        timestampFormat: "MMM DD YYYY, HH:mm:ss",
        fallbackFormat: "MM/DD/YYYY HH:mm:ss",
        timezone: localStorage.timezone ? parseInt(localStorage.timezone, 10) : (new Date()).getTimezoneOffset() / -60,
        alwaysUtc: true,
        //used to determine threshold for notifying potentially large queries
        scoreThreshold: 50,
        daysThreshold: 30,
        popupLargeQueryMsg: "Please notice that this change might cause the query to take longer than usual. " +
            "To send the query, please select 'YES' otherwise select 'NO'"
    };
    config.popupScoreMessage = "You have chosen to filter the results by a Minimum Score smaller than <b>" +
        config.scoreThreshold + "</b>. " + config.popupLargeQueryMsg;
    config.popupDaysMessage = "You have chosen to filter the results by a Time Range greater than <b>" +
        config.daysThreshold + "</b> days. " + config.popupLargeQueryMsg;
    angular.module("Config", [])
        .constant("config", config)
        .constant("configFlags", {
        qa: !!localStorage.qa,
        verbose: !!localStorage.verbose,
        mockData: !!localStorage.allowMockData
    });
}());

(function () {
    'use strict';
    var writeLastLoginTimeoutId = null;
    /**
     * Writes the last successfull rest api time to localStorage
     */
    function writeLastLoginTime() {
        localStorage.setItem('last-login-time', new Date().valueOf() - 2000);
    }
    /**
     * Creates a 2 s throttle before writing to localStorage
     */
    function setLastLoginTimeout() {
        clearTimeout(writeLastLoginTimeoutId);
        writeLastLoginTimeoutId = setTimeout(writeLastLoginTime, 2000);
    }
    angular.module('Config')
        .factory('httpAuthorizationErrorInterceptor', [
        '$q',
        '$rootScope',
        'BASE_URL',
        function ($q, $rootScope, BASE_URL) {
            return {
                response: function (response) {
                    // If a successfull attempt was made to the server api, the last login
                    // time is updated
                    var rgx = new RegExp('^' + BASE_URL);
                    if (rgx.test(response.config.url)) {
                        setLastLoginTimeout();
                    }
                    return response;
                },
                responseError: function (rejection) {
                    if (rejection.status === 401 && rejection.statusText === 'Unauthorized') {
                        // Get a session login. If it was not found, go to login without
                        // the modal.
                        var sessionLogin = sessionStorage.getItem('session-login');
                        if (!sessionLogin) {
                            var href = 'signin.html?redirect=' +
                                encodeURIComponent(document.location.hash);
                            window.location.href = href;
                        }
                        else {
                            sessionStorage.removeItem('session-login');
                            localStorage.removeItem('last-login-time');
                            $rootScope.modal = {
                                show: true,
                                src: rejection.status === 403 ?
                                    "views/modals/password_expired.html" :
                                    "views/modals/session_expired.html"
                            };
                        }
                    }
                    return $q.reject(rejection);
                }
            };
        }])
        .config(['$httpProvider', function ($httpProvider) {
            $httpProvider.interceptors.push('httpAuthorizationErrorInterceptor');
        }]);
}());

(function () {
    'use strict';
    angular.module("Popup", []).directive("popup", [function () {
            return {
                templateUrl: 'scripts/directives/popup/popup.template.html',
                restrict: 'E',
                scope: true,
                replace: true,
                link: function postLink(scope, element, attrs) {
                    var lastSrc;
                    scope.$watch(attrs.popupConfig, function (popup) {
                        if (!popup) {
                            return;
                        }
                        scope.params = popup.params || {};
                        scope.width = popup.width || 500;
                        scope.height = popup.height || 400;
                        scope.popupTitle = popup.title;
                        scope.position = popup.position;
                        scope.show = popup.show;
                        if (popup.src && lastSrc !== popup.src) {
                            scope.popupSrc = popup.src;
                            lastSrc = popup.src;
                        }
                        if (popup.scope) {
                            for (var scopeParam in popup.scope) {
                                if (popup.scope.hasOwnProperty(scopeParam)) {
                                    scope[scopeParam] = popup.scope[scopeParam];
                                }
                            }
                        }
                        setStyle();
                    });
                    scope.close = function () {
                        if (scope.popup) {
                            scope.show = scope.popup.show = false;
                        }
                    };
                    element.on("click", "a[href]", function () {
                        scope.close();
                        return true;
                    });
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                    scope.$on("closePopups", scope.close);
                    function setStyle() {
                        if (scope.position) {
                            var top = scope.position.top, left = scope.position.left;
                            if (top + scope.height + 30 > document.body.clientHeight) {
                                top = scope.position.top - scope.height;
                                if (top < document.body.scrollTop) {
                                    top = document.body.clientHeight - scope.height - 30;
                                }
                            }
                            if (left + scope.width + 30 > document.body.clientWidth) {
                                left = scope.position.left - scope.width;
                                if (left < document.body.scrollLeft) {
                                    left = document.body.clientWidth - scope.width - 30;
                                }
                            }
                            scope.popupStyle = {
                                width: scope.width,
                                height: scope.height,
                                left: left,
                                top: top
                            };
                        }
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Dropdown", []).directive("dropdown", ["$timeout", function ($timeout) {
            function dropdownLink(scope, element) {
                function open() {
                    dropdownEl.classList.add("dropdown-open");
                    setTimeout(setMenuPositionAndShow);
                    document.body.addEventListener("mousedown", onMouseDown);
                }
                function close(e) {
                    if (e && (e.target.classList.contains("dropdown-list-toggle-label") ||
                        e.target.classList.contains("dropdown-directive-menu"))) {
                        return true;
                    }
                    dropdownEl.classList.remove("dropdown-visible");
                    $timeout(function () {
                        dropdownEl.classList.remove("dropdown-open");
                        menuEl.style.removeProperty("height");
                        menuEl.style.removeProperty("width");
                    });
                    document.body.removeEventListener("mousedown", onMouseDown);
                }
                function toggle() {
                    if (scope.isOpen) {
                        close();
                    }
                    else {
                        open();
                    }
                }
                function onMouseDown(e) {
                    var el = e.target;
                    if (el.classList.contains("dropdown-list-toggle-label")) {
                        return true;
                    }
                    do {
                        if (el === document.documentElement) {
                            return close();
                        }
                        if (el === menuEl) {
                            return true;
                        }
                    } while (!!(el = el.parentNode));
                }
                function setMenuPositionAndShow() {
                    var buttonRect = buttonEl.getBoundingClientRect();
                    menuEl.style.top = buttonRect.top + "px";
                    menuEl.style.left = buttonRect.left + "px";
                    var documentWidth = document.documentElement.clientWidth, documentHeight = document.documentElement.clientHeight, menuClientRect = menuEl.getBoundingClientRect(), maxWidth = documentWidth - MARGIN * 2, maxHeight = documentHeight - MARGIN * 2;
                    var recalculateRect, dontSetLeft, dontSetTop;
                    if (menuClientRect.width > maxWidth) {
                        menuEl.style.width = maxWidth + "px";
                        menuEl.style.left = MARGIN + "px";
                        recalculateRect = true;
                        dontSetLeft = true;
                    }
                    if (menuClientRect.height > maxHeight) {
                        menuEl.style.height = maxHeight + "px";
                        menuEl.style.top = MARGIN + "px";
                        recalculateRect = true;
                        dontSetTop = true;
                    }
                    if (!dontSetLeft || !dontSetTop) {
                        if (recalculateRect) {
                            menuClientRect = menuEl.getBoundingClientRect();
                        }
                        if (!dontSetLeft) {
                            var farthestPosition = documentWidth - MARGIN;
                            if (menuClientRect.right > farthestPosition && menuClientRect.width < maxWidth) {
                                var leftDelta = menuClientRect.right - farthestPosition;
                                menuEl.style.left = (buttonRect.left - leftDelta) + "px";
                            }
                        }
                        if (!dontSetTop) {
                            var lowestPosition = documentHeight - MARGIN;
                            if (menuClientRect.bottom > lowestPosition && menuClientRect.height < maxHeight) {
                                var bottomDelta = menuClientRect.bottom - lowestPosition;
                                menuEl.style.top = (buttonRect.top - bottomDelta) + "px";
                            }
                        }
                    }
                    dropdownEl.classList.add("dropdown-visible");
                }
                var dropdownEl = element[0], menuEl = dropdownEl.querySelector(".dropdown-directive-menu"), buttonEl = dropdownEl.querySelector("button");
                var MARGIN = 20;
                scope.toggle = toggle;
                menuEl.addEventListener("mouseup", close);
            }
            return {
                replace: true,
                restrict: "E",
                transclude: true,
                scope: {
                    buttonText: "@",
                    buttonClass: "@",
                    closeOnClick: "=",
                    disabled: "="
                },
                template: '<div class="dropdown-directive"><button ng-click="toggle()" class="{{buttonClass}}" ' +
                    'ng-disabled="disabled">{{buttonText}}</button>' +
                    '<div class="dropdown-directive-menu" ng-transclude></div></div>',
                link: dropdownLink
            };
        }]);
})();

(function () {
    'use strict';
    var prefix = "cache_";
    var CACHE_DISABLED = !!localStorage.__disableCache;
    function Cache($rootScope, options) {
        if (!options || !options.id) {
            throw new Error("Can't instantiate Cache - no id specified.");
        }
        this.$rootScope = $rootScope;
        this.options = options || {};
        this.data = {};
        if (this.__defineGetter__) {
            this.__defineGetter__("id", function () {
                return options.id;
            });
        }
        else {
            this.id = options.id;
        }
    }
    Cache.clearAll = function () {
        var cachePrefixRegExp = new RegExp("^" + prefix);
        for (var key in localStorage) {
            if (cachePrefixRegExp.test(key)) {
                localStorage.removeItem(key);
            }
        }
    };
    Cache.prototype = {
        getKey: function (keyName) {
            return [prefix, this.id, keyName].join("_");
        },
        getItem: function (keyName, options) {
            if (CACHE_DISABLED) {
                return null;
            }
            var dataStr = localStorage.getItem(this.getKey(keyName));
            if (!dataStr) {
                return null;
            }
            var dataObj = JSON.parse(dataStr);
            if (dataObj && dataObj.expires && dataObj.expires < new Date().valueOf()) {
                this.removeItem(keyName);
                return null;
            }
            var data = dataObj && dataObj.data;
            if (options && options.hold) {
                this.data[keyName] = data;
            }
            return data;
        },
        removeItem: function (keyName) {
            if (CACHE_DISABLED) {
                return null;
            }
            localStorage.removeItem(this.getKey(keyName));
            if (this.data[keyName]) {
                delete this.data[keyName];
            }
        },
        setItem: function (keyName, data, options) {
            if (CACHE_DISABLED) {
                return null;
            }
            options = options || {};
            if (!options.expires && !options.expiresIn) {
                options.expiresIn = this.options.itemsExpireIn;
            }
            var storageData = { data: data };
            if (options.expires) {
                storageData.expires = options.expires;
            }
            else if (options.expiresIn) {
                storageData.expires = new Date().valueOf() + options.expiresIn * 1000;
            }
            localStorage.setItem(this.getKey(keyName), JSON.stringify(storageData));
            if (options.hold) {
                this.data[keyName] = data;
            }
        }
    };
    angular.module("Cache", []).factory('Cache', function ($injector) {
        var constructor = function (options) { return $injector.instantiate(Cache, { options: options }); };
        constructor.clearAll = Cache.clearAll;
        return constructor;
    });
})();

(function () {
    'use strict';
    angular.module("EventBus", [])
        .factory("EventBus", ["$rootScope", function ($rootScope) {
            function EventBus() {
                var eventHandlers = {};
                this.subscribe = function (eventName, eventHandler) {
                    var event = eventHandlers[eventName];
                    if (!event) {
                        event = eventHandlers[eventName] = [];
                    }
                    if (!~event.indexOf(eventHandler)) {
                        event.push(eventHandler);
                    }
                };
                this.unsubscribe = function (eventName, eventHandler) {
                    var event = eventHandlers[eventName];
                    if (event) {
                        for (var i = event.length - 1; i >= 0; i--) {
                            if (event[i] === eventHandler) {
                                event.splice(i, 1);
                            }
                        }
                    }
                };
                this.triggerEvent = function (eventName, data) {
                    if (!eventName) {
                        throw new Error("No event name specified to trigger.");
                    }
                    if (typeof (eventName) !== "string") {
                        throw new TypeError("Invalid eventName to trigger, expected a string but got " +
                            eventName.constructor.name + ".");
                    }
                    var event = eventHandlers[eventName];
                    if (event) {
                        event.forEach(function (eventHandler) {
                            eventHandler({ eventName: eventName }, data);
                        });
                    }
                };
            }
            /**
             * Creates objects for subscribing/unsubscribing to events in an object.
             * e.g, called like this: EventBus.setToObject({}, ["addChild"]) the object will look like this:
             * { onAddChild: { subscribe: function(eventHandler), ubsubscribe: function(eventHandler) }
             * @param obj
             * @param events
             * @returns The created eventBus, so the object can trigger it internally.
             */
            EventBus.setToObject = function (obj, events) {
                var eventBus = new EventBus();
                events.forEach(function (event) {
                    obj[getEventName(event)] = {
                        subscribe: function (eventHandler) {
                            eventBus.subscribe(event, eventHandler);
                        },
                        unsubscribe: function (eventHandler) {
                            eventBus.unsubscribe(event, eventHandler);
                        }
                    };
                });
                return eventBus;
            };
            function getEventName(eventName) {
                return "on" + eventName.replace(/\b\w/g, function (a) {
                    return a.toUpperCase();
                });
            }
            return EventBus;
        }]);
}());

(function () {
    'use strict';
    /**
     * Manages app-wide events for operations that can't be done by function calls
     * @param EventBus
     * @returns {{triggerDashboardEvent: triggerDashboardEvent}}
     */
    function events(EventBus) {
        function triggerDashboardEvent(event, data, params) {
            var eventObj = {};
            if (event.constructor === Array) {
                eventObj.events = event;
            }
            else {
                eventObj.event = event;
            }
            if (data) {
                eventObj.data = data;
            }
            if (params) {
                eventObj.params = params;
            }
            eventsEventBus.triggerEvent("dashboardEvent", eventObj);
        }
        var api = {
            triggerDashboardEvent: triggerDashboardEvent
        };
        var eventsEventBus = EventBus.setToObject(api, ["dashboardEvent"]);
        return api;
    }
    events.$inject = ["EventBus"];
    angular.module("Events", ["EventBus"])
        .factory("events", events);
})();

(function () {
    'use strict';
    angular.module("Utils", ["Config"])
        .factory("utils", ["$http", "config",
        function ($http, config) {
            var ipAddressRegExp = /^(\d{1,3}\.){3}\d{1,3}$/, // Not exactly accurate, but good enough for now
            hashRegExp = /#.*$/, parsedStringTest = /\{\{/;
            var stringParsers = {};
            var parseStringFormatters = {
                /**
                 *
                 * @param {*} value
                 * @returns {*}
                 * @description
                 * Takes a value argument.
                 * If value is number, the method tries to convert it to absolute number.
                 * If value is anything but a number, the value is returned.
                 */
                abs: function (value) {
                    return angular.isNumber(value) ? Math.abs(value) : value;
                },
                allowNull: function (value) {
                    return value === undefined || value === null || value === "" ? null : value;
                },
                bytesCount: function (value) {
                    return methods.numbers.bytesCount(value);
                },
                defaultIfEmpty: function (value, defaultValue) {
                    return typeof value !== "undefined" ? value : defaultValue;
                },
                bytesPerSecCount: function (value) {
                    value = methods.numbers.bytesCount(value);
                    if (!value) {
                        return value;
                    }
                    return value + "/sec";
                },
                capitalize: function (value) {
                    return methods.strings.capitalize(value);
                },
                cast: function (value, type) {
                    if (type === "number") {
                        return parseFloat(value);
                    }
                    if (type === "boolean") {
                        return !!value;
                    }
                    return value.toString();
                },
                closeDate: function (value) {
                    var momentValue = methods.date.getMoment(value);
                    if (momentValue.isValid()) {
                        return momentValue.fromNow();
                    }
                    return value;
                },
                count: function (value) {
                    return value.length;
                },
                /**
                 * Get date string from date
                 *
                 * @param  {number|Object} value           Date time value or Moment instance
                 * @param  {string}        format          Set format
                 *     "unixtimestamp" - Unix time value
                 *     "valueOf"       - Regular time value
                 *     "MM/DD/YYYY"    - Custom pattern (any valid Moment pattern)
                 *
                 * @param  {string}        add             Custom `add` (can be negative)
                 *     (e.g. "4hours", "-1month")
                 *     See: http://momentjs.com/docs/#/manipulating/add/
                 *
                 * @param  {string}        startOrEndOfDay Set time to start/end of day
                 *     "start" - Set time to start of day
                 *     "end"   - Set time to end of day
                 *
                 * @return {string}                        Resulting date string or ""
                 */
                date: function (value, format, add, startOrEndOfDay) {
                    if (!value) {
                        return "";
                    }
                    // Build date object
                    // If already a moment object, returns as is
                    var momentValue = methods.date.getMoment(value);
                    if (momentValue.isValid()) {
                        if (startOrEndOfDay === "start") {
                            momentValue.startOf("day");
                        }
                        else if (startOrEndOfDay === "end") {
                            momentValue.endOf("day");
                        }
                        if (add) {
                            // Custom `add` (e.g. "4hours" or "-1month")
                            momentValue = methods.date.shiftDate(momentValue, add);
                        }
                        if (format) {
                            // Predefined setups
                            if (format === "unixtimestamp") {
                                return Math.floor(momentValue.valueOf() / 1000);
                            }
                            if (format === "valueOf") {
                                return momentValue.valueOf();
                            }
                            // If part of config default patterns, use it, otherwise use as is
                            return momentValue.format(config[format] || format);
                        }
                        else {
                            // Format using default patterns
                            return momentValue.format(config.timestampFormat || config.fallbackFormat);
                        }
                    }
                    return "";
                },
                dayDiff: function (value1, value2) {
                    var m1 = methods.date.getMoment(value1), m2 = methods.date.getMoment(value2);
                    if (!m1.isValid() || !m2.isValid()) {
                        console.error("Can't get dayDiff, values: ", value1, value2);
                        return "?";
                    }
                    return methods.date.diff(m1.toDate(), m2.toDate(), "days");
                },
                dateDiffFromNow: function (value, valueUnit, returnFormat, startOrEndOfDay) {
                    valueUnit = valueUnit || "days";
                    returnFormat = returnFormat || "unixtimestamp";
                    switch (valueUnit) {
                        case "days":
                            value *= 24 * 60 * 60 * 1000;
                            break;
                        case "hours":
                            value *= 60 * 60 * 1000;
                            break;
                        case "minutes":
                            value *= 60 * 1000;
                            break;
                        case "seconds":
                            value *= 1000;
                            break;
                    }
                    // we reduce the time in miliseconds
                    var momentValue = methods.date.getMoment(new Date().getTime() - value);
                    if (startOrEndOfDay) {
                        if (startOrEndOfDay === "start") {
                            momentValue.startOf("day");
                        }
                        else if (startOrEndOfDay === "end") {
                            momentValue.endOf("day");
                        }
                    }
                    if (returnFormat === "unixtimestamp") {
                        return Math.floor(momentValue.valueOf() / 1000);
                    }
                    if (returnFormat === "valueOf") {
                        return momentValue.valueOf();
                    }
                    return momentValue.format(returnFormat); // for example "MM/DD/YYYY HH:mm"
                },
                dateSql: function (value, column) {
                    return "to_date(" + parseStringFormatters.dateToUtc(column || 'date_time') + ")";
                },
                dateToUtc: function (value, columnName) {
                    return "hours_add(" + (value || columnName || 'date_time') + ", " + config.timezone + ")";
                },
                /**
                 *
                 * @param {*} value
                 * @returns {*}
                 * @description
                 * Takes a value. Validates that the value is a number.
                 * Returns the value if not a number.
                 * Returns (n*100).toFixes(2) if is number.
                 */
                decimalToPercentage: function (value) {
                    if (angular.isNumber(value)) {
                        return (value * 100).toFixed(2);
                    }
                    return value;
                },
                /**
                 * Given a number, which represents a time span, returns the number formatted with prettyDate
                 */
                diffToPrettyDate: function (value, units) {
                    var seconds = methods.date.toSeconds(value, units);
                    if (!seconds && seconds !== 0) {
                        return seconds;
                    }
                    return methods.date.prettyDate(seconds, true);
                },
                /**
                 * Given a number, which represents a time span, returns the number formatted with prettyTime
                 */
                diffToPrettyTime: function (value, units) {
                    return methods.duration.prettyTime(value, units);
                },
                /**
                 * Given a prettyTime format, return the number according to the units
                 */
                durationToNumber: function (value, units) {
                    return methods.duration.durationToNumber(value, units);
                },
                divide: function (value, divideBy, mathFunc) {
                    value = Number(value);
                    divideBy = Number(divideBy);
                    if (isNaN(value) || isNaN(divideBy)) {
                        return value;
                    }
                    if (!angular.isNumber(value) || !angular.isNumber(Number(divideBy))) {
                        return value;
                    }
                    var result = value / divideBy;
                    if (mathFunc) {
                        return Math[mathFunc](result);
                    }
                    return result;
                },
                encodeURIComponent: function (value) {
                    return encodeURIComponent(value);
                },
                /**
                 *
                 * @param {number} score
                 * @param {string} tableName
                 * @returns {string}
                 * @description
                 * Given a table name and a minimum event score, returns the optimized table's name,
                 * if it exists and the score fits.
                 **/
                eventsTable: function (score, tableName) {
                    return methods.strings.getEventsTableName(tableName, score);
                },
                eventUserSql: function () {
                    return "users.displayname, users.id as userid, users.isuseradministrator, " +
                        "users.isuserexecutive, users.accountisdisabled, users.isuseraccountservice, " +
                        "users.followed";
                },
                groupName: function (value) {
                    var groupMatch = value.match(/^CN=([^\,]+)/);
                    if (groupMatch) {
                        return groupMatch[1];
                    }
                    return value;
                },
                //This function return a string that replace the separator with the splitter,
                //e.g: (shavit,yossi):join:$:, will be ---> shavit$yossi
                "join": function (value, separator, splitter) {
                    if (typeof (value) === "string") {
                        value = value.split(splitter || ",");
                    }
                    return (value) ? value.join(separator || ",") : null;
                },
                max: function (value, secondValue) {
                    var int1 = parseInt(value), int2 = parseInt(secondValue), max = Math.max(int1, int2);
                    return isNaN(max) ? "?" : max;
                },
                min: function (value, secondValue) {
                    var int1 = parseInt(value), int2 = parseInt(secondValue), min = Math.min(int1, int2);
                    return isNaN(min) ? "?" : min;
                },
                multiply: function (value, multiplyBy) {
                    if (!angular.isNumber(value) || !angular.isNumber(Number(multiplyBy))) {
                        return value;
                    }
                    return value * multiplyBy;
                },
                not: function (value) {
                    return !value;
                },
                number: function (value) {
                    var match = value.match(/\d+/);
                    if (match) {
                        return match[0];
                    }
                    return value;
                },
                "or": function (value1, value2) {
                    return !value1 && value1 !== 0 ? value2 : value1;
                },
                //squiz cahrs to the left side of a value to make it be with the proper chars
                //e.g: "shavit":10:- will be "----shavit"
                padLeft: function (value, length, character) {
                    return methods.strings.padLeft(value, length, character);
                },
                /*
                 * parse strings into URL params format (e.g replace "," with "%2C")
                 */
                paramValue: function (value) {
                    return encodeURIComponent(value);
                },
                removeEmptyValue: function (value) {
                    if (value === undefined || value === null) {
                        return "";
                    }
                    return value;
                },
                removeAtDomain: function (value) {
                    if (!value) {
                        return "";
                    }
                    var match = value.match(/^(.+)@/);
                    return match ? (match[1] !== "" ? match[1] : value) : value;
                },
                removeDotDomain: function (value) {
                    if (methods.strings.isIpAddress(String(value))) {
                        return value;
                    }
                    if (!value) {
                        return "";
                    }
                    var match = value.match(/^([^\.]+)\./);
                    return match ? match[1] : value;
                },
                round: function (value) {
                    if (!angular.isNumber(value)) {
                        return value;
                    }
                    return Math.round(value);
                },
                secondsToHour: function (value, hourOnly) {
                    if (hourOnly) {
                        return Math.round(value / 3600);
                    }
                    return [
                        methods.strings.padLeft(Math.floor(value / 3600), 2, "0"),
                        methods.strings.padLeft(Math.floor(value % 3600 / 60), 2, "0"),
                        methods.strings.padLeft(value % 60, 2, "0")
                    ].join(":");
                },
                sinceNow: function (value, format, add, startOrEndOfDay) {
                    return parseStringFormatters.date.call(this, "now", format, add, startOrEndOfDay);
                },
                span: function (value1, value2Field, divider) {
                    var span = Math.abs(this.data[value2Field] - value1);
                    if (!isNaN(span) && divider) {
                        return Math.floor(span / divider);
                    }
                    return span;
                },
                "switch": function (value, ifTrue, ifFalse) {
                    return value ? ifTrue : ifFalse;
                },
                paging: function (page, pagingParamName, pageSize) {
                    page = page || 1;
                    if (typeof (page) === "string") {
                        page = parseInt(page);
                    }
                    var paging = this.params[pagingParamName], offset = (page - 1) * pageSize;
                    pageSize = parseInt(pageSize, 10);
                    if (!paging || !pageSize || isNaN(offset) || isNaN(pageSize) || !paging.total ||
                        !paging.currentPageCount) {
                        return null;
                    }
                    return (offset + 1) + " - " + (offset + paging.currentPageCount) + " of " + paging.total;
                },
                pluralOrSingular: function (value, singular, plural) {
                    if (!value || !angular.isNumber(value)) {
                        return plural;
                    }
                    if (value === 1) {
                        return singular;
                    }
                    return plural;
                },
                properties: function (value) {
                    var str = [];
                    for (var p in value) {
                        if (value.hasOwnProperty(p)) {
                            str.push(p + ": " + value[p]);
                        }
                    }
                    return str.join(", ");
                },
                timeSpan: function (value1, value2Field) {
                    if (!value1 || value2Field && !this.data[value2Field]) {
                        return null;
                    }
                    var value2 = value2Field ? this.data[value2Field] : 'now';
                    var moment1 = methods.date.getMoment(value1);
                    var moment2 = methods.date.getMoment(value2);
                    if (!moment1.isValid() || !moment2.isValid()) {
                        return "?";
                    }
                    var diff = Math.abs(moment1.diff(moment2));
                    return diff < 1000 && (diff / 1000).toFixed(2) + " seconds" ||
                        (diff = diff / 1000) < 60 && diff.toFixed(2) + " seconds" ||
                        (diff = diff / 60) < 60 && Math.floor(diff) + ":" +
                            methods.strings.padLeft(String(Math.floor(60 * (diff % 1))), 2, "0") + " minutes" ||
                        (diff = diff / 60) < 24 && Math.floor(diff) + ":" +
                            methods.strings.padLeft(String(Math.floor(60 * (diff % 1))), 2, "0") + " hours" ||
                        Math.floor(diff / 24) + " days";
                },
                timeZone: function (value) {
                    return new Date().getTimezoneOffset() * -1;
                },
                toLowerCase: function (value) {
                    if (!value || !angular.isString(value)) {
                        return value;
                    }
                    return value.toLowerCase();
                },
                toUpperCase: function (value) {
                    if (!value || !angular.isString(value)) {
                        return value;
                    }
                    return value.toUpperCase();
                },
                unixTimeToDate: function (value) {
                    return methods.date.getMoment(Number(value) * 1000).toDate();
                },
                matches: function (value, pattern, matchValue, noMatchValue) {
                    var patternRegexp = methods.regexp.patterns[pattern] || new RegExp(pattern);
                    if (!patternRegexp || !patternRegexp.test(value)) {
                        return noMatchValue;
                    }
                    return matchValue;
                },
                toFixed: function (value, decimals) {
                    if (!value) {
                        return value;
                    }
                    return parseFloat(value.toFixed(decimals));
                },
                yesNo: function (value) {
                    return value ? "Yes" : "No";
                }
            };
            function getParamValueForParser(value) {
                if (!value || typeof (value) !== "string") {
                    return value;
                }
                var paramMatch = value.match(/^@(.+)/);
                if (paramMatch) {
                    // This line is bad. There is no way to know what will be the 'this'
                    // However, fixing it is a problem because the original intention is not known.
                    // So adding validthis is the best ot the worst options :(
                    /*jshint validthis: true */
                    return this.params[paramMatch[1]];
                }
                return value;
            }
            function getValueVariable(val) {
                var objName, path;
                if (/^@/.test(val)) {
                    objName = "params";
                    path = val.match(/^@(.*)/)[1];
                }
                else {
                    objName = "data";
                    path = val;
                }
                var pathProperties = path.split("."), propertyName = pathProperties[0], finalVariable = [objName + (~propertyName.indexOf("**dot**") ? "['" + propertyName + "']" :
                        "." + propertyName)];
                if (pathProperties.length > 1) {
                    for (var i = 1; i < pathProperties.length; i++) {
                        propertyName = pathProperties[i];
                        finalVariable.push(finalVariable[finalVariable.length - 1] +
                            (~propertyName.indexOf("**dot**") ? "['" + propertyName + "']" : "." + propertyName));
                    }
                }
                return finalVariable.join(" && ").replace(/\*\*dot\*\*/g, ".");
            }
            function getParamsAndFormatting(param) {
                var paramWithFormatting = param.replace(/\\:/g, "*__*"), params;
                paramWithFormatting = paramWithFormatting.split(":");
                var value = paramWithFormatting[0];
                value = value.replace(/\\\./g, "**dot**");
                params = value.split(/\s?\|\|\s?/);
                for (var i = params.length - 1; i >= 0; i--) {
                    param = params[i];
                    if (!param) {
                        params.splice(i, 1);
                    }
                    else {
                        params[i] = getValueVariable(param);
                    }
                }
                if (paramWithFormatting.length === 1) {
                    return { params: params };
                }
                var methodParams = paramWithFormatting.slice(2);
                angular.forEach(methodParams, function (paramValue, i) {
                    methodParams[i] = '"' + paramValue.replace(/\*__\*/g, ":") + '"';
                });
                return {
                    params: params,
                    method: paramWithFormatting[1],
                    parameters: methodParams
                };
            }
            var methods = {
                // Exposing parsing methods for unit testing
                // This is private, do not call it from other files!
                _parseStringFormatters: parseStringFormatters,
                arrays: {
                    areEqual: function (arr1, arr2) {
                        if (!arr1 || !arr2) {
                            throw new Error("Missing values to compare arrays.");
                        }
                        if (!angular.isArray(arr1) || !angular.isArray(arr2)) {
                            throw new Error("areEqual received non-array parameter(s).");
                        }
                        if (arr1.length !== arr2.length) {
                            return false;
                        }
                        for (var i = 0; i < arr1.length; i++) {
                            if (!methods.objects.areEqual(arr1[i], arr2[i])) {
                                return false;
                            }
                        }
                        return true;
                    },
                    /**
                     *
                     * @param {Array} arr1
                     * @param {Array} arr2
                     * @returns {boolean}
                     * @description
                     * Verifies that all members in second array exist in first array
                     */
                    doesNotContain: function (arr1, arr2) {
                        var _errMsg = 'utils.arrays.doesNotContain: ';
                        // Validations
                        if (!angular.isArray(arr1)) {
                            throw new TypeError(_errMsg + 'first argument must be an array.');
                        }
                        if (!angular.isArray(arr2)) {
                            throw new TypeError(_errMsg + 'second argument must be an array.');
                        }
                        // Iterate through second array and find the indexOf for each member.
                        // If any of the members return indexof of 0 and up the method will return false,
                        // otherwise the method will return true.
                        for (var i = 0; i < arr2.length; i++) {
                            if (!!~arr1.indexOf(arr2[i])) {
                                return false;
                            }
                        }
                        return true;
                    },
                    /**
                     *
                     * @param {Array} arr
                     * @param findFunction
                     * @returns {*}
                     * @description
                     * Takes an array and a function.
                     * Iterates through the array.
                     * The find function is invoked for each member of the array with the member.
                     * If the fundFunction returns true, the method returns the member.
                     * If findFunction does not return true for any of the iterations, the method returns null.
                     */
                    find: function (arr, findFunction) {
                        // Validations
                        var _errMsg = 'utils.arrays.find: ';
                        if (!angular.isArray(arr)) {
                            throw new TypeError(_errMsg + 'arr argument must be an array.');
                        }
                        if (!angular.isFunction(findFunction)) {
                            throw new TypeError(_errMsg + 'findFunction argument must be a function.');
                        }
                        var member;
                        for (var i = 0; i < arr.length; i++) {
                            member = arr[i];
                            if (findFunction(member)) {
                                return member;
                            }
                        }
                        return null;
                    },
                    /**
                     * Given an array of objects, returns an array of unique values for the specified property.
                     * For example, for ([{ a: 2, b: 1}, { a: 3, b: 1}, { a: 2, b: 6 }], "a"), returns [2, 3]
                     * If the array is not of objects, the property is disregarded and an array of unique values
                     * is returned, for example:
                     * [1,2,4,2,4,6,1,2,1] returns [1,2,4,6]
                     * @param array An array of objects
                     * @param property The property to get unique values for
                     */
                    getUniqueValues: function (array, property) {
                        var index = {};
                        array.forEach(function (obj) {
                            var value;
                            if (obj) {
                                if (angular.isObject(obj)) {
                                    value = obj[property];
                                }
                                else {
                                    value = obj;
                                }
                                if (value !== undefined) {
                                    index[value] = true;
                                }
                            }
                        });
                        return Object.keys(index);
                    },
                    /**
                     * Replaces the array's member in the 'index' position with the specified newMembers.
                     * If multiple members are specified, the size of the array changes.
                     * @param arr The array in which to do the replacement
                     * @param index the position in the array that should be replaced
                     * @param newMembers The new members. Can be either a value, object or array. If array,
                     * the replacement puts all array members into the original array.
                     */
                    replace: function (arr, index, newMembers) {
                        if (newMembers.constructor !== Array) {
                            newMembers = [newMembers];
                        }
                        Array.prototype.splice.apply(arr, [index, 1].concat(newMembers));
                    },
                    shuffle: function (array) {
                        var currentIndex = array.length, temporaryValue, randomIndex;
                        // While there remain elements to shuffle...
                        while (0 !== currentIndex) {
                            // Pick a remaining element...
                            randomIndex = Math.floor(Math.random() * currentIndex);
                            currentIndex -= 1;
                            // And swap it with the current element.
                            temporaryValue = array[currentIndex];
                            array[currentIndex] = array[randomIndex];
                            array[randomIndex] = temporaryValue;
                        }
                        return array;
                    },
                    toSentence: function (array, connector, wrapper) {
                        var arrayCopy = angular.copy(array);
                        connector = connector || "and";
                        if (arrayCopy.length < 2) {
                            return arrayCopy.toString();
                        }
                        if (wrapper) {
                            arrayCopy.forEach(function (member, i) {
                                arrayCopy[i] = wrapper + member + wrapper;
                            });
                        }
                        return arrayCopy.slice(0, -1).join(", ") + " " + connector + " " +
                            arrayCopy[arrayCopy.length - 1];
                    }
                },
                date: {
                    /**
                     * Used to match "4hours" or "-1month"
                     */
                    re_shiftDate: /^(-?\d+)(\w+)$/,
                    /**
                     * Shift a date object forward or backwards
                     *
                     * @param  {Object} dateObj Moment date object
                     * @param  {string} shiftBy Shift string (can be negative)
                     *     (e.g. "4hours", "-1month")
                     *     See: http://momentjs.com/docs/#/manipulating/add/
                     *
                     * @return {Object}         Shifted date object
                     */
                    shiftDate: function (dateObj, shiftBy) {
                        var addMatch = shiftBy.match(this.re_shiftDate);
                        // Validations
                        if (!addMatch) {
                            throw new Error("Invalid shiftBy string: " + shiftBy);
                        }
                        if (!moment.isMoment(dateObj)) {
                            throw new Error("dateObj must be a moment instance: " + dateObj);
                        }
                        return dateObj.add(Number(addMatch[1]), addMatch[2]);
                    },
                    /**
                     * Is the value a timestamp string
                     *
                     * @param  {*}       value Timestamp value
                     * @return {Boolean}       Is it a timestamp in seconds or milliseconds
                     */
                    isTimeStamp: function (value) {
                        if (typeof value !== 'string' && typeof value !== 'number') {
                            throw new TypeError("Timestap value must be a String or a Number; Value: " + value);
                        }
                        return /^(\d{10}|\d{13})$/.test(value);
                    },
                    compareDates: function (date1, date2) {
                        return date1.getYear() === date2.getYear() && date1.getMonth() === date2.getMonth() &&
                            date1.getDate() === date2.getDate();
                    },
                    diff: function (date1, date2, units) {
                        if (date1 === "now") {
                            date1 = this.getMoment('now').toDate();
                        }
                        if (date2 === "now") {
                            date2 = this.getMoment('now').toDate();
                        }
                        var milliseconds = Math.abs(date2 - date1);
                        if (!units || units === "milliseconds") {
                            return milliseconds;
                        }
                        var seconds = milliseconds / 1000;
                        if (units === "minutes") {
                            return Math.round(seconds / 60);
                        }
                        if (units === "hours") {
                            return Math.round(seconds / 3600);
                        }
                        if (units === "days") {
                            return Math.round(seconds / (3600 * 24));
                        }
                        if (units === "weeks") {
                            return Math.round(seconds / (3600 * 24 * 7));
                        }
                        if (units === "months") {
                            return Math.round(seconds / (3600 * 24 * 30));
                        }
                        if (units === "years") {
                            return Math.round(seconds / (3600 * 24 * 365));
                        }
                    },
                    /**
                     * Get a Moment object
                     *
                     * @param  {number|string|Object} date Input date
                     * @param  {boolean=} utc         Flag to define usage of moment with UTC
                     *     Use `null` to force the default setting
                     * @param  {string=}  parseFormat Specific parsing format for the input
                     *     See: http://momentjs.com/docs/#/parsing/string-format/
                     *
                     * @return {Object}       Moment object
                     */
                    getMoment: function (date, utc, parseFormat) {
                        // Handle default UTC value from `config`
                        if (typeof utc === 'undefined' || utc === null) {
                            utc = config.alwaysUtc || false;
                        }
                        // Cache a reference to Moment depending on UTC flag
                        var _moment = utc ? moment.utc : moment;
                        if (!date) {
                            date = 'now';
                        }
                        if (typeof date === "number") {
                            // Sometimes the time value is returned in seconds and not milliseconds
                            if (String(date).length === 10) {
                                date = date * 1000;
                            }
                            return _moment(date);
                        }
                        if (typeof date === "string") {
                            // If date in format "+0d" or "-0h"
                            if (date === "now" || /^[\-\+]?0[smhd]$/.test(date)) {
                                return _moment();
                            }
                            // If a string of a number date value, reasses as a number
                            if (/^\d+$/.test(date)) {
                                return this.getMoment(Number(date));
                            }
                            // If date in format "YYYY-MM-DD"
                            if (/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                                var newDate = _moment(date, "YYYY-MM-DD");
                                if (newDate.isValid()) {
                                    return newDate;
                                }
                            }
                            // If date in format "4hours" or "-1month",
                            // return current time after shift
                            if (this.re_shiftDate.test(date)) {
                                return this.shiftDate(_moment(), date);
                            }
                        }
                        // If already a moment object, return it
                        if (moment.isMoment(date)) {
                            return date;
                        }
                        // If a specific parsing format has been given
                        if (parseFormat && _moment(date, parseFormat).isValid()) {
                            return _moment(date, parseFormat);
                        }
                        // If a JS date object, wrap it with moment
                        // Or if it's a valid date after creation, use that
                        if (angular.isDate(date) || _moment(date).isValid()) {
                            return _moment(date);
                        }
                        throw new Error("Invalid date: " + date);
                    },
                    getDatesSpan: function (start, end) {
                        var firstDate = this.getMoment(start), lastDate = this.getMoment(end);
                        if (!firstDate.isValid() || !lastDate.isValid()) {
                            return null;
                        }
                        var daysCount = Math.abs(firstDate.diff(lastDate, "days")), dates = [];
                        for (var i = 0; i < daysCount; i++) {
                            dates.push(firstDate.add(1, "days").clone().toDate());
                        }
                        return dates;
                    },
                    localToUtc: function (date) {
                        var moment = this.getMoment(date);
                        if (!moment.isValid()) {
                            throw new Error("Invalid date: " + date);
                        }
                        moment.subtract(config.timezone, "hours");
                        return moment.toDate();
                    },
                    // ES6 Getter
                    get timezone() {
                        return config.timezone;
                    },
                    toUnixTimestamp: function (date) {
                        var moment = this.getMoment(date);
                        return Math.floor(moment.valueOf() / 1000);
                    },
                    utcToLocal: function (date) {
                        var moment = this.getMoment(date);
                        if (!moment.isValid()) {
                            throw new Error("Invalid date: " + date);
                        }
                        moment.add(config.timezone, "hours");
                        return moment.toDate();
                    },
                    prettyDate: function (diffSeconds, isShort) {
                        var day_diff = Math.floor(diffSeconds / 86400);
                        var units = {
                            long: {
                                now: "< 1 minute",
                                second: "1 second",
                                seconds: " seconds",
                                minute: "1 minute",
                                minutes: " minutes",
                                hour: "1 hour",
                                hours: " hours",
                                yesterday: "1 day",
                                days: " days",
                                week: " week",
                                weeks: " weeks",
                                month: "1 month",
                                months: " months",
                                years: " years"
                            },
                            short: {
                                now: "< 1m",
                                second: "1s",
                                seconds: "s",
                                minute: "1m",
                                minutes: "m",
                                hour: "1h",
                                hours: "h",
                                yesterday: "1d",
                                days: "d",
                                weeks: "w",
                                month: "1M",
                                months: "M",
                                years: "y"
                            }
                        };
                        var unitsToUse = isShort ? units.short : units.long;
                        if (isNaN(day_diff) || day_diff < 0) {
                            return;
                        }
                        return (day_diff === 0 && (diffSeconds < 1 && unitsToUse.now ||
                            diffSeconds === 1 && unitsToUse.second ||
                            diffSeconds < 60 && diffSeconds + unitsToUse.seconds ||
                            diffSeconds < 120 && unitsToUse.minute ||
                            diffSeconds < 3600 && Math.floor(diffSeconds / 60) + unitsToUse.minutes ||
                            diffSeconds < 7200 && unitsToUse.hour ||
                            diffSeconds < 86400 && Math.floor(diffSeconds / 3600) + unitsToUse.hours) ||
                            day_diff === 1 && unitsToUse.yesterday ||
                            day_diff < 14 && day_diff + unitsToUse.days ||
                            day_diff < 31 && Math.ceil(day_diff / 7) + unitsToUse.weeks ||
                            day_diff < 62 && unitsToUse.month ||
                            day_diff < 365 && Math.floor(day_diff / 30.416) + unitsToUse.months ||
                            Math.floor(day_diff / 365) + unitsToUse.years);
                    },
                    toSeconds: function (value, units) {
                        switch (units) {
                            case "milliseconds":
                                return value / 1000;
                            case "seconds":
                                return value;
                            case "minutes":
                                return value * 60;
                            case "hours":
                                return value * 3600;
                            case "days":
                                return value * 3600 * 24;
                            default:
                                throw new Error("Unsupported unit, '" + units +
                                    "', expecting milliseconds, seconds, minutes, hours or days.");
                        }
                    }
                },
                http: {
                    wrappedHttpGet: function (url, config) {
                        return $http.get(url, config).then(function (response) {
                            return response.data;
                        });
                    },
                    wrappedHttpPost: function (url, config) {
                        return $http.post(url, config).then(function (response) {
                            return response.data;
                        });
                    }
                },
                numbers: {
                    parse: function (value) {
                        if (typeof (value) === "number") {
                            return value;
                        }
                        if (typeof (value) === "string") {
                            if (/^(\-|\+)?([0-9\.]+|Infinity)$/.test(value)) {
                                return value;
                            }
                        }
                        return NaN;
                    },
                    /**
                     *
                     * @param {*} value
                     * @returns {string}
                     * @description
                     * Takes a value argument.
                     * It tries to parse it to integer.
                     * If the parse fails, RangeError is thrown.
                     * If the parse is successful a string is returned by the following value:
                     * (n < 10^3) => n + ' B'
                     * else (n < 10^6) => (n/10^3).toFixed(2) + ' KB'
                     * else (n < 10^9) => (n/10^6).toFixed(2) + ' MB'
                     * else (n < 10^12) => (n/10^9).toFixed(2) + ' TB'
                     * Examples: bytesCount('999990') //returns '999.99 KB'
                     * Examples: bytesCount(1010000000000) //returns '999.99 GB'
                     */
                    bytesCount: function (value) {
                        if (!value) {
                            return value;
                        }
                        var count = parseInt(value, 10);
                        if (isNaN(count)) {
                            throw new RangeError('utils.numbers.bytesCount: parseInt(value, 10) returned NaN.');
                        }
                        return count < 1000 && count + " B" ||
                            (count = count / 1000) < 1000 && count.toFixed(2) + " KB" ||
                            (count = count / 1000) < 1000 && count.toFixed(2) + " MB" ||
                            (count = count / 1000) < 1000 && count.toFixed(2) + " GB" ||
                            (count = count / 1000) && count.toFixed(2) + " TB";
                    }
                },
                strings: {
                    /**
                     * Return the string with a capital letter
                     * @param str
                     * @returns {*}
                     */
                    capitalize: function (str) {
                        if (!str) {
                            return str;
                        }
                        if (!angular.isString(str)) {
                            throw new TypeError('utils.strings.capitalize: str is not a String');
                        }
                        return str.toLowerCase().replace(/\b\w/g, 
                        //For each first character of any word - do "char".upparcase
                        function (c) {
                            return c.toUpperCase();
                        });
                    },
                    /**
                     *
                     * @param {string|*} tableName
                     * @param {number=} minScore Optional
                     * @returns {string}
                     * @description
                     * Given a table name and a minimum event score, returns the optimized table's name,
                     * if it exists and the score fits.
                     */
                    getEventsTableName: function (tableName, minScore) {
                        // Validations
                        var _errMsg = 'utils.strings.getEventsTableName: ';
                        if (!tableName) {
                            throw new ReferenceError(_errMsg +
                                'tableName argument must not be falsy.');
                        }
                        // If tableName is not in this whiteList array, the tableName is returned as-is
                        if (["authenticationscores", "sshscores", "vpndatares", "vpnsessiondatares"]
                            .indexOf(tableName) === -1) {
                            return tableName;
                        }
                        if (minScore && angular.isNumber(minScore) && minScore >= 50) {
                            return tableName + "_top";
                        }
                        return tableName;
                    },
                    /**
                     * Test IPAddress
                     * @param str
                     * @returns {boolean}
                     */
                    isIpAddress: function (str) {
                        return ipAddressRegExp.test(str);
                    },
                    /**
                     * Return value of a shorter string acording to length
                     * @param str
                     * @param numOfChars
                     * @returns {string}
                     */
                    shortStr: function (str, numOfChars) {
                        if (str.length > 0) {
                            if (str.length > numOfChars) {
                                return str.substring(0, numOfChars - 3) + "...";
                            }
                            else {
                                return str;
                            }
                        }
                    },
                    padLeft: function (str, length, padCharacter) {
                        str = String(str);
                        var padLength = length - str.length;
                        if (padLength <= 0) {
                            return str;
                        }
                        var pad = [];
                        while (pad.length < padLength) {
                            pad.push(padCharacter);
                        }
                        return pad.join("") + str;
                    },
                    /**
                     * @param value The string to parse (placeholders using {{}} )
                     * @param data  Parameters to use to replace placeholders
                     * @param params    Parameters to use to replace placeholders
                     * @param index
                     * @param dataOverrideParams    In case the same parameters exists both in the data and params,
                     * use the data's (default is false)
                     * @returns {*} The parsed string
                     */
                    parseValue: function (value, data, params, index, dataOverrideParams) {
                        if (!value) {
                            return "";
                        }
                        if (!parsedStringTest.test(value)) {
                            return value;
                        }
                        var cachedParser = stringParsers[value];
                        if (!cachedParser) {
                            var foundVars = false, escapedValue = value.replace(/\"/g, "\\\"");
                            var parserStr = escapedValue.replace(/\{\{([^\}]+)\}\}/g, function (match, variable) {
                                foundVars = true;
                                var paramsAndFormatting = getParamsAndFormatting(variable);
                                if (paramsAndFormatting.method) {
                                    return '" + parsers.removeEmptyValue.call({ originalContext: this }, parsers.' +
                                        paramsAndFormatting.method + '.apply({ data: data, params: params, ' +
                                        'index: index, originalContext: this }, [' +
                                        paramsAndFormatting.params.join(" || ") + ', ' +
                                        paramsAndFormatting.parameters.join(",") +
                                        '].map(getParamValueForParser.bind({ params: params })))) + "';
                                }
                                else {
                                    return '" + parsers.removeEmptyValue.call({ originalContext: this }, ' +
                                        paramsAndFormatting.params.join(" || ") + ') + "';
                                }
                            });
                            if (!foundVars) {
                                return value;
                            }
                            parserStr = 'try{ return "' + parserStr +
                                '"; } catch(e){ console.error("Error parsing string \'' + value +
                                '\': ", e.message); throw e; }';
                            /*jslint evil: true */
                            //The following code causes: The Function constructor is a form of eval.
                            cachedParser = stringParsers[value] = new Function("data", "params", "index", "parsers", "getParamValueForParser", parserStr);
                        }
                        /*
                         IMPORTANT: This is a hack. Originally we used only the "data" to fill the placeholders
                         in the value string, but after adding also the "params", we didn't handle the scenario of
                         properties with the same key that appear both in "data" and "params". In order to avoid
                         major changes we left the default to be "params" overrides "data", but left an option to
                         change it. We should probably try to let the "data" override the "param"
                         */
                        if (dataOverrideParams) {
                            // In case the same parameters exists both in the data and params, use the data's
                            return cachedParser(angular.extend({}, params, data), params || {}, index, parseStringFormatters, getParamValueForParser) || "";
                        }
                        else {
                            // In case the same parameters exists both in the data and params, use the param's
                            return cachedParser(angular.extend({}, data, params), params || {}, index, parseStringFormatters, getParamValueForParser) || "";
                        }
                    }
                },
                duration: {
                    /**
                     gets string of format hh:mm:ss and return number that represent duration in decimal
                     notation (hours scope).
                     */
                    durationToNumber: function (value, units) {
                        if (value === undefined || value === 'undefined' || value === null) {
                            return 0;
                        }
                        var duration = moment.duration(value, units);
                        switch (units) {
                            case "milliseconds":
                                return duration.asMilliseconds();
                            case "seconds":
                                return duration.asSeconds();
                            case "minutes":
                                return duration.asMinutes();
                            case "hours":
                                return duration.asHours().toFixed(2);
                            case "days":
                                return duration.asDays().toFixed(2);
                            default:
                                throw new Error("Unsupported unit, '" + units + "', expecting milliseconds, " +
                                    "seconds, minutes, hours or days.");
                        }
                    },
                    /**
                     * Formats an int representing number of seconds into a time string, hh:mm:ss
                     * @param diffSeconds
                     */
                    prettyTime: function (diffSeconds, units) {
                        // if no duration in source data - like to show the value as "" -
                        // which will be translated to N/A
                        if (diffSeconds === null || diffSeconds === undefined) {
                            return "";
                        }
                        else {
                            var duration = moment.duration(Number(diffSeconds), units);
                            var days = duration.days();
                            //should never happened in our product - all our sessions are defined as less
                            // than 24 hours
                            if (days && days > 0) {
                                return days + "d";
                            }
                            else {
                                var hours = duration.hours(), minutes = duration.minutes(), seconds = duration.seconds();
                                if (hours || minutes || seconds) {
                                    return methods.strings.padLeft(hours, 2, "0") + ":" +
                                        methods.strings.padLeft(minutes, 2, "0") + ":" +
                                        methods.strings.padLeft(seconds, 2, "0");
                                }
                                else {
                                    //if session duration is less than 1 sec - will shown as 0 second
                                    return "00:00:00";
                                }
                            }
                        }
                    }
                },
                objects: {
                    arrayToObject: function (arr, property) {
                        var obj = {};
                        angular.forEach(arr, function (member) {
                            var memberPropertyValue = member[property];
                            if (memberPropertyValue) {
                                obj[memberPropertyValue] = member;
                            }
                        });
                        return obj;
                    },
                    areEqual: function (a, b) {
                        if (typeof (a) !== typeof (b)) {
                            return false;
                        }
                        if (!a && b || a && !b) {
                            return false;
                        }
                        if (angular.isArray(a) !== angular.isArray(b)) {
                            return false;
                        }
                        if (angular.isArray(a) && angular.isArray(b)) {
                            if (a.length !== b.length) {
                                return false;
                            }
                            for (var i = 0; i < a.length; i++) {
                                if (!methods.objects.areEqual(a[i], b[i])) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        else if (angular.isObject(a)) {
                            if (a.constructor !== b.constructor) {
                                return false;
                            }
                            if (angular.isDate(a) && angular.isDate(b)) {
                                return a.valueOf() === b.valueOf();
                            }
                            if (Object.keys(a).length !== Object.keys(b).length) {
                                return false;
                            }
                            for (var p in a) {
                                if (a.hasOwnProperty(p)) {
                                    if (!methods.objects.areEqual(a[p], b[p])) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        }
                        else {
                            return a === b;
                        }
                    },
                    /**
                     * Return true if obj contains any of the specified param names
                     * @param obj
                     * @param paramNames
                     */
                    containsAnyParam: function (obj, paramNames) {
                        for (var i = 0; i < paramNames.length; i++) {
                            if (obj[paramNames[i]] !== undefined) {
                                return true;
                            }
                        }
                        return false;
                    },
                    containsAllParams: function (obj, paramNames) {
                        for (var i = 0, paramName; (!!(paramName = paramNames[i])); i++) {
                            if (!obj[paramName]) {
                                return false;
                            }
                        }
                        return true;
                    },
                    /**
                     * DEEP copy! Muaahaaahaahhh!
                     * @param obj
                     * @returns {*|void}
                     */
                    copy: function (obj) {
                        return methods.objects.extend({}, obj);
                    },
                    /**
                     * Extends objects, uses jQuery.extend, since angular.extend doesn't have deep-extend support.
                     * @param args
                     * @returns {*|void}
                     */
                    extend: function (args) {
                        return jQuery.extend.apply(this, [true].concat(Array.prototype.slice.call(arguments, 0)));
                    },
                    getObjectByPath: function (rootObj, path) {
                        path = path || '';
                        var parts = path.split("."), obj = rootObj;
                        for (var i = 0, part; (part = parts[i]) !== undefined; i++) {
                            obj = obj[part];
                            if (obj === null || obj === undefined) {
                                return obj;
                            }
                        }
                        return obj;
                    },
                    toArray: function (obj, formatter) {
                        var arr = [];
                        for (var p in obj) {
                            if (obj.hasOwnProperty(p)) {
                                arr.push(formatter ? formatter(p, obj[p]) : obj[p]);
                            }
                        }
                        return arr;
                    }
                },
                regexp: {
                    patterns: {
                        IP: /^(\d{1,3}\.){3}(\d{1,3})$/
                    }
                },
                url: {
                    escapeUrl: function (url) {
                        var parts = url.split("?");
                        if (parts.length > 1) {
                            var params = parts[1].split("&"), escapedParams = [];
                            params.forEach(function (param) {
                                var paramSplit = param.match(/^([\w\.]+=)(.*)$/);
                                if (paramSplit) {
                                    escapedParams.push(paramSplit[1] + encodeURIComponent(paramSplit[2]));
                                }
                                else {
                                    escapedParams.push(param);
                                }
                            });
                            return parts[0] + "?" + escapedParams.join("&");
                        }
                        return url;
                    },
                    getQuery: function (params) {
                        var paramValue, encodedParams = [];
                        for (var paramName in params) {
                            if (params.hasOwnProperty(paramName)) {
                                paramValue = params[paramName];
                                if (angular.isObject(paramValue)) {
                                    paramValue = JSON.stringify(paramValue);
                                }
                                if (paramValue !== null && paramValue !== undefined && paramValue !== "") {
                                    encodedParams.push([paramName, encodeURIComponent(paramValue)].join("="));
                                }
                            }
                        }
                        return encodedParams.join("&");
                    },
                    getQueryParams: function () {
                        var queryParams = window.location.search;
                        return this.parseUrlParams(queryParams);
                    },
                    //given a url string parse it to an object where each url parameter is mapped to a property
                    // in the return object
                    parseUrlParams: function (url) {
                        var params = {};
                        if (url) {
                            // Discard the URL prefix (take only the parameters)
                            var index = url.indexOf("?");
                            var paramKeyValues = index >= 0 ? url.substring(index + 1).split("&") : [];
                            angular.forEach(paramKeyValues, function (keyValue) {
                                if (keyValue) {
                                    var parts = keyValue.split("=");
                                    var decoded = decodeURIComponent(parts[1]);
                                    // Do not add key-value pair if decoding failed
                                    if (decoded) {
                                        params[parts[0]] = decoded;
                                    }
                                }
                            });
                        }
                        return params;
                    },
                    haveTheSameHash: function (url1, url2) {
                        var hash1 = url1.match(hashRegExp), hash2 = url2.match(hashRegExp);
                        if (hash1 && hash2) {
                            return hash1[0] === hash2[0];
                        }
                        return false;
                    }
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Format", ["Utils"])
        .factory("format", ["utils", function (utils) {
            var methods = {
                boolean: function (value) {
                    return !!value;
                },
                date: function (value, options) {
                    var date = utils.date.getMoment(value);
                    if (options.prettyDate) {
                        return utils.date.prettyDate(date.toDate(), options.shortPrettyDate);
                    }
                    return date.format(options.format);
                },
                float: function (value, options) {
                    var floatValue = parseFloat(value, 10);
                    if (options && options.decimals) {
                        return floatValue.toFixed(options.decimals);
                    }
                    else {
                        return floatValue;
                    }
                },
                int: function (value, options) {
                    return parseInt(value, 10);
                },
                formatItem: function (item, value) {
                    if (!item.format) {
                        return value;
                    }
                    var method = methods[item.format];
                    if (!method) {
                        return value;
                    }
                    return method(value, item.formatOptions);
                }
            };
            methods.datetime = methods.date;
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Conditions", ["Format", "Transforms", "DataEntities"]).factory("conditions", ["format", "utils", "dataEntities", function (format, utils, dataEntities) {
            var validations = {
                contains: function (val1, val2) {
                    if (validations.hasNoValue(val1) || validations.hasNoValue(val2)) {
                        return false;
                    }
                    if (angular.isArray(val1)) {
                        return !!~val1.indexOf(val2);
                    }
                    var regexp = new RegExp(val2, "i");
                    return regexp.test(val1);
                }, equals: function (val1, val2) {
                    if (angular.isObject(val1) && angular.isObject(val2)) {
                        return val1 === val2;
                    }
                    if ((val1 === null || val1 === undefined) && (val2 === null || val2 === undefined)) {
                        return true;
                    }
                    if (((val1 === null || val1 === undefined) && (val2 !== null && val2 !== undefined)) ||
                        ((val1 !== null && val1 !== undefined) && (val2 === undefined || val2 === undefined))) {
                        return false;
                    }
                    return val1.toString() === val2.toString();
                }, entityExists: function (val1, val2) {
                    return dataEntities.entityExists(val1 || val2);
                }, entityDoesntExists: function (val1, val2) {
                    return !dataEntities.entityExists(val1 || val2);
                }, isFalsy: function (val) {
                    return !val;
                }, isTruthy: function (val) {
                    return !!val;
                }, notEquals: function (val1, val2) {
                    return val1 !== val2;
                }, greaterThan: function (val1, val2) {
                    return val1 > val2;
                }, greaterThanOrEquals: function (val1, val2) {
                    return val1 >= val2;
                }, lesserThan: function (val1, val2) {
                    return val1 < val2;
                }, lesserThanOrEqual: function (val1, val2) {
                    return val1 <= val2;
                }, included: function (val1, arr) {
                    return !!~arr.indexOf(val1);
                }, hasValue: function (value) {
                    return value !== undefined && value !== null;
                }, hasNoValue: function (value) {
                    return !validations.hasValue(value);
                }
            };
            function getQueryParamOperator(paramValue) {
                var paramOperator = getParamOperator(paramValue), defaultOperator = "equals";
                if (!paramOperator) {
                    return defaultOperator;
                }
                for (var operatorName in operatorTypesParamPrefixes) {
                    if (operatorTypesParamPrefixes.hasOwnProperty(operatorName)) {
                        if (operatorTypesParamPrefixes[operatorName] === paramOperator) {
                            return operatorName;
                        }
                    }
                }
                return defaultOperator;
            }
            var paramParsers = {
                dateRange: function (param) {
                    if (angular.isObject(param)) {
                        return param;
                    }
                    var dates = param.split("::"), dateRange = {
                        timeStart: dates[0], timeEnd: dates[0]
                    };
                    if (dates.length > 1) {
                        dateRange.timeEnd = dates[1];
                    }
                    return dateRange;
                },
                range: function (param) {
                    if (angular.isObject(param)) {
                        return param;
                    }
                    var range = param.split("::");
                    return {
                        min: range[0], max: range[1]
                    };
                },
                "default": function (param) {
                    return param;
                }
            };
            function getParamOperator(param) {
                var operator;
                for (var i = 0, prefix; (!!(prefix = operatorCharacters[i])); i++) {
                    if (!param.indexOf(prefix)) {
                        if (!operator || prefix.length > operator.length) {
                            operator = prefix;
                        }
                    }
                }
                return operator;
            }
            var operatorTypesParamPrefixes = {
                contains: "~",
                notEquals: "!",
                greaterThan: ">",
                greaterThanOrEquals: ">=",
                lesserThan: "<",
                lesserThanOrEqual: "<=",
                startsWith: "^",
                endsWith: "$",
                "in": "[]",
                dateRange: ":",
                hasValue: "*",
                hasNoValue: "!*",
                range: "--"
            };
            var operatorCharacters = [];
            angular.forEach(operatorTypesParamPrefixes, function (prefix) {
                operatorCharacters.push(prefix);
            });
            var operators = {
                boolean: {
                    "default": "equals", operators: [{ name: "equals", display: "=", requiresValue: true }]
                }, string: {
                    "default": "equals",
                    operators: [{ name: "equals", display: "=", requiresValue: true, allowMultiple: true },
                        { name: "in", display: "IN", text: "=", requiresValue: true },
                        { name: "notEquals", display: "!=", requiresValue: true, allowMultiple: true },
                        { name: "contains", display: "Contains", requiresValue: true },
                        { name: "hasValue", display: "Has value", sql: "IS NOT NULL", requiresValue: false },
                        { name: "hasNoValue", display: "Has no value", sql: "IS NULL", requiresValue: false },
                        { name: "startsWith", display: "Starts With", requiresValue: true },
                        { name: "endsWith", display: "Ends With", requiresValue: true },
                        { name: "regexp", display: "RegExp", requiresValue: true }]
                }, number: {
                    "default": "equals",
                    operators: [{ name: "equals", display: "=", requiresValue: true },
                        { name: "greaterThan", display: ">", requiresValue: true, types: ["number"] },
                        { name: "greaterThanOrEquals", display: "", requiresValue: true, types: ["number"] },
                        { name: "lesserThan", display: "<", requiresValue: true, types: ["number"] },
                        { name: "lesserThanOrEqual", display: "", requiresValue: true, types: ["number"] },
                        { name: "hasValue", display: "Has value", requiresValue: false },
                        { name: "hasNoValue", display: "Has no value", requiresValue: false }]
                }, date: {
                    "default": "dateRange",
                    operators: [{ name: "dateRange", display: "Dates", text: "", requiresValue: true, types: ["date"] },
                        { name: "greaterThan", display: ">", requiresValue: true, types: ["date"] },
                        { name: "greaterThanOrEquals", display: "", requiresValue: true, types: ["date"] },
                        { name: "lesserThan", display: "<", requiresValue: true, types: ["date"] },
                        { name: "lesserThanOrEqual", display: "", requiresValue: true, types: ["date"] }]
                }, hours: {
                    "default": "greaterThan",
                    operators: [{ name: "equals", display: "=", requiresValue: true },
                        { name: "greaterThan", display: ">", requiresValue: true, types: ["number"] },
                        { name: "greaterThanOrEquals", display: "", requiresValue: true, types: ["number"] },
                        { name: "lesserThan", display: "<", requiresValue: true, types: ["number"] },
                        { name: "lesserThanOrEqual", display: "", requiresValue: true, types: ["number"] }]
                }, range: {
                    "default": "range", operators: [{ name: "range", display: "", requiresValue: true, types: ["range"] }]
                }
            };
            function getFormattedValue(value) {
                if (angular.isDate(value)) {
                    return utils.date.getMoment(value).format("YYYY-MM-DD");
                }
                return value;
            }
            var operatorsToParamValues = {
                dateRange: function (dates) {
                    var strDates = [dates.timeStart];
                    if (dates.timeEnd && dates.timeEnd !== dates.timeStart) {
                        strDates.push(dates.timeEnd);
                    }
                    return strDates.join("::");
                },
                range: function (rangeValue) {
                    return rangeValue.min + "::" + rangeValue.max;
                },
                greaterThan: getFormattedValue,
                greaterThanOrEquals: getFormattedValue,
                lesserThan: getFormattedValue,
                lesserThanOrEqual: getFormattedValue
            };
            var operatorsToString = {
                dateRange: function (value) {
                    var isRange = value.timeEnd && value.timeEnd !== value.timeStart, str = isRange ? "between " : "= ";
                    str += utils.date.getMoment(value.timeStart).format("MM/DD/YYYY");
                    if (isRange) {
                        str += " - ";
                        str += utils.date.getMoment(value.timeEnd).format("MM/DD/YYYY");
                    }
                    return str;
                }
            };
            var stringToOperators = {
                date: function (value) {
                    var time = utils.date.getMoment(value).format("YYYY-MM-DD");
                    return {
                        timeStart: time, timeEnd: time
                    };
                }
            };
            var operatorsSqlValue = {
                contains: function (value, fieldName, condition) {
                    return "lcase(" + fieldName + ") LIKE '%" + value.toLowerCase() + "%'";
                }, equals: function (value, fieldName, condition) {
                    if (condition.valueField) {
                        return [fieldName, condition.valueField].join(" = ");
                    }
                    if (condition.castAs) {
                        return fieldName + " = cast(" + value + " as " + condition.castAs + ")";
                    }
                    else if (typeof (value) === "string") {
                        if (condition.type === "date") {
                            var dateStr;
                            if (/^\d+$/.test(value)) {
                                dateStr = utils.date.getMoment(parseInt(value)).format("YYYY-MM-DD");
                            }
                            else {
                                dateStr = value;
                            }
                            return dateStr ? 'to_date(' + fieldName + ') = "' + dateStr + '"' : "";
                        }
                        else {
                            return "lcase(" + fieldName + ") = \"" + value.toLowerCase() + "\"";
                        }
                    }
                    else {
                        return [fieldName, value].join(" = ");
                    }
                }, range: function (value, fieldName, condition) {
                    return fieldName + " <= " + value.max + " AND " + fieldName + " >= " + value.min;
                }, dateRange: function (value, fieldName, condition) {
                    var dateStart = utils.date.getMoment(angular.isObject(value) ? value.timeStart :
                        value), dateEnd = utils.date.getMoment(angular.isObject(value) ? value.timeEnd :
                        value), fieldNameParts = fieldName.split("."), tableName = fieldNameParts.length > 1 ?
                        fieldNameParts[0] + "." : "";
                    var dateStartValue;
                    var dateEndValue;
                    // Shift to fill in the whole day
                    dateStart.startOf("day");
                    dateEnd.endOf("day");
                    // Set date start
                    if (condition.useValueOfDates) {
                        dateStartValue = getValueForType(dateStart.valueOf(), "date");
                    }
                    else {
                        dateStartValue = "'" + dateStart.format("YYYY-MM-DD") + " 00:00:00'";
                    }
                    // Set date end
                    if (condition.useValueOfDates) {
                        dateEndValue = getValueForType(dateEnd.valueOf(), "date");
                    }
                    else {
                        dateEndValue = "'" + dateEnd.format("YYYY-MM-DD") + " 23:59:59'";
                    }
                    var sql;
                    if (dateStartValue === dateEndValue) {
                        sql = fieldName + " = " + dateEndValue;
                    }
                    else {
                        sql = [fieldName, "IS NOT NULL AND", fieldName, ">=", dateStartValue, "AND", fieldName, "<=",
                            dateEndValue].join(" ");
                    }
                    if (condition.usePartitions !== false) {
                        var partitions = utils.date.getDatePartitionSql(dateStart, dateEnd, tableName + "yearmonthday");
                        sql = partitions + " AND " + sql;
                    }
                    return sql;
                }, endsWith: function (value, fieldName) {
                    return "lcase(" + fieldName + ") LIKE '%" + value.toLowerCase() + "'";
                }, greaterThan: function (value, fieldName, condition) {
                    return getDeltaCondition(value, fieldName, condition);
                }, greaterThanOrEquals: function (value, fieldName, condition) {
                    return getDeltaCondition(value, fieldName, condition);
                }, hasValue: function (value, fieldName, condition) {
                    var sql = fieldName + " IS NOT NULL";
                    if (condition.type !== "number" && condition.type !== "boolean") {
                        sql += " AND " + fieldName + " != \"\"";
                    }
                    return sql;
                }, hasNoValue: function (value, fieldName, condition) {
                    var sql = fieldName + " IS NULL";
                    if (condition.type !== "number" && condition.type !== "boolean") {
                        sql += " OR " + fieldName + " = \"\"";
                    }
                    return sql;
                }, "in": function (value, fieldName) {
                    return fieldName + " IS NOT NULL AND " + fieldName + " IN (" + value + ")";
                }, lesserThan: function (value, fieldName, condition) {
                    return getDeltaCondition(value, fieldName, condition);
                }, lesserThanOrEqual: function (value, fieldName, condition) {
                    return getDeltaCondition(value, fieldName, condition);
                }, regexp: function (value, fieldName) {
                    return fieldName + " REGEXP '" + value + "'";
                }, startsWith: function (value, fieldName) {
                    return "lcase(" + fieldName + ") LIKE '" + value.toLowerCase() + "%'";
                }
            };
            function getPartitionStamp(value, operator) {
                var momentValue;
                if (isNaN(value)) {
                    momentValue = utils.date.getMoment(value);
                }
                else {
                    momentValue = utils.date.getMoment(Number(value));
                }
                return utils.date.getDatePartitionSql(momentValue, null, "yearmonthday", false, operator);
            }
            function getDeltaCondition(value, fieldName, condition) {
                var operator = operatorTypesParamPrefixes[condition.operator];
                var sql = "(" + fieldName + " IS NOT NULL AND ";
                if (condition.type === "date") {
                    if (condition.usePartitions !== false) {
                        sql += getPartitionStamp(value, operator) + " AND ";
                    }
                    sql += fieldName + " " + operator + " " +
                        (condition.valueField || getValueForType(value, condition.type, condition.operator));
                }
                else {
                    sql += fieldName + " " + operator + " " + (condition.valueField || value);
                }
                return sql + ")";
            }
            function getValueForType(value, type, conditionOperator) {
                if (type === "date") {
                    if (typeof value === "string") {
                        if (/^\d+$/.test(value)) {
                            var momentValue = utils.date.getMoment(Number(value));
                            if (conditionOperator) {
                                if (conditionOperator === "greaterThanOrEquals" ||
                                    conditionOperator === "greaterThan") {
                                    momentValue.startOf("day");
                                }
                                else if (conditionOperator === "lesserThanOrEqual" ||
                                    conditionOperator === "greaterThan") {
                                    momentValue.endOf("day");
                                }
                            }
                            return "cast(" + Math.floor(momentValue.valueOf() / 1000) + " as timestamp)";
                        }
                        else if (/^\d{4}-\d{2}-\d{2}$/.test(value)) {
                            return "'" + value + "'";
                        }
                    }
                }
                return value;
            }
            var operatorsIndex = {};
            function populateOperatorsIndex(operator) {
                operatorsIndex[operator.name] = {
                    sql: operator.sql || operator.display,
                    display: operator.display,
                    requiresValue: operator.requiresValue,
                    text: operator.text
                };
            }
            for (var operatorType in operators) {
                if (operators.hasOwnProperty(operatorType)) {
                    angular.forEach(operators[operatorType].operators, populateOperatorsIndex);
                }
            }
            function getOrConditionsIndex(conditions) {
                var orConditionsValues = {}, index = {};
                angular.forEach(conditions, function (condition) {
                    var orConditionValue = orConditionsValues[condition.field];
                    if (orConditionValue === undefined) {
                        orConditionsValues[condition.field] = 0;
                    }
                    else {
                        orConditionsValues[condition.field]++;
                    }
                });
                for (var field in orConditionsValues) {
                    if (orConditionsValues.hasOwnProperty(field)) {
                        if (orConditionsValues[field]) {
                            index[field] = false;
                        }
                    }
                }
                return index;
            }
            function hasConditionsWithValue(filter) {
                if (filter.type === "search") {
                    return true;
                }
                if (!filter.conditions || !filter.conditions.length) {
                    return false;
                }
                var conditionConfig;
                for (var i = 0, condition; (!!(condition = filter.conditions[i])); i++) {
                    conditionConfig = methods.getOperator(condition.operator);
                    if (!conditionConfig.requiresValue) {
                        return true;
                    }
                    if (condition.valueField) {
                        return true;
                    }
                    if (condition.value || condition.value === 0 || condition.value === false ||
                        condition.values && condition.values.length) {
                        return true;
                    }
                }
                return false;
            }
            function filterValuesToConditions(operator, filterValues, fieldId, entities, innerAnd, availableEntities) {
                var paramParser = paramParsers[operator] ||
                    paramParsers.default, conditionsArr = [], entitiesDictionary = utils.objects.arrayToObject(entities, "id"), entitiesFiltersIndex = {};
                function addCondition(conditionValue) {
                    var valueField = getValueField(getParamValueSqlField(conditionValue, availableEntities, true)), value = valueField ? null :
                        paramParser(conditionValue), fieldIdParts = fieldId.split("."), fieldIdWithoutEntity = fieldIdParts[fieldIdParts.length - 1], entityId = fieldIdParts[0], filter = entitiesFiltersIndex[entityId] &&
                        entitiesFiltersIndex[entityId][fieldIdWithoutEntity];
                    if (!filter) {
                        entitiesFiltersIndex[entityId] =
                            utils.objects.arrayToObject(entitiesDictionary[entityId].filters, "id");
                        filter = entitiesFiltersIndex[entityId][fieldIdWithoutEntity];
                    }
                    conditionsArr.push({
                        field: filter.column || fieldIdWithoutEntity,
                        table: fieldIdParts.length > 1 && !filter.column ?
                            entitiesDictionary[entityId].tableAlias || entitiesDictionary[entityId].table : null,
                        operator: operator,
                        valueField: valueField,
                        value: value,
                        or: true,
                        type: filter.type,
                        usePartitions: entitiesDictionary[entityId].usePartitions,
                        useValueOfDates: entitiesDictionary[entityId].useValueOfDates,
                        innerAnd: innerAnd
                    });
                }
                if (operator === "in") {
                    var inValues = [];
                    filterValues.forEach(function (value) {
                        if (!getValueField(value)) {
                            inValues.push("\"" + value + "\"");
                        }
                    });
                    addCondition(inValues.join(","));
                }
                else {
                    filterValues.forEach(addCondition);
                }
                return conditionsArr;
            }
            function getValueField(value) {
                if (typeof (value) !== "string") {
                    return null;
                }
                var fieldMatch = value.match(/^\[(\w+\.\w+)\]$/);
                return fieldMatch ? fieldMatch[1] : null;
            }
            function getFilterParamName(filter) {
                if (filter.type === "search") {
                    return "search." + filter.id;
                }
                return (filter.entityId || filter.entity.id) + "." + (filter.id || filter.filterId);
            }
            function paramsToEntityFilters(entity, params, availableEntities) {
                var filtersValues = {};
                function getParamValues(filter, paramOperatorValues) {
                    var operator = getQueryParamOperator(paramOperatorValues), paramValues = operator === "equals" ?
                        paramOperatorValues :
                        paramOperatorValues.substr(operatorTypesParamPrefixes[operator].length), paramValuesParser = paramParsers[operator] || paramParsers.default, tempParamValues = paramValues.replace(/\,\,/g, "**;;**");
                    paramValues = tempParamValues.split(",");
                    angular.forEach(paramValues, function (value, i) {
                        value = value.replace(/\*\*\;\;\*\*/g, ",");
                        var paramValue = getParamValueSqlField(value, availableEntities);
                        if (!paramValue) {
                            if (filter.type === "string" || filter.type === "date" || filter.type === "range") {
                                paramValue = paramValuesParser(value.replace(/_;_/g, ",").replace(/_;;_/g, "|"));
                            }
                            else if (filter.type === "number" || filter.type === "hours") {
                                paramValue = parseFloat(value);
                                if (isNaN(paramValue)) {
                                    paramValue = null;
                                }
                            }
                            else if (filter.type === "boolean") {
                                paramValue = value.toLowerCase() === "true";
                            }
                        }
                        paramValues[i] = paramValue;
                    });
                    var paramName = getParamName(filter), filterValues = filtersValues[paramName];
                    if (!filterValues) {
                        filterValues = filtersValues[paramName] = {};
                    }
                    filterValues[operator] = paramValues;
                }
                function getBulkFilters() {
                    var values = ["true", "false"];
                    values.forEach(function (value) {
                        var bulkFields = params[entity.id + "._" + value];
                        if (bulkFields) {
                            bulkFields.split(",").forEach(function (field) {
                                params[entity.id + "." + field] = value;
                            });
                        }
                    });
                }
                function getParamName(filter) {
                    return entity.id + "." + filter.id;
                }
                getBulkFilters();
                angular.forEach(entity.filters, function (filter) {
                    var paramName = getParamName(filter), paramValue = params[paramName];
                    if (paramValue !== undefined && paramValue !== null) {
                        var paramOperators = angular.isArray(paramValue) ? paramValue :
                            typeof (paramValue) === "string" ? paramValue.split("|") : [String(paramValue)];
                        paramOperators.forEach(function (paramOperator) {
                            getParamValues(filter, paramOperator);
                        });
                        if (params[paramName + ".or"]) {
                            filtersValues[paramName].andOr = "or";
                        }
                        if (params[paramName + "_conjuction"]) {
                            filtersValues[paramName].innerAnd =
                                params[paramName + "_conjuction"].toLowerCase() === "and";
                        }
                    }
                });
                return filtersValues;
            }
            function getParamValueSqlField(value, availableEntities, useTable) {
                var fieldMatch = typeof (value) === "string" && value.match(/^\[(\w+)(?:\.(\w+))?\]$/);
                if (!fieldMatch) {
                    return null;
                }
                var entity;
                var fieldEntity = fieldMatch[2] ? getEntityTableName(fieldMatch[1], availableEntities) || entity :
                    entity;
                var sqlField = fieldEntity[useTable ? "table" : "id"] + ".", fieldName = fieldMatch[2] ||
                    fieldMatch[1], entitySqlField = getEntityFieldName(fieldEntity, fieldName);
                if (!entitySqlField) {
                    throw new Error("Invalid field, " + fieldName);
                }
                return "[" + sqlField + entitySqlField + "]";
            }
            function getEntityTableName(entityName, availableEntities) {
                for (var i = 0, entity; (!!(entity = availableEntities[i])); i++) {
                    if (entity.id === entityName) {
                        return entity;
                    }
                }
                return null;
            }
            function getEntityFieldName(entity, fieldId) {
                for (var i = 0, entityField; (!!(entityField = entity.fields[i])); i++) {
                    if (entityField.id === fieldId) {
                        return entityField.column || entityField.id;
                    }
                }
                return null;
            }
            var methods = {
                conditionsToSql: function (conditions) {
                    var sql = [], conditionFields = {}, fieldSql = {}, fieldSqlClauses, fieldConjuctions;
                    angular.forEach(conditions, function (condition) {
                        if (condition.sql) {
                            sql.push(condition.sql);
                        }
                        else if (condition.field) {
                            var field = conditionFields[condition.field];
                            if (!field) {
                                field = conditionFields[condition.field] = [];
                                fieldSql[condition.field] = [];
                            }
                            field.push(condition);
                        }
                    });
                    function populateFieldConjuctions(condition) {
                        var conditionValue = condition.value;
                        var getValueFunction = operatorsSqlValue[condition.operator], orCondition, conditionTable = condition.table ? condition.table + "." : "", conditionField = conditionTable + condition.field;
                        fieldConjuctions.push(condition.innerAnd ? "AND" : "OR");
                        if (getValueFunction) {
                            orCondition = getValueFunction(conditionValue, conditionField, condition);
                        }
                        else {
                            if (typeof (conditionValue) === "string") {
                                conditionValue = "\"" + conditionValue + "\"";
                            }
                            orCondition = [conditionField, operatorsIndex[condition.operator].sql,
                                condition.valueField || conditionValue].join(" ");
                        }
                        if (orCondition && !~fieldSql[fieldName].indexOf(orCondition)) {
                            fieldSql[fieldName].push(orCondition);
                        }
                    }
                    function populateFieldSqlClauses(fieldClause, i) {
                        if (i) {
                            fieldSqlClauses.push(" " + fieldConjuctions[i] + " ");
                        }
                        fieldSqlClauses.push(fieldClause);
                    }
                    for (var fieldName in conditionFields) {
                        if (conditionFields.hasOwnProperty(fieldName)) {
                            fieldConjuctions = [];
                            fieldSqlClauses = [];
                            angular.forEach(conditionFields[fieldName], populateFieldConjuctions);
                            fieldSqlClauses.push("(");
                            fieldSql[fieldName].forEach(populateFieldSqlClauses);
                            fieldSqlClauses.push(")");
                            sql.push(fieldSqlClauses.join(""));
                        }
                    }
                    return sql.join(" AND ");
                },
                conditionToString: function (condition, filter) {
                    var operator = methods.getOperator(condition.operator), operatorDisplay = operator.text !==
                        undefined ? operator.text :
                        operator.display, conditionText = [operatorDisplay.toLowerCase()], valueWrapper = filter.type === "string" ? "'" : "";
                    if (operator.requiresValue) {
                        if (condition.values && condition.values.length) {
                            valueWrapper = typeof condition.values[0] === "string" ? "'" : "";
                            conditionText.push(utils.arrays.toSentence(condition.values, filter.conjuction, valueWrapper));
                        }
                        else {
                            var valueField = condition.valueField || getValueField(condition.value);
                            if (valueField) {
                                conditionText.push(valueField);
                            }
                            else if (operatorsToString[condition.operator]) {
                                conditionText.push(operatorsToString[condition.operator](condition.value));
                            }
                            else {
                                if (condition.filterType === "date" || condition.filterType === "dateSelect") {
                                    if (condition.timeStart && condition.timeEnd) {
                                        conditionText.push(operatorsToString.dateRange(condition.value));
                                    }
                                    else {
                                        var m = utils.date.getMoment(condition.value);
                                        if (m.isValid()) {
                                            conditionText.push(m.format("YYYY-MM-DD"));
                                        }
                                        else {
                                            conditionText.push("BAD DATE");
                                        }
                                    }
                                }
                                else if (condition.filterType === "hoursSelect") {
                                    conditionText.push(condition.value / 3600 + ":00");
                                }
                                else if (condition.filterType === "range") {
                                    conditionText.push(condition.value.min + filter.settings.labelSuffix + "  " +
                                        filter.name + "  " + condition.value.max + filter.settings.labelSuffix);
                                }
                                else {
                                    if (angular.isDate(condition.value)) {
                                        conditionText.push(utils.date.getMoment(condition.value).format("YYYY-MM-DD"));
                                    }
                                    else {
                                        conditionText.push(condition.value !== null && condition.value !== undefined ?
                                            " " + valueWrapper + condition.value + valueWrapper : "(none)");
                                    }
                                }
                            }
                        }
                    }
                    return conditionText.join(" ");
                },
                filterHasConditionsWithValue: hasConditionsWithValue,
                filtersToSqlParams: function (filters, entities, entitiesJoin, savedSearches, sqlConditions, availableEntities) {
                    function getJoins() {
                        var joins = [];
                        if (entitiesJoin) {
                            entitiesJoin.forEach(function (entityJoin) {
                                if (joinRequired(entityJoin)) {
                                    var join = { caseSensitive: entityJoin._caseSensitive }, i = 1;
                                    for (var p in entityJoin) {
                                        if (entityJoin.hasOwnProperty(p)) {
                                            if (p[0] === "_") {
                                                continue;
                                            }
                                            join["table" + i] = entitiesDictionary[p].table;
                                            join["field" + i] = entityJoin[p];
                                            i++;
                                        }
                                    }
                                    joins.push(join);
                                }
                            });
                        }
                        return joins;
                    }
                    function joinRequired(entityJoin) {
                        var i, entity, entityFound;
                        for (var p in entityJoin) {
                            if (entityJoin.hasOwnProperty(p)) {
                                entityFound = false;
                                if (p[0] === "_") {
                                    continue;
                                }
                                for (i = 0; (!!(entity = entities[i])); i++) {
                                    if (entity.id === p) {
                                        entityFound = true;
                                        break;
                                    }
                                }
                                if (!entityFound) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    var sqlParams = {
                        whereClauses: []
                    }, entitiesDictionary = utils.objects.arrayToObject(entities, "id"), joins = getJoins(), filterConditions;
                    if (savedSearches && savedSearches.length) {
                        sqlParams.whereClauses =
                            sqlParams.whereClauses.concat(methods.savedSearchesToFilters(savedSearches, entities, entitiesJoin));
                    }
                    if (sqlConditions && sqlConditions.length) {
                        var sqlConditionsData = [];
                        if (!angular.isArray(sqlConditions)) {
                            sqlConditions = [sqlConditions];
                        }
                        sqlConditions.forEach(function (sqlCondition) {
                            sqlConditionsData.push({
                                sql: sqlCondition
                            });
                        });
                        sqlParams.whereClauses.push({
                            conditions: sqlConditionsData
                        });
                    }
                    function setFiltersCondition(filterValues, index) {
                        if (index !== "andOr" && index !== "innerAnd") {
                            var operator = angular.isString(index) ? index :
                                getQueryParamOperator(filterValues);
                            if (!angular.isArray(filterValues)) {
                                filterValues = [filterValues];
                            }
                            filterConditions.conditions =
                                filterConditions.conditions.concat(filterValuesToConditions(operator, filterValues, fieldId, entities, !!filters[fieldId].innerAnd, availableEntities));
                        }
                    }
                    for (var fieldId in filters) {
                        if (filters.hasOwnProperty(fieldId)) {
                            filterConditions = { conditions: [], isOr: !!filters[fieldId].andOr };
                            angular.forEach(filters[fieldId], setFiltersCondition);
                            sqlParams.whereClauses.push(filterConditions);
                        }
                    }
                    if (joins.length) {
                        sqlParams.join = joins;
                    }
                    return sqlParams;
                },
                filtersToParams: function (filters, entities) {
                    var params = {};
                    if (!filters) {
                        return params;
                    }
                    if (!angular.isArray(filters)) {
                        filters = [filters];
                    }
                    entities.forEach(function (entity) {
                        params[entity.id + "_page"] = null;
                    });
                    angular.forEach(filters, function (filter) {
                        var filterParamName = getFilterParamName(filter);
                        if (filter.enabled && methods.filterHasConditionsWithValue(filter)) {
                            if (filter.type === "search") {
                                params[filterParamName] = 1;
                            }
                            else {
                                var filterValues = [];
                                var conditionOperators = {};
                                filter.conditions.forEach(function (condition) {
                                    var conditionOperator = condition.valueField && condition.operator === "in" ?
                                        "equals" :
                                        condition.operator, operator = conditionOperators[conditionOperator], values = condition.values ? angular.copy(condition.values) : [];
                                    if (condition.valueField) {
                                        values.push("[" + condition.valueField + "]");
                                    }
                                    if (condition.value !== null && condition.value !== undefined) {
                                        values.push(condition.value);
                                    }
                                    if (!operator) {
                                        operator = conditionOperators[conditionOperator] = [];
                                    }
                                    if (values && values.length) {
                                        values.forEach(function (value) {
                                            if (value !== null && value !== undefined) {
                                                var strValue = operatorsToParamValues[conditionOperator] ?
                                                    operatorsToParamValues[conditionOperator](value) :
                                                    angular.isString(value) ? utils.url.formatStringForParam(value) :
                                                        value;
                                                if (!~operator.indexOf(strValue)) {
                                                    operator.push(strValue);
                                                }
                                            }
                                        });
                                    }
                                });
                                for (var operatorName in conditionOperators) {
                                    if (conditionOperators.hasOwnProperty(operatorName)) {
                                        filterValues.push((operatorTypesParamPrefixes[operatorName] || "") +
                                            conditionOperators[operatorName].join(","));
                                    }
                                }
                                if (filterValues.length) {
                                    params[filterParamName] = filterValues.join("|");
                                    if (filter.andOr === "or") {
                                        params[filterParamName + ".or"] = 1;
                                    }
                                }
                                else {
                                    params[filterParamName] = null;
                                }
                            }
                        }
                        else {
                            params[filterParamName] = null;
                        }
                    });
                    return params;
                },
                filterStringToValue: function (filterType, value) {
                    var convertor = stringToOperators[filterType];
                    return convertor ? convertor(value) : value;
                },
                getFilterParamName: getFilterParamName,
                getOperator: function (operatorName) {
                    return operatorsIndex[operatorName];
                },
                getParamOperator: function (operatorName) {
                    return operatorTypesParamPrefixes[operatorName];
                },
                getUsedEntities: function (entities, savedSearches, params) {
                    var filters = this.paramsToFilters(entities, params), usedEntities = [], usedEntityIds = {};
                    savedSearches.forEach(function (search) {
                        search.entities.forEach(function (entityId) {
                            usedEntityIds[entityId] = true;
                        });
                    });
                    var entityMatchRegExp = /^(.*)\./, operator, operatorValues;
                    function setUsedEntityId(value) {
                        var valueField = getValueField(value);
                        if (valueField) {
                            usedEntityIds[valueField.split(".")[0]] = true;
                        }
                    }
                    for (var filterName in filters) {
                        if (filters.hasOwnProperty(filterName)) {
                            usedEntityIds[filterName.match(entityMatchRegExp)[1]] = true;
                            for (operator in filters[filterName]) {
                                if (filters[filterName].hasOwnProperty(operator)) {
                                    operatorValues = filters[filterName][operator];
                                    if (angular.isArray(operatorValues)) {
                                        operatorValues.forEach(setUsedEntityId);
                                    }
                                }
                            }
                        }
                    }
                    entities.forEach(function (entity) {
                        if (usedEntityIds[entity.id]) {
                            var entityCopy = angular.copy(entity), minScore = entity.scoreField &&
                                params[entity.id + "." + entity.scoreField];
                            if (minScore) {
                                if (typeof (minScore) === "string") {
                                    minScore = minScore.match(/^\>\=?(\d+)/);
                                }
                                if (minScore) {
                                    if (!angular.isNumber(minScore)) {
                                        minScore = parseInt(minScore[1], 10);
                                    }
                                    if (!isNaN(minScore)) {
                                        entityCopy.table = utils.strings.getEventsTableName(entity.table, minScore);
                                        if (entityCopy.table !== entity.table) {
                                            entityCopy.tableAlias = entity.table;
                                        }
                                    }
                                }
                            }
                            usedEntities.push(entityCopy);
                        }
                    });
                    return usedEntities;
                },
                getValueField: getValueField,
                operators: operators,
                get operatorsIndex() {
                    return angular.copy(operatorsIndex);
                },
                paramsToSqlParams: function (usedEntities, entitiesJoin, savedSearches, params, sqlConditions, availableEntities) {
                    return methods.filtersToSqlParams(methods.paramsToFilters(usedEntities, params, availableEntities), usedEntities, entitiesJoin, savedSearches, sqlConditions, availableEntities);
                },
                paramsToFilters: function (usedEntities, params, availableEntities) {
                    var filtersValues = {};
                    availableEntities = availableEntities || usedEntities;
                    usedEntities.forEach(function (entity) {
                        angular.extend(filtersValues, paramsToEntityFilters(entity, params, availableEntities));
                    });
                    return filtersValues;
                },
                savedSearchesToFilters: function (savedSearches, entities, entitiesJoin) {
                    var filters = [];
                    savedSearches.forEach(function (search) {
                        if (search.enabled === undefined) {
                            search.enabled = true;
                        }
                        search.type = "search";
                        search.filters.forEach(function (filter) {
                            filter.enabled = true;
                        });
                        var params = methods.filtersToParams(search.filters, entities), filterObj = methods.paramsToSqlParams(entities, entitiesJoin, search.savedSearches || [], params, [], entities);
                        filterObj.isOr = search.andOr === "or";
                        filters.push(filterObj);
                    });
                    return filters;
                },
                validateCondition: function (value1, operator, value2) {
                    var validation = validations[operator];
                    if (!validation) {
                        throw new Error("Invalid operator for validation: '" + operator + "'.");
                    }
                    return validation(value1, value2);
                },
                /**
                 * Gets an array of conditions and returns true/false, whether the conditions are met or not.
                 * @param conditions Array of conditions
                 * @param data Data object to use in condition checkers
                 * @param params State object
                 * @returns {boolean}
                 */
                validateConditions: function (conditions, data, params) {
                    if (!conditions) {
                        return true;
                    }
                    if (!angular.isArray(conditions)) {
                        conditions = [conditions];
                    }
                    var conditionValue, conditionField, dataValue, paramMatch, orConditionsValues = getOrConditionsIndex(conditions);
                    for (var i = 0, condition; (!!(condition = conditions[i])); i++) {
                        conditionValue = condition.value;
                        if (conditionValue !== undefined) {
                            if (/^@/.test(condition.value)) {
                                conditionValue = data[condition.value];
                            }
                            else if (params) {
                                if (!condition.value.match) {
                                    conditionValue = condition.value;
                                }
                                else if (!!(paramMatch = condition.value.match(/^\{\{([^\}]+)\}\}$/))) {
                                    conditionValue = params[paramMatch[1]];
                                }
                            }
                        }
                        conditionField = condition.field;
                        if (conditionField) {
                            if (!!(paramMatch = conditionField.match(/^\{\{([^\}]+)\}\}$/))) {
                                dataValue = params[paramMatch[1]];
                            }
                            else {
                                dataValue = utils.objects.getObjectByPath(data, conditionField);
                            }
                            if (condition.fieldType) {
                                dataValue = format[condition.fieldType](dataValue, {});
                            }
                        }
                        var conditionResult = methods.validateCondition(dataValue, condition.operator, conditionValue), orConditionsValue = orConditionsValues[condition.field];
                        if (orConditionsValue !== undefined) {
                            orConditionsValues[condition.field] = orConditionsValue | conditionResult;
                        }
                        else if (!conditionResult) {
                            return false;
                        }
                    }
                    for (var field in orConditionsValues) {
                        if (orConditionsValues.hasOwnProperty(field)) {
                            if (!orConditionsValues[field]) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Styles", ["Format", "Conditions"])
        .factory("styles", ["$q", "$http", "conditions", "format", "utils",
        function ($q, $http, conditions, format, utils) {
            var savedStyles, onStylesLoad = [], loadingStyles;
            function getSavedStyle(styleName) {
                if (savedStyles) {
                    var style = savedStyles[styleName];
                    if (style) {
                        return $q.when(style);
                    }
                    else {
                        return $q.reject("Style '" + styleName + "' not found.");
                    }
                }
                if (loadingStyles) {
                    var deferred = $q.defer();
                    onStylesLoad.push({ name: styleName, deferred: deferred });
                    return deferred.promise;
                }
                else {
                    loadingStyles = true;
                    return utils.http.wrappedHttpGet("data/styles.json").then(function (stylesData) {
                        savedStyles = stylesData;
                        loadingStyles = false;
                        if (onStylesLoad.length) {
                            onStylesLoad.forEach(function (onLoad) {
                                getSavedStyle(onLoad.name).then(function (style) {
                                    onLoad.deferred.resolve(style);
                                });
                            });
                            onStylesLoad = null;
                        }
                        return getSavedStyle(styleName);
                    });
                }
            }
            var presets = {
                severity: function (settings) {
                    var colors = {
                        medium: "rgb(226, 172, 1)",
                        high: "#cc0000"
                    };
                    function getCondition(properties, value) {
                        return {
                            properties: properties,
                            "conditions": [
                                {
                                    "field": settings.conditionField,
                                    "fieldType": settings.conditionType,
                                    "operator": "greaterThanOrEquals",
                                    "value": value
                                }
                            ]
                        };
                    }
                    return [
                        getCondition({ color: colors.medium, "font-weight": "bold" }, settings.medium),
                        getCondition({ color: colors.high, "font-weight": "bold" }, settings.high)
                    ];
                }
            };
            function getStylePreset(options) {
                if (!options.preset || !presets[options.preset]) {
                    throw new Error("Invalid style preset, '" + options.preset + "'.");
                }
                var preset = presets[options.preset];
                return preset(options.settings);
            }
            function parseStyle(styleSettings, data, params) {
                var style = {};
                function addItemProperties(styleItem) {
                    for (var property in styleItem.properties) {
                        if (styleItem.properties.hasOwnProperty(property)) {
                            style[property] = styleItem.properties[property];
                        }
                    }
                }
                angular.forEach(styleSettings, function (styleItem) {
                    if (!styleItem.conditions) {
                        addItemProperties(styleItem);
                    }
                    else {
                        var conditionValue, conditionField, dataValue, paramMatch;
                        for (var i = 0, condition; (condition = styleItem.conditions[i]) !== undefined; i++) {
                            conditionValue = condition.value;
                            if (/^@/.test(condition.value)) {
                                conditionValue = data[condition.value];
                            }
                            conditionField = condition.field;
                            if (!!(paramMatch = conditionField.match(/^\{\{([^\}]+)\}\}$/))) {
                                dataValue = params[paramMatch[1]];
                            }
                            else {
                                dataValue = data[conditionField];
                            }
                            if (condition.fieldType) {
                                dataValue = format[condition.fieldType](dataValue);
                            }
                            if (!conditions.validateCondition(dataValue, condition.operator, condition.value)) {
                                return;
                            }
                        }
                        addItemProperties(styleItem);
                    }
                });
                return style;
            }
            function getStyleParams(field, data) {
                if (!field.styleParams) {
                    return {};
                }
                var styleParams = {};
                for (var paramName in field.styleParams) {
                    if (field.styleParams.hasOwnProperty(paramName)) {
                        styleParams[paramName] = data[field.styleParams[paramName]];
                    }
                }
                return styleParams;
            }
            var methods = {
                getStyle: function (field, data) {
                    if (field.style.preset) {
                        return $q.when(getStylePreset(field.style));
                    }
                    else {
                        if (typeof (field.style) === "string") {
                            return getSavedStyle(field.style).then(function (styleSettings) {
                                return parseStyle(styleSettings, data, getStyleParams(field, data));
                            });
                        }
                        else {
                            return parseStyle(field.style, data, getStyleParams(field, data));
                        }
                    }
                },
                getParseStyleFunction: function (field) {
                    if (typeof (field.style) === "string") {
                        return getSavedStyle(field.style).then(function (styleSettings) {
                            return function (data) {
                                return parseStyle(styleSettings, data, getStyleParams(field, data));
                            };
                        });
                    }
                    else {
                        return function (data) {
                            return parseStyle(field.style, data, getStyleParams(field, data));
                        };
                    }
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Transforms", ["Utils"]).factory("transforms", ["utils", function (utils) {
            //function getGroupLinkDn(groupParts, partIndex) {
            //    var linkParts = [];
            //    for (var i = partIndex; i < groupParts.length; i++) {
            //        linkParts.push(groupParts[i]);
            //    }
            //    return linkParts.join(",");
            //}
            var methods = {
                adUser: function (value) {
                    var cnMatch = value.match(/^CN=([^\,]+)/);
                    if (cnMatch) {
                        return cnMatch[1];
                    }
                    return value;
                },
                adUsers: function (value) {
                    if (!value) {
                        return value;
                    }
                    var users = value.match(/CN=([^\,]+)/g), adUsers = [];
                    if (!users) {
                        return value;
                    }
                    users.forEach(function (user) {
                        adUsers.push(user.split("=")[1]);
                    });
                    if (adUsers.length) {
                        return adUsers.join(", ");
                    }
                    return value;
                },
                arrayJoin: function (array, options) {
                    if (!array) {
                        return null;
                    }
                    options = options || {};
                    return array.join(options.joiner || ", ");
                },
                count: function (array) {
                    if (!array) {
                        return 0;
                    }
                    return array.length;
                },
                date: function (date, options) {
                    if (!date) {
                        return "";
                    }
                    if (!options) {
                        options = { format: "MM/DD/YY HH:mm" };
                    }
                    var newDate = utils.date.getMoment(date);
                    if (options.prettyDate) {
                        return utils.date.prettyDate(newDate.toDate(), options.shortPrettyDate);
                    }
                    return newDate.format(options.format);
                },
                /* Deprecated, remove after March 1st, 2015 if no problem arises!
                 group: function(groupStr, options){
                 if (!groupStr)
                 return "";
    
                 options = options || {};
    
                 var groupParts = groupStr.split(","),
                 results = [];
    
    
                 angular.forEach(groupParts, function(part, partIndex){
                 var partMatch = part.match(/^(\w{2})=(.*)/);
                 if (partMatch && partMatch[1] !== "DC"){
                 results.splice(0, 0, "<a href='#/d/investigate/group_membership?user_groups.group_dn=" +
                 encodeURIComponent("$" + getGroupLinkDn(groupParts, partIndex).replace(/,/g, "_;_")) + "'>" +
                 partMatch[2] + "</a>");
                 }
                 });
    
                 return results.join(options.divider || " &gt; ");
                 },
                 */
                ou: function (ouStr, options) {
                    if (!ouStr) {
                        return "";
                    }
                    options = options || {};
                    var ous = ouStr.split(","), results = [], ouMatch = /^OU=(.*)$/;
                    angular.forEach(ous, function (ou) {
                        var match = ou.match(ouMatch);
                        if (match) {
                            results.push(match[1]);
                        }
                    });
                    return results.join(options.divider || " &gt; ");
                },
                round: function (number) {
                    return parseInt(number, 10);
                },
                string: function (str, options) {
                    if (options && options.regExp) {
                        return str.replace(new RegExp(options.regExp), options.replaceWith);
                    }
                    return str;
                },
                stringDate: function (value, options) {
                    var transformed = methods.date(value, options);
                    return methods.string(transformed, options);
                },
                transformParams: function (params, paramsTransform) {
                    var transformedParams = angular.copy(params);
                    if (paramsTransform) {
                        var transform;
                        transformedParams = {};
                        for (var paramName in paramsTransform) {
                            if (paramsTransform.hasOwnProperty(paramName)) {
                                transform = paramsTransform[paramName];
                                if (params[paramName] !== undefined) {
                                    transformedParams[paramName] = methods[transform.type](params[paramName], transform);
                                }
                            }
                        }
                    }
                    return transformedParams;
                },
                transformValue: function (value, transformSettings) {
                    var method = methods[transformSettings.method];
                    if (!method) {
                        throw new Error("Invalid transform method: ", transformSettings.method);
                    }
                    return method(value, transformSettings.options);
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Icons", ["Conditions", "Format", "Styles"])
        .factory("icons", ["$q", "$http", "conditions", "format", "styles", "utils",
        function ($q, $http, conditions, format, styles, utils) {
            var savedIcons, onLoad = [], loadingData;
            function getSavedIcon(presetName) {
                if (savedIcons) {
                    if (savedIcons[presetName]) {
                        return $q.when(savedIcons[presetName]);
                    }
                    else {
                        return $q.reject("Icon '" + presetName + "' not found.");
                    }
                }
                else {
                    if (loadingData) {
                        var deferred = $q.defer();
                        onLoad.push({ name: presetName, deferred: deferred });
                        return deferred.promise;
                    }
                    loadingData = true;
                    return utils.http.wrappedHttpGet("data/icons.json").then(function (iconsData) {
                        savedIcons = iconsData;
                        onLoad.forEach(function (_onLoad) {
                            getSavedIcon(_onLoad.name).then(function (icon) {
                                _onLoad.deferred.resolve(icon);
                            }, _onLoad.deferred.reject);
                        });
                        return getSavedIcon(presetName);
                    });
                }
            }
            function getIconPresetStyles(iconPreset) {
                var iconItemIndex = 0, iconItem = iconPreset[iconItemIndex], styleParsers = {}, stylePromises = [];
                do {
                    iconItem.__id = iconItemIndex;
                    if (iconItem.style) {
                        stylePromises.push(styles.getParseStyleFunction(iconItem));
                    }
                    else {
                        stylePromises.push($q.when(null));
                    }
                } while (!!(iconItem = iconPreset[++iconItemIndex]));
                return $q.all(stylePromises).then(function (_styleParsers) {
                    _styleParsers.forEach(function (styleParser, i) {
                        if (styleParser) {
                            styleParsers[i] = styleParser;
                        }
                    });
                    return styleParsers;
                });
            }
            function parseIconSync(iconPreset, data, params, styles) {
                var icon = {}, iconItemIndex = 0, iconItem = iconPreset[iconItemIndex];
                do {
                    if (!iconItem.conditions) {
                        icon.type = iconItem.type;
                    }
                    else {
                        var conditionValue, conditionField, dataValue, paramMatch;
                        for (var i = 0, condition; !!(condition = iconItem.conditions[i]); i++) {
                            conditionValue = condition.value;
                            if (/^@/.test(condition.value)) {
                                conditionValue = data[condition.value];
                            }
                            conditionField = condition.field;
                            paramMatch = conditionField.match(/^\{\{([^\}]+)\}\}$/);
                            if (paramMatch) {
                                dataValue = params[paramMatch[1]];
                            }
                            else {
                                dataValue = data[conditionField];
                            }
                            if (condition.fieldType) {
                                dataValue = format[condition.fieldType](dataValue);
                            }
                            if (conditions.validateCondition(dataValue, condition.operator, condition.value)) {
                                icon.type = iconItem.type;
                                break;
                            }
                        }
                    }
                    if (iconItem.tooltip) {
                        icon.tooltip = utils.strings.parseValue(iconItem.tooltip, data, params);
                    }
                    if (icon.type) {
                        if (styles[iconItemIndex]) {
                            icon.style = styles[iconItemIndex](data);
                        }
                        return icon;
                    }
                } while (!!(iconItem = iconPreset[++iconItemIndex]));
                return icon;
            }
            function parseIcon(iconPreset, data, params) {
                return getIconPresetStyles(iconPreset, params).then(function (styles) {
                    return parseIconSync(iconPreset, data, params, styles);
                });
            }
            function getIconParams(iconSettings, data) {
                if (!iconSettings.presetParams) {
                    return {};
                }
                var iconParams = {};
                for (var paramName in iconSettings.presetParams) {
                    if (iconSettings.presetParams.hasOwnProperty(paramName)) {
                        iconParams[paramName] = utils.objects.getObjectByPath(data, iconSettings.presetParams[paramName]);
                    }
                }
                return iconParams;
            }
            var methods = {
                getIcon: function (iconSettings, data) {
                    function parseAndReturnIcon(iconPreset) {
                        var params = getIconParams(iconSettings, data);
                        return parseIcon(iconPreset, data, params).then(function (icon) {
                            if (iconSettings.tooltip) {
                                icon.tooltip = utils.strings.parseValue(iconSettings.tooltip, data, params);
                            }
                            return icon;
                        });
                    }
                    if (typeof (iconSettings) === "string") {
                        return $q.when({ type: iconSettings });
                    }
                    if (iconSettings.type) {
                        return $q.when(iconSettings.type);
                    }
                    else if (iconSettings.map) {
                        var fieldValue = data[iconSettings.mapField];
                        if (fieldValue) {
                            return $q.when(iconSettings.map[fieldValue]);
                        }
                    }
                    else if (iconSettings.preset) {
                        return getSavedIcon(iconSettings.preset).then(parseAndReturnIcon);
                    }
                    else {
                        return parseAndReturnIcon(iconSettings);
                    }
                },
                getIconParsers: function (iconsSettings) {
                    var promises = [];
                    iconsSettings.forEach(function (iconSettings) {
                        promises.push(methods.getParseIconFunction(iconSettings));
                    });
                    return $q.all(promises);
                },
                getParseIconFunction: function (iconSettings) {
                    if (typeof (iconSettings) === "string") {
                        return getSavedIcon(iconSettings).then(function (iconPreset) {
                            return function (data) {
                                return parseIcon(iconPreset, data, getIconParams(iconSettings, data));
                            };
                        }, function (error) {
                            return function () {
                                return { type: iconSettings };
                            };
                        });
                    }
                    else if (iconSettings.preset) {
                        return getSavedIcon(iconSettings.preset).then(function (iconPreset) {
                            var presetCopy = angular.copy(iconPreset);
                            presetCopy.forEach(function (iconItem) {
                                angular.extend(iconItem, iconSettings);
                            });
                            iconPreset = presetCopy;
                            return getIconPresetStyles(iconPreset, iconSettings).then(function (styles) {
                                return function (data) {
                                    var params = getIconParams(iconSettings, data), icon = parseIconSync(iconPreset, data, params, styles);
                                    if (iconSettings.tooltip) {
                                        icon.tooltip = utils.strings.parseValue(iconSettings.tooltip, data, params);
                                    }
                                    return icon;
                                };
                            });
                        });
                    }
                    else {
                        return $q.when(function (data) {
                            return parseIcon(iconSettings, data, getIconParams(iconSettings, data));
                        });
                    }
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Tags", []).factory("tags", ["$q", "utils",
        function ($q, utils) {
            var savedTags;
            var defer;
            function getTags(tagsName, data) {
                if (!tagsName || !data) {
                    return null;
                }
                var tagsObj = angular.isObject(tagsName) && tagsName;
                var tagsConfig = savedTags[tagsObj ? tagsObj.name : tagsName];
                if (!tagsConfig) {
                    return null;
                }
                var usedTags = [], valuesData = {};
                if (tagsObj && tagsObj.values && data[tagsObj.values]) {
                    var tags = data[tagsObj.values];
                    if (typeof (tags) === "string") {
                        tags = tags.split(",");
                    }
                    if (tags.constructor !== Array) {
                        throw new TypeError("Invalid tags, expected an Array but got " +
                            tags.constructor.name + ".");
                    }
                    tags.forEach(function (value) {
                        valuesData[tagsObj.valuesMap && tagsObj.valuesMap[value] || value] = true;
                    });
                }
                tagsConfig.forEach(function (tag) {
                    var fieldName = tagsObj && tagsObj.map && tagsObj.map[tag.field] || tag.field;
                    if (valuesData[fieldName] || data[fieldName]) {
                        usedTags.push(tag);
                    }
                });
                return usedTags;
            }
            var methods = {
                getTagsSync: getTags,
                getTags: function (tagsName, data) {
                    if (savedTags) {
                        return $q.when(getTags(tagsName, data));
                    }
                    else {
                        return methods.initTags().then(function (tags) {
                            return getTags(tagsName, data);
                        });
                    }
                },
                initTags: function () {
                    // Check if it's the first time we're fetching the tags
                    var firstTime = !defer;
                    // If called before, use the same deferred object
                    defer = defer || $q.defer();
                    // If first time, fetch the tags data
                    if (firstTime) {
                        utils.http.wrappedHttpGet("data/tags.json").then(function (tags) {
                            savedTags = tags;
                            // Resolve all of the promises that are waiting for the tags
                            defer.resolve(tags);
                        });
                    }
                    // Always return the same promise
                    // If it was already resolved, it's `.then` will execute immediately
                    // with `tags` data as first param
                    return defer.promise;
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("ChartWidgets", ["Utils", "Styles", "Transforms"])
        .factory("chartWidgetsData", ["$q", "utils", "styles", "transforms", function ($q, utils, styles, transforms) {
            function getPredefinedValues(predefinedValuesSettings) {
                if (predefinedValuesSettings.type === "date") {
                    var dates = utils.date.getDatesSpan(predefinedValuesSettings.first, predefinedValuesSettings.last), timestamps = [];
                    angular.forEach(dates, function (date) {
                        timestamps.push(date.valueOf());
                    });
                    return timestamps;
                }
                return null;
            }
            function isSameValue(type, val1, val2) {
                if (type === "date") {
                    if (!val1 || !val2) {
                        return false;
                    }
                    var moment1 = utils.date.getMoment(val1), moment2 = utils.date.getMoment(val2);
                    return moment1.year() === moment2.year() && moment1.month() === moment2.month() &&
                        moment1.date() === moment2.date();
                }
                return false;
            }
            function isSmallerValue(type, val1, val2) {
                if (type === "date") {
                    if (!val1 || !val2) {
                        return false;
                    }
                    var moment1 = utils.date.getMoment(val1), moment2 = utils.date.getMoment(val2);
                    return !utils.date.compareDates(moment1.toDate(), moment2.toDate()) && moment1 < moment2;
                }
                return false;
            }
            function createDefaultValue(seriesSettings, labelSettings, labelValue) {
                var value = {};
                value[labelSettings.field] = labelValue;
                angular.forEach(seriesSettings, function (series) {
                    value[series.field] = series.default !== undefined ? series.default : null;
                });
                return value;
            }
            function setPredefinedValues(data, seriesSettings, labelSettings) {
                var predefinedValuesSettings = labelSettings.predefinedValues, labelValues = getPredefinedValues(predefinedValuesSettings), labelField = labelSettings.field;
                if (predefinedValuesSettings.type === "date") {
                    while (data.length && isSmallerValue("date", data[0][labelField], labelValues[0])) {
                        data.splice(0, 1);
                    }
                }
                for (var i = 0; i < labelValues.length; i++) {
                    if (!isSameValue(predefinedValuesSettings.type, data[i] && data[i][labelField], labelValues[i])) {
                        data.splice(i, 0, createDefaultValue(seriesSettings, labelSettings, labelValues[i]));
                    }
                }
            }
            function setPercent(data, countField) {
                var total = 0;
                data.forEach(function (item) {
                    var count = item[countField];
                    if (count && !isNaN(count)) {
                        total += count;
                    }
                });
                data.forEach(function (item) {
                    var count = item[countField];
                    if (count && !isNaN(count)) {
                        item._percent = 100 * count / total;
                    }
                });
            }
            return {
                getData: function (view, data, params) {
                    var deferred = $q.defer(), styleDeferreds = [], styleDeferredsMapping = {};
                    var viewData = { chartValues: data };
                    if (view.settings.labels.predefinedValues) {
                        setPredefinedValues(viewData.chartValues, view.settings.series, view.settings.labels);
                    }
                    angular.forEach(view.settings.series, function (series, i) {
                        series._label = utils.strings.parseValue(series.label, data, params, i);
                        if (series.style) {
                            styleDeferredsMapping[String(styleDeferreds.length)] = i;
                            styleDeferreds.push(styles.getParseStyleFunction(series));
                        }
                        if (view.settings.setPercent) {
                            setPercent(viewData.chartValues, series.field);
                        }
                        if (series.tooltip) {
                            viewData.chartValues.forEach(function (item) {
                                item.tooltip = utils.strings.parseValue(series.tooltip, item, params);
                            });
                        }
                    });
                    if (view.settings.legend) {
                        viewData.legend = view.settings.legend;
                    }
                    else if (view.settings.series.length === 1 && view.settings.series[0].legend) {
                        viewData.legend = { items: [] };
                        angular.forEach(data, function (item) {
                            viewData.legend.items.push({ value: utils.strings.parseValue(view.settings.series[0].legend, item, params) });
                        });
                    }
                    angular.forEach(viewData.chartValues, function (item, itemIndex) {
                        if (view.settings.labels.transform) {
                            item._label =
                                transforms[view.settings.labels.transform.method](item[view.settings.labels.field], view.settings.labels.transform.options);
                        }
                        else {
                            item._label = utils.strings.parseValue(view.settings.labels.value, item, params, itemIndex);
                        }
                    });
                    if (view.settings.selectedData) {
                        for (var property in view.settings.selectedData) {
                            if (view.settings.selectedData.hasOwnProperty(property)) {
                                view.settings.selectedData[property] =
                                    utils.strings.parseValue(view.settings.selectedData[property], data, params);
                            }
                        }
                    }
                    if (styleDeferreds.length) {
                        $q.all(styleDeferreds).then(function (styleParsers) {
                            var colorSeries = [];
                            for (var styleDeferredIndex in styleDeferredsMapping) {
                                if (styleDeferredsMapping.hasOwnProperty(styleDeferredIndex)) {
                                    colorSeries.push({
                                        series: view.settings.series[styleDeferredsMapping[styleDeferredIndex]],
                                        styleParser: styleParsers[parseInt(styleDeferredIndex, 10)]
                                    });
                                }
                            }
                            angular.forEach(viewData.chartValues, function (item, itemIndex) {
                                item._style = {};
                                angular.forEach(colorSeries, function (colorSeriesItem) {
                                    item._style[colorSeriesItem.series.field] = colorSeriesItem.styleParser(item);
                                    if (!view.settings.legend && viewData.legend) {
                                        viewData.legend.items[itemIndex].color =
                                            item._style[colorSeriesItem.series.field].color;
                                    }
                                });
                            });
                            deferred.resolve(viewData);
                        });
                    }
                    else {
                        deferred.resolve(viewData);
                    }
                    return deferred.promise;
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Colors", []).factory("colors", [function () {
            var colors = {
                success: "rgb(50, 146, 36)",
                failure: "#D77576"
            };
            var colorMaps = {
                severity: {
                    low: '#80BFF0',
                    medium: '#F1CC37',
                    high: '#F59925',
                    critical: '#D77576'
                },
                scale: ['#D6D6D6', '#880000'],
                binary: ['#D6D6D6', '#880000'],
                sshStatus: {
                    accepted: colors.success,
                    failed: colors.failure
                },
                status: {
                    "success": colors.success,
                    "failure": colors.failure
                }
            };
            var defaultRange = ['#D6D6D6', '#880000'];
            var methods = {
                getScale: function (colorSettings) {
                    if (colorSettings && angular.isObject(colorSettings)) {
                        if (colorSettings.map) {
                            var defaultColor = colorSettings.map._default || "#000000", field = colorSettings.field, map = typeof (colorSettings.map) === "string" ? colorMaps[colorSettings.map] :
                                colorSettings.map;
                            if (!map || !angular.isObject(map)) {
                                throw new Error("Invalid color map, " + colorSettings.map);
                            }
                            return function (d) {
                                var value = angular.isObject(d) ? d[field] : d, mapValue = map[value.toLowerCase()];
                                if (!value || !mapValue) {
                                    return defaultColor;
                                }
                                return mapValue;
                            };
                        }
                        else if (colorSettings.domain) {
                            var rangeCopy;
                            if (colorSettings.range && colorSettings.rangeMap) {
                                var rangeMap = colorMaps[colorSettings.rangeMap];
                                rangeCopy = colorSettings.range && angular.copy(colorSettings.range);
                                if (rangeMap) {
                                    for (var i = 0, color; i < rangeCopy.length; i++) {
                                        color = rangeMap[rangeCopy[i]];
                                        if (color) {
                                            rangeCopy[i] = color;
                                        }
                                    }
                                }
                            }
                            return d3.scale.linear().domain(colorSettings.domain)
                                .range(rangeCopy || colorSettings.range || defaultRange);
                        }
                    }
                    if (colorSettings) {
                        if (colorSettings === "score" || colorSettings === "severity") {
                            return d3.scale.linear().domain([0, 50, 51, 79, 80, 94, 95, 100])
                                .range([
                                colorMaps.severity.low, colorMaps.severity.low,
                                colorMaps.severity.medium, colorMaps.severity.medium,
                                colorMaps.severity.high, colorMaps.severity.high,
                                colorMaps.severity.critical, colorMaps.severity.critical
                            ]);
                        }
                        if (colorSettings === "binary" || colorSettings === "scale") {
                            return d3.scale.linear().domain([0, 1]).range([colorMaps[colorSettings][0],
                                colorMaps[colorSettings][1]]);
                        }
                        var d3Scale = d3.scale[colorSettings];
                        if (d3Scale) {
                            return d3Scale();
                        }
                    }
                    return d3.scale.category20c();
                },
                getColors: function (type) {
                    return type ? colorMaps[type] : colorMaps;
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module('DatePicker', ["Utils"])
        .directive('ofsDatepicker', ["utils", function (utils) {
            return {
                template: '<span><input type="text" ng-model="dateValue" ng-change="onDateValueChange(dateValue)" ' +
                    'class="datepicker" placeholder="{{placeholder}}" ng-class="{ error: isRequired && !currentDate}" /> ' +
                    '<select ng-show="showHours" ng-options="hour.value as hour.label for hour in hours" ng-model="hour"' +
                    ' ng-change="onSelectHour(hour)"></select></span>',
                restrict: 'E',
                require: '?ngModel',
                replace: true,
                scope: {
                    onSelect: "&",
                    isRequired: "=?",
                    endOfDay: "=?",
                    startOfDay: "=?",
                    min: "=?minValue",
                    max: "=?maxValue",
                    showHours: "=?",
                    placeholder: "@"
                },
                link: function postLink(scope, element, attrs, ngModel) {
                    var $input = element.find("input"), currentHour = 0;
                    var MOMENT_DATE_FORMAT = "MM/DD/YYYY", DATEPICKER_DATE_FORMAT = "mm/dd/yy";
                    function setHours(min, max) {
                        scope.min = scope.min || 0;
                        scope.max = scope.max || 24;
                        scope.hours = [];
                        for (var i = scope.min; i <= scope.max; i++) {
                            scope.hours.push({ value: i, label: utils.strings.padLeft(String(i), 2, "0") + ":00" });
                        }
                    }
                    function selectDate(date) {
                        if (scope.onSelect) {
                            scope.onSelect({ date: date });
                        }
                        scope.currentDate = date;
                        ngModel.$setViewValue(date, scope);
                    }
                    function minMaxWatch(datepickerOption) {
                        return function (value) {
                            if (!value) {
                                return;
                            }
                            var currentDate = scope.currentDate;
                            if (!angular.isDate(currentDate) && typeof (scope.currentDate === "string")) {
                                currentDate = utils.date.getMoment(scope.currentDate, null, MOMENT_DATE_FORMAT);
                            }
                            $input.datepicker("option", datepickerOption + "Date", value);
                            if (typeof value === "string") {
                                value = parseInt(value, 10);
                            }
                            if (typeof value === "number") {
                                value = utils.date.getMoment('now').add(value, "days").toDate();
                            }
                            var shouldChange = datepickerOption === "min" ?
                                currentDate.valueOf() >= value.valueOf() :
                                currentDate.valueOf() <= value.valueOf();
                            if (currentDate && value && shouldChange) {
                                $input.val(utils.date.getMoment(currentDate).format(MOMENT_DATE_FORMAT));
                            }
                        };
                    }
                    scope.$on("$destroy", function (e, data) {
                        element.empty();
                        element.off();
                    });
                    ngModel.$render = function () {
                        try {
                            var valueMoment;
                            if (ngModel.$viewValue && ngModel.$viewValue.timeStart && ngModel.$viewValue.timeEnd) {
                                if (utils.date.getDatesSpan(ngModel.$viewValue.timeStart, ngModel.$viewValue.timeEnd).length === 0) {
                                    valueMoment = utils.date.getMoment(ngModel.$viewValue.timeStart);
                                }
                            }
                            if (!valueMoment) {
                                valueMoment = ngModel.$viewValue && utils.date.getMoment(ngModel.$viewValue);
                            }
                            if (valueMoment && valueMoment.isValid()) {
                                scope.dateValue = valueMoment.format(MOMENT_DATE_FORMAT);
                                scope.currentDate = valueMoment.toDate();
                                scope.hour = scope.currentDate.getHours();
                            }
                            else {
                                $input.val("");
                                scope.currentDate = null;
                            }
                        }
                        catch (e) {
                            $input.val("");
                            scope.currentDate = null;
                        }
                        scope.selectedTab = ngModel.$viewValue;
                    };
                    scope.$watch("min", minMaxWatch("min"));
                    scope.$watch("max", minMaxWatch("max"));
                    scope.onSelectHour = function (hour) {
                        currentHour = hour;
                        scope.hour = hour;
                        if (scope.onSelect) {
                            scope.onSelect({
                                date: utils.date.getMoment(scope.currentDate.setHours(hour)).toDate()
                            });
                        }
                    };
                    scope.onDateValueChange = function (value) {
                        if (!value && scope.currentDate) {
                            selectDate(null);
                        }
                    };
                    scope.hour = 0;
                    $input.datepicker({
                        dateFormat: DATEPICKER_DATE_FORMAT,
                        onSelect: function (dateText) {
                            scope.$apply(function () {
                                var date = utils.date.getMoment(dateText, null, MOMENT_DATE_FORMAT);
                                if (scope.endOfDay) {
                                    date.endOf("day");
                                }
                                else if (scope.startOfDay) {
                                    date.startOf("day");
                                }
                                else if (scope.hour) {
                                    date.add(scope.hour, "hours");
                                }
                                selectDate(date.toDate());
                            });
                        }
                    });
                    setHours();
                }
            };
        }]);
}());

(function () {
    'use strict';
    /**
     * Holds the current state of the app - global params.
     * Listens for changes to state in the browser's URL and updates accordingly, then triggers an event.
     * @param $rootScope
     * @param $routeParams
     * @param utils
     * @returns {{currentParams, setParams: setParams}}
     */
    function state($rootScope, $routeParams, $location, $route, $timeout, utils, EventBus) {
        var currentParams = {}, locked = false, 
        // Lock is available to avoid an infinite loop when the service updates the URL.
        // In case the service updates URL, it first locks temporarily the URL listener.
        lockTimeout, eventBus;
        function init() {
            setParams();
            /*
             * Notice the difference between locationChangeSuccess and routeChangeSuccess:
             *
             * locationChangeSuccess is triggered when the URL parameters
             * are changed, i.e. when there's a change after the ?
             * (for example: /#/d/explore/ssh?...)
             *
             * routeChangeSuccess is triggered when the URL route is changed,
             * i.e. when something after the #, but before the ? is changed
             * (for example: /#/d/explore/ssh?... ---> /#/d/explore/vpn)
             */
            $rootScope.$on("$locationChangeSuccess", function (e, params) {
                if (!locked) {
                    setParams();
                }
            });
            $rootScope.$on("$routeChangeSuccess", function (e, params) {
                if (!locked) {
                    setParams();
                }
            });
        }
        function lockUrlListener() {
            $timeout.cancel(lockTimeout);
            locked = true;
            lockTimeout = $timeout(function () {
                locked = false;
            }, 15);
        }
        function setParamsToUrl(params) {
            var paramValue;
            for (var paramName in params) {
                if (params.hasOwnProperty(paramName)) {
                    paramValue = params[paramName];
                    // If the param exists in the URL, remove it.
                    if ($routeParams[paramName]) {
                        $location.search(paramName, null);
                    }
                    // Make sure that the parameter has value.
                    if (paramValue !== null && (typeof paramValue !== 'undefined')) {
                        $location.search(paramName, getParamQueryValue(paramValue));
                    }
                }
            }
        }
        function getParamQueryValue(paramValue) {
            var queryValue;
            if (paramValue.constructor === Array) {
                queryValue = paramValue.map(function (member) {
                    return getParamQueryValue(member);
                });
                queryValue = queryValue.join(",");
            }
            else if (Object(paramValue) === paramValue) {
                queryValue = [];
                for (var p in paramValue) {
                    if (paramValue.hasOwnProperty(p)) {
                        queryValue.push(p + "=" + paramValue[p]);
                    }
                }
                queryValue = queryValue.join(",");
            }
            else {
                queryValue = paramValue;
            }
            return queryValue;
        }
        function getChangedParams(params) {
            var changedParams = {};
            var paramValue;
            for (var p in params) {
                if (params.hasOwnProperty(p)) {
                    paramValue = parseParamValue(params[p]);
                    if (paramValue === "") {
                        paramValue = null;
                    }
                    if (currentParams[p] !== paramValue) {
                        changedParams[p] = paramValue;
                    }
                }
            }
            for (p in currentParams) {
                if (params[p] === null) {
                    changedParams[p] = null;
                }
            }
            return changedParams;
        }
        function parseParamValue(paramValue) {
            var paramValueCopy = angular.copy(paramValue);
            if (Object(paramValueCopy) === paramValueCopy) {
                if (paramValueCopy.constructor === Array) {
                    var arrayMembers = [], property;
                    for (var _i = 0, paramValueCopy_1 = paramValueCopy; _i < paramValueCopy_1.length; _i++) {
                        var member = paramValueCopy_1[_i];
                        if (Object(member) === member) {
                            for (property in member) {
                                if (member.hasOwnProperty(property)) {
                                    arrayMembers.push(property + "=" + member[property]);
                                }
                            }
                        }
                        else {
                            arrayMembers.push(member);
                        }
                    }
                    paramValueCopy = arrayMembers.join(",");
                }
            }
            return paramValueCopy;
        }
        function parseParams(params) {
            var parsedParams = {};
            var paramValue;
            for (var p in params) {
                if (params.hasOwnProperty(p)) {
                    paramValue = params[p];
                    if (paramValue.constructor === Array) {
                        parsedParams[p] = paramValue.join(",");
                    }
                    else {
                        parsedParams[p] = paramValue;
                    }
                }
            }
            return parsedParams;
        }
        function setParams() {
            var changedParams = getChangedParams($routeParams);
            currentParams = parseParams($routeParams);
            notifyParamsChange(changedParams);
        }
        function notifyParamsChange(changedParams) {
            if (eventBus && Object.keys(changedParams).length) {
                eventBus.triggerEvent("stateChange", { params: changedParams });
            }
        }
        function notifyStateChange() {
            if (eventBus) {
                eventBus.triggerEvent("stateChange", {});
            }
        }
        /**
         * Gets a mapping of parameters and returns a flat object with the params and their parsed value according
         * to the data
         * Example:
         * mapParams({ param1: { value: 'Hello {{testParam}}' },
         * param2: { value: 'Not included', setIf: 'nonExistingProperty' } },
         * { testParam: 'World' }) returns { param1: 'Hello World' }
         * @param {Object} paramsMap
         * @param {Object} data
         */
        function mapParams(paramsMap, data) {
            var params = {};
            var paramConfig, useParam, paramValue;
            for (var param in paramsMap) {
                if (paramsMap.hasOwnProperty(param)) {
                    paramConfig = paramsMap[param];
                    useParam = true;
                    if (Object(paramConfig) === paramConfig) {
                        if (paramConfig.setIf) {
                            useParam = !!data[paramConfig.setIf];
                        }
                        if (useParam) {
                            paramValue = paramConfig.dataValue ? data[paramConfig.dataValue] :
                                utils.strings.parseValue(paramConfig.value, data);
                        }
                    }
                    else {
                        paramValue = utils.strings.parseValue(paramConfig, data);
                    }
                    if (useParam) {
                        params[param] = paramValue;
                    }
                }
            }
            return params;
        }
        init();
        var stateObj = {
            get currentParams() {
                return currentParams;
            },
            /**
             * Returns a URL-ready string of params. If params are not specified, uses the current state params.
             * @param params
             */
            getUrlParams: function (params) {
                params = params || currentParams;
                var urlParams = [];
                for (var param in params) {
                    if (param !== "dashboardId" && param !== "entityId") {
                        urlParams.push(param + "=" + encodeURIComponent(getParamQueryValue(params[param])));
                    }
                }
                return urlParams.join("&");
            },
            mapParams: mapParams,
            setParams: function (params, setToUrl, notify) {
                var changedParams = getChangedParams(params);
                if (Object.keys(changedParams).length) {
                    var paramValue;
                    for (var p in changedParams) {
                        if (changedParams.hasOwnProperty(p)) {
                            paramValue = changedParams[p];
                            if (paramValue === null) {
                                delete currentParams[p];
                            }
                            else {
                                currentParams[p] = paramValue;
                            }
                        }
                    }
                    lockUrlListener();
                    if (setToUrl !== false) {
                        setParamsToUrl(params);
                    }
                    if (notify !== false) {
                        notifyParamsChange(changedParams);
                    }
                }
            },
            refresh: function () {
                notifyStateChange();
            }
        };
        eventBus = EventBus.setToObject(stateObj, ["stateChange"]);
        return stateObj;
    }
    state.$inject = ["$rootScope", "$routeParams", "$location", "$route", "$timeout", "utils", "EventBus"];
    angular.module("State", ["Utils", "EventBus"]).factory("state", state);
})();

(function () {
    'use strict';
    angular.module("DAL", ["Version", "Utils", "Config"])
        .factory("DAL", ["$http", "$q", "api", "version", "utils", "configFlags", "$timeout",
        function ($http, $q, api, version, utils, configFlags, $timeout) {
            var runningReports = {};
            var methods = {
                dashboards: {
                    getDashboardById: function (dashboardId) {
                        if (!dashboardId) {
                            return $q.reject("No dashboard ID specified.");
                        }
                        return utils.http.wrappedHttpGet("data/dashboards/" + dashboardId.replace(/\./g, "/") +
                            ".json?v=" + version)
                            .catch(function (error) {
                            var errorMessage = error.status === 404 ?
                                "Dashboard '" + dashboardId + "' not found." :
                                "Can't get dashboard '" + dashboardId + "'. Error: " + error.data;
                            errorMessage += ' Redirecting to Overview.';
                            var err = {
                                message: errorMessage,
                                code: 404,
                                redirectToState: 'overview'
                            };
                            return $q.reject(err);
                        });
                    }
                },
                entities: {
                    getEntity: function (entityId) {
                        return utils.http.wrappedHttpGet("data/entities/" + entityId + ".json?v=" + version)
                            .catch(function (error) {
                            var errorMessage = error.status === 404 ? "Entity '" + entityId + "' not found." :
                                "Can't get entity '" + entityId + "'. Error: " + error.data;
                            return $q.reject(errorMessage);
                        });
                    }
                },
                filters: {
                    getSavedSearch: function (searchId) {
                        var search = localStorage.getItem("search_" + searchId);
                        if (search) {
                            return $q.when(JSON.parse(search));
                        }
                        return $q.reject("Saved search with ID '" + searchId + "' not found.");
                    },
                    getSavedSearches: function () {
                        var searches = [], keyMatch = /^search_/;
                        for (var key in localStorage) {
                            if (localStorage.hasOwnProperty(key)) {
                                if (keyMatch.test(key)) {
                                    searches.push(JSON.parse(localStorage[key]));
                                }
                            }
                        }
                        return $q.when(searches);
                    },
                    save: function (search) {
                        var searchId = search.name.toLowerCase().replace(/\W/g, "_"), storageKey = "search_" + searchId;
                        if (localStorage[storageKey] && !confirm('A search named "' + search.name +
                            '" already exists. Overwrite?')) {
                            return $q.reject("A search named \"" + search.name + "\" already exists.");
                        }
                        search.id = searchId;
                        localStorage.setItem("search_" + searchId, JSON.stringify(search));
                        return $q.when(search);
                        //return utils.http.wrappedHttpPost()
                    },
                    remove: function (search) {
                        var searchId = search.name.toLowerCase().replace(/\W/g, "_"), storageKey = "search_" + searchId;
                        localStorage.removeItem(storageKey);
                        return $q.when(search);
                    }
                },
                reports: {
                    /**
                     * Gets a report config file's contents
                     * @param reportId The ID of the report to get. Dots (.) are replaced with slashes to form
                     * folder paths (user.top_events -> user/top_events.json)
                     * @returns {promise}
                     */
                    getReport: function (reportId) {
                        var deferred = $q.defer();
                        $http.get("data/reports/" + reportId.replace(/\./g, "/") + ".json?v=" + version)
                            .success(deferred.resolve)
                            .error(deferred.reject);
                        return deferred.promise;
                    },
                    /**
                     * Routes the report between mock data or server API. If any of the required params are not
                     * available, returns empty data.
                     * @param report The report object
                     * @param params The report params, each with the value ready to send
                     * @returns {promise}
                     */
                    runReport: function (report, params) {
                        function resolveSameReports(results, error) {
                            var runningReportDeferreds = runningReports[runningReportKey];
                            if (runningReportDeferreds) {
                                runningReportDeferreds.forEach(function (deferred) {
                                    if (error) {
                                        deferred.reject(error);
                                    }
                                    else {
                                        deferred.resolve(results);
                                    }
                                });
                            }
                            delete runningReports[runningReportKey];
                        }
                        function onReportSuccess(results) {
                            resolveSameReports(results);
                            return results;
                        }
                        function onReportError(error) {
                            var errorMessage = error.status === 404 ? "File '" + fileUrl + "' not found." :
                                error.data;
                            resolveSameReports(null, errorMessage);
                            return $q.reject(errorMessage);
                        }
                        // report.delay is used for testing only, to simulate slow requests.
                        if (report.delay) {
                            var reportCopy = report.clone(), deferred = $q.defer();
                            delete reportCopy.delay;
                            $timeout(function () {
                                methods.reports.runReport(reportCopy, params)
                                    .then(deferred.resolve, deferred.reject);
                            }, report.delay);
                            return deferred.promise;
                        }
                        var runningReportKey = JSON.stringify({ report: report, params: params }), runningReportDeferreds = runningReports[runningReportKey];
                        // If the same report is being queried at the moment, there's no need to query it again,
                        // just use the same results:
                        if (runningReportDeferreds) {
                            var reportDeferred = $q.defer();
                            runningReportDeferreds.push(reportDeferred);
                            return reportDeferred.promise;
                        }
                        else {
                            runningReports[runningReportKey] = [];
                        }
                        // Transitioning from the old (mock_data) to the new (mockData)
                        var mockData = report.mockData || report.mock_data;
                        if (mockData && configFlags.mockData) {
                            var urlParams = utils.url.getQuery(params), fileUrl = "data/mock_data/" + utils.strings.parseValue(mockData, {}, params)
                                .replace(/\./g, "/") + ".json?v=" + new Date().valueOf() +
                                (urlParams ? "&" + urlParams : "");
                            return utils.http.wrappedHttpGet(fileUrl)
                                .then(onReportSuccess.bind(report), onReportError);
                        }
                        else {
                            var paramValue;
                            if (report.requiredParams) {
                                for (var i = 0; i < report.requiredParams.length; i++) {
                                    paramValue = params[report.requiredParams[i]];
                                    if (!paramValue && paramValue !== 0) {
                                        return $q.when({
                                            data: [],
                                            total: 0
                                        }).then(onReportSuccess.bind(report), onReportError);
                                    }
                                }
                            }
                            return api.query(report, params, report.options)
                                .then(onReportSuccess.bind(report), onReportError);
                        }
                    }
                },
                widgets: {
                    getWidget: function (widgetId) {
                        return utils.http.wrappedHttpGet("data/widgets/" + widgetId.replace(/\./g, "/") +
                            ".json?v=" + version).catch(function (error) {
                            var errorMessage = error.status === 404 ? "Widget '" + widgetId + "' not found." :
                                "Can't get widget '" + widgetId + "'. Error: " + error.data;
                            return $q.reject(errorMessage);
                        });
                    }
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    /**
     * Handles data requests from/to the Fortscale API
     * @param $q
     * @param $resource
     * @param $rootScope
     * @param utils
     * @returns {{query: queryApi}}
     */
    function api($q, $resource, $rootScope, utils) {
        function getParamsData(data) {
            var resourceParams = ["entity", "id", "method"], params = {}, paramsData = {};
            for (var paramName in data) {
                if (data.hasOwnProperty(paramName)) {
                    if (~resourceParams.indexOf(paramName)) {
                        params[paramName] = data[paramName];
                    }
                    else {
                        paramsData[paramName] = data[paramName];
                    }
                }
            }
            return { data: paramsData, params: params };
        }
        function queryApi(query, params, options) {
            var timeStart = new Date();
            function promiseSuccess(queryResult) {
                if (angular.isObject(queryResult)) {
                    queryResult.time = new Date() - timeStart;
                }
                return queryResult || $q.reject("No response received for query: " + JSON.stringify(query));
            }
            function promiseError(error) {
                if (error.status === 401 || error.status === 403) {
                    $rootScope.$broadcast("authError", error.data || { status: error.status });
                    return $q.reject("Authentication error.");
                }
                if (error.status === 404) {
                    return $q.reject("API unavailable.");
                }
                if (typeof (error) === "string") {
                    return $q.reject(error);
                }
                return $q.reject("API call failed: " + error.data.message + " (" + error.data.code + ")." +
                    (error.data.developerMessage ? " Description: " + error.data.developerMessage : ""));
            }
            if (typeof (query.path) === "string") {
                return utils.http.wrappedHttpGet(utils.strings.parseValue(query.path, params))
                    .then(promiseSuccess, promiseError);
            }
            var resource = query.endpoint && query.endpoint.subEntityName ? apiWithSubEntityResource : apiResource, resourceData = angular.extend({}, options, params, query.endpoint);
            for (var property in resourceData) {
                if (resourceData.hasOwnProperty(property)) {
                    if (angular.isString(resourceData[property])) {
                        if (property === "query" && options && options.isCount) {
                            continue;
                        }
                        else if ((!options || !options.isCount) && property === "countQuery") {
                            continue;
                        }
                        resourceData[property] = utils.strings.parseValue(resourceData[property], {}, params);
                    }
                }
            }
            if (resourceData.paging) {
                var page = resourceData.paging.param ?
                    params[resourceData.paging.param] && parseInt(params[resourceData.paging.param], 10) :
                    utils.strings.parseValue(resourceData.paging.page, {}, params);
                resourceData.size = resourceData.limit = resourceData.size || resourceData.paging.pageSize || 10;
                resourceData.page = page || 0;
                resourceData.offset = ((page - 1) * resourceData.size) || 0;
                delete resourceData.paging;
            }
            if (query.method && query.method.toLowerCase() === "post") {
                var resourcesParams = getParamsData(resourceData);
                return resource.save(resourcesParams.params, resourcesParams.data).$promise
                    .then(promiseSuccess, promiseError);
            }
            else if (query.openInIframe) {
                var IFRAME_ID = "reportIframe";
                var iframe = document.querySelector("#" + IFRAME_ID);
                if (!iframe) {
                    iframe = document.createElement('iframe');
                    iframe.id = IFRAME_ID;
                    iframe.style.display = 'none';
                    document.body.appendChild(iframe);
                }
                var iframeSrc = "/fortscale-webapp/api/" + resourceData.api + "?", queryParams = [];
                for (var paramName in resourceData) {
                    if (resourceData.hasOwnProperty(paramName)) {
                        var paramValue = resourceData[paramName];
                        if (angular.isObject(paramValue)) {
                            paramValue = JSON.stringify(paramValue);
                        }
                        if (paramValue !== null && paramValue !== undefined && paramValue !== "") {
                            queryParams.push(paramName + "=" + encodeURIComponent(paramValue));
                        }
                    }
                }
                iframeSrc += queryParams.join("&");
                iframe.src = iframeSrc;
                var deferred = $q.defer();
                deferred.resolve({});
                return deferred.promise.then(promiseSuccess, promiseError);
            }
            else {
                return resource.get(resourceData).$promise.then(promiseSuccess, promiseError);
            }
        }
        var apiResource = $resource("/fortscale-webapp/api/:api/:entity/:id/:method", {
            id: "@id"
        });
        var apiWithSubEntityResource = $resource("" +
            "/fortscale-webapp/api/:api/:entity/:id/:subEntityName/:subEntityId/:method", {
            id: "@id",
            subEntityName: "@subEntityName",
            subEntityId: "@subEntityId"
        });
        return {
            query: queryApi
        };
    }
    api.$inject = ["$q", "$resource", "$rootScope", "utils"];
    angular.module("DAL").factory("api", api);
})();

(function () {
    'use strict';
    angular.module("FSHighChart", ["Colors", "Utils"]).service('fsHighChartService', function () {
        var basicConfiguration;
        /**
         * Init static highchart settings
         * Define the init and execute it
         */
        var init = function () {
            /**
             * Workaround - when have multi highcharts and you print one of them-
             * all the other are shrink.
             * This workaround taken from: https://github.com/highslide-software/highcharts.com/issues/1093
             */
            Highcharts.setOptions({
                chart: {
                    events: {
                        //When any chart trigger "afterPrint" event, we manually iterate all the charts and operate the
                        // "reflow" method.
                        afterPrint: function () {
                            Highcharts.charts.forEach(function (chart) {
                                if (chart !== undefined) {
                                    chart.reflow();
                                }
                            });
                        }
                    }
                }
            });
            basicConfiguration = {
                "chart": {},
                "series": [],
                "title": {
                    //Must be empty, if we will remove it, highchart will generate default title
                    "text": ""
                },
                "credits": {
                    //Payment license, no credits needed.
                    "enabled": false
                },
                tooltip: {
                    enabled: false
                },
                // Fortscale as default loading mechanism, no need to use loading of highchart.
                "loading": false,
                "size": {}
            };
        };
        this.getBasicChartConfiguration = function () {
            return angular.copy(basicConfiguration);
        };
        init();
    });
}());

(function () {
    'use strict';
    var LOW = "low";
    var MEDIUM = "medium";
    var HIGH = "high";
    var CRITICAL = "critical";
    var LOW_SCORE = 50;
    var MEDIUM_SCORE = 80;
    var HIGH_SCORE = 95;
    var CRITICAL_SCORE = 101;
    var LOW_COLOR = "#80BFF0";
    var MEDIUM_COLOR = "#F1CD37";
    var HIGH_COLOR = "#F78D1B";
    var CRITICAL_COLOR = "#D77576";
    //Pay attention- changing the order of the score colors in the array will change the order of the legend
    var SCORE_COLOR_META_DATA = {
        critical: {
            name: CRITICAL,
            color: CRITICAL_COLOR,
            minScore: HIGH_SCORE,
            maxScore: CRITICAL_SCORE
        },
        high: {
            name: HIGH,
            color: HIGH_COLOR,
            minScore: MEDIUM_SCORE,
            maxScore: HIGH_SCORE
        },
        medium: {
            name: MEDIUM,
            color: MEDIUM_COLOR,
            minScore: LOW_SCORE,
            maxScore: MEDIUM_SCORE
        },
        low: {
            name: LOW,
            color: LOW_COLOR,
            minScore: 0,
            maxScore: LOW_SCORE
        }
    };
    var COLORS_RANGE_BLUE = ['#A4C0FC', '#6E9AF5', '#5786EB', '#2661E0', '#0441C4', '#032B80'];
    angular.module("FSHighChart").constant('SCORE_COLOR_META_DATA', SCORE_COLOR_META_DATA);
    angular.module("FSHighChart").constant('COLORS_RANGE_BLUE', COLORS_RANGE_BLUE);
})();

angular.module("Menus", ["Utils", "Version", "Conditions"]);

(function () {
    'use strict';
    angular.module("Menus").factory("Menu", ["dynamicMenus", function (dynamicMenus) {
            function Menu(config) {
                this.validate(config);
                parseDynamicMenuItems(config);
                this.items = config.items;
                this.id = config.id;
                if (config.name) {
                    this.text = config.name;
                }
            }
            Menu.prototype.validate = function (config) {
                if (!config) {
                    return;
                }
                var ERROR_PREFIX = "Can't create Menu, ";
                if (!config.id) {
                    throw new Error(ERROR_PREFIX + "missing ID.");
                }
                if (typeof (config.id) !== "string") {
                    throw new TypeError(ERROR_PREFIX + "expected a string ID but got " + typeof (config.id));
                }
                if (!config.items) {
                    throw new Error(ERROR_PREFIX + "missing the items array.");
                }
                if (config.items.constructor !== Array) {
                    throw new TypeError(ERROR_PREFIX + " expected an array for items.");
                }
                for (var _i = 0, _a = config.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.dynamicMenu) {
                        continue;
                    }
                    if (Object(item) !== item) {
                        throw new TypeError(ERROR_PREFIX + "invalid item config, expected an object but got " + item);
                    }
                    if (!item.text && !item.name) {
                        throw new Error(ERROR_PREFIX + "missing text for item.");
                    }
                    if (!item.url && !item.onSelect) {
                        throw new Error(ERROR_PREFIX + "a menu item must have either a url or onSelect properties.");
                    }
                }
            };
            function parseDynamicMenuItems(menuConfig) {
                dynamicMenus.setDynamicMenus(menuConfig.items);
            }
            return Menu;
        }]);
})();

(function () {
    'use strict';
    function menusFactory($q, utils, version, conditions, Menu) {
        var menus = {}, onMenuLoad = {};
        function getMenu(menu, settings, data, params) {
            var menuItems = [], itemsData = angular.copy(data), menuInstance = angular.copy(menu);
            if (settings.params) {
                var param;
                for (var paramName in settings.params) {
                    if (settings.params.hasOwnProperty(paramName)) {
                        param = settings.params[paramName];
                        if (typeof (param) === "string") {
                            itemsData[paramName] = utils.strings.parseValue(settings.params[paramName], data, params);
                        }
                        else if (angular.isObject(param) && param.dashboardParam) {
                            itemsData[paramName] = params[param.dashboardParam];
                        }
                    }
                }
            }
            menu.items.forEach(function (item, i) {
                var itemCopy = angular.copy(item);
                if (!item.conditions || conditions.validateConditions(item.conditions, itemsData, params)) {
                    itemCopy.text = utils.strings.parseValue(item.text || item.name, itemsData, params, i);
                    if (item.url) {
                        itemCopy.href = utils.strings.parseValue(item.url, itemsData, params);
                        if (itemCopy.href === window.location.href ||
                            utils.url.haveTheSameHash(itemCopy.href, window.location.href)) {
                            return true;
                        }
                    }
                    menuItems.push(itemCopy);
                }
            });
            if (!menuItems.length) {
                return null;
            }
            menuInstance.items = menuItems;
            menuInstance.params = settings.params;
            return menuInstance;
        }
        var methods = {
            getMenuById: function (menuId) {
                if (menus[menuId]) {
                    return $q.when(new Menu(utils.objects.copy(menus[menuId])));
                }
                if (onMenuLoad[menuId]) {
                    var deferred = $q.defer();
                    onMenuLoad[menuId].push({ menuId: menuId, deferred: deferred });
                    return deferred.promise;
                }
                onMenuLoad[menuId] = [];
                return utils.http.wrappedHttpGet("data/menus/" + menuId.replace(/\./g, "/") + ".json?v=" +
                    version).then(function (menu) {
                    menus[menuId] = menu;
                    var menuObj = new Menu(utils.objects.copy(menu));
                    if (onMenuLoad[menuId].length) {
                        onMenuLoad[menuId].forEach(function (onLoad) {
                            onLoad.deferred.resolve(menuObj);
                        });
                    }
                    return menuObj;
                });
            },
            getMenu: function (menuSettings, data, params) {
                if (menuSettings.id) {
                    return methods.getMenuById(menuSettings.id).then(function (menu) {
                        return getMenu(menu, menuSettings, data, params);
                    });
                }
                return getMenu(menuSettings, menuSettings, data, params);
            },
            getMenuParser: function (menuSettings) {
                if (!menuSettings.id) {
                    return $q.when(menuSettings);
                }
                return this.getMenuById(menuSettings.id).then(function (menu) {
                    return function (data, params) {
                        return getMenu(menu, menuSettings, data, params);
                    };
                });
            },
            initMenu: function (menuId) {
                return methods.getMenuById(menuId);
            },
            initMenus: function (menuIds) {
                if (!menuIds || !menuIds.length) {
                    return $q.when(null);
                }
                var promises = [];
                menuIds.forEach(function (menuId) {
                    promises.push(methods.initMenu(menuId));
                });
                return $q.all(promises);
            }
        };
        return methods;
    }
    menusFactory.$inject = ["$q", "utils", "version", "conditions", "Menu"];
    angular.module("Menus").factory("menus", menusFactory);
})();

(function () {
    'use strict';
    function dynamicMenus(dataEntities, utils, state) {
        /**
         * Iterates over an array of menu items and replaces dynamic menus with entities menu items
         * @param menuItems
         * @param params
         */
        function setDynamicMenus(menuItems, params) {
            var newIndices = [];
            params = params || state.currentParams;
            menuItems.forEach(function (menuItem, index) {
                if (menuItem.dynamicMenu) {
                    newIndices.push({
                        index: index,
                        newItems: getBaseEntityDynamicMenu(menuItem.dynamicMenu)
                    });
                }
                else if (menuItem.children) {
                    setDynamicMenus(menuItem.children);
                }
            });
            // It's done from the end to the start because the size of navData changes while looping:
            for (var itemsMap, i = newIndices.length - 1; i >= 0; i--) {
                itemsMap = newIndices[i];
                utils.arrays.replace(menuItems, itemsMap.index, itemsMap.newItems);
            }
            menuItems.forEach(function (menuItem) {
                if (menuItem.url) {
                    menuItem.href = utils.strings.parseValue(menuItem.url, {}, params);
                }
            });
        }
        /**
         * Given a dynamic menu configuration, with base entity, returns an array of menu items for all extending
         * (non-abstract) entities. Each menu item has 'name' and 'url' properties.
         * @param dynamicMenuConfig
         * @returns {*}
         */
        function getBaseEntityDynamicMenu(dynamicMenuConfig) {
            if (!dynamicMenuConfig) {
                throw new Error("Can't create base entity dynamic menu items - missing dynamicMenuConfig.");
            }
            if (!dynamicMenuConfig.baseEntity || dynamicMenuConfig.baseEntity.length === 0) {
                throw new Error("Can't get base entity dynamic menu items - no base entity specified.");
            }
            if (!dynamicMenuConfig.name || !dynamicMenuConfig.url) {
                throw new Error("Can't create dynamic menu items for base entity, 'name' and 'url' are required.");
            }
            // Go over all base entities to collect extending entities for menu
            var menuItems = [];
            // gets entity and returns item that represents menu item
            function extractMenuDataFromEntity(entity) {
                return {
                    name: utils.strings.parseValue(dynamicMenuConfig.name, { entity: entity }).replace(/\\\\/g, ""),
                    url: utils.strings.parseValue(dynamicMenuConfig.url, { entity: entity }).replace(/\\\\/g, "")
                };
            }
            var leafEntities;
            for (var index = 0; index < dynamicMenuConfig.baseEntity.length; index++) {
                // get extending entities of base entity
                leafEntities = dataEntities.getExtendingEntities(dynamicMenuConfig.baseEntity[index]);
                // create menu item for each extended entity
                menuItems = menuItems.concat(leafEntities.map(extractMenuDataFromEntity));
            }
            return menuItems;
        }
        return {
            setDynamicMenus: setDynamicMenus
        };
    }
    dynamicMenus.$inject = ["dataEntities", "utils", "state"];
    angular.module("Menus").factory("dynamicMenus", dynamicMenus);
})();

angular.module("Controls", ["Utils", "Conditions", "EventBus", "State"]);

(function () {
    'use strict';
    var controlTypes = new Set(["search", "constant", "date", "dateRange", "number", "select", "checklist", "duration",
        "buttonSelect", "checkbox", "multiSelect", "paging", "simplePagination", "text"]);
    function ControlClass() {
        function Control(config) {
            this.validate(config);
            this._config = config;
            this.hide = config.hide;
            /**
             * The type of the control. Has to be one of the known control types, in the controlTypes Set above.
             * @type {config.type|*}
             */
            this.type = config.type;
            /**
             * The name of the param this Control controls.
             */
            this.param = config.param;
            /**
             * The name of the param this Control controls.
             */
            this.paramGroup = config.paramGroup;
            /**
             * [Optional] If specified, the url is parsed according to the formatParam string before the param controls
             * are updated.
             */
            this.formatParam = config.formatParam;
            /**
             * If isRequired is true, the param controls can't be updated if the Control has no value.
             * @type {boolean}
             */
            this.isRequired = !!config.isRequired;
            /**
             * If the control need a specific validator which is defined in the filterValidators
             * @type {string}
             */
            if (config.filterValidator) {
                this.filterValidator = config.filterValidator;
            }
            /**
             * If autoUpdate is true, the param controls are updated when the control is changed, no need for the
             * update button
             * @type {boolean}
             */
            this.autoUpdate = !!config.autoUpdate;
            this.disabled = !!config.disabled;
            /**
             * Text to display near the control
             * @type {*|string}
             */
            this.label = config.label && String(config.label);
            /**
             * Text to add by the control template after the control's input
             * @type {parseLanguage.suffix|*|obj.suffix|string}
             */
            this.suffix = config.suffix && String(config.suffix);
            /**
             * type-specific configuration for the control
             * @type {view.settings|*|$scope.view.settings|Function|widgetConfig.settings|exports.translations.settings}
             */
            this.settings = config.settings;
            this.value = config.value;
        }
        Control.prototype.validate = function (config) {
            if (!config.type) {
                throw new Error("Can't create Control, missing the 'type' property.");
            }
            if (!controlTypes.has(config.type)) {
                throw new Error("Unknown Control type, '" + config.type + "'.");
            }
            if (!config.param) {
                throw new Error("Can't create Control, missing the 'param' property.");
            }
            if (typeof (config.param) !== "string") {
                throw new TypeError("Invalid param for Control, expected a string but got " + typeof (config.param) +
                    ".");
            }
            if (config.paramGroup && typeof (config.paramGroup) !== "string") {
                throw new TypeError("Invalid paramGroup for Control, expected a string but got " +
                    typeof (config.paramGroup) + ".");
            }
            if (config.formatParam && typeof (config.formatParam) !== "string") {
                throw new TypeError("Invalid formatParam for Control, expected a string but got " +
                    typeof (config.formatParam) + ".");
            }
        };
        Control.prototype.clone = function () {
            return Control.copy(this);
        };
        Control.copy = function (otherControl) {
            if (!otherControl) {
                throw new Error("No Control provided to copy.");
            }
            if (!(otherControl instanceof Control)) {
                throw new TypeError("Can't copy Control, expected an instance of Control but got " +
                    otherControl.constructor.name + ".");
            }
            return new Control(otherControl._config);
        };
        return Control;
    }
    ControlClass.$inject = [];
    angular.module("Controls").factory("Control", ControlClass);
})();

(function () {
    'use strict';
    function ControlListClass(controls) {
        function ControlList(config) {
            if (!config) {
                return this;
            }
            if (config.constructor === Array) {
                config = { controls: config };
            }
            this.validate(config);
            var controlList = this;
            if (!controlList.controls) {
                controlList.controls = [];
            }
            config.controls.forEach(function (controlConfig) {
                controlList.controls.push(controls.loadControl(controlConfig));
            });
        }
        ControlList.prototype.validate = function (config) {
            if (!config.controls) {
                throw new Error("Can't create ControlList, missing the 'controls' property.");
            }
        };
        ControlList.prototype.getParams = function () {
            var params = {};
            if (!this.controls) {
                return params;
            }
            this.controls.forEach(function (control) {
                controls.getControlValue(control, {}, params);
            });
            return params;
        };
        return ControlList;
    }
    ControlListClass.$inject = ["controls"];
    angular.module("Controls").factory("ControlList", ControlListClass);
})();

(function () {
    'use strict';
    angular.module("Controls").factory("controls", ["Control", "$q", "utils", "conditions", function (Control, $q, utils, conditions) {
            function checkInit() {
                if (!controls) {
                    throw new Error("Controls are not initialized yet.");
                }
            }
            function setControls() {
                controls = new Map();
                window.__controlsConfig__.forEach(function (controlConfig) {
                    var control = new Control(controlConfig);
                    controls.set(controlConfig.controlId, control);
                });
                // Clean-up, remove the temporary controls:
                delete window.__controlsConfig__;
            }
            var controls;
            /**
             * update control specific properties according to control type
             **/
            var controlInitMethods = {
                link: function (control, data, params) {
                    if (!control._href) {
                        control._href = control.href;
                    }
                    control.href = utils.strings.parseValue(control._href, data, params);
                    control.text = utils.strings.parseValue(control.text, data, params);
                },
                select: function (control) {
                    function checkConditions(option) {
                        return !(option.conditions && !conditions.validateConditions(option.conditions, null, null));
                    }
                    if (!control.settings._options) {
                        control.settings._options = control.settings.options;
                    }
                    control.settings._options = control.settings._options.filter(checkConditions);
                    control.settings.options = control.settings._options.map(function (option) {
                        var parsedOption = {};
                        if (Object(option) === option) {
                            if (option.label === undefined && option.value === undefined) {
                                throw new Error("Can't create select control, option missing value and label.");
                            }
                            parsedOption.label = String(option.label || option.value);
                            parsedOption.value = option.value && String(option.value);
                        }
                        else {
                            parsedOption.label = String(option);
                            parsedOption.value = String(option);
                        }
                        return parsedOption;
                    });
                }
            };
            // Getting pre-loaded controls:
            if (window.__controlsConfig__) {
                setControls();
            }
            return {
                getControlById: function (controlId) {
                    checkInit();
                    // Because of the caching mechanism, there was reuse of controls, which lead to shared behavior
                    // between controls. Changed to a deep copy, instead of returning a reference Originally: return
                    // controls.get(controlId);
                    return angular.copy(controls.get(controlId));
                },
                loadControl: function (controlConfig) {
                    if (controlConfig instanceof Control) {
                        return controlConfig.clone();
                    }
                    if (controlConfig.controlId) {
                        var existingControl = this.getControlById(controlConfig.controlId);
                        var fullControlConfig = angular.extend({}, existingControl._config, controlConfig);
                        return new Control(fullControlConfig);
                    }
                    else {
                        var controlInit = controlInitMethods[controlConfig.type];
                        if (controlInit) {
                            controlInit(controlConfig);
                        }
                        return new Control(controlConfig);
                    }
                },
                /**
                 * Inits the entities. This should be done before any usage of other methods in this service.
                 * Runs in the Loader app, NOT in Fortscale app!
                 * @returns {*}
                 */
                initControl: function (controlId) {
                    if (controls.has(controlId)) {
                        return $q.when(angular.copy(controls.get(controlId)));
                    }
                    return utils.http.wrappedHttpGet("data/controls/" + controlId.replace(/\./g, "/") +
                        ".json").then(function (resourceControlConfig) {
                        return resourceControlConfig;
                    }, function (error) {
                        var errorMessage = error.status === 404 ?
                            "Control '" + controlId + "' not found." :
                            "Can't get control '" + controlId + "'. Error: " + error.data;
                        return $q.reject(errorMessage);
                    });
                },
                /*
                 *
                 * Loads all the currently known param, done manually, since there is no way to load all file exists
                 * in a folder.
                 *
                 */
                initControls: function () {
                    controls = new Map();
                    var controlPromise = [this.initControl("account_properties"), this.initControl("minscore"),
                        this.initControl("user_types")];
                    return $q.all(controlPromise).then(function (promise) {
                        var array = [];
                        promise.forEach(function (controlConfig) {
                            array.push(controlConfig);
                        });
                        window.__controlsConfig__ = array;
                    });
                },
                /*
                 *
                 * Load params according to given configuration
                 *
                 */
                loadControls: function (controlsToLoad) {
                    if (!controls) {
                        return null;
                    }
                    controlsToLoad.forEach(function (control, i) {
                        if (control.controlId && !control._ready) {
                            var loadedControl = this.getControlById(control.controlId) || {};
                            controls[i] = jQuery.extend(true, loadedControl, control);
                            controls[i]._ready = true;
                            var controlInit = controlInitMethods[control.type];
                            if (controlInit) {
                                controlInit(control);
                            }
                        }
                    });
                    return controlsToLoad;
                },
                /*
                 *
                 * Load params according to given configuration
                 *
                 */
                getControlValue: function (control, inputParams, outputParams) {
                    var paramValue = this.getControlValueForParam(control, inputParams);
                    if (control.paramGroup) {
                        var groupParamValue = control.param + "=" +
                            ((paramValue === null) || (typeof paramValue === 'undefined') ? "_null_" : paramValue);
                        if (!outputParams[control.paramGroup]) {
                            outputParams[control.paramGroup] = groupParamValue;
                        }
                        else {
                            outputParams[control.paramGroup] += "," + groupParamValue;
                        }
                    }
                    else {
                        outputParams[control.param] = paramValue;
                    }
                },
                /**
                 * Returns the value to be used in the param the specified control is for. The return value is a string.
                 * @param control
                 * @param params
                 * @returns {String|undefined}
                 */
                getControlValueForParam: function (control, params) {
                    if (!control.value && control.value !== 0) {
                        return;
                    }
                    var value = angular.copy(control.value);
                    var timeStart;
                    var timeEnd;
                    if (angular.isArray(value)) {
                        if (!value.length) {
                            return;
                        }
                        value = value.join(",");
                    }
                    // If we have a format, parse it and return the result
                    if (control.formatParam) {
                        return utils.strings.parseValue(control.formatParam, {
                            value: control.value
                        }, params);
                    }
                    if (control.type === "date") {
                        if (control.settings && control.settings.endOfDay) {
                            timeEnd = angular.isDate(value) ? value : parseInt(value, 10);
                            value = utils.date.getMoment(timeEnd).endOf("day").valueOf();
                        }
                        else if (control.settings && control.settings.startOfDay) {
                            timeStart = angular.isDate(value) ? value : parseInt(value, 10);
                            value = utils.date.getMoment(timeStart).startOf("day").valueOf();
                        }
                    }
                    else if (control.type === "dateRange") {
                        // Get time values of the start of the day and end of the day
                        timeStart = utils.date.getMoment(value.timeStart)
                            .startOf("day").valueOf();
                        timeEnd = utils.date.getMoment(value.timeEnd)
                            .endOf("day").valueOf();
                        value = timeStart + "," + timeEnd;
                    }
                    return value;
                }
            };
        }]);
}());

angular.module("DataEntities", ["Utils", "Config"]);

(function () {
    'use strict';
    angular.module("DataEntities").factory("DataEntity", ["DataEntityField", "DataEntitySort", function (DataEntityField, DataEntitySort) {
            function DataEntity(config) {
                if (config) {
                    this.validate(config);
                    this.name = config.name;
                    this.id = config.id;
                    this.baseEntityId = config.extendsEntity;
                    this.isAbstract = config.isAbstract;
                    this.showInExplore = config.showInExplore;
                    this.fields = new Map();
                    for (var _i = 0, _a = config.fields; _i < _a.length; _i++) {
                        var field = _a[_i];
                        this.fields.set(field.id, new DataEntityField(field, this));
                    }
                    // link scoredFields:
                    var scoreFieldId;
                    for (var _b = 0, _c = Array.from(this.fields.values()); _b < _c.length; _b++) {
                        field = _c[_b];
                        if (!!(scoreFieldId = field.scoreField)) {
                            field.scoreField = this.fields.get(scoreFieldId);
                            if (!field.scoreField) {
                                throw new Error("Can't create DataEntity, score field '" + scoreFieldId +
                                    "' not found.");
                            }
                        }
                    }
                    this.eventsEntity = config.eventsEntity || null;
                    this.sessionEntity = config.sessionEntity || null;
                    this.requiredFields = config.requiredFields || [];
                    this.nameForMenu = config.nameForMenu || null; //nameForMenu is sometimes different than entity
                    // name. for example: name: 'SSH'. nameForMenu: 'SSH
                    // events'
                    if (config.defaultSort) {
                        var sort = config.defaultSort;
                        if (sort.constructor !== Array) {
                            sort = [sort];
                        }
                        this.defaultSort = sort.map(function (sortField) {
                            return new DataEntitySort(sortField);
                        });
                    }
                    // TODO: Get this from the server!!
                    if (this.fields.has("event_score") || this.fields.has("session_score")) {
                        this.performanceField = {
                            field: this.fields.get("event_score") || this.fields.get("session_score"),
                            value: 50
                        };
                    }
                }
            }
            DataEntity.prototype.validate = function (config) {
                if (Object(config) !== config) {
                    throw new TypeError("Invalid configuration for DataEntity, expected an object, got " +
                        typeof (config) + ".");
                }
                if (config.name) {
                    if (typeof (config.name) !== "string") {
                        throw new TypeError("Invalid name for DataEntity, expected a string but got " +
                            typeof (config.name));
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntity, missing the 'name' property.");
                }
                if (config.id) {
                    if (typeof (config.id) !== "string") {
                        throw new TypeError("Invalid id for DataEntity, expected a string but got " +
                            typeof (config.id));
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntity, missing the 'id' property.");
                }
                if (config.extends) {
                    if (typeof (config.extends) !== "string") {
                        throw new TypeError("Invalid extends for DataEntity, expected a string but got " +
                            typeof (config.extends));
                    }
                }
                if (config.fields) {
                    if (config.fields.constructor !== Array) {
                        throw new TypeError("Invalid fields for DataEntity, expected and array but got " +
                            typeof (config.fields));
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntity, missing the 'fields' property.");
                }
                if (config.requiredFields) {
                    if (config.requiredFields.constructor !== Array) {
                        throw new TypeError("Invalid requiredFields for DataEntity. Expected array but got " +
                            typeof (config.requiredFields.constructor));
                    }
                    for (var _i = 0, _a = config.requiredFields; _i < _a.length; _i++) {
                        var field = _a[_i];
                        if (typeof (field) !== "string") {
                            throw new TypeError("Invalid required field for DataEntity. Expected a string but got " +
                                typeof (field));
                        }
                    }
                }
                if (config.eventsEntity && typeof (config.eventsEntity) !== "string") {
                    throw new TypeError("Invalid eventsEntity for DataEntity. Expected a string but got " +
                        typeof (config.eventsEntity));
                }
                if (config.sessionEntity && typeof (config.sessionEntity) !== "string") {
                    throw new TypeError("Invalid sessionEntity for DataEntity. Expected a string but got " +
                        typeof (config.sessionEntity));
                }
            };
            /**
             * Checks whether this DataEntity extends the specified DataEntity by checking the baseEntity tree.
             * @param anotherDataEntity
             * @returns {Boolean}
             */
            DataEntity.prototype.extendsEntity = function (anotherDataEntity) {
                if (!this.baseEntity || !anotherDataEntity || !(anotherDataEntity instanceof DataEntity)) {
                    return false;
                }
                if (this.baseEntity === anotherDataEntity) {
                    return true;
                }
                return this.baseEntity.extendsEntity(anotherDataEntity);
            };
            DataEntity.prototype.__defineGetter__("fieldsArray", function () {
                if (!this._fieldsArray) {
                    this._fieldsArray = [];
                    for (var _i = 0, _a = Array.from(this.fields.values()); _i < _a.length; _i++) {
                        var field = _a[_i];
                        this._fieldsArray.push(field);
                    }
                }
                return this._fieldsArray;
            });
            /**
             * Given a the ID of another DataEntity, returns the possible JOINS between this entity and that one, which
             * can be used in a DataQuery
             * @param entityId
             */
            DataEntity.prototype.getEntityJoin = function (entityId) {
                if (!entityId || typeof (entityId) !== "string") {
                    throw new Error("Invalid joinedEntityId, expected a string but got " + entityId + ".");
                }
                if (entityId === this.id) {
                    return [];
                }
                return (this.linkedEntities || []).filter(function (linkedEntity) {
                    return linkedEntity.entity === entityId;
                });
            };
            return DataEntity;
        }]);
}());

(function () {
    'use strict';
    angular.module("DataEntities").factory("DataEntityField", ["dataEntityFieldTypes", function (dataEntityFieldTypes) {
            /**
             * Constructor for fields in Data Entities
             * @param config
             * @param dataEntity
             * @constructor
             */
            function DataEntityField(config, dataEntity) {
                this.validate(config);
                this.entity = dataEntity;
                this.id = config.id;
                this.name = config.name;
                this.type = dataEntityFieldTypes[config.type.toLowerCase()];
                this.scoreField = config.scoreField || null;
                this.isSearchable = !!config.searchable;
                this.isDefaultEnabled = !!config.isDefaultEnabled;
                this.attributes = config.attributes || [];
                this.tags = config.tags || [];
                this.format = config.format;
                this.valueList = config.valueList;
                this.shownForSpecificEntity = config.shownForSpecificEntity;
                /**
                 * joinFrom and joinTo are keys which are used to connect entities. From and to describe directionality, so
                 * a join can be done only from one entity to another but not in reverse.
                 * @type {null|*}
                 */
                this.joinFrom = config.joinFrom || null;
                this.joinTo = config.joinTo || null;
            }
            DataEntityField.prototype.validate = function (config) {
                if (Object(config) !== config) {
                    throw new TypeError("Invalid configuration for DataEntityField, expected an object, got " +
                        typeof (config) + ".");
                }
                if (config.name) {
                    if (typeof (config.name) !== "string") {
                        throw new TypeError("Invalid name for DataEntityField, expected a string but got " +
                            typeof (config.name));
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntityField, missing the 'name' property.");
                }
                if (config.id) {
                    if (typeof (config.id) !== "string") {
                        throw new TypeError("Invalid id for DataEntityField, expected a string but got " +
                            typeof (config.id));
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntityField, missing the 'id' property.");
                }
                if (config.type) {
                    if (typeof (config.type) !== "string") {
                        throw new TypeError("Invalid type for DataEntityField, expected a string but got " +
                            typeof (config.type) + ".");
                    }
                    if (!dataEntityFieldTypes[config.type.toLowerCase()]) {
                        throw new Error("Can't instantiate DataEntityField, unknown field type, '" + config.type + "'.");
                    }
                }
                else {
                    throw new Error("Can't instantiate DataEntityField, missing the 'id' property.");
                }
                if (config.scoreField) {
                    if (typeof (config.id) !== "string") {
                        throw new TypeError("Invalid scoreField for DataEntityField, expected a string but got " +
                            typeof (config.scoreField) + ".");
                    }
                }
                if (config.valueList) {
                    if (!angular.isArray(config.valueList)) {
                        throw new TypeError("Invalid valueList for DataEntityField, expected and array but got " +
                            config.valueList + ".");
                    }
                }
                if (config.attributes) {
                    if (!angular.isArray(config.attributes)) {
                        throw new TypeError("Invalid attributes for DataEntityField, expected and array but got " +
                            config.attributes + ".");
                    }
                }
                if (config.tags) {
                    if (!angular.isArray(config.tags)) {
                        throw new TypeError("Invalid tags for DataEntityField, expected and array but got " + config.tags +
                            ".");
                    }
                }
            };
            return DataEntityField;
        }]);
}());

(function () {
    'use strict';
    function DataEntitySortClass() {
        function DataEntitySort(config) {
            this.validate(config);
            this.field = config.field.id;
            this.direction = config.direction ? config.direction.toUpperCase() : "ASC";
        }
        DataEntitySort.prototype.validate = function (config) {
            if (!config.field) {
                throw new Error("Can't create DataEntitySort, missing field.");
            }
            if (config.direction) {
                if (typeof (config.direction) !== "string") {
                    throw new TypeError("Invalid 'direction' for DataEntitySort, expected a string but got " +
                        typeof (config.direction));
                }
                var directionStr = config.direction.toUpperCase();
                if (directionStr !== "ASC" && directionStr !== "DESC") {
                    throw new Error("Unknown direction for DataEntitySort, '" + config.direction + "'.");
                }
            }
        };
        return DataEntitySort;
    }
    angular.module("DataEntities").factory("DataEntitySort", DataEntitySortClass);
})();

(function () {
    'use strict';
    angular.module("DataEntities").factory("dataEntities", ["DataEntity", "$q", "utils", "configFlags", function (DataEntity, $q, utils, configFlags) {
            function checkInit() {
                if (!entities) {
                    throw new Error("Entities are not initialized yet.");
                }
            }
            function setEntities() {
                entities = new Map();
                window.__entitiesConfig__.forEach(function (entityConfig) {
                    var entity = new DataEntity(entityConfig);
                    entities.set(entity.id, entity);
                });
                getAllEntities();
                // Set the base entities:
                entities.forEach(function (entity) {
                    if (entity.baseEntityId) {
                        var baseEntity = entities.get(entity.baseEntityId);
                        if (!baseEntity) {
                            throw new Error("Unknown base entity, '" + entity.baseEntityId + "'.");
                        }
                        entity.baseEntity = baseEntity;
                        delete entity.baseEntityId;
                        entity.linkedEntities = getLinkedEntities(entity);
                    }
                });
                // Clean-up, remove the temporary entities:
                delete window.__entitiesConfig__;
            }
            function getEntityById(entityId) {
                checkInit();
                return entities.get(entityId);
            }
            /**
             * Given a DataEntity, returns all entities with which JOIN data queries can be done.
             * @param dataEntity
             */
            function getLinkedEntities(dataEntity) {
                if (!(dataEntity instanceof DataEntity)) {
                    throw new TypeError("Expected an instance of DataEntity, got: " + dataEntity + ".");
                }
                if (!dataEntity._joinFromFields) {
                    dataEntity._joinFromFields = dataEntity.fieldsArray.filter(function (field) {
                        return field.joinFrom;
                    });
                    dataEntity._joinFromFields = utils.objects.arrayToObject(dataEntity._joinFromFields, "joinFrom");
                }
                if (!Object.keys(dataEntity._joinFromFields).length) {
                    return [];
                }
                var linkedEntities = [];
                entitiesArray.forEach(function (entity) {
                    if (entity === dataEntity) {
                        return true;
                    }
                    if (!entity._joinToFields) {
                        entity._joinToFields = entity.fieldsArray.filter(function (entityField) {
                            return entityField.joinTo;
                        });
                        entity._joinToFields = utils.objects.arrayToObject(entity._joinToFields, "joinTo");
                    }
                    for (var joinTo in entity._joinToFields) {
                        if (entity._joinToFields.hasOwnProperty(joinTo)) {
                            if (dataEntity._joinFromFields[joinTo]) {
                                linkedEntities.push({
                                    entity: entity.id,
                                    joinFields: {
                                        left: dataEntity.id + "." + dataEntity._joinFromFields[joinTo].id,
                                        right: entity.id + "." + entity._joinToFields[joinTo].id
                                    }
                                });
                            }
                        }
                    }
                });
                return linkedEntities;
            }
            /**
             * Returns all the non-abstract entities
             * @returns {*}
             */
            function getAllEntities() {
                if (entitiesArray && entitiesArray.length) {
                    return entitiesArray;
                }
                entitiesArray = [];
                for (var _i = 0, _a = Array.from(entities); _i < _a.length; _i++) {
                    var entity = _a[_i];
                    if (!entity[1].isAbstract) {
                        entitiesArray.push(entity[1]);
                    }
                }
                return entitiesArray;
            }
            var entities, entitiesArray;
            // Getting pre-loaded entities:
            if (window.__entitiesConfig__) {
                setEntities();
            }
            return {
                entityExists: function (entityId) {
                    return entities.has(entityId);
                },
                getAllEntities: getAllEntities,
                getEntityById: getEntityById,
                /**
                 * Gets all non-abstract entities that extend the specified base entity
                 * @param baseEntityId
                 * @returns {*}
                 */
                getExtendingEntities: function (baseEntityId) {
                    var baseEntity = entities.get(baseEntityId);
                    if (!baseEntity) {
                        throw new Error("Unknown base entity, '" + baseEntityId + "'.");
                    }
                    if (baseEntity._childEntities !== undefined) {
                        return baseEntity._childEntities;
                    }
                    var childEntities = [];
                    entities.forEach(function (entity) {
                        if (!entity.isAbstract && entity.extendsEntity(baseEntity)) {
                            childEntities.push(entity);
                        }
                    });
                    baseEntity._childEntities = childEntities;
                    return childEntities;
                },
                getLinkedEntities: getLinkedEntities,
                getField: function (entityId, fieldId) {
                    var field;
                    var entity = getEntityById(entityId);
                    if (entity) {
                        field = entity.fields.get(fieldId);
                    }
                    return field;
                }.bind(this),
                /**
                 * Inits the entities. This should be done before any usage of other methods in this service.
                 * Runs in the Loader app, NOT in Fortscale app!
                 * @returns {*}
                 */
                initEntities: function () {
                    if (entities) {
                        return $q.when(entities);
                    }
                    return utils.http.wrappedHttpGet(configFlags.mockData ? "data/mock_data/getentities.json" :
                        "/fortscale-webapp/api/getEntities").then(function (results) {
                        // Put the entities data temporarily in the global scope, since after this the Fortscale
                        // angular app will start
                        window.__entitiesConfig__ = results.data;
                    }, function (error) {
                        console.error("Error getting entities: ", error);
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("DataEntities").factory("QueryOperator", function () {
        function QueryOperator(config) {
            this.validate(config);
            this.id = config.id;
            this.name = config.name;
            this.requiresValue = !!config.requiresValue;
            this.supportsSearch = !!config.supportsSearch;
            this.inputTemplate = config.inputTemplate;
            this.defaultValue = config.defaultValue;
            this.paramOperator = config.paramOperator || "";
            this.valueToParamConfig = config.valueToParam;
            if (this.valueToParamConfig) {
                this.valueToParam = function valueToParam(value, valueType, valueFormat) {
                    if (this.valueToParamConfig.constructor === Function) {
                        return this.valueToParamConfig(value);
                    }
                    else if (this.valueToParamConfig[valueType]) {
                        return this.valueToParamConfig[valueType](value, valueFormat);
                    }
                    return value;
                };
            }
            this.paramToValueConfig = config.paramToValue;
            if (this.paramToValueConfig) {
                this.paramToValue = function paramToValue(param, valueType) {
                    if (this.paramToValueConfig.constructor === Function) {
                        return this.paramToValueConfig(param);
                    }
                    else if (this.paramToValueConfig[valueType]) {
                        return this.paramToValueConfig[valueType](param);
                    }
                    return param;
                };
            }
            //add support in display which is different from the value - relevant currently for duration fields
            this.paramToDisplayValueConfig = config.paramToDisplayValue;
            if (this.paramToDisplayValueConfig) {
                this.paramToDisplayValue = function paramToDisplayValue(param, valueType, valueFormat) {
                    if (this.paramToDisplayValueConfig.constructor === Function) {
                        return this.paramToDisplayValueConfig(param);
                    }
                    else if (this.paramToDisplayValueConfig[valueType]) {
                        return this.paramToDisplayValueConfig[valueType](param, valueFormat);
                    }
                    return undefined;
                };
            }
            this.dataQueryOperator = config.dataQueryOperator || config.id;
            this.validators = config.validators || [];
            this.displayValidators = config.displayValidators || [];
        }
        QueryOperator.prototype.validate = function (config) {
            if (!config.id) {
                throw new Error("Can't create QueryOperator, missing id.");
            }
            if (!config.name) {
                throw new Error("Can't create QueryOperator, missing name.");
            }
            if (config.requiresValue && !config.inputTemplate) {
                throw new Error("Can't create QueryOperator for operator '" + config.name +
                    "', missing inputTemplate.");
            }
            if (config.paramOperator && typeof (config.paramOperator) !== "string") {
                throw new TypeError("Can't create QueryOperator, expected string for paramOperator but got " +
                    typeof (config.paramOperator));
            }
        };
        return QueryOperator;
    });
}());

(function () {
    'use strict';
    angular.module("DataEntities").factory("queryOperators", ["QueryOperator", "utils",
        function (QueryOperator, utils) {
            /**
             * Common handlers
             */
            function durationPrettyTime(paramValue, valueFormat) {
                return utils.duration.prettyTime(paramValue, valueFormat);
            }
            function durationToNumber(value, valueFormat) {
                return utils.duration.durationToNumber(value, valueFormat);
            }
            /**
             * Get date range string of a full day from a single date value
             *
             * @param  {*}      value Any valid value for `utils.date.getMoment`
             * @return {string}       Day start to day end range
             */
            function valueToDateRange(value) {
                var start = utils.date.getMoment(value).startOf('day');
                var end = utils.date.getMoment(value).endOf('day');
                return start + "::" + end;
            }
            /**
             * Get date range object from a date range string
             *
             * @param  {string} paramValue Date range string, as in `valueToDateRange` above
             * @param  {string} operatorId The relevant operator context, used for the error
             * @return {Object}            An object with `timeStart` and `timeEnd` properties
             */
            function parseDateRangeStr(paramValue, operatorId) {
                // Validate input
                if (!(/[^:]+::[^:]+/.test(paramValue))) {
                    throw new Error("Date range value must be in format: 'date::date'");
                }
                var rangeParts = paramValue.split("::");
                var timeStart = utils.date.getMoment(rangeParts[0]);
                var timeEnd = utils.date.getMoment(rangeParts[1]);
                // If range of strings that are not timestamps
                // Shift to start of and end of days
                if (!utils.date.isTimeStamp(rangeParts[0])) {
                    timeStart.startOf('day');
                }
                if (!utils.date.isTimeStamp(rangeParts[1])) {
                    timeEnd.endOf('day');
                }
                // Make sure we have valid dates
                if (!timeStart.isValid() || !timeEnd.isValid()) {
                    throw new Error("Invalid value for " + operatorId +
                        " - one or both dates are invalid: '" + paramValue + "'.");
                }
                return {
                    timeStart: timeStart.toDate(),
                    timeEnd: timeEnd.toDate()
                };
            }
            /**
             * Operators settings
             */
            var operatorsConfig = [
                {
                    id: "equals",
                    name: "=",
                    requiresValue: true,
                    supportsSearch: true,
                    inputTemplate: {
                        string: "string",
                        number: "number",
                        date_time: "date",
                        timestamp: "date",
                        boolean: "boolean",
                        duration: "duration",
                        select: "select"
                    },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        boolean: true,
                        date_time: "now"
                    },
                    valueToParam: {
                        date_time: valueToDateRange,
                        duration: durationToNumber
                    },
                    paramToValue: {
                        date_time: function (paramValue) {
                            return parseDateRangeStr(paramValue, 'EqualsRange');
                        }
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    //notEquals for date relates to a certain day, not timestamp, therefore we need range
                    // -startOfDay and EndofDay. not a single parameter.
                    id: "notEquals",
                    name: "",
                    paramOperator: "!",
                    requiresValue: true,
                    supportsSearch: true,
                    inputTemplate: {
                        string: "string",
                        number: "number",
                        date_time: "date",
                        timestamp: "date",
                        boolean: "boolean",
                        duration: "duration",
                        select: "select"
                    },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        boolean: true,
                        date_time: "now"
                    },
                    valueToParam: {
                        date_time: valueToDateRange,
                        duration: durationToNumber
                    },
                    paramToValue: {
                        date_time: function (paramValue) {
                            return parseDateRangeStr(paramValue, 'notEqualsRange');
                        }
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    id: "in",
                    name: "IN",
                    paramOperator: "[]",
                    text: "=",
                    requiresValue: true,
                    inputTemplate: "stringIn",
                    defaultValue: { string: [] },
                    validators: ["isArrayValidator"],
                    valueToParam: function (value) {
                        return value.map(function (val) {
                            return val.replace(/[|]/g, "~~");
                        }).join("|");
                    },
                    paramToValue: function (paramValue) {
                        if (paramValue === "") {
                            return [];
                        }
                        return paramValue.split("|").map(function (val) {
                            return val.replace(/~~/g, "|");
                        });
                    }
                },
                {
                    id: "contains",
                    name: "Contains",
                    paramOperator: "~",
                    requiresValue: true,
                    inputTemplate: "string"
                },
                {
                    id: "hasValue",
                    name: "Has value",
                    paramOperator: "*",
                    requiresValue: false
                },
                {
                    id: "hasNoValue",
                    name: "Has no value",
                    paramOperator: "!*",
                    requiresValue: false
                },
                {
                    id: "startsWith",
                    name: "Starts With",
                    paramOperator: "^",
                    requiresValue: true,
                    inputTemplate: "string"
                },
                {
                    id: "endsWith",
                    name: "Ends With",
                    paramOperator: "$",
                    requiresValue: true,
                    inputTemplate: "string"
                },
                {
                    id: "regexp",
                    name: "RegExp",
                    paramOperator: "/",
                    requiresValue: true,
                    inputTemplate: "regex"
                },
                {
                    id: "greaterThan",
                    name: ">",
                    paramOperator: ">",
                    requiresValue: true,
                    inputTemplate: { number: "number", date_time: "date", timestamp: "date", duration: "duration" },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        date_time: "now",
                        timestamp: "now",
                        number: 0
                    },
                    valueToParam: {
                        date_time: function (paramValue) {
                            return utils.date.getMoment(paramValue).endOf('day');
                        },
                        duration: durationToNumber
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    id: "greaterThanOrEquals",
                    name: "",
                    paramOperator: ">=",
                    requiresValue: true,
                    inputTemplate: { number: "number", date_time: "date", timestamp: "date", duration: "duration" },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        date_time: "now",
                        timestamp: "now",
                        number: 0
                    },
                    valueToParam: {
                        date_time: function (paramValue) {
                            return utils.date.getMoment(paramValue).startOf('day');
                        },
                        duration: durationToNumber
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    id: "lesserThan",
                    name: "<",
                    paramOperator: "<",
                    requiresValue: true,
                    inputTemplate: { number: "number", date_time: "date", timestamp: "date", duration: "duration" },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        date_time: "now",
                        timestamp: "now",
                        number: 0
                    },
                    valueToParam: {
                        date_time: function (paramValue) {
                            return utils.date.getMoment(paramValue).startOf('day');
                        },
                        duration: durationToNumber
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    id: "lesserThanOrEquals",
                    name: "",
                    paramOperator: "<=",
                    requiresValue: true,
                    inputTemplate: { number: "number", date_time: "date", timestamp: "date", duration: "duration" },
                    validators: { date_time: ["dateValidator"] },
                    displayValidators: { duration: ["isDurationValidator"] },
                    defaultValue: {
                        date_time: "now",
                        timestamp: "now",
                        number: 0
                    },
                    valueToParam: {
                        date_time: function (paramValue) {
                            return utils.date.getMoment(paramValue).endOf('day');
                        },
                        duration: durationToNumber
                    },
                    paramToDisplayValue: {
                        duration: durationPrettyTime
                    }
                },
                {
                    id: "range",
                    dataQueryOperator: "between",
                    name: "Range",
                    paramOperator: "--",
                    requiresValue: true,
                    inputTemplate: "numberRange",
                    validators: ["numberRangeValidator"],
                    valueToParam: function (value) {
                        return value.fromValue + "--" + value.toValue;
                    },
                    paramToValue: function (paramValue) {
                        if (typeof (paramValue) !== "string") {
                            throw new TypeError("Invalid param value for numberRange, expected a string but got " +
                                paramValue);
                        }
                        var rangeParts = paramValue.split("--");
                        if (rangeParts.length !== 2) {
                            throw new Error("Invalid value for numberRange, '" + paramValue + "'.");
                        }
                        return {
                            fromValue: rangeParts[0],
                            toValue: rangeParts[1]
                        };
                    }
                },
                {
                    id: "dateRange",
                    dataQueryOperator: "between",
                    validators: ["dateRangeValidator"],
                    name: "Between",
                    paramOperator: ":",
                    requiresValue: true,
                    inputTemplate: "dateRange",
                    valueToParam: function (value) {
                        var start;
                        var end;
                        // If an object with timeStart and timeEnd
                        if (angular.isObject(value) && value.timeStart && value.timeEnd) {
                            start = utils.date.getMoment(value.timeStart).startOf('day');
                            end = utils.date.getMoment(value.timeEnd).endOf('day');
                        }
                        else {
                            start = utils.date.getMoment(value).startOf('day');
                            end = utils.date.getMoment(value).endOf('day');
                        }
                        return start + '::' + end;
                    },
                    paramToValue: function (paramValue) {
                        return parseDateRangeStr(paramValue, 'dateRange');
                    },
                    defaultValue: {
                        date_time: {
                            timeStart: "-7d",
                            timeEnd: "now"
                        }
                    }
                }
            ];
            var operators = new Map(), paramOperators = {};
            operatorsConfig.forEach(function (operator) {
                var paramOperatorId = operator.paramOperator || "equals";
                // Checking that paramOperators are unique:
                if (paramOperators[paramOperatorId]) {
                    throw new Error("Duplicate param operator: " + paramOperatorId);
                }
                var queryOperator = new QueryOperator(operator);
                operators.set(operator.id, queryOperator);
                paramOperators[paramOperatorId] = queryOperator;
            });
            var logicalOperators = {
                AND: "AND",
                OR: "OR"
            };
            return {
                /**
                 * Given a param value (URL param), returns the used QueryOperator
                 * @param paramValue
                 */
                getParamOperator: function (paramValue) {
                    var paramPrefixMatch = paramValue.match(/^[^\w\d]{1,2}/), operator;
                    if (paramPrefixMatch) {
                        var prefix = paramPrefixMatch[0];
                        // The operator prefix is either one or two characters. First we try to find a
                        // two-character operator, then a single-character, if two isn't found:
                        operator = paramOperators[prefix] || paramOperators[prefix[0]];
                    }
                    return operator || paramOperators.equals;
                },
                get operators() {
                    return operators;
                },
                get logicalOperators() {
                    return logicalOperators;
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("DataEntities").factory("DataEntityFieldType", ["queryOperators", function (queryOperators) {
            /**
             * Constructor that represents a type for dataEntity fields, to be used in DataQueries.
             * Contains the type and its available operators.
             * @param config
             * @constructor
             */
            function DataEntityFieldType(config) {
                this.validate(config);
                this.id = config.id;
                this.name = config.name;
                this.operators = config.operators.map(function (operatorId) {
                    var operator = queryOperators.operators.get(operatorId);
                    if (!operator) {
                        throw new Error("Invalid operator for DataEntityFieldType: " + operatorId);
                    }
                    return operator;
                });
                this.parseValue = config.parser;
            }
            DataEntityFieldType.prototype.validate = function (config) {
                if (!config.id || typeof (config.id) !== "string") {
                    throw new TypeError("Can't crate DataEntityFieldType, expected a string ID.");
                }
                if (!config.name || typeof (config.name) !== "string") {
                    throw new TypeError("Can't crate DataEntityFieldType, expected a string name.");
                }
                if (!config.operators) {
                    throw new Error("Can't create DataEntityFieldType, missing the operators array.");
                }
                if (!config.parser || !(config.parser instanceof Function)) {
                    throw new Error("Can't create DataEntityFieldType, expected a parser function.");
                }
                if (config.operators.constructor !== Array) {
                    throw new TypeError("Invalid operators for DataEntityFieldType, expected an array.");
                }
            };
            DataEntityFieldType.prototype.__defineGetter__("defaultOperator", function () {
                return this.operators[0];
            });
            return DataEntityFieldType;
        }]);
})();

(function () {
    'use strict';
    /**
     * The available types for Data Entity fields. Returns an object, of which each property is the ID of a type
     * ('string', 'boolean', ...). Each type has an ID, name and its possible operators.
     * @param DataEntityFieldType DI for the DataEntityFieldType constructor
     * @param utils DI for the DataEntityFieldType constructor
     * @returns {{boolean: {id: string, name: string, operators: string[]}, string: {id: string, name: string,
     *     operators: string[]}, number: {id: string, name: string, operators: string[]}, date_time: {id: string, name:
     *     string, operators: string[]}, timestamp: {id: string, name: string, operators: string[]}}}
     * @constructor
     */
    function dataEntityFieldTypes(DataEntityFieldType, utils) {
        function dateTimeParser(value) {
            if (value === undefined || value === null) {
                return value;
            }
            // It's a date range:
            if (Object(value) === value && !angular.isDate(value)) {
                if (!value.timeEnd || !value.timeStart) {
                    throw new Error("Invalid object for date, should contain both timeStart and timeEnd.");
                }
                var startMoment = utils.date.getMoment(value.timeStart).startOf("day"), endMoment = utils.date.getMoment(value.timeEnd).endOf("day");
                if (!startMoment.isValid() || !endMoment.isValid()) {
                    throw new Error("Invalid timeStart or timeEnd for date.");
                }
                return { timeStart: startMoment.toDate(), timeEnd: endMoment.toDate() };
            }
            else {
                var momentValue = utils.date.getMoment(value);
                if (momentValue.isValid()) {
                    return momentValue.toDate();
                }
            }
            throw new TypeError("Can't parse value to date_time: " + value + ".");
        }
        function timestampParser(value) {
            if (value === undefined || value === null) {
                return value;
            }
            // It's a timestamp range:
            if (Object(value) === value && !angular.isDate(value)) {
                if (!value.timeEnd || !value.timeStart) {
                    throw new Error("Invalid object for date, should contain both timeStart and timeEnd.");
                }
                var startMoment = utils.date.getMoment(value.timeStart), endMoment = utils.date.getMoment(value.timeEnd);
                if (!startMoment.isValid() || !endMoment.isValid()) {
                    throw new Error("Invalid timeStart or timeEnd for date.");
                }
                return { timeStart: startMoment.toDate(), timeEnd: endMoment.toDate() };
            }
            else {
                var momentValue = utils.date.getMoment(value);
                if (momentValue.isValid()) {
                    return momentValue.toDate();
                }
            }
            throw new TypeError("Can't parse value to date_time: " + value + ".");
        }
        var commonOperators = ["hasValue", "hasNoValue"], dateOperators = ["dateRange", "equals", "notEquals", "greaterThan", "greaterThanOrEquals", "lesserThan",
            "lesserThanOrEquals"];
        var types = {
            "boolean": {
                id: "BOOLEAN",
                name: "Boolean",
                operators: ["equals"],
                parser: function (value) {
                    if (value === undefined || value === null) {
                        return value;
                    }
                    if (value === "true") {
                        return true;
                    }
                    if (value === "false") {
                        return false;
                    }
                    return !!value;
                }
            },
            "string": {
                id: "STRING",
                name: "String",
                operators: ["equals", "notEquals", "contains", "in", "startsWith", "endsWith"],
                parser: function (value) {
                    if (value === undefined || value === null) {
                        return value;
                    }
                    if (typeof (value) === "string") {
                        return value;
                    }
                    if (Object(value) === value) {
                        if (angular.isArray(value)) {
                            return value;
                        }
                        return JSON.parse(value);
                    }
                    return value.toString();
                }
            },
            "number": {
                id: "NUMBER",
                name: "Number",
                operators: ["equals", "notEquals", "greaterThan", "greaterThanOrEquals", "lesserThan",
                    "lesserThanOrEquals", "range"],
                parser: function (value) {
                    //undefiend is whne the filter is not set and should set 0 for numeric default value
                    if (value === undefined || value === 'undefined') {
                        return 0;
                    }
                    //null is defined and handled by changing it to the default value of '0'
                    if (value === null || value === 'null') {
                        return null;
                    }
                    if (angular.isObject(value)) {
                        return value;
                    }
                    return utils.numbers.parse(value);
                }
            },
            //date_time: the time in day resolution.
            "date_time": {
                id: "DATE_TIME",
                name: "Date",
                operators: dateOperators,
                parser: dateTimeParser
            },
            //timestamp: includes also the hours, minutes, etc.
            "timestamp": {
                id: "TIMESTAMP",
                name: "Timestamp",
                operators: dateOperators,
                parser: timestampParser
            },
            //duration is in format hh:mm:ss
            "duration": {
                id: "duration",
                name: "duration",
                operators: ["equals", "notEquals", "greaterThan", "greaterThanOrEquals", "lesserThan",
                    "lesserThanOrEquals"],
                parser: function (value) {
                    return value;
                }
            },
            //select from constant list of values
            "select": {
                id: "select",
                name: "select",
                operators: ["equals", "notEquals"],
                parser: function (value) {
                    return value;
                }
            }
        };
        var type;
        for (var typeId in types) {
            if (types.hasOwnProperty(typeId)) {
                type = types[typeId];
                type.operators = type.operators.concat(commonOperators);
                types[typeId] = new DataEntityFieldType(type);
            }
        }
        return types;
    }
    dataEntityFieldTypes.$inject = ["DataEntityFieldType", "utils"];
    angular.module("DataEntities").factory("dataEntityFieldTypes", dataEntityFieldTypes);
})();

angular.module("DataQueries", ["Conditions", "Utils", "DataEntities"]);

(function () {
    'use strict';
    angular.module("DataQueries").factory("DataQuery", ["utils", "conditions", "dataEntities", "queryOperators", "DataEntity",
        function (utils, conditions, dataEntities, queryOperators, DataEntity) {
            function dateTimeParse(value) {
                if (typeof (value) === "string") {
                    var dateRangeMatch = value.match(dateRangeRegExp);
                    if (dateRangeMatch) {
                        value = { timeStart: parseInt(dateRangeMatch[1]), timeEnd: parseInt(dateRangeMatch[2]) };
                    }
                }
                if (Object(value) === value && !angular.isDate(value)) {
                    return dateTimeParse(value.timeStart) + "," + dateTimeParse(value.timeEnd);
                }
                var _value = value, momentValue = utils.date.getMoment(value);
                if (momentValue.isValid()) {
                    return momentValue.unix();
                }
                return _value;
            }
            function numberRangeParse(value) {
                if (typeof (value) === "number") {
                    return value;
                }
                if (typeof (value) === "string") {
                    var parsedNumber = parseFloat(value);
                    if (!isNaN(parsedNumber)) {
                        return parsedNumber;
                    }
                    var numberRangeMatch = value.match(numberRangeRegExp);
                    if (numberRangeMatch) {
                        value = { fromValue: parseInt(numberRangeMatch[1]), toValue: parseInt(numberRangeMatch[2]) };
                    }
                    else {
                        throw new Error("Unable to parse string into int:  " + value);
                    }
                }
                return value.fromValue + "," + value.toValue;
            }
            function validateEntity(entityId) {
                if (!dataEntities.getEntityById(entityId)) {
                    throw new Error("Unknown entity, '" + entityId + "'.");
                }
            }
            function validateField(entityId, fieldId) {
                var entity = dataEntities.getEntityById(entityId);
                if (!entity) {
                    throw new Error("Unknown DataEntity, '" + entityId + "'.");
                }
                if (!entity.fields.get(fieldId)) {
                    throw new Error("Unknown DataQuery field in entity " + entityId + ": " + fieldId);
                }
            }
            // Helper to check if an entity exists in a DataQuery, for validating fields:
            function validateEntityExistsInDataQuery(dataQuery, entityId) {
                if (!entityId || typeof (entityId) !== "string") {
                    throw new Error("Invalid entityId to validate, expected a string, got: " + entityId);
                }
                if (~dataQuery.entities.indexOf(entityId)) {
                    return true;
                }
                var found;
                if (dataQuery.join) {
                    found = dataQuery.join.some(function (join) {
                        return join.entity === entityId;
                    });
                }
                if (!found && dataQuery.subQuery) {
                    found = dataQuery.subQuery.dataQueries.some(function (subQuery) {
                        try {
                            validateEntityExistsInDataQuery(subQuery, entityId);
                            return true;
                        }
                        catch (error) {
                            return false;
                        }
                    });
                }
                if (found) {
                    return true;
                }
                throw new Error("Entity '" + entityId + "' is not available in the DataQuery.");
            }
            function DataQuery(data, params) {
                var dataQuery = this;
                this.fields = [];
                this.entities = [];
                this.sort = [];
                // Setting to undefined just so it's clear they're available:
                this.conditions = undefined;
                this.limit = undefined;
                this.offset = undefined;
                this.subQuery = undefined;
                if (data && Object(data) === data) {
                    if (data.entity) {
                        if (typeof (data.entity) !== "string") {
                            throw new TypeError("Invalid entity for DataQuery, expected string but got " +
                                typeof (data.entity));
                        }
                        data.entities = this.entities = [data.entity];
                    }
                    else if (data.entities) {
                        if (!angular.isArray(data.entities)) {
                            throw new TypeError("Expected array for DataQuery.entities, got " +
                                typeof (data.entities));
                        }
                        this.entities = data.entities;
                    }
                    // Make sure the DataQuery doesn't use unknown entities:
                    this.entities.forEach(validateEntity);
                    if (data.entitiesJoin) {
                        var entitiesJoin = data.entitiesJoin.constructor === Array ? data.entitiesJoin :
                            [data.entitiesJoin];
                        this.join = entitiesJoin.map(function (joinConfig) {
                            return new DataQueryJoin(joinConfig, dataQuery.entities, params);
                        });
                    }
                    if (data.subQuery) {
                        if (this.entities && this.entities.length) {
                            throw new Error("A DataQuery can't have both an entity and a subquery.");
                        }
                        this.subQuery = new DataQuerySubQuery(data.subQuery, params);
                    }
                    if (data.fields) {
                        if (!angular.isArray(data.fields)) {
                            throw new TypeError("Expected array for DataQuery.fields, got " + typeof (data.fields));
                        }
                        this.fields = data.fields.map(function (field) {
                            return new DataQueryField(field, dataQuery, params);
                        });
                    }
                    if (data.conditions) {
                        var rootTerm = angular.isArray(data.conditions) ? {
                            operator: "AND",
                            terms: data.conditions
                        } : data.conditions;
                        if (!angular.isObject(rootTerm)) {
                            throw new Error("Invalid conditions for data query, must be either an object or " +
                                "array.");
                        }
                        if (isConditionEnabled(rootTerm, params)) {
                            this.conditions = new DataQueryCondition(rootTerm, params, this);
                        }
                    }
                    if (data.groupBy) {
                        var groupByArray = angular.isArray(data.groupBy) ? data.groupBy : [data.groupBy];
                        this.groupBy = groupByArray.map(function (groupByField) {
                            return new DataQueryField(groupByField, dataQuery, params);
                        });
                    }
                    if (data.sort) {
                        var sortArray = angular.isArray(data.sort) ? data.sort : [data.sort];
                        this.sort = sortArray.map(function (sortItem) {
                            return new DataQuerySort(sortItem, dataQuery, params);
                        });
                    }
                    if (data.limit !== null && typeof (data.limit) !== 'undefined') {
                        var limit = data.limit;
                        if (typeof (data.limit) === "string") {
                            limit = Number(utils.strings.parseValue(limit));
                        }
                        // -1 == no limit
                        if (isNaN(limit) || !angular.isNumber(limit) || limit < -1 || Math.floor(limit) !== limit) {
                            throw new TypeError("Invalid limit for DataQuery, must be a positive integer");
                        }
                        this.limit = limit;
                        this.offset = 0;
                    }
                    if (data.offset) {
                        var offset = data.offset;
                        if (typeof (data.offset) === "string") {
                            offset = Number(utils.strings.parseValue(offset));
                        }
                        if (isNaN(offset) || !angular.isNumber(data.offset) || data.offset < 1 ||
                            Math.floor(data.offset) !== data.offset) {
                            throw new TypeError("Invalid offset for DataQuery, must be a positive integer");
                        }
                        this.offset = data.offset;
                    }
                }
            }
            function isConditionEnabled(condition, params) {
                if (condition.enabled === undefined) {
                    return true;
                }
                if (condition.enabled === true || condition.enabled === false) {
                    return condition.enabled;
                }
                return conditions.validateConditions(condition.enabled, params, params);
            }
            function DataQueryField(data, dataQuery, params) {
                if (typeof (data) === "string") {
                    var parts = data.split(".");
                    if (parts.length === 1) {
                        data = { id: data };
                    }
                    else if (parts.length === 2) {
                        data = { entity: parts[0] };
                        if (parts[1] === "*") {
                            data.allFields = true;
                        }
                        else {
                            data.id = parts[1];
                        }
                    }
                    else {
                        throw new Error("Invalid field, '" + data + "'");
                    }
                }
                if (Object(data) !== data) {
                    throw new TypeError("Invalid configuration for DataQueryField. Expected string or object, " +
                        "got " + typeof (data));
                }
                if (!data.id && !data.alias && !data.allFields) {
                    throw new Error("Invalid DataQuery field - must have either id, alias or allFields.");
                }
                if (data.alias) {
                    this.alias = data.alias;
                }
                if (data.entity) {
                    if (!dataEntities.getEntityById(data.entity)) {
                        throw new Error("Unknown entity, '" + data.entity + "', for field '" +
                            (data.alias || data.id) + "'.");
                    }
                    this.entity = data.entity;
                }
                if (data.id) {
                    this.id = utils.strings.parseValue(data.id, {}, params);
                }
                if (data.allFields) {
                    this.allFields = true;
                }
                if (data.func) {
                    this.func = new DataQueryFieldFunction(data.func, params);
                }
                if (data.valueParam) {
                    this.value = params[data.valueParam];
                }
                else if (data.value !== undefined) {
                    if (data.value === null) {
                        throw new Error("The value of a DataQueryField can't be null.");
                    }
                    this.value =
                        typeof (data.value) === "string" ? utils.strings.parseValue(data.value, {}, params) :
                            data.value;
                }
                if (this.value !== undefined) {
                    if (this.value !== null && typeof (this.value) === "object" && !angular.isDate(this.value) &&
                        !angular.isArray(this.value)) {
                        throw new TypeError("Invalid value for field - can't be a literal object.");
                    }
                    this.valueType = this.value === null ? "STRING" : String(typeof (this.value)).toUpperCase();
                    if (angular.isDate(this.value)) {
                        this.valueType = "TIMESTAMP";
                    }
                    else if (angular.isArray(this.value)) {
                        this.valueType = "ARRAY";
                    }
                }
                var entityId = this.entity;
                // If an entity is explicitly specified for the field, validate that it's available in the DataQuery
                if (entityId) {
                    try {
                        validateEntityExistsInDataQuery(dataQuery, entityId);
                    }
                    catch (error) {
                        throw new Error("Unavailable entity '" + entityId + "' for field: " + JSON.stringify(this));
                    }
                }
                else if (dataQuery.entities && dataQuery.entities.length) {
                    // Otherwise, assume the DataQuery's entity
                    entityId = dataQuery.entities[0];
                }
                if (this.id && entityId) {
                    validateField(entityId, this.id);
                }
            }
            function DataQueryCondition(data, params, dataQuery) {
                if (Object(data) !== data) {
                    throw new TypeError("Invalid type for DataQuery condition, should be an object");
                }
                if (!dataQuery) {
                    throw new Error("Missing dataQuery.");
                }
                if (!(dataQuery instanceof DataQuery)) {
                    throw new TypeError("Can't create DataQueryCondition, expected dataQuery to be an " +
                        "instance of DataQuery, got " + dataQuery.constructor.name + ".");
                }
                this.type = "term";
                if (data.operator) {
                    if (typeof (data.operator) !== "string") {
                        throw new TypeError("Invalid value for DataQueryCondition.operator, " +
                            "expecting a string, got " + typeof (data.operator));
                    }
                    var upperCaseType = data.operator.toUpperCase();
                    if (upperCaseType !== "AND" && upperCaseType !== "OR") {
                        throw new Error("Invalid value for DataQueryCondition.operator, must be either " +
                            "'AND' or 'OR' (case insensitive)");
                    }
                    this.logicalOperator = upperCaseType;
                }
                else {
                    this.logicalOperator = "AND";
                }
                if (data.terms) {
                    this.terms = [];
                }
                for (var i = 0, term; !!(term = data.terms[i]); i++) {
                    if (term.type && term.type === "term") {
                        if (isConditionEnabled(term, params)) {
                            this.terms.push(new DataQueryCondition(term, params, dataQuery));
                        }
                    }
                    else {
                        if (isConditionEnabled(term, params)) {
                            this.terms.push(new DataQueryConditionField(term, params, dataQuery));
                        }
                    }
                }
            }
            function DataQueryConditionField(data, params, dataQuery) {
                if (Object(data) !== data) {
                    throw new TypeError("Invalid type for DataQuery condition field, should be an object");
                }
                var dataCopy = angular.copy(data);
                var conditionValue = dataCopy.valueParam ? params[dataCopy.valueParam] : dataCopy.value;
                delete dataCopy.value;
                delete dataCopy.valueParam;
                this.field = new DataQueryField(dataCopy, dataQuery, params);
                if (!data.operator || typeof (data.operator) !== "string") {
                    throw new Error("Can't create DataQueryConditionField - operator property is missing " +
                        "or is not a string");
                }
                var conditionOperator = queryOperators.operators.get(data.operator);
                if (!conditionOperator) {
                    throw new Error("Can't create DataQueryConditionField - unknown operator, '" + data.operator +
                        "'");
                }
                this.queryOperator = conditionOperator.dataQueryOperator;
                this.type = "field";
                if (conditionOperator.requiresValue) {
                    // The condition can be evaluated against another field, like "event_score > event_time_score",
                    // rather than "event_score > 50":
                    if (data.valueField) {
                        this.valueField = new DataQueryField(data.valueField, dataQuery, params);
                    }
                    if (conditionValue === undefined && !this.valueField) {
                        throw new Error("Can't create DataQueryConditionField - a value is required for " +
                            "operator '" + data.operator + "'");
                    }
                    this.value = conditionValue;
                    this.valueType = this.field.valueType;
                    if (this.field.id) {
                        var entityId = this.field.entity || dataQuery.entities[0];
                        validateField(entityId, this.field.id);
                        // If valueField is used, meaning that another field is used as value, there's no need to
                        // do anything about the condition's value:
                        if (!this.valueField) {
                            var entity = dataEntities.getEntityById(entityId);
                            var entityField = entity.fields.get(this.field.id);
                            if (typeof (this.value) === "string") {
                                this.value = utils.strings.parseValue(this.value, {}, params);
                            }
                            // Some field types have parsers, since the data might have to be formatted before
                            // sending:
                            var valueParser = valueTypeParsers[entityField.type.id];
                            if (valueParser) {
                                this.value = valueParser(this.value);
                            }
                            if (angular.isArray(this.value)) {
                                this.value = this.value.map(function (val) {
                                    return val.replace(/[,]/g, "~~");
                                }).join();
                            }
                        }
                    }
                }
                delete this.field.valueType;
            }
            function DataQuerySort(data, dataQuery, params) {
                if (typeof (data) === "string") {
                    this.field = new DataQueryField(data, dataQuery, params);
                }
                if (typeof (data.field) === "string") {
                    this.field = new DataQueryField(data.field, dataQuery, params);
                }
                else if (Object(data) === data) {
                    this.field = new DataQueryField(data.field || data, dataQuery, params);
                }
                if (!this.field) {
                    throw new Error("Can't create DataQuery sort - missing the field property");
                }
                if (data.direction) {
                    if (typeof (data.direction) !== "string") {
                        throw new TypeError("Invalid direction for DataQuerySort - expected string but got " +
                            typeof (data.direction));
                    }
                    var directionUpperCase = data.direction.toUpperCase();
                    if (directionUpperCase !== "ASC" && directionUpperCase !== "DESC") {
                        throw new Error("Invalid direction for DataQuery sort, expected either 'ASC' or " +
                            "'DESC' (case insensitive) but got '" + data.direction + "'");
                    }
                    this.direction = directionUpperCase;
                }
            }
            function DataQueryFieldFunction(data) {
                if (!data.name) {
                    throw new Error("Can't create DataQuery field function - missing function name.");
                }
                if (typeof (data.name) !== "string") {
                    throw new Error("Can't create DataQuery field function - function name must be a string.");
                }
                this.name = data.name.toLowerCase();
                if (data.params) {
                    this.params = {};
                    for (var p in data.params) {
                        if (data.params.hasOwnProperty(p)) {
                            this.params[p] = String(data.params[p]);
                        }
                    }
                }
            }
            function DataQueryJoin(data, entities) {
                if (data.joinType) {
                    if (typeof (data.joinType) !== "string") {
                        throw new TypeError("Invalid joinType for DataQueryJoin. Expected string, got " +
                            typeof (data.joinType) + ".");
                    }
                    var joinType = data.joinType.toUpperCase();
                    if (!~["RIGHT", "LEFT"].indexOf(joinType)) {
                        throw new Error("Invalid joinType, expected either 'RIGHT' or 'LEFT' " +
                            "(case-insensitive), got '" + joinType + "'.");
                    }
                    this.type = joinType;
                }
                else {
                    this.type = "LEFT";
                }
                if (!data.entity) {
                    throw new Error("Missing entity for DataQueryJoin.");
                }
                this.entity = data.entity instanceof DataEntity ? data.entity.id : data.entity;
                if (typeof (this.entity) !== "string") {
                    throw new TypeError("Invalid entity for DataQueryJoin. Expected string, got " +
                        typeof (this.entity));
                }
                if (~entities.indexOf(data.entity)) {
                    throw new Error("Can't create DataQueryJoin, the entity " + data.entity +
                        " already exists in the DataQuery.");
                }
                if (!data.joinFields.left || !data.joinFields.right) {
                    throw new Error("DataQueryJoin.joinFields should contain both left and right fields.");
                }
                ["left", "right"].forEach(function (side) {
                    var entityField = data.joinFields[side].split(".");
                    if (entityField.length !== 2) {
                        throw new Error("Invalid " + side + " joinField. Expected [entity].[field] but got '" +
                            data.joinFields[side] + "'.");
                    }
                    validateEntity(entityField[0]);
                    validateField(entityField[0], entityField[1]);
                    this[side] = { entity: entityField[0], field: entityField[1] };
                }.bind(this));
            }
            function DataQuerySubQuery(data, params) {
                if (data.combineMethod && typeof (data.combineMethod) !== "string") {
                    throw new TypeError("Invalid combineMethod for DataQuerySubQuery, expected a string but got " +
                        typeof (data.combineMethod) + ".");
                }
                this.combineMethod = data.combineMethod ? queryCombineMethods[data.combineMethod] :
                    queryCombineMethods.UnionDistinct;
                if (!this.combineMethod) {
                    throw new Error("Invalid combineMethod for DataQuerySubQuery: '" + data.combineMethod + "'.");
                }
                if (data.dataQueries) {
                    if (!angular.isArray(data.dataQueries)) {
                        throw new TypeError("Can't create DataQuerySubQuery, expected dataQueries to be an array.");
                    }
                    this.dataQueries = data.dataQueries.map(function (dataQueryConfig) {
                        var extendedDataQueryConfig = utils.objects.extend({}, dataQueryConfig, data.common);
                        return new DataQuery(extendedDataQueryConfig, params);
                    });
                }
                else {
                    this.dataQueries = [];
                }
            }
            var queryCombineMethods = {
                "UnionAll": "UnionAll",
                "UnionDistinct": "UnionDistinct"
            };
            /**
             * valueTypeParsers are used for preparing values to be sent to the server in data queries.
             * DataQueryConditionField.value, for example, needs to be parsed. All parsers should return a string,
             * since the dataQuery API expects values to be sent as strings.
             */
            var valueTypeParsers = {
                "DATE_TIME": dateTimeParse,
                "TIMESTAMP": dateTimeParse,
                "NUMBER": numberRangeParse
            };
            var numberRangeRegExp = /^(\d+),(\d+)$/;
            var dateRangeRegExp = /^(\d+),(\d+)$/;
            return DataQuery;
        }]);
}());

angular.module("Reports", ["DAL", "Cache", "Utils", "Config", "DataQueries"]);

(function () {
    'use strict';
    var setOfProcess = new Set(["add", "combine", "extend", "getUsersDetails", "groupBy", "groupByField", "map", "sort",
        "limit"]);
    function ReportClass($q, utils, reports) {
        var allReports = {};
        function Report(config) {
            this.validate(config);
            function getReportById(reportId) {
                /* jshint validthis: true */
                this._initializing = true;
                onInit = [];
                reports.getReport(reportId).then(function (reportConfig) {
                    delete config.reportId;
                    utils.objects.extend(reportConfig, config);
                    setReportProperties(reportConfig);
                    if (onInit.length) {
                        for (var _i = 0, onInit_1 = onInit; _i < onInit_1.length; _i++) {
                            var onInitDeferred = onInit_1[_i];
                            onInitDeferred.resolve(self);
                        }
                    }
                }, function (error) {
                    if (onInit.length) {
                        for (var _i = 0, onInit_2 = onInit; _i < onInit_2.length; _i++) {
                            var onInitDeferred = onInit_2[_i];
                            onInitDeferred.reject(error);
                        }
                    }
                }).finally(function () {
                    onInit = null;
                    delete self._initializing;
                    delete self.onInitSubscribe;
                });
            }
            function setReportProperties(reportConfig) {
                self.validate(reportConfig);
                self.endpoint = reportConfig.endpoint;
                self.params = reportConfig.params ? reportConfig.params.map(function (paramConfig) {
                    return new ReportParam(paramConfig);
                }) : [];
                self.allowCache = reportConfig.allowCache !== false;
                self.mockData = reportConfig.mock_data;
                self.requiredParams = reportConfig.requiredParams;
                self.process = reportConfig.process;
                if (reportConfig.joinReports) {
                    self.joinReports = reportConfig.joinReports.reports.map(function (childReport) {
                        var childReportConfig = reportConfig.joinReports.common ?
                            utils.objects.extend({}, reportConfig.joinReports.common, childReport) : childReport;
                        return new Report(childReportConfig);
                    });
                }
            }
            var self = this, onInit;
            if (config.reportId) {
                getReportById(config.reportId);
            }
            else {
                setReportProperties(config);
            }
            this._config = config;
            self.onInitSubscribe = function () {
                var deferred = $q.defer();
                onInit.push(deferred);
                return deferred.promise;
            };
        }
        Report.prototype.validate = function (config) {
            var param = null;
            if (!config) {
                throw new Error("No report configuration to validate.");
            }
            if (Object(config) !== config) {
                throw new TypeError("Invalid report configuration, expected an object but got " + config);
            }
            if (config.reportId && typeof (config.reportId) !== "string") {
                throw new TypeError("Can't create report, the 'reportId' property must be a string.");
            }
            if (!config.endpoint && !config.joinReports) {
                throw new Error("Can't create report, missing the 'endpoint' property.");
            }
            if (config.endpoint && Object(config.endpoint) !== config.endpoint) {
                throw new TypeError("Can't create report, endpoint is not an object.");
            }
            if (config.joinReports) {
                if (!angular.isObject(config.joinReports)) {
                    throw new TypeError("Invalid joinReports, expected an object but got " + config.joinReports);
                }
                if (!config.joinReports.reports) {
                    throw new Error("Report.joinReports is mising the 'reports' property.");
                }
                if (!angular.isArray(config.joinReports.reports)) {
                    throw new TypeError("Invalid 'reports' for joinReports, expected an Arrya but got " +
                        config.joinReports.reports);
                }
            }
            if (config.mock_data && typeof (config.mock_data) !== "string") {
                throw new TypeError("Can't create report, expected a string for mock_data but got " +
                    typeof (config.mock_data) + ".");
            }
            if (config.params) {
                if (config.params.constructor !== Array) {
                    throw new TypeError("Can't create report, expected params to be an array but got " + config.params);
                }
                for (var _i = 0, _a = config.params; _i < _a.length; _i++) {
                    param = _a[_i];
                    if (param.dashboardParam === undefined && param.value === undefined &&
                        param.default === undefined) {
                        throw new Error("Can't create report, param doesn't have either 'dashboardParam', " +
                            "'value' or 'default' properties.");
                    }
                }
            }
            if (config.requiredParams) {
                if (config.requiredParams.constructor !== Array) {
                    throw new TypeError("Cant' create report, requiredParams must be an Array.");
                }
                for (var _b = 0, _c = config.requiredParams; _b < _c.length; _b++) {
                    param = _c[_b];
                    if (typeof (param) !== "string") {
                        throw new TypeError("Can't create report, invalid required param, expected a string but got " +
                            param + ".");
                    }
                }
            }
            if (config.process) {
                if (config.process.constructor !== Array) {
                    config.process = [config.process];
                }
                for (var _d = 0, _e = config.process; _d < _e.length; _d++) {
                    var process = _e[_d];
                    if (!process.processId || typeof (process.processId) !== "string") {
                        throw new TypeError("Cant' create report, processId must be a string.");
                    }
                    if (!setOfProcess.has(process.processId)) {
                        throw new TypeError("Cant' create report, unknown processId " + process.processId);
                    }
                }
            }
        };
        /**
         * Creates a deep copy of the specified Report
         * @param report
         * @returns {ReportClass.Report}
         */
        Report.copy = function (report) {
            var newReport = new Report(report._config);
            for (var p in report) {
                if (report.hasOwnProperty(p) && p !== "joinReports") {
                    newReport[p] = report[p];
                }
            }
            return newReport;
        };
        /**
         * Returns a copy of this Report
         */
        Report.prototype.clone = function () {
            return Report.copy(this);
        };
        /**
         * Runs the report. Returns a promise which is resolved when data is ready or an error occurs.
         * @param {object} state Params to use when running the report
         * @param {number} priority The priority on which to run the report - lower number is higher priority
         * @param {boolean} noCache Whether to allow data to be retrieved from cache
         * @returns {Promise}
         */
        Report.prototype.run = function (state, priority, noCache) {
            var report = this;
            this.isLoading = true;
            if (this._initializing) {
                return this.onInitSubscribe().then(function () {
                    return report.run(state);
                }, function (error) {
                    report.isLoading = false;
                    return $q.reject(error);
                });
            }
            else {
                var forceRefresh = noCache !== undefined ? !!noCache : !report.allowCache;
                return reports.runReport(this, state, forceRefresh, priority).finally(function () {
                    report.isLoading = false;
                });
            }
        };
        Report.loadReport = function (config) {
            if (config.reportId) {
                var existingReport = allReports[config.reportId];
                if (existingReport) {
                    return $q.when(existingReport);
                }
                return utils.http.wrappedHttpGet("data/reports/" + config.reportId.replace(/\./g, "/") +
                    ".json").then(function (reportConfig) {
                    var fullReportConfig = utils.objects.extend({}, reportConfig, config), reportId = fullReportConfig.reportId;
                    delete fullReportConfig.reportId;
                    var report = new Report(fullReportConfig);
                    allReports[reportId] = report;
                    return report;
                }, function (error) {
                    var errorMessage = error.status === 404 ? "Report '" + config.reportId + "' not found." :
                        "Can't get report '" + config.reportId + "'. Error: " + error.data;
                    return $q.reject(errorMessage);
                });
            }
            return new Report(config);
        };
        function ReportParam(config) {
            /**
             * The name of the param in the state params object
             * @type string
             */
            this.dashboardParam = config.dashboardParam;
            /**
             * The value of the param - will be parsed using the state params object
             */
            this.value = config.value;
            /**
             * Default value for the param, if it's not present in the state params object (Optional)
             */
            this["default"] = config.default;
            /**
             * The name of the param inside the report
             */
            this.field = config.field;
            this.isRequired = !!config.isRequired;
            return this;
        }
        return Report;
    }
    ReportClass.$inject = ["$q", "utils", "reports"];
    angular.module("Reports").factory("Report", ReportClass);
})();

(function () {
    'use strict';
    /**
     * Service for running reports - configurations of calls to the REST API
    **/
    function reports($q, $timeout, DAL, Cache, reportsProcess, utils, configFlags, DataQuery, conditions, state) {
        var cache = new Cache({ id: "reports" }), // this is for data
        cachedReports = {}, // This one is just for the report definitions
        runReportsTimeout;
        var globalSearchParams = ["page", "limit", "offset", "pageSize", "orderBy", "orderByDirection"];
        var queue = {
            clearRunReportQueue: function () {
                console.log("CLEAR: ");
                if (!queue.runReportQueue) {
                    return;
                }
                queue.runReportQueue.forEach(function (reportPriority) {
                    reportPriority.reports.forEach(function (report) {
                        if (report.deferred) {
                            report.deferred.reject({ aborted: true });
                        }
                        if (configFlags.verbose) {
                            console.log("Aborted report ", report);
                        }
                    });
                });
                queue.runReportQueue = null;
                queue.currentRunningPriority = null;
            },
            findReportPosition: function (reportObj) {
                var priorityIndex, reportIndex, priority;
                for (priorityIndex = 0; priorityIndex < this.runReportQueue.length; priorityIndex++) {
                    priority = this.runReportQueue[priorityIndex];
                    for (reportIndex = 0; reportIndex < priority.reports.length; reportIndex++) {
                        if (reportObj === priority.reports[reportIndex]) {
                            return { priority: priority, reportIndex: reportIndex, priorityIndex: priorityIndex };
                        }
                    }
                }
                return null;
            },
            runReportQueue: null,
            currentRunningPriority: null,
            currentRunningReports: null,
            runNextQueuedPriority: function () {
                if (queue.currentRunningReports && queue.currentRunningReports.length) {
                    return;
                }
                if (!queue.runReportQueue || !queue.runReportQueue.length) {
                    return;
                }
                var nextQueuePriority;
                for (var priorityIndex = 0, priority; !!(priority = queue.runReportQueue[priorityIndex]); priorityIndex++) {
                    if (priority.reports && priority.reports.length) {
                        nextQueuePriority = priority;
                        break;
                    }
                }
                if (!nextQueuePriority) {
                    return;
                }
                queue.currentRunningPriority = nextQueuePriority;
                queue.currentRunningReports = [];
                queue.currentRunningPriority.reports.forEach(function (reportObj) {
                    if (~queue.currentRunningReports.indexOf(reportObj)) {
                        return true;
                    }
                    queue.currentRunningReports.push(reportObj);
                    if (configFlags.verbose) {
                        console.log("Run report: ", reportObj);
                    }
                    runReport(reportObj).then(function (results) {
                        var deferred = reportObj.deferred;
                        delete reportObj.deferred;
                        deferred.resolve(results);
                    }, function (error) {
                        var deferred = reportObj.deferred;
                        delete reportObj.deferred;
                        deferred.reject(error);
                    }).finally(function () {
                        queue.currentRunningReports.splice(queue.currentRunningReports.indexOf(reportObj), 1);
                        queue.runNextQueuedPriority();
                    });
                });
                this.currentRunningPriority.reports = [];
            },
            queueReport: function (reportObj) {
                var deferred = $q.defer();
                $timeout.cancel(runReportsTimeout);
                reportObj.deferred = deferred;
                if (!queue.runReportQueue) {
                    queue.runReportQueue = [{ priority: reportObj.priority, reports: [reportObj] }];
                }
                else {
                    var added;
                    for (var i = 0, reportPriority; i < queue.runReportQueue.length; i++) {
                        reportPriority = queue.runReportQueue[i];
                        if (reportPriority.priority === reportObj.priority) {
                            reportPriority.reports.push(reportObj);
                            added = true;
                            break;
                        }
                    }
                    if (!added) {
                        queue.runReportQueue.push({ priority: reportObj.priority, reports: [reportObj] });
                    }
                    queue.runReportQueue.sort(function (a, b) {
                        return a.priority > b.priority ? 1 : -1;
                    });
                }
                runReportsTimeout = $timeout(function () {
                    queue.runNextQueuedPriority();
                }, 40);
                return deferred.promise;
            }
        };
        function parseParams(report, params) {
            var parsedParams = {};
            angular.forEach(report.params, function (param) {
                var paramValue = params[param.dashboardParam], fieldName = param.field;
                if (param.value && paramValue !== undefined && paramValue !== null && paramValue !== "") {
                    parsedParams[fieldName] = utils.strings.parseValue(param.value, params, {});
                }
                else if (paramValue !== undefined && paramValue !== null && paramValue !== "") {
                    parsedParams[fieldName] = paramValue;
                }
                else if ((parsedParams[fieldName] === undefined || parsedParams[fieldName] === null ||
                    parsedParams[fieldName] === "") && param.default !== undefined && param.default !== null) {
                    parsedParams[fieldName] =
                        typeof (param.default) === "string" ? utils.strings.parseValue(param.default, {}, params) :
                            param.default;
                }
            });
            if (params) {
                for (var paramName in params) {
                    if (params.hasOwnProperty(paramName)) {
                        if (~globalSearchParams.indexOf(paramName) && params[paramName] !== undefined &&
                            params[paramName] !== null) {
                            parsedParams[paramName] = params[paramName];
                        }
                    }
                }
            }
            return parsedParams;
        }
        function getInSeconds(value) {
            var valueMatch = value.match(/^(\d+)(\w)$/);
            if (!valueMatch) {
                throw new Error("Invalid time period value: " + value);
            }
            var int = parseInt(valueMatch[1], 10), unit = valueMatch[2];
            if (unit === "s") {
                return int;
            }
            if (unit === "m") {
                return int * 60;
            }
            if (unit === "h") {
                return int * 3600;
            }
            if (unit === "d") {
                return int * 3600 * 24;
            }
            throw new Error("Invalid time period value: " + value);
        }
        function checkRequiredParams(report, params) {
            var result = { success: true, missingParams: [] };
            if (report.params) {
                report.params.forEach(function (param) {
                    if (param.isRequired && !params[param.dashboardParam]) {
                        result.success = false;
                        result.missingParams.push(param.dashboardParam);
                    }
                });
            }
            return result;
        }
        function getCachedDataByKey(cacheItemKey, forceRefresh) {
            if (forceRefresh) {
                cache.removeItem(cacheItemKey);
                return null;
            }
            else {
                var cachedData = cache.getItem(cacheItemKey, { hold: true });
                if (cachedData) {
                    return cachedData;
                }
            }
            return null;
        }
        function getCacheKey(report, params) {
            var keyParams = utils.objects.copy(params), reportEndpoint = utils.objects.copy(report.endpoint) || "";
            if (reportEndpoint) {
                delete reportEndpoint.fields;
                delete reportEndpoint.sort;
                delete reportEndpoint.paging;
                if (reportEndpoint.entities) {
                    var entityIds = [];
                    reportEndpoint.entities.forEach(function (entity) {
                        entityIds.push(entity.id);
                    });
                    reportEndpoint.entities = entityIds.join("_");
                }
            }
            if (report.cacheIgnoredParams) {
                report.cacheIgnoredParams.forEach(function (ignoredParam) {
                    delete keyParams[ignoredParam];
                });
            }
            return JSON.stringify(reportEndpoint) + "_" + JSON.stringify(keyParams);
        }
        function getReportDataFromCache(reportObj, cacheKey) {
            if (!reportObj.report || !reportObj.report.cache) {
                return null;
            }
            var report = reportObj.report, params = reportObj.params;
            var parsedParams = parseParams(report, params), cacheItemKey = cacheKey || getCacheKey(report, parsedParams);
            var cachedData = getCachedDataByKey(cacheItemKey, reportObj.forceRefresh);
            if (cachedData) {
                return cachedData;
            }
        }
        function runReport(reportObj) {
            /**
             * This function resolves the reports.
             * It handle the process in sense that if there is few process like "groupBy" and "limit",
             * it will chain then one at the time while the processed data will pass from process to process
             * @param results
             * @param index
             * @returns {*}
             */
            function resolve(results, index) {
                if (report.process && results.data) {
                    var processesArr = [];
                    //if the value is not in array, we push it to the array
                    if (angular.isArray(report.process)) {
                        processesArr = report.process;
                    }
                    else {
                        processesArr.push(report.process);
                    }
                    // we format the index if this is the first run
                    index = index ? index : 0;
                    return $q.when(reportsProcess.processData(processesArr[index].processId, results, processesArr[index].params))
                        .then(function (processedResults) {
                        if (index < processesArr.length - 1) {
                            //if there is more then one process, we will call this function again and pass the new
                            // processed data to it
                            index++;
                            return resolve(processedResults, index);
                        }
                        else {
                            // else we return the processed data
                            return finishResolve(processedResults);
                        }
                    }, onError);
                }
                else {
                    return finishResolve(results);
                }
            }
            function finishResolve(results) {
                if (report.cache && results.data.length) {
                    var saveData = utils.objects.copy(results);
                    delete saveData.$promise;
                    delete saveData.$resolved;
                    delete saveData.time;
                    cache.setItem(cacheItemKey, results, { expiresIn: getInSeconds(report.cache), hold: false });
                }
                results.time = utils.date.getMoment('now').toDate() - timeStart;
                return results.data ? results : { data: [], total: 0, time: results.time };
            }
            function onError(error) {
                if (report.cache) {
                    cache.removeItem(cacheItemKey);
                }
                return $q.reject(error);
            }
            function doRunReport() {
                return DAL.reports.runReport(report, parsedParams)
                    .then(function (results) {
                    return resolve(results);
                }, onError);
            }
            var report = reportObj.report, params = reportObj.params, forceRefresh = reportObj.forceRefresh, timeStart = utils.date.getMoment('now').toDate();
            if (typeof (report) === "string") {
                return methods.runReportById(report, params, forceRefresh);
            }
            var requiredParamsCheck = checkRequiredParams(report, params);
            if (!requiredParamsCheck.success) {
                return $q.reject({
                    error: "requiredParams",
                    message: "Missing required parameters: " + requiredParamsCheck.missingParams.join(", ") + "."
                });
            }
            var parsedParams = parseParams(report, params), cacheItemKey = getCacheKey(report, parsedParams), cachedData = getReportDataFromCache(reportObj, cacheItemKey);
            //support addition of condition check on an report,
            //Uses for a case where there is a report on a general entity as User but with a condition on a special
            // data source. If the condition is not meet the report wont be execute.
            if (report.endpoint && report.endpoint.conditions &&
                !conditions.validateConditions(report.endpoint.conditions, null, state.currentParams)) {
                return resolve({ data: [], total: 0 });
            }
            if (cachedData) {
                return $q.when(cachedData);
            }
            if (report.joinReports) {
                return methods.runReports(report.joinReports, report, params, forceRefresh).then(function (results) {
                    var data = [], total = 0, totalTime = 0;
                    angular.forEach(results, function (result) {
                        data = data.concat(result.data);
                        total += result.total;
                        totalTime += result.time || 0;
                    });
                    return resolve({ data: data, total: total });
                });
            }
            // Since we're replacing the dataQuery configuration with the data for the REST API,
            // stash the configuration for later use.
            var dataQueryConfig = report.dataQueryConfig || report.endpoint && report.endpoint.dataQuery;
            if (dataQueryConfig) {
                try {
                    try {
                        report.endpoint.dataQuery = dataQueryConfig instanceof DataQuery ? dataQueryConfig :
                            new DataQuery(dataQueryConfig, parsedParams);
                        if (!report.dataQueryConfig) {
                            report.dataQueryConfig = dataQueryConfig;
                        }
                    }
                    catch (error) {
                        return $q.reject({ message: "Can't create DataQuery. Error: " + error.message, error: error });
                    }
                    if (configFlags.verbose) {
                        console.log("Running DataQuery: ", report.endpoint.dataQuery);
                    }
                    return doRunReport();
                }
                catch (error) {
                    return $q.reject(error);
                }
            }
            return doRunReport();
        }
        var methods = {
            abortCurrentReports: queue.clearRunReportQueue,
            getReport: function (reportId) {
                if (cachedReports[reportId]) {
                    return $q.when(cachedReports[reportId]);
                }
                else {
                    return DAL.reports.getReport(reportId).then(function (report) {
                        cachedReports[reportId] = report;
                        return report;
                    });
                }
            },
            runReport: function (report, params, forceRefresh, priority) {
                var reportObj = {
                    priority: priority || 0,
                    report: report,
                    params: params,
                    forceRefresh: forceRefresh
                };
                var cachedData = getReportDataFromCache(reportObj);
                if (cachedData) {
                    return $q.when(cachedData);
                }
                if (!angular.isNumber(priority)) {
                    return runReport(reportObj);
                }
                return queue.queueReport(reportObj);
            },
            runReportById: function (reportId, params, forceRefresh) {
                return methods.getReport(reportId).then(function (report) {
                    return methods.runReport(report, params, forceRefresh);
                });
            },
            runReports: function (reports, parentReport, params, forceRefresh) {
                var promises = [], common;
                if (Object(reports) === reports) {
                    if (!!(common = reports.common)) {
                        reports = reports.reports.map(function (report) {
                            return utils.objects.extend({}, common, report);
                        });
                    }
                }
                angular.forEach(reports, function (report) {
                    var reportCopy = report.constructor.name === "Report" ? report.clone() : utils.objects.copy(report);
                    reportCopy.params =
                        reportCopy.params ? reportCopy.params.concat(parentReport.params || []) : parentReport.params;
                    promises.push(methods.runReport(reportCopy, params, forceRefresh));
                });
                return $q.all(promises);
            }
        };
        return methods;
    }
    reports.$inject =
        ["$q", "$timeout", "DAL", "Cache", "reportsProcess", "utils", "configFlags", "DataQuery", "conditions",
            "state"];
    angular.module("Reports").factory("reports", reports);
})();

(function () {
    'use strict';
    /**
     * Post-processing for data returned by a report call. The process is define within the report itself.
     * @param $q
     * @param DAL
     * @param utils
     * @returns {{processData: processData}}
     */
    function reportsProcess($q, DAL, utils) {
        var processes = {
            add: function (results, params) {
                if (!params || !params.field) {
                    throw new Error("Can't add results - no field specified.");
                }
                if (!results.data || !results.data.length) {
                    return null;
                }
                var addResult = results.data[0][params.field], result = params.extend || {};
                if (results.data.length > 1) {
                    for (var i = 1; i < results.data.length; i++) {
                        addResult += results.data[i][params.field];
                    }
                }
                result[params.field] = addResult;
                return { data: [result], total: 1, time: results.time };
            },
            combine: function (results, params) {
                var index = {}, indexedResults = [];
                angular.forEach(results.data, function (result) {
                    var groupByValue = result[params.groupBy];
                    var indexObj = index[groupByValue];
                    if (!indexObj) {
                        indexObj = index[groupByValue] = angular.copy(params.defaultValue);
                        indexObj[params.groupBy] = groupByValue;
                    }
                    for (var fieldName in params.fields) {
                        if (params.fields.hasOwnProperty(fieldName)) {
                            indexObj[result[fieldName]] = result[params.fields[fieldName]];
                        }
                    }
                });
                for (var groupByValue in index) {
                    if (index.hasOwnProperty(groupByValue)) {
                        indexedResults.push(index[groupByValue]);
                    }
                }
                return $q.when({ data: indexedResults, total: results.total, time: results.time });
            },
            extend: function (results, params) {
                if (!params || !Object.keys(params).length) {
                    return results;
                }
                results.data.forEach(function (item) {
                    angular.extend(item, params);
                });
                return results;
            },
            getUsersDetails: function (results, params) {
                var deferred = $q.defer(), usernames = [];
                if (!params || !params.userField || !params.userType) {
                    deferred.reject("Missing parameters for getUserDetails.");
                    return deferred.promise;
                }
                angular.forEach(results.data, function (item) {
                    usernames.push(item[params.userField]);
                });
                if (!usernames.length) {
                    deferred.resolve({ data: [], total: 0 });
                }
                DAL.reports.runReport({
                    endpoint: {
                        entity: "app",
                        id: params.userType,
                        method: "usersDetails",
                        usernames: usernames.join(",")
                    },
                    "mock_data": "userFind"
                }).then(function (userDetailsResults) {
                    angular.forEach(userDetailsResults.data, function (userDetails) {
                        for (var i = 0, item; i < results.data.length; i++) {
                            item = results.data[i];
                            if ((userDetails.samacountName &&
                                userDetails.samacountName.toLowerCase() === item[params.userField].toLowerCase()) ||
                                (userDetails.adUserPrincipalName && userDetails.adUserPrincipalName.toLowerCase() ===
                                    item[params.userField].toLowerCase() || (userDetails.name &&
                                    userDetails.name.toLowerCase() === item[params.userField].toLowerCase()))) {
                                item.userDetails = userDetails;
                                break;
                            }
                        }
                    });
                    deferred.resolve(results);
                }, deferred.reject);
                return deferred.promise;
            },
            /*
             *
             *	Allow group by aggregation also in the frontend - ideally this functionality will move completely to
             *	the backend, cause of time implementation issues currently implemented in the frontend.
             *
             *
             */
            groupBy: function (results, params) {
                var index = {}, indexedResults = [];
                angular.forEach(results.data, function (result) {
                    var resultProperties = Object.keys(result);
                    var groupByValue = "";
                    // create id for all records that are group together
                    // support multiple group by fields, from which this id is created.
                    angular.forEach(params.groupBy, function (groupByColumn) {
                        groupByValue += "_" + result[groupByColumn];
                    });
                    // add/return the id to the distinct record map.
                    var indexObj = index[groupByValue];
                    if (!indexObj) {
                        indexObj = index[groupByValue] = {};
                    }
                    //remove group by fields values from original record.
                    angular.forEach(params.groupBy, function (groupByColumn) {
                        indexObj[groupByColumn] = result[groupByColumn];
                        resultProperties.splice(resultProperties.indexOf(groupByColumn), 1);
                    });
                    if (params.fields) {
                        // for all aggregation fields
                        angular.forEach(params.fields, function (field) {
                            // get field name and value and destination field name for the joined record.
                            var fieldValue = result[field.fieldName];
                            var fieldName = field.fieldName;
                            // remove value from original record if needed.
                            if (field.fieldNewName === undefined) {
                                var propertyIndex = resultProperties.indexOf(fieldName);
                                if (~propertyIndex) {
                                    resultProperties.splice(propertyIndex, 1);
                                }
                            }
                            else {
                                fieldName = field.fieldNewName;
                            }
                            //allow pivot operation uses the pivot field to get the prefix for the column name as
                            // addition to the aggregated field. the new field name pattern will be
                            // pivotFieldValue_aggregatedFieldName and the operation on the value can be any of the
                            // basic aggregation operations.
                            if (field.fieldFunc === "pivot") {
                                if (field.pivotFieldName !== undefined) {
                                    var pivotPropertyIndex = resultProperties.indexOf(field.pivotFieldName);
                                    if (~pivotPropertyIndex) {
                                        var pivotField = result[field.pivotFieldName];
                                        resultProperties.splice(pivotPropertyIndex, 1);
                                        fieldName = pivotField + "_" + fieldName;
                                        aggregateOperation(indexObj, fieldName, fieldValue, field.fieldPivotFunc);
                                    }
                                }
                            }
                            else {
                                aggregateOperation(indexObj, fieldName, fieldValue, field.fieldFunc, result[field.referenceFieldName], field.referenceValue);
                            }
                        });
                    }
                    // add all other values haven't been handled until now
                    if (resultProperties.length) {
                        resultProperties.forEach(function (propertyName) {
                            indexObj[propertyName] = result[propertyName];
                        });
                    }
                });
                // add all joined records to new result set
                for (var groupByValue in index) {
                    if (index.hasOwnProperty(groupByValue)) {
                        indexedResults.push(index[groupByValue]);
                    }
                }
                return $q.when({ data: indexedResults, total: results.total, time: results.time });
            },
            groupByField: function (results, params) {
                function groupRows(fieldValue) {
                    var rows = [];
                    for (var i = originalData.length - 1, row; !!(row = originalData[i]); i--) {
                        if (row[params.field] === fieldValue) {
                            rows.splice(0, 0, originalData.splice(i, 1)[0]);
                        }
                    }
                    newResults = newResults.concat(rows);
                }
                var originalData = angular.copy(results.data);
                if (!originalData || originalData.length <= 2) {
                    return results;
                }
                var newResults = originalData.splice(0, 1);
                while (originalData.length) {
                    groupRows(newResults[newResults.length - 1][params.field]);
                    if (originalData.length) {
                        newResults.push(originalData.splice(0, 1)[0]);
                    }
                }
                return { data: newResults, total: results.total, time: results.time };
            },
            map: function (results, params) {
                var mappedData = [];
                angular.forEach(results.data, function (item) {
                    mappedData.push(mapObj(params.map, item));
                });
                return { data: mappedData, total: results.total, time: results.time };
            },
            sort: function (results, params) {
                var fields = params.fields || [params.field];
                var resultsCopy = angular.copy(results), sortFunc = params.direction && params.direction.toLocaleLowerCase() === "desc" ?
                    function (a, b) {
                        var values = getValuesToCompare(a, b);
                        if (values.a === values.b) {
                            return 0;
                        }
                        if (!values.a && values.a !== 0 && values.b) {
                            return -1;
                        }
                        if (!values.b && values.b !== 0 && values.a) {
                            return 1;
                        }
                        return values.a < values.b ? 1 : -1;
                    } :
                    function (a, b) {
                        var values = getValuesToCompare(a, b);
                        if (values.a === values.b) {
                            return 0;
                        }
                        if (!values.a && values.a !== 0 && values.b) {
                            return 1;
                        }
                        if (!values.b && values.b !== 0 && values.a) {
                            return -1;
                        }
                        return values.a > values.b ? 1 : -1;
                    };
                resultsCopy.data = resultsCopy.data.sort(sortFunc);
                function getValuesToCompare(a, b) {
                    var fieldIndex = -1, field, aVal, bVal;
                    do {
                        fieldIndex++;
                        field = fields[fieldIndex];
                        if (field) {
                            aVal = a[field];
                            bVal = b[field];
                        }
                    } while (field && aVal === bVal);
                    return { a: aVal, b: bVal };
                }
                return resultsCopy;
            },
            limit: function (results, params) {
                var resultsCopy = angular.copy(results);
                resultsCopy.data = resultsCopy.data.splice(0, params.numOfRows);
                return resultsCopy;
            }
        };
        function aggregateOperation(indexObj, fieldName, fieldValue, fieldFunc, referenceField, referenceValue) {
            if (fieldFunc === "case") {
                if (referenceValue === referenceField) {
                    indexObj[fieldName] = fieldValue;
                }
            }
            else if (indexObj[fieldName] === undefined) {
                indexObj[fieldName] = fieldValue;
            }
            else {
                if (fieldFunc === "sum") {
                    indexObj[fieldName] += fieldValue;
                }
                else if (fieldFunc === "max") {
                    indexObj[fieldName] = Math.max(indexObj[fieldName], fieldValue);
                }
                else if (fieldFunc === "min") {
                    indexObj[fieldName] = Math.max(indexObj[fieldName], fieldValue);
                }
                else if (fieldFunc === "count") {
                    indexObj[fieldName] += 1;
                }
                else if (fieldValue) {
                    indexObj[fieldName] = fieldValue;
                }
            }
        }
        function mapObj(map, data) {
            var mappedObj = {}, pValue;
            function populateMappedObj(propertyName) {
                mappedObj[p][propertyName] = data[propertyName];
            }
            for (var p in map) {
                if (map.hasOwnProperty(p)) {
                    pValue = map[p];
                    if (typeof (pValue) === "string") {
                        mappedObj[p] = utils.strings.parseValue(pValue, data);
                    }
                    else if (angular.isArray(pValue)) {
                        mappedObj[p] = {};
                        angular.forEach(pValue, populateMappedObj);
                    }
                    else if (angular.isObject(pValue)) {
                        mappedObj[p] = mapObj(pValue, data);
                    }
                }
            }
            return mappedObj;
        }
        return {
            processData: function (processId, results, params) {
                var process = processes[processId];
                if (!process) {
                    throw new Error("Invalid process, '" + processId + "'.");
                }
                var data = results.data && angular.isArray(results.data) ? results : { data: [results] };
                return $q.when(process(data, params));
            }
        };
    }
    reportsProcess.$inject = ["$q", "DAL", "utils"];
    angular.module("Reports").factory("reportsProcess", reportsProcess);
})();

(function () {
    "use strict";
    /**
     * Service for searching data, for example searching available values in an entity
     * @param reports
     * @param DataEntityField
     * @param Report
     * @returns {{searchDataEntityField: searchDataEntityField}}
     */
    function search(reports, DataEntityField, Report) {
        function getDataEntityFieldSearchSettings(dataEntityField, labelField) {
            if (!(dataEntityField instanceof DataEntityField)) {
                throw new TypeError("Invalid data entity field, expected an instance of dataEntityField.");
            }
            if (labelField && !(labelField instanceof DataEntityField)) {
                throw new TypeError("Invalid labelField, expected an instance of dataEntityField.");
            }
            /* jshint validthis: true */
            return {
                search: searchDataEntityField.bind(this, dataEntityField.entity.id, dataEntityField.id, labelField && labelField.id, null),
                placeholder: "Search " + dataEntityField.name,
                resultField: dataEntityField.id,
                showValueOnSelect: true
            };
        }
        function searchDataEntityField(dataEntityId, dataEntityFieldId, labelFieldId, extraTerms, term) {
            var report = new Report({
                endpoint: {
                    api: "dataQuery",
                    dataQuery: getSearchFieldDataQuery(dataEntityId, dataEntityFieldId, labelFieldId, extraTerms)
                }, requiredParams: ["term"], params: [{
                        dashboardParam: "term", field: "term"
                    }], mock_data: "user_search"
            });
            return reports.runReport(report, { term: term }).then(function (results) {
                /**
                 *
                 * @type {Array<{normalized_username: string=, label: string=, value: string=}>}
                 */
                var tempArray = [];
                //since the search was changed to "Start with" and not "like" - no need for this option any more
                //keeping this code for the case we we change it back to like
                /*
                 //add the searched term to the first position at the result array
                 // - only if it's not exactly the return result
                 var addSearchLabel = true;
                 if(results.data.length == 1){
                 report.endpoint.dataQuery.fields.forEach(function (field) {
                 if(field.id && results.data[0][field.id] && results.data[0][field.id].toLowerCase() ===
                  term.toLowerCase()){
                 addSearchLabel = false;
                 }
                 });
                 }*/
                var addSearchLabel = false;
                if (addSearchLabel) {
                    tempArray[0] = { label: "Search: " + term, value: term };
                }
                results.data.forEach(function (result) {
                    tempArray.push(result);
                });
                //sanity check to verify display_name and normalized_username are present
                if (tempArray.length > 0 && tempArray[0].display_name && tempArray[0].normalized_username) {
                    //check for duplicate display names, if found concatenate the normalized_username
                    for (var i = 0; i < tempArray.length; i++) {
                        for (var j = i + 1; j < tempArray.length; j++) {
                            //if a pair was found, update both and go on to check the next name
                            if (tempArray[i].display_name === tempArray[j].display_name) {
                                tempArray[i].display_name += " (" + tempArray[i].normalized_username + ")";
                                tempArray[j].display_name += " (" + tempArray[j].normalized_username + ")";
                                break;
                            }
                        }
                    }
                }
                return tempArray;
            }).catch(function (error) {
                console.error("Can't execute field search: ", error);
            });
        }
        /*
         *   The search if preform using the start with operator define as part of the dataQuery language.
         *   dataEntityId - The entity on which the search is been perform
         *   dataEntityFieldId - field used as the return result of the search for the dashboard/widget using the search
         *   labelFieldId - field used for the search itself
         *   extraTerms - in the case you need to add additional condition to the search data query
         */
        function getSearchFieldDataQuery(dataEntityId, dataEntityFieldId, labelFieldId, extraTerms) {
            var fields = dataEntityFieldId;
            //if fields is not an array, make it an array (this test is for legacy purposes)
            if (!angular.isArray(fields)) {
                fields = [dataEntityFieldId];
            }
            if (labelFieldId) {
                fields.push(labelFieldId);
            }
            var terms = [{
                    type: "field", id: labelFieldId || dataEntityFieldId, operator: "startsWith", valueParam: "term"
                }];
            if (extraTerms) {
                terms = terms.concat(extraTerms);
            }
            return {
                entity: dataEntityId, fields: fields, conditions: {
                    operator: "AND", terms: terms
                }, groupBy: fields, sort: labelFieldId || dataEntityFieldId, limit: 10
            };
        }
        return {
            getDataEntityFieldSearchSettings: getDataEntityFieldSearchSettings,
            searchDataEntityField: searchDataEntityField
        };
    }
    search.$inject = ["reports", "DataEntityField", "Report"];
    angular.module("Search", ["Utils", "Reports", "DataEntities"]).factory("search", search);
})();

(function () {
    "use strict";
    /**
     * Service for checking the conditions for displaying the popup to potentially prevent the user from running large
     * queries
     */
    function popupConditions(config) {
        var scoreThreshold = config.scoreThreshold;
        var daysThreshold = config.daysThreshold;
        function shouldNotifyPopup(params) {
            var minScore = 100;
            var timeStart = 0;
            var timeEnd = 0;
            var filter;
            //sanity - if no control params
            if (!params) {
                return "";
            }
            //if explore screen
            if (params.filters) {
                filter = params.filters;
                minScore = filter[1].value;
                timeStart = filter[0].value.timeStart;
                timeEnd = filter[0].value.timeEnd;
            }
            else {
                filter = params.urlParams;
                //can only be one of these cases, order does not matter
                if (filter.top_events_dates) {
                    timeStart = filter.top_events_dates.split(",")[0];
                    timeEnd = filter.top_events_dates.split(",")[1];
                }
                else if (filter.notifications_events_dates) {
                    timeStart = filter.notifications_events_dates.split(",")[0];
                    timeEnd = filter.notifications_events_dates.split(",")[1];
                }
                else if (filter.notifications_events_dates) {
                    timeStart = filter.high_privileged_accounts_event_dates.split(",")[0];
                    timeEnd = filter.high_privileged_accounts_event_dates.split(",")[1];
                }
                else if (filter.notifications_events_dates) {
                    timeStart = filter.sensitive_resources_events_dates.split(",")[0];
                    timeEnd = filter.sensitive_resources_events_dates.split(",")[1];
                }
                else if (filter.ip_investigation_events_dates) {
                    timeStart = filter.ip_investigation_events_dates.split(",")[0];
                    timeEnd = filter.ip_investigation_events_dates.split(",")[1];
                }
                else if (filter.default_filters) {
                    timeStart = filter.default_filters.split(":")[1];
                    timeEnd = filter.default_filters.split(":")[3].split(",")[0];
                }
                if (filter.filters && filter.filters.indexOf("score") > 0) {
                    var array = filter.filters.split("=");
                    minScore = array[array.length - 1];
                }
                else if (filter.minscore !== undefined && _.isNumber(filter.minscore)) {
                    minScore = filter.minscore;
                }
            }
            var daysDiff = (timeEnd - timeStart) / (1000 * 60 * 60 * 24);
            if (minScore < scoreThreshold) {
                return config.popupScoreMessage;
            }
            if (daysDiff > daysThreshold) {
                return config.popupDaysMessage;
            }
            return "";
        }
        return {
            shouldNotifyPopup: shouldNotifyPopup
        };
    }
    popupConditions.$inject = ["config"];
    angular.module("PopupConditions", [])
        .factory("popupConditions", popupConditions);
})();

angular.module("Widgets", ["Utils", "Conditions", "State", "EventBus", "Controls"]);

(function () {
    'use strict';
    var widgetFlags = new Set(["alignControlsRight", "contentsOnly", "noBorder", "stretchVertically", "fullHeight"]);
    function WidgetClass($q, $timeout, utils, widgetViews, WidgetView, WidgetButton, Report, conditions, state, ControlList, EventBus) {
        function validateWidgetReport(config) {
            if (config.reportId && typeof (config.reportId) !== "string") {
                throw new TypeError("Can't create widget, reportId must be a string.");
            }
            if (config.reportId && config.report) {
                throw new Error("A widget cannot have both a 'reportId' and a 'report' properties.");
            }
        }
        /**
         Some widgets, e.g. users_dist, need additional data process after the report result gets back from server.
         in user_dist, we need to merge the results according to their label
         */
        function mergeResults(data) {
            var mergedData = {};
            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                var line = data_1[_i];
                if (!mergedData[line.label]) {
                    mergedData[line.label] = 0;
                }
                mergedData[line.label] += line.login_count;
            }
            var newMergedData = [];
            for (var item in mergedData) {
                if (mergedData.hasOwnProperty(item)) {
                    newMergedData.push({ "label": item, "login_count": mergedData[item] });
                }
            }
            return newMergedData;
        }
        /**
         * If the specified widget has a report and it has params, the dashboardParams from the report are added
         * to the widget's refreshOn map, so it refreshes when those params change.
         * @param widget
         */
        function setWidgetReportRefreshOn(widget) {
            if (!widget.report || !widget.report.params) {
                return;
            }
            if (!widget.refreshOn) {
                widget.refreshOn = {};
            }
            widget.report.params.forEach(function (reportParam) {
                widget.refreshOn[reportParam.dashboardParam] = true;
            });
        }
        /**
         * To avoid infinite recursion when working with widgets, a dashboard can't be set as a property of the widget
         * i holds
         * (It's possible, but Angular dies), just the properties required for the widget to work are set as the
         * parent.
         * @param parentObj
         * @returns {{getState: (Function|*|getState)}}
         */
        function getNonRecursiveParent(parentObj) {
            if (parentObj && parentObj.getState) {
                return {
                    getState: parentObj.getState.bind(parentObj),
                    isReady: parentObj.isReady ? parentObj.isReady.bind(parentObj) : function () {
                        return true;
                    }
                };
            }
            return null;
        }
        // String properties of widgets which are affected by state changes:
        var parsableProperties = ["params", "title", "noDataTitle", "loadingTitle", "description", "noDataMessage",
            "controlsTitle"];
        var STATE_CHANGE_EVENT = "stateChange";
        var allWidgets = {};
        function Widget(config, parent) {
            if (config instanceof Widget) {
                config = config._config;
            }
            var widget = this;
            this.validate(config);
            this._config = config;
            this.parent = getNonRecursiveParent(parent);
            this.refreshOn = {};
            this.id = config.id;
            this.config = {
                show: config.show
            };
            this.show = true;
            for (var _i = 0, parsableProperties_1 = parsableProperties; _i < parsableProperties_1.length; _i++) {
                var parsableProperty = parsableProperties_1[_i];
                this.config[parsableProperty] = config[parsableProperty];
            }
            this.views = config.views.map(function (viewConfig) {
                return new WidgetView(viewConfig);
            });
            this.priority = config.priority || 0;
            this.hideOnNoData = !!config.hideOnNoData;
            this.hideOnError = !!config.hideOnError;
            if (config.forceRefresh) {
                this.forceRefresh = config.forceRefresh;
            }
            else {
                this.forceRefresh = false;
            }
            if (config.exploreBased) {
                this.exploreBased = config.exploreBased;
            }
            if (config.className) {
                this.className = config.className;
            }
            if (config.controls) {
                this.controlsList = new ControlList(config.controls);
            }
            this.setReport(config);
            this.flags = config.flags;
            this.loadingDataMessage = config.loadingDataMessage || "Loading data";
            if (config.height) {
                this.height = config.height;
            }
            if (config.buttons) {
                this.setWidgetButtons(config.buttons);
            }
            if (config.mergeResults) {
                this.mergeResults = config.mergeResults;
            }
            if (config.refreshOn) {
                var refreshOn = config.refreshOn.constructor === Array ? config.refreshOn : [config.refreshOn];
                refreshOn.forEach(function (param) {
                    widget.refreshOn[param] = true;
                });
            }
            this.update();
            this.getData();
            this._eventBus = EventBus.setToObject(this, [STATE_CHANGE_EVENT]);
        }
        /**
         * Creates a copy of the widget, by first creating another Widget with the same config, then setting the
         * current properties.
         * @param widget
         * @returns {WidgetClass.Widget}
         */
        Widget.copy = function (widget) {
            var newWidget = new Widget(widget._config);
            for (var p in widget) {
                if (widget.hasOwnProperty(p)) {
                    // Views are not copied from widget to widget, they're taken from configuration only.
                    if (p !== "views") {
                        newWidget[p] = widget[p];
                    }
                }
            }
            return newWidget;
        };
        /**
         * Returns a copy of this widget
         * @returns {WidgetClass.Widget}
         */
        Widget.prototype.clone = function () {
            return Widget.copy(this);
        };
        /**
         * Validates the configuration used to build the Widget. Throws error if invalid.
         * @param config
         */
        Widget.prototype.validate = function (config) {
            if (!config) {
                return;
            }
            if (config.id && typeof (config.id) !== "string") {
                throw new TypeError("Invalid ID for widget. Expected a string but got " + typeof (config.id));
            }
            validateWidgetReport(config);
            if (config.show) {
                if (!config.show.conditions) {
                    throw new Error("Can't create widget - 'show' exists without conditions.");
                }
            }
            if (config.priority && typeof (config.priority) !== "number") {
                throw new TypeError("Cant' create widget, priority must be a number.");
            }
            if (!config.views) {
                throw new Error("Can't create widget, missing the views array.");
            }
            if (config.views.constructor !== Array) {
                throw new TypeError("Invalid views property for widget, expected an array.");
            }
            for (var _i = 0, _a = config.views; _i < _a.length; _i++) {
                var view = _a[_i];
                if (!view.type) {
                    throw new Error("Can't create widget, view has no type.");
                }
                if (typeof (view.type) !== "string") {
                    throw new TypeError("Cant' create widget, view type must be a string.");
                }
                if (!widgetViews.viewExists(view.type)) {
                    throw new Error("Unknown view type, '" + view.type + "'.");
                }
                widgetViews.validateSettings(view.type, view.settings);
            }
            if (config.flags) {
                for (var flagName in config.flags) {
                    if (config.flags.hasOwnProperty(flagName)) {
                        if (!widgetFlags.has(flagName)) {
                            throw new Error("Unknown widget flag, '" + flagName + "'.");
                        }
                    }
                }
            }
            if (config.loadingDataMessage && typeof (config.loadingDataMessage) !== "string") {
                throw new TypeError("Invalid loadingDataMessage for widget, expected a string but got " +
                    config.loadingDataMessage);
            }
            if (config.height) {
                if (typeof (config.height) !== "number") {
                    throw new TypeError("Invalid height for widget, expected a number but got " +
                        typeof (config.height));
                }
                if (config.height < 0) {
                    throw new Error("Invalid height for widget, must be a positive number.");
                }
            }
            if (config.buttons && config.buttons.constructor !== Array) {
                throw new TypeError("Invalid buttons for Widget, expected an array but got " + config.buttons);
            }
            if (config.refreshOn) {
                if (config.refreshOn.constructor === Array) {
                    config.refreshOn.forEach(function (refreshOnItem) {
                        if (typeof (refreshOnItem) !== "string") {
                            throw new TypeError("Invalid refreshOn for widget, expected a string but got " +
                                refreshOnItem + ".");
                        }
                    });
                }
                else if (typeof (config.refreshOn) !== "string") {
                    throw new TypeError("Invalid refreshOn for widget, expected either an array or a string.");
                }
            }
        };
        /**
         * Called when the widget is no longer needed, to clear memory and event handlers.
         *
         */
        Widget.prototype.destroy = function () {
            this.parent = null;
            this.show = true;
            this.rawData = null;
            this.views.forEach(function (view) {
                view.destroy();
            });
            this.noData = false;
            this.error = null;
        };
        /**
         * Sets a report to the widget. Must be an object, containing either 'reportId' (string), Object report or a
         * Report instance.
         * @param reportConfig
         */
        Widget.prototype.setReport = function (reportConfig) {
            var widget = this;
            validateWidgetReport(reportConfig);
            if (reportConfig.reportId) {
                Report.loadReport(reportConfig).then(function (report) {
                    widget.report = report;
                    setWidgetReportRefreshOn(widget);
                });
            }
            else if (reportConfig.report) {
                if (reportConfig.report instanceof Report) {
                    this.report = reportConfig.report;
                }
                else {
                    this.report = new Report(utils.objects.copy(reportConfig.report));
                }
                setWidgetReportRefreshOn(widget);
            }
            return this;
        };
        /**
         * Sets the Widget's buttons and sets the Widget as the widgetButton' parent
         * @param buttons
         */
        Widget.prototype.setWidgetButtons = function (buttons) {
            this.buttons = buttons.map(function (buttonConfig) {
                return new WidgetButton(buttonConfig, this);
            }.bind(this));
        };
        /**
         * Re-runs the widget's data, without using ui cache
         * @returns {*}
         */
        Widget.prototype.refresh = function () {
            this.getData(true);
        };
        /**
         * Runs the widget's report and sets the data for the widget
         */
        Widget.prototype.getData = function (noCache) {
            if (this.forceRefresh) {
                state.refresh();
                return;
            }
            if (!this.report || !this.parent || this.parent.isReady() === false) {
                return;
            }
            if (this._widgetReportTimeout) {
                $timeout.cancel(this._widgetReportTimeout);
            }
            var widget = this;
            widget.isLoading = true;
            if (widget.loadingTitle) {
                widget.title = widget.loadingTitle;
            }
            this._widgetReportTimeout = $timeout(function () {
                // We need to run the report in case we plan to show the widget,
                // or in case we show it only if it has data
                if (widget.show || widget.hideOnNoData) {
                    widget.report.run(widget.getState(), widget.priority, noCache).then(function (results) {
                        widget.noData = results.data && !results.data.length;
                        var widgetState = widget.getState();
                        widget.rawData = results.data;
                        widget.total = results.total;
                        if (widget.mergeResults) {
                            widget.rawData = mergeResults(results.data);
                        }
                        widget.views.forEach(function (view) {
                            view.setData(widget.rawData, widgetState);
                        });
                        // Add a warning message to the widget if the number of results exceeds the maximum that can be
                        // displayed
                        if (widget._config.message && widget._config.message.params &&
                            widget._config.message.params.maxResults) {
                            var maxResults = widget._config.message.params.maxResults;
                            if (widget.total >= maxResults) {
                                widget.message = " Too many results, displaying the first " + maxResults + ".";
                            }
                            else if (widget.message) {
                                delete widget.message;
                            }
                        }
                    }, function (error) {
                        widget.error = "Error loading data";
                        console.error("Error getting data for widget: ", error);
                    }).finally(function () {
                        widget.isLoading = false;
                        widget.update();
                    });
                }
            }, 40);
        };
        /**
         * Re-runs the widget's data, without using ui cache and also force server not using cache
         * @returns {*}
         */
        Widget.prototype.manualRefresh = function () {
            if (this.report) {
                this.report.options = utils.objects.extend({}, this.report.options, { useCache: true });
            }
            return this.refresh();
        };
        /**
         * Gets an object containing the params for this widget, including parent's state and app state
         * @returns object
         */
        Widget.prototype.getState = function () {
            var parentState = this.parent && this.parent.getState && this.parent.getState();
            return utils.objects.extend({}, state.currentParams, parentState, this.params, this.controlsList && this.controlsList.getParams());
        };
        Widget.prototype.setState = function (params) {
            if (!this.params) {
                this.params = {};
            }
            var prevParams = utils.objects.copy(this.params);
            utils.objects.extend(this.params, params);
            if (!utils.objects.areEqual(prevParams, this.params)) {
                utils.objects.extend(this.params, params);
                state.setParams(params, true, false);
                this._eventBus.triggerEvent(STATE_CHANGE_EVENT, { params: params });
                this.refreshIfRequired(params);
            }
        };
        /**
         * Updates any parsable properties according to the current widget and application state
         * Also updates views
         */
        Widget.prototype.update = function () {
            function getParsedValue(parsableProperty) {
                var propertyConfig = widget.config[parsableProperty];
                if (!propertyConfig) {
                    return undefined;
                }
                if (Object(propertyConfig) === propertyConfig) {
                    var parsedValue = {};
                    for (var p in propertyConfig) {
                        if (propertyConfig.hasOwnProperty(p)) {
                            parsedValue[p] = parseStringValue(propertyConfig[p]);
                        }
                    }
                    return parsedValue;
                }
                else {
                    return parseStringValue(propertyConfig);
                }
            }
            function parseStringValue(value) {
                var widgetData = angular.extend({}, widget.params, { total: widget.total, resultsCount: widget.rawData && widget.rawData.length });
                return utils.strings.parseValue(value, widgetData, widgetState);
            }
            var widgetState = this.getState(), widget = this;
            for (var _i = 0, parsableProperties_2 = parsableProperties; _i < parsableProperties_2.length; _i++) {
                var parsableProperty = parsableProperties_2[_i];
                this[parsableProperty] = getParsedValue(parsableProperty);
            }
            if (this.noDataTitle && (this.noData || this.error)) {
                this.title = this.noDataTitle;
            }
            if (!this.noDataMessage) {
                this.noDataMessage = "No data to display";
            }
            if (widget.noData && widget.hideOnNoData) {
                widget.show = false;
            }
            else if (!(this.hideOnNoData && this.noData) && this.config.show) {
                this.show = conditions.validateConditions(this.config.show.conditions, {}, widgetState);
            }
            else {
                this.show = true;
            }
            if (this.rawData) {
                for (var _a = 0, _b = this.views; _a < _b.length; _a++) {
                    var view = _b[_a];
                    view.setData(this.rawData, widgetState);
                }
            }
        };
        /**
         * Sets the parent object of the Widget, avoids infinite recursion
         * @param parent
         */
        Widget.prototype.setParent = function (parent) {
            this.parent = getNonRecursiveParent(parent);
        };
        Widget.loadWidget = function (config) {
            function loadWidgetReport(widgetConfig) {
                if (widgetConfig.reportId) {
                    return Report.loadReport(utils.objects.extend({}, widgetConfig.report, { reportId: widgetConfig.reportId })).then(function (report) {
                        widgetConfig.report = report;
                        delete widgetConfig.reportId;
                        return widgetConfig;
                    });
                }
                return $q.when(widgetConfig);
            }
            if (config instanceof Widget) {
                return config.clone();
            }
            if (config.widgetId) {
                var widgetId = createWidgetId(config);
                if (!config.noCache) {
                    var existingWidget = allWidgets[widgetId];
                    if (existingWidget) {
                        return $q.when(existingWidget);
                    }
                }
                return utils.http.wrappedHttpGet("data/widgets/" + config.widgetId.replace(/\./g, "/") +
                    ".json").then(function (widgetConfig) {
                    var fullWidgetConfig = utils.objects.extend({}, widgetConfig, config), widgetId = createWidgetId(fullWidgetConfig);
                    delete fullWidgetConfig.widgetId;
                    return loadWidgetReport(fullWidgetConfig).then(function (fullWidgetConfig) {
                        var widget = new Widget(fullWidgetConfig);
                        allWidgets[widgetId] = widget;
                        return widget;
                    });
                }, function (error) {
                    var errorMessage = error.status === 404 ? "Widget '" + widgetId + "' not found." :
                        "Can't get widget '" + widgetId + "'. Error: " + error.data;
                    return $q.reject(errorMessage);
                });
            }
            if (config.reportId) {
                return loadWidgetReport(config).then(function (widgetConfig) {
                    return new Widget(widgetConfig);
                });
            }
            return new Widget(config);
        };
        /**
         * This function get widgetr id and create an extend of widgetid if needed using the specificId configuration -
         * for example in graph case
         * @param config
         */
        function createWidgetId(config) {
            //if specific id is define at the configuration the widget id will be - widgetid+"_"+specificId
            return config.widgetId + (config.specificId ? "_" + config.specificId : "");
        }
        /**
         * Runs when the app's state changes. If the widget should be updated according to the refreshOn map, it is
         * refreshed.
         * @param params
         */
        Widget.prototype.refreshIfRequired = function (params) {
            for (var changedParam in params) {
                if (params.hasOwnProperty(changedParam)) {
                    if (this.refreshOn[changedParam]) {
                        this.refresh();
                        return this;
                    }
                }
            }
            return this;
        };
        return Widget;
    }
    WidgetClass.$inject =
        ["$q", "$timeout", "utils", "widgetViews", "WidgetView", "WidgetButton", "Report", "conditions", "state",
            "ControlList", "EventBus"];
    angular.module("Widgets").factory("Widget", WidgetClass);
})();

(function () {
    'use strict';
    function WidgetViewClass(widgetViews) {
        /**
         * Constructor for widget views
         * @param config
         * @constructor
         */
        function WidgetView(config) {
            this.type = config.type;
            this.settings = config.settings;
            this.templateUrl =
                'widgets/' + this.type.replace(/\./g, '/') + '/' + this.type.split('.').pop() + '.view.html';
        }
        /**
         * Sets data to the view, which parses it according to its view type.
         * @param {Array} data
         * @param {Object} state
         */
        WidgetView.prototype.setData = function (data, state) {
            var view = this;
            view.data = null;
            widgetViews.parseViewData(view, data, state).then(function (viewData) {
                view.data = viewData;
            }, function (error) {
                view.error = error;
            });
        };
        /**
         * To be called when the view is no longer needed, to free memory, etc.
         */
        WidgetView.prototype.destroy = function () {
            this.data = null;
            this.error = null;
        };
        return WidgetView;
    }
    WidgetViewClass.$inject = ["widgetViews"];
    angular.module("Widgets").factory("WidgetView", WidgetViewClass);
})();

(function () {
    'use strict';
    function WidgetButtonClass($location, utils) {
        var supportedButtonTypes = new Set(["button", "multiLink", "link"]);
        /**
         * To avoid infinite recursion when working with widgets and widgetButton , a widget can't be set as a property
         * of the widgetButton i holds
         * (It's possible, but Angular dies), just the properties required for the widgetButton to work are set as the
         * parent.
         * @param parentObj
         * @returns {{getState: (Function|*|getState)}}
         */
        function getNonRecursiveParent(parentObj) {
            if (parentObj && parentObj.getState) {
                return {
                    getState: parentObj.getState.bind(parentObj),
                    isReady: parentObj.isReady ? parentObj.isReady.bind(parentObj) : function () {
                        return true;
                    }
                };
            }
            return null;
        }
        function WidgetButton(config, parent) {
            this.validate(config);
            if (config.type) {
                this.type = config.type;
                this.settings = config.settings;
            }
            else {
                this.type = config.type || "button";
                this._text = config.text;
                this.icon = config.icon;
                this.onClick = config.onClick;
                this.url = config.url;
                this.title = config.title;
                this.parent = getNonRecursiveParent(parent);
                this.text = utils.strings.parseValue(this._text, {}, this.parent.getState());
            }
        }
        WidgetButton.prototype.redirect = function () {
            $location.url(utils.strings.parseValue(this.url, {}, this.parent.getState()));
        };
        /**
         * update the button text
         */
        WidgetButton.prototype.refresh = function () {
            this.text = utils.strings.parseValue(this._text, {}, this.parent.getState());
        };
        WidgetButton.prototype.validate = function (config) {
            if (config.type) {
                if (!supportedButtonTypes.has(config.type)) {
                    throw new Error("Unknown widget button type, '" + config.type + "'.");
                }
            }
            else {
                if (!config.onClick && !config.url) {
                    throw new Error("Can't create WidgetButton, missing onClick.");
                }
                if (!config.onClick && config.url) {
                    config.onClick = this.redirect;
                }
                if (!angular.isFunction(config.onClick)) {
                    throw new TypeError("Invalid onClick for WidgetButton, expected a function but got " +
                        config.onClick);
                }
                if (!config.text && !config.icon) {
                    throw new Error("Can't create WidgetButton, text or icon is required.");
                }
            }
        };
        return WidgetButton;
    }
    WidgetButtonClass.$inject = ["$location", "utils"];
    angular.module("Widgets").factory("WidgetButton", WidgetButtonClass);
})();

(function () {
    'use strict';
    function dashboards($q, DAL, Widget, Dashboard, utils, Report) {
        function loadWidgets(widgets) {
            var loadPromises = widgets.map(function (widgetConfig) {
                return Widget.loadWidget(widgetConfig);
            });
            return $q.all(loadPromises);
        }
        function loadReports(reports) {
            var loadPromises = reports.map(function (reportConfig) {
                return Report.loadReport(reportConfig).then(function (report) {
                    var loadedConfig = {
                        report: report
                    };
                    return utils.objects.extend({}, reportConfig, loadedConfig);
                });
            });
            return $q.all(loadPromises);
        }
        function getColumnWidgets(column) {
            var promises = [];
            if (column.widgets) {
                promises.push(loadWidgets(column.widgets).then(function (widgets) {
                    column.widgets = prepareDashboardWidgets(widgets);
                }));
                column.widgets = [];
            }
            if (column.rows) {
                column.rows.forEach(function (row) {
                    if (row.widgets) {
                        promises.push(loadWidgets(row.widgets).then(function (widgets) {
                            row.widgets = prepareDashboardWidgets(widgets);
                        }));
                        row.widgets = [];
                    }
                    if (row.columns) {
                        row.columns.forEach(function (column) {
                            promises.push(getColumnWidgets(column));
                        });
                    }
                });
            }
            return $q.all(promises);
        }
        /**
         * Creates a closure to use for preparing widgets to be placed in a dashboard
         * @param widgets
         * @returns {Function}
         */
        function prepareDashboardWidgets(widgets) {
            return widgets.map(function (widget) {
                return widget.clone();
            });
        }
        function getDashboardWidgets(dashboardConfig) {
            dashboardConfig = utils.objects.copy(dashboardConfig);
            var dashboardPromises = [];
            if (dashboardConfig.widgets) {
                dashboardPromises.push(loadWidgets(dashboardConfig.widgets).then(function (widgets) {
                    dashboardConfig.widgets = prepareDashboardWidgets(widgets);
                }));
            }
            if (dashboardConfig.columns) {
                dashboardConfig.columns.forEach(function (column) {
                    dashboardPromises.push(getColumnWidgets(column));
                });
            }
            if (dashboardConfig.reports) {
                dashboardPromises.push(loadReports(dashboardConfig.reports).then(function (reports) {
                    dashboardConfig.reports = reports;
                }));
            }
            return $q.all(dashboardPromises).then(function () {
                return new Dashboard(dashboardConfig);
            });
        }
        var cachedDashboardConfigs = {};
        var methods = {
            getDashboardById: function (dashboardId, dashboardDataOnly) {
                if (cachedDashboardConfigs[dashboardId]) {
                    return getDashboardWidgets(cachedDashboardConfigs[dashboardId]).then(function (dashboard) {
                        return dashboard;
                    });
                }
                else {
                    return DAL.dashboards.getDashboardById(dashboardId).then(function (dashboard) {
                        function getWidgetsAndReturn(dashboardConfig) {
                            cachedDashboardConfigs[dashboardId] = dashboardConfig;
                            return getDashboardWidgets(dashboardConfig).then(function (dashboard) {
                                return dashboard;
                            });
                        }
                        if (dashboard.extends) {
                            return methods.getDashboardById(dashboard.extends, true).then(function (extendedDashboard) {
                                var dashboardConfig = utils.objects.extend({}, extendedDashboard, dashboard);
                                delete dashboardConfig.extends;
                                return getWidgetsAndReturn(dashboardConfig);
                            });
                        }
                        else {
                            if (dashboardDataOnly) {
                                return dashboard;
                            }
                            return getWidgetsAndReturn(dashboard);
                        }
                    });
                }
            },
            createDashboard: function (settings) {
                var dashboard = {
                    id: "dashboard_" + new Date().valueOf(),
                    name: "Untitled Dashboard",
                    columns: [
                        { widgets: [] }
                    ]
                };
                return angular.extend(dashboard, settings);
            }
        };
        return methods;
    }
    dashboards.$inject = ["$q", "DAL", "Widget", "Dashboard", "utils", "Report"];
    angular.module("Widgets").factory("dashboards", dashboards);
})();

(function () {
    'use strict';
    function DashboardClass($q, Widget, WidgetButton, DashboardLayout, utils, conditions, Report, reports, state, ControlList) {
        // String properties of widgets which are affected by state changes:
        var parsableProperties = ["params", "title", "description", "browserTitle"];
        function Dashboard(config) {
            function checkConditions(navItem) {
                if (navItem.children) {
                    navItem.children = navItem.children.filter(checkConditions);
                }
                return !(navItem.conditions &&
                    !conditions.validateConditions(navItem.conditions, null, state.currentParams));
            }
            this.validate(config);
            this._config = config;
            this.id = config.id || config.dashboardId;
            this.config = {};
            for (var _i = 0, parsableProperties_1 = parsableProperties; _i < parsableProperties_1.length; _i++) {
                var parsableProperty = parsableProperties_1[_i];
                this.config[parsableProperty] = config[parsableProperty];
            }
            if (config.controls) {
                this.controlsList = new ControlList(config.controls);
            }
            if (config.navigation) {
                // TODO: Create a DashboardNavigationClass
                this.navigation = config.navigation;
                if (this.navigation.children) {
                    this.navigation.children = this.navigation.children.filter(checkConditions);
                }
            }
            if (config.className) {
                this.className = config.className;
            }
            // The config.details have to be validated and maybe have a class of their own:
            if (config.details) {
                this.details = config.details;
            }
            // TODO: Validate and create a class for DashboardMessage
            if (config.messages) {
                this.messages = config.messages;
            }
            if (config.requiredParams) {
                this.requiredParams = config.requiredParams;
                this.checkReady();
            }
            else {
                this.ready = true;
            }
            if (config.search) {
                this.search = config.search;
            }
            this.update();
            if (config.reports) {
                this.ready = false;
                this.reports = config.reports.map(function (report) {
                    return new DashboardReport(report);
                });
            }
            if (config.buttons) {
                this.setDashboardButtons(config.buttons);
            }
            if (config.widgets) {
                this.setWidgets(config.widgets);
            }
            if (config.columns) {
                this.setColumns(config.columns);
            }
            if (config.rows) {
                this.setRows(config.rows);
            }
            this.runReports();
        }
        Dashboard.prototype.validate = function (config) {
            /*
             if (!config.widgets && !config.columns && !config.rows)
             throw new Error("Can't create Dashboard, missing one of the following: widgets, columns or rows.");
             */
            if (config.name && typeof (config.name) !== "string") {
                throw new TypeError("Invalid name for Dashboard, expected a string but got " +
                    config.name.constructor.name + ".");
            }
            if (config.reports) {
                if (config.reports.constructor !== Array) {
                    throw new TypeError("Invalid reports for Dashboard, expected an array but got " +
                        config.reports.constructor.name + ".");
                }
                config.reports.forEach(function (reportConfig) {
                    if (!(reportConfig.report instanceof Report)) {
                        throw new TypeError("Can't create dashboard, report is not an instance of Report: " +
                            reportConfig.report + ".");
                    }
                });
            }
            if (config.requiredParams) {
                if (config.requiredParams.constructor !== Array) {
                    throw new TypeError("Invalid requiredParams for Dashboard, expected an Array but got " +
                        config.requiredParams.constructor.name + ".");
                }
                config.requiredParams.forEach(function (param) {
                    if (typeof (param) !== "string") {
                        throw new TypeError("Invalid param name. Expected a string but got " + param + ".");
                    }
                });
            }
        };
        /**
         * Check if all the dashboard's required params exist, then set the 'ready' property to true/false.
         * @returns {boolean}
         */
        Dashboard.prototype.checkReady = function () {
            if (!this.requiredParams) {
                this.ready = true;
                return true;
            }
            var currentState = this.getState();
            for (var _i = 0, _a = this.requiredParams; _i < _a.length; _i++) {
                var param = _a[_i];
                if (!currentState[param]) {
                    this.ready = false;
                    return false;
                }
            }
            this.ready = true;
            return true;
        };
        /**
         * Returns true if all the dashboard's required params are available, false if not.
         * @returns {boolean|*}
         */
        Dashboard.prototype.isReady = function () {
            return this.ready;
        };
        /**
         * If the dashboard has reports, run them, set the returned data to the dashboard's state, then refresh any
         * widgets and buttons that need to be refreshed
         * @returns {Promise}
         */
        Dashboard.prototype.runReports = function () {
            if (!this.reports) {
                return $q.when();
            }
            var dashboard = this, dashboardState = this.getState();
            var reportPromises = this.reports.map(function (dashboardReport) {
                return reports.runReport(dashboardReport.report, dashboardState, false).then(function (results) {
                    if (results.data) {
                        // replace the userId from the URL (e.g"55133cede4b0fc25429d9770") to meaningfull username (e.g
                        // "user tag")
                        var paramsData = results.data.constructor === Array ? results.data[0] : results.data;
                        return state.mapParams(dashboardReport.dashboardParams, paramsData);
                    }
                });
            });
            return $q.all(reportPromises).then(function (reportsParams) {
                for (var _i = 0, reportsParams_1 = reportsParams; _i < reportsParams_1.length; _i++) {
                    var params = reportsParams_1[_i];
                    dashboard.setParams(params);
                }
                if (dashboard.checkReady()) {
                    dashboard.getAllWidgets().forEach(function (widget) {
                        widget.refreshIfRequired(params);
                    });
                    if (dashboard.buttons) {
                        dashboard.buttons.forEach(function (button) {
                            button.refresh();
                        });
                    }
                    delete dashboard._messages;
                    state.setParams(params, false);
                }
            });
        };
        /**
         * Extends the dashboard's params with the specified params
         * @param {Object} params
         */
        Dashboard.prototype.setParams = function (params) {
            if (!this.params) {
                this.params = {};
            }
            utils.objects.extend(this.params, params);
        };
        /**
         * Sets the Dashboard's widgets and sets the Dashboard as the widgets' parent
         * @param widgets
         */
        Dashboard.prototype.setWidgets = function (widgets) {
            this.widgets = widgets.map(function (widgetConfig) {
                if (widgetConfig instanceof Widget) {
                    widgetConfig.setParent(this);
                    return widgetConfig;
                }
                return new Widget(widgetConfig, this);
            }.bind(this));
        };
        /**
         * Sets the Dashboard's buttons and sets the Dashboard as the widgetButton' parent
         * @param buttons
         */
        Dashboard.prototype.setDashboardButtons = function (buttons) {
            this.buttons = buttons.map(function (buttonConfig) {
                return new WidgetButton(buttonConfig, this);
            }.bind(this));
        };
        /**
         * Sets the Dashboard's columns and sets the Dashboard as the columns' parent
         * @param columns
         */
        Dashboard.prototype.setColumns = function (columns) {
            this.columns = columns.map(function (columnConfig) {
                return new DashboardLayout.Column(columnConfig, this);
            }.bind(this));
            this.columns = this.columns.filter(function (column) {
                return column.show;
            });
            DashboardLayout.setColumnSpans(this.columns);
        };
        /**
         * Sets the Dashboard's rows and sets the Dashboard as the rows' parent
         * @param rows
         */
        Dashboard.prototype.setRows = function (rows) {
            this.rows = rows.map(function (rowConfig) {
                return new DashboardLayout.Row(rowConfig, this);
            }.bind(this));
        };
        /**
         * Updates any parsable properties according to the current dashboard and application state
         * Also updates views
         */
        Dashboard.prototype.update = function () {
            function getParsedValue(parsableProperty) {
                var propertyConfig = dashboard.config[parsableProperty];
                if (!propertyConfig) {
                    return undefined;
                }
                if (Object(propertyConfig) === propertyConfig) {
                    var parsedValue = {};
                    for (var p in propertyConfig) {
                        if (propertyConfig.hasOwnProperty(p)) {
                            parsedValue[p] = parseStringValue(propertyConfig[p]);
                        }
                    }
                    return parsedValue;
                }
                else {
                    return parseStringValue(propertyConfig);
                }
            }
            function parseStringValue(value) {
                return utils.strings.parseValue(value, {}, dashboardState);
            }
            var dashboardState = this.getState(), dashboard = this;
            for (var _i = 0, parsableProperties_2 = parsableProperties; _i < parsableProperties_2.length; _i++) {
                var parsableProperty = parsableProperties_2[_i];
                this[parsableProperty] = getParsedValue(parsableProperty);
            }
        };
        /**
         * Returns all the widgets in the dashboard: in columns, rows and the dashboard itself
         */
        Dashboard.prototype.getAllWidgets = function () {
            var widgets = this.widgets || [];
            if (this.columns) {
                for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    widgets = widgets.concat(column.getAllWidgets());
                }
            }
            if (this.rows) {
                for (var _b = 0, _c = this.rows; _b < _c.length; _b++) {
                    var row = _c[_b];
                    widgets = widgets.concat(row.getAllWidgets());
                }
            }
            return widgets;
        };
        Dashboard.prototype.getState = function () {
            return utils.objects.extend({}, state.currentParams, this.params, this.controlsList && this.controlsList.getParams());
        };
        function DashboardReport(config) {
            this.report = config.report;
            this.dashboardParams = config.dashboardParams;
            this.useFirstIndex = !!config.useFirstIndex;
        }
        Dashboard.prototype.getDefaultUrlNavigation = function () {
            function getNavigationUrl(navItem) {
                if (navItem.url) {
                    return navItem.url;
                }
                if (navItem.children && navItem.children.length > 0) {
                    for (var childIndex in navItem.children) {
                        if (navItem.children.hasOwnProperty(childIndex)) {
                            var url = getNavigationUrl(navItem.children[childIndex]);
                            if (url) {
                                return url;
                            }
                        }
                    }
                }
            }
            if (this.navigation) {
                return getNavigationUrl(this.navigation);
            }
        };
        return Dashboard;
    }
    DashboardClass.$inject =
        ["$q", "Widget", "WidgetButton", "DashboardLayout", "utils", "conditions", "Report", "reports", "state",
            "ControlList"];
    angular.module("Widgets").factory("Dashboard", DashboardClass);
})();

(function () {
    'use strict';
    function DashboardLayout(Widget, conditions) {
        var SPAN_SIZE = 15;
        function DashboardRow(config, dashboard) {
            this.validate(config);
            if (config.className) {
                this.className = config.className;
            }
            if (config.show) {
                this.show = conditions.validateConditions(config.show.conditions, {}, null);
            }
            else {
                this.show = true;
            }
            if (this.show) {
                if (config.widgets) {
                    this.widgets = config.widgets.map(function (widgetConfig) {
                        return new Widget(widgetConfig, dashboard);
                    });
                }
                if (config.columns) {
                    this.columns = config.columns.map(function (rowConfig) {
                        return new DashboardColumn(rowConfig, dashboard);
                    });
                }
            }
        }
        DashboardRow.prototype.validate = function (config) {
            if (!config.widgets && !config.columns) {
                throw new Error("Can't create DashboardRow, it must have either widgets or columns.");
            }
            if (config.widgets && config.widgets.constructor !== Array) {
                throw new TypeError("Invalid 'widgets' property for DashboardRow, expected an array but got " +
                    config.widgets.constructor.name + ".");
            }
            if (config.columns && config.columns.constructor !== Array) {
                throw new TypeError("Invalid 'columns' property for DashboardColumn, expected an array but got " +
                    config.rows.constructor.name + ".");
            }
            if (config.weight) {
                if (typeof (config.weight) !== "number") {
                    throw new TypeError("Invalid weight for DashboardRow. Expected a number but got " + config.weight +
                        ".");
                }
                if (config.weight <= 0) {
                    throw new Error("Invalid weight for DashboardRow. It must be a positive number.");
                }
            }
        };
        /**
         * Returns all the widgets in the row: Columns in the row and the row itself
         */
        DashboardRow.prototype.getAllWidgets = function () {
            var widgets = this.widgets || [];
            if (this.columns) {
                for (var _i = 0, _a = this.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    widgets = widgets.concat(column.getAllWidgets());
                }
            }
            return widgets;
        };
        function DashboardColumn(config, dashboard) {
            this.validate(config);
            this.weight = config.weight || 1;
            this.span = "span" + SPAN_SIZE;
            if (config.show) {
                this.show = conditions.validateConditions(config.show.conditions, {}, null);
            }
            else {
                this.show = true;
            }
            if (config.className) {
                this.className = config.className;
            }
            if (this.show) {
                if (config.widgets) {
                    this.widgets = config.widgets.map(function (widgetConfig) {
                        return new Widget(widgetConfig, dashboard);
                    });
                }
                if (config.rows) {
                    this.rows = config.rows.map(function (rowConfig) {
                        return new DashboardRow(rowConfig, dashboard);
                    });
                }
            }
        }
        DashboardColumn.prototype.validate = function (config) {
            if (config.show) {
                if (!config.show.conditions) {
                    throw new Error("Can't create dashboardLayout - 'show' exists without conditions.");
                }
            }
            if (!config.widgets && !config.rows) {
                throw new Error("Can't create DashboardColumn, it must have either widgets or rows.");
            }
            if (config.widgets && config.widgets.constructor !== Array) {
                throw new TypeError("Invalid 'widgets' property for DashboardColumn, expected an array but got " +
                    config.widgets.constructor.name + ".");
            }
            if (config.rows && config.rows.constructor !== Array) {
                throw new TypeError("Invalid 'rows' property for DashboardColumn, expected an array but got " +
                    config.rows.constructor.name + ".");
            }
            if (config.weight) {
                if (typeof (config.weight) !== "number") {
                    throw new TypeError("Invalid weight for DashboardColumn. Expected a number but got " +
                        config.weight + ".");
                }
                if (config.weight <= 0) {
                    throw new Error("Invalid weight for DashboardColumn. It must be a positive number.");
                }
            }
        };
        /**
         * Returns all the widget in the column: Rows inside the column and the column itself
         */
        DashboardColumn.prototype.getAllWidgets = function () {
            var widgets = this.widgets || [];
            if (this.rows) {
                for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {
                    var row = _a[_i];
                    widgets = widgets.concat(row.getAllWidgets());
                }
            }
            return widgets;
        };
        /**
         * Given an array of DashboardColumns, calculates each column's span according to its requested weight and sets
         * the column's span accordingly.
         * @param {[DashboardColumn]} columns
         */
        function setColumnSpans(columns) {
            var totalWeight = columns.length === 1 ? columns[0].weight :
                columns.reduce(function (previousValue, currentValue) {
                    if (!currentValue.weight) {
                        throw new Error("Can't set column classes, weight not found.");
                    }
                    return (!isNaN(previousValue) ? previousValue : previousValue.weight || 0) + currentValue.weight;
                });
            columns.forEach(function (column) {
                column.span = "span" + column.weight * SPAN_SIZE / totalWeight;
            });
        }
        return {
            Column: DashboardColumn,
            Row: DashboardRow,
            setColumnSpans: setColumnSpans
        };
    }
    DashboardLayout.$inject = ["Widget", "conditions"];
    angular.module("Widgets").factory("DashboardLayout", DashboardLayout);
})();

(function () {
    'use strict';
    function widgetViews($q) {
        function getView(viewType) {
            var view = registeredViews[viewType];
            if (!view) {
                throw new Error("Unknown view, '" + viewType + "'.");
            }
            return view;
        }
        var registeredViews = {};
        return {
            parseViewData: function (_view, data, params, rawData) {
                var view = getView(_view.type);
                if (view.dataParser) {
                    return $q.when(view.dataParser(_view, data, params, rawData));
                }
                return $q.when(data);
            },
            registerView: function (viewId, view) {
                if (!view) {
                    view = {};
                }
                if (Object(view) !== view) {
                    throw new TypeError("Can't register view, expected an object but got " + view);
                }
                if (view.dataParser && view.dataParser.constructor !== Function) {
                    throw new TypeError("Can't register view, expected a function for dataParser but got " +
                        view.dataParser);
                }
                registeredViews[viewId] = view;
            },
            validateSettings: function (viewId, settings) {
                var view = getView(viewId);
                if (!settings) {
                    return true;
                }
                if (!view.validate) {
                    return true;
                }
                return view.validate(settings);
            },
            viewExists: function (viewId) {
                return !!registeredViews[viewId];
            }
        };
    }
    widgetViews.$inject = ["$q"];
    angular.module("Widgets").factory("widgetViews", widgetViews);
})();

(function () {
    'use strict';
    function widgetDirective(Widget, state, widgets) {
        function linkFn(scope) {
            scope.$on("$destroy", function () {
                scope.widget.destroy();
                removeWidgetListeners();
            });
            scope.$watch("widgetModel", function (value) {
                if (value && !(value instanceof Widget)) {
                    throw new TypeError("Invalid widgetModel for widget directive, expected an instance of Widget.");
                }
                scope.widget = value;
                setWidgetListeners(scope.widget);
            });
            function setWidgetListeners(widget) {
                removeWidgetListeners();
                if (widget) {
                    if (Object.keys(widget.refreshOn).length) {
                        state.onStateChange.subscribe(onStateChange);
                    }
                }
                widgets.onRefreshAll.subscribe(onRefreshAll);
            }
            function removeWidgetListeners() {
                state.onStateChange.unsubscribe(onStateChange);
                widgets.onRefreshAll.unsubscribe(onRefreshAll);
            }
            function onStateChange(e, data) {
                scope.widget.refreshIfRequired(data.params);
            }
            function onRefreshAll() {
                scope.widget.refresh();
            }
        }
        return {
            templateUrl: "scripts/modules/widgets/widget.directive/widget.directive.template.html",
            restrict: 'E',
            replace: true,
            scope: {
                widgetModel: "="
            },
            link: linkFn
        };
    }
    /**
     * Decorator for the original directive.
     * @param Widget
     * @param state
     * @param widgets
     * @returns {{templateUrl, restrict, replace, scope, link}|*}
     */
    function widgetExploreDirective(Widget, state, widgets) {
        var origDirective = widgetDirective(Widget, state, widgets);
        origDirective.templateUrl =
            'scripts/modules/widgets/widget.directive/widget-explore.directive.template.html';
        return origDirective;
    }
    widgetDirective.$inject = ["Widget", "state", "widgets"];
    widgetExploreDirective.$inject = ["Widget", "state", "widgets"];
    angular.module("Widgets").directive("widget", widgetDirective);
    angular.module("Widgets").directive("widgetExplore", widgetExploreDirective);
})();

angular.module("Explore.Filters", ["Explore", "DataQueries", "Search", "EventBus"]);

(function () {
    'use strict';
    function FilterClass(DataEntityField, QueryOperator, search, FilterValidators) {
        /**
         * Constructor for Filter objects, used in the Explore page
         * @param field
         * @constructor
         */
        function Filter(field) {
            if (!(field instanceof DataEntityField)) {
                throw new TypeError("Invalid field for filter, expected an instance of DataEntityFilter.");
            }
            this.field = field;
            this.valueField = null;
            this.operator = field.type.defaultOperator;
            this.isDirty = true;
            this._value = this.defaultValue;
            this.validObj = {};
            this.initValidState();
            this.valueList = field.valueList;
        }
        Filter.prototype.copy = function (filter) {
            if (!(filter instanceof Filter)) {
                throw new TypeError("Can't copy Filter, expected an instance of Filter.");
            }
            this.valueField = filter.valueField;
            this._operator = filter._operator;
            this._value = filter.value;
            this._displayValue = filter.displayValue;
            this.isDirty = filter.isDirty;
            this.validObj = filter.validObj;
            filter.validate(this._value);
            return this;
        };
        Filter.prototype.initValidState = function () {
            if (this.validObj) {
                this.validObj.errorMessage = "";
                this.validObj.showErrors = false;
                this.validObj.isValid = true;
                // Set isValidOnInit:
                // If it requires value, and '_value" and '_displayValue' are not set, set it to false
                // Else set it to true
                if (this.operator.requiresValue) {
                    this.validObj.isValidOnInit =
                        (angular.isDefined(this._value) || angular.isDefined(this._displayValue));
                }
                else {
                    this.validObj.isValidOnInit = true;
                }
            }
        };
        Filter.copy = function (filter) {
            var newFilter = new Filter(filter.field);
            newFilter.copy(filter);
            return newFilter;
        };
        /**
         * Compares this filter to another one. Returns true if they are equal or false if they're not.
         * @param anotherFilter
         */
        Filter.prototype.equals = function (anotherFilter) {
            if (!anotherFilter) {
                return false;
            }
            if (!(anotherFilter instanceof Filter)) {
                return false;
            }
            if (anotherFilter.operator.id !== this.operator.id) {
                return false;
            }
            if (typeof this.value !== typeof anotherFilter.value) {
                return false;
            }
            if (typeof this.displayValue !== typeof anotherFilter.displayValue) {
                return false;
            }
            if ((!!this.valueField).toString() !== (!!anotherFilter.valueField).toString()) {
                return false;
            }
            if (this.valueField && anotherFilter.valueField) {
                if (this.valueField.id !== anotherFilter.valueField.id ||
                    this.valueField.entity.id !== anotherFilter.valueField.entity.id) {
                    return false;
                }
            }
            if (this.field.id !== anotherFilter.field.id) {
                return false;
            }
            if (!angular.isObject(this.value)) {
                if (this.value !== anotherFilter.value) {
                    return false;
                }
            }
            else {
                if (JSON.stringify(this.value) !== JSON.stringify(anotherFilter.value)) {
                    return false;
                }
            }
            if (!angular.isObject(this.displayValue)) {
                if (this.displayValue !== anotherFilter.displayValue) {
                    return false;
                }
            }
            else {
                if (JSON.stringify(this.displayValue) !== JSON.stringify(anotherFilter.displayValue)) {
                    return false;
                }
            }
            return true;
        };
        Filter.prototype.__defineGetter__("operator", function () {
            return this._operator;
        });
        Filter.prototype.__defineSetter__("operator", function (operator) {
            if (!(operator instanceof QueryOperator)) {
                throw new TypeError("Invalid operator, expected an instance of QueryOperator.");
            }
            this._operator = operator;
            if (this._value === undefined) {
                this._value = this.defaultValue;
            }
            else {
                try {
                    this.validate(this._value);
                }
                catch (e) {
                    this._value = this.defaultValue;
                }
            }
            this.initValidState();
            this.isDirty = true;
        });
        Filter.prototype.validate = function (value, isDisplay) {
            var validatorsArr = getValidators.call(this, isDisplay) || [];
            if (this._operator.requiresValue) {
                validatorsArr.unshift("requiredValidator");
            }
            if (validatorsArr.length === 0) {
                return this;
            }
            for (var i = 0; i < validatorsArr.length; i++) {
                var validator = FilterValidators.getValidator(validatorsArr[i], value); //also sets "value" as a member
                // of Validator.
                validator.validate();
            }
            return this;
        };
        //there two sets of validators - one for display values and one for actual values
        //isDisplay - defines which set to use
        function getValidators(isDisplay) {
            /* jshint validthis: true */
            var validators = this.operator.validators;
            if (isDisplay) {
                validators = this.operator.displayValidators;
            }
            if (angular.isArray(validators)) {
                return angular.copy(validators);
            }
            return angular.copy(validators[this.field.type.id.toLowerCase()]);
        }
        Filter.prototype.__defineGetter__("inputTemplate", function () {
            var templateName = "exploreFilter-";
            if (!this.operator.inputTemplate) {
                return null;
            }
            if (typeof (this.operator.inputTemplate) === "string") {
                templateName += this.operator.inputTemplate;
            }
            else {
                templateName += this.operator.inputTemplate[this.field.type.id.toLowerCase()];
            }
            if (this.field.isSearchable && this.operator.supportsSearch) {
                templateName += "-searchable";
            }
            return templateName;
        });
        Filter.prototype.__defineGetter__("searchSettings", function () {
            if (this._searchSettings === undefined) {
                if (this.field.isSearchable) {
                    this._searchSettings = search.getDataEntityFieldSearchSettings(this.field);
                }
                else {
                    this._searchSettings = null;
                }
            }
            return this._searchSettings;
        });
        Filter.prototype.__defineGetter__("defaultValue", function () {
            if (this.operator.defaultValue) {
                return this.operator.defaultValue[this.field.type.id.toLowerCase()];
            }
        });
        /*
         * The getter and setter mechanism is used for validation and defining the filter as dirty every time you
         * edit the filter content
         */
        Filter.prototype.__defineGetter__("value", function () {
            return this._value;
        });
        Filter.prototype.__defineSetter__("value", function (value) {
            if (value !== this._value) {
                try {
                    this.validate(value);
                    this.validObj.isValid = true;
                    this.validObj.showErrors = false;
                }
                catch (errorMessage) {
                    this.validObj.isValid = false;
                    this.validObj.errorMessage = errorMessage.message;
                    this.validObj.showErrors = true;
                }
                this._value = this.field.type.parseValue(value);
                this.isDirty = true;
                this.validObj.isValidOnInit = true;
            }
        });
        Filter.prototype.__defineGetter__("displayValue", function () {
            return this._displayValue;
        });
        Filter.prototype.__defineSetter__("displayValue", function (displayValue) {
            if (displayValue !== this._displayValue) {
                try {
                    this.validate(displayValue, true);
                    this.validObj.isValid = true;
                    this.validObj.showErrors = false;
                }
                catch (errorMessage) {
                    this.validObj.isValid = false;
                    this.validObj.errorMessage = errorMessage.message;
                    this.validObj.showErrors = true;
                }
                this._displayValue = this.field.type.parseValue(displayValue);
                this.isDirty = true;
                this.validObj.isValidOnInit = true;
            }
        });
        /**
         * Returns a string that can be used by state
         * @returns {string}
         */
        Filter.prototype.getParamValue = function () {
            var valueParam = this.valueField ? "[" + this.valueField.entity.id + "." + this.valueField.id + "]" :
                this.displayValue || this.value;
            if (this.operator.valueToParam) {
                valueParam =
                    this.operator.valueToParam(valueParam, this.field.type.id.toLowerCase(), this.field.format);
            }
            return this.operator.paramOperator + valueParam;
        };
        return Filter;
    }
    FilterClass.$inject = ["DataEntityField", "QueryOperator", "search", "FilterValidators"];
    angular.module("Explore.Filters").factory("Filter", FilterClass);
})();

(function () {
    'use strict';
    function FilterCollectionClass(Filter, queryOperators, filters, EventBus, filtersToDataQueriesAdapter, $rootScope) {
        /**
         * Constructor for a collection of filters. Parallel to DataQueryCondition
         * @constructor
         */
        function FilterCollection() {
            var filters = [];
            var operator = queryOperators.logicalOperators.AND;
            var FILTERS_CHANGE_EVENT = "filtersChange";
            var self = this;
            var eventBus = EventBus.setToObject(this, [FILTERS_CHANGE_EVENT]);
            this.__defineGetter__("filters", function () {
                return filters;
            });
            this.addFilter = function (filter, index) {
                if (!(filter instanceof Filter)) {
                    throw new TypeError("Invalid filter to add to FilterCollection, expected an instance of Filter.");
                }
                // Avoid adding duplicate filters:
                if (this.containsFilter(filter)) {
                    return this;
                }
                this._isDirty = true;
                if (typeof (index) === "number") {
                    filters.splice(index, 0, filter);
                }
                else {
                    filters.push(filter);
                }
                Object.observe(filter.validObj, observeFiltersState);
                eventBus.triggerEvent(FILTERS_CHANGE_EVENT, { method: "add", filter: filter });
                return this;
            }.bind(this);
            this.removeFilter = function (filter) {
                var filterPosition = filters.indexOf(filter);
                if (!~filterPosition) {
                    return false;
                }
                this._isDirty = true;
                filter.validObj.isValid = true;
                filter.validObj.isValidOnInit = true;
                Object.unobserve(filter.validObj, observeFiltersState);
                var removedFilter = filters.splice(filterPosition, 1);
                eventBus.triggerEvent(FILTERS_CHANGE_EVENT, { method: "remove", filter: removedFilter });
                return this;
            }.bind(this);
            /**
             * Returns true if the collection contains a filter - checked by value, not by pointer!
             * @type {function(this:FilterCollectionClass.FilterCollection)|*}
             */
            this.containsFilter = function (filter) {
                return filters.some(function (_filter) {
                    return filter.equals(_filter);
                });
            }.bind(this);
            function observeFiltersState() {
                $rootScope.$apply(function () {
                    self._isValid = isAllFiltersValid();
                });
            }
            this.clearFilters = function () {
                while (filters.length) {
                    filters.pop();
                }
                eventBus.triggerEvent(FILTERS_CHANGE_EVENT, { method: "clear" });
                return this;
            };
            this.__defineGetter__("operator", function () {
                return operator;
            });
            this.__defineGetter__("isValid", function () {
                if (this._isValid === undefined) {
                    return true;
                }
                return this._isValid;
            });
            this.__defineSetter__("operator", function (value) {
                var logicalOperator = queryOperators.logicalOperators[value];
                if (!logicalOperator) {
                    throw new Error("Invalid operator for FilterCollection, expected either 'AND' or 'OR'");
                }
                this._isDirty = true;
                operator = logicalOperator;
            }.bind(this));
            this.copy = function (filterCollection) {
                if (!(filterCollection instanceof FilterCollection)) {
                    throw new TypeError("Can't copy FilterCollection, expected an instance of FilterCollection.");
                }
                filters = filterCollection.filters.map(function (filter) {
                    return Filter.copy(filter);
                });
                operator = filterCollection.operator;
                this._isDirty = filterCollection._isDirty;
            };
            this.unDirty = function () {
                var changedFilters = [];
                this._isDirty = false;
                filters.forEach(function (filter) {
                    if (filter.isDirty) {
                        filter.isDirty = false;
                        changedFilters.push(filter);
                    }
                });
                if (changedFilters.length) {
                    eventBus.triggerEvent(FILTERS_CHANGE_EVENT, { method: "unDirty", filters: changedFilters });
                }
                return this;
            };
            this.hasFilterForField = function (dataEntityField) {
                return filters.some(function (filter) {
                    return filter.field === dataEntityField;
                });
            };
            function isAllFiltersValid() {
                for (var i = 0; i < filters.length; i++) {
                    var filter = filters[i];
                    if (!filter.validObj.isValid || !filter.validObj.isValidOnInit) {
                        return false;
                    }
                }
                return true;
            }
        }
        FilterCollection.copy = function (filterCollection) {
            var newFilterCollection = new FilterCollection();
            newFilterCollection.copy(filterCollection);
            return newFilterCollection;
        };
        FilterCollection.prototype.__defineGetter__("isDirty", function () {
            if (this._isDirty) {
                return true;
            }
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
                var filter = _a[_i];
                if (filter.isDirty) {
                    return true;
                }
            }
            return false;
        });
        /**
         * Returns an object with the collection's filters as an array of name/value objects.
         * In the future, should send also the operator of the FilterCollection (AND/OR), when it's used.
         * @returns {*}
         */
        FilterCollection.prototype.getParams = function () {
            return this.filters.map(function (filter) {
                var obj = {};
                obj[filter.field.entity.id + "." + filter.field.id] = filter.getParamValue();
                return obj;
            });
        };
        /**
         * Accepts params and sets the collection's filters accordingly.
         * @param params
         * @returns {FilterCollection}
         */
        FilterCollection.prototype.setParams = function (params) {
            this.clearFilters();
            if (!params) {
                return this;
            }
            var self = this;
            if (params.constructor !== Array) {
                params = [params];
            }
            var filter;
            params.forEach(function (paramObj) {
                for (var paramName in paramObj) {
                    if (paramObj.hasOwnProperty(paramName)) {
                        filter = filters.getFilterFromParam(paramName, paramObj[paramName]);
                        if (filter) {
                            self.addFilter(filter);
                        }
                    }
                }
            });
            return this;
        };
        /**
         *
         * @returns {*}
         */
        FilterCollection.prototype.getDataQuery = function () {
            if (!this.filters.length) {
                return {};
            }
            return { conditions: filtersToDataQueriesAdapter.filterCollectionToConditionTerm(this) };
        };
        return FilterCollection;
    }
    FilterCollectionClass.$inject =
        ["Filter", "queryOperators", "filters", "EventBus", "filtersToDataQueriesAdapter", "$rootScope"];
    angular.module("Explore.Filters").factory("FilterCollection", FilterCollectionClass);
})();

(function () {
    'use strict';
    function filters(Filter, dataEntities, queryOperators) {
        /**
         * Given a param name and a param value, returns a new Filter that matches the param
         * @param paramName
         * @param paramValue
         * @returns {*}
         */
        function getFilterFromParam(paramName, paramValue) {
            if (paramValue === null || paramValue === undefined || paramValue === "_null_") {
                return null;
            }
            if (typeof (paramValue) !== "string") {
                throw new TypeError("Invalid param value, expected a string but got " + typeof (paramValue));
            }
            var entityField = paramName.split("."), dataEntityField = dataEntities.getField(entityField[0], entityField[1]);
            if (!dataEntityField) {
                return null;
            }
            var filter = new Filter(dataEntityField);
            var paramOperator = queryOperators.getParamOperator(paramValue), paramValueWithoutOperator = paramValue.replace(paramOperator.paramOperator, "");
            var valueFieldMatch = paramValueWithoutOperator.match(/\[((\w+).(\w+))\]$/);
            if (valueFieldMatch) {
                var valueField = dataEntities.getField(valueFieldMatch[2], valueFieldMatch[3]);
                if (!valueField) {
                    console.warn("WARNING: Unknown field, '" + valueFieldMatch[1] + ", treating '" +
                        paramValueWithoutOperator + "' as a string value.");
                }
                filter.valueField = valueField;
            }
            else {
                filter.value = paramOperator.paramToValue ?
                    paramOperator.paramToValue(paramValueWithoutOperator, filter.field.type.id.toLowerCase()) :
                    paramValueWithoutOperator;
                // Use display value only for fields that support it
                if (paramOperator.paramToDisplayValue) {
                    filter.displayValue =
                        paramOperator.paramToDisplayValue(paramValueWithoutOperator, filter.field.type.id.toLowerCase(), filter.field.format);
                }
            }
            filter.operator = paramOperator;
            return filter;
        }
        return {
            getFilterFromParam: getFilterFromParam
        };
    }
    filters.$inject = ["Filter", "dataEntities", "queryOperators"];
    angular.module("Explore.Filters").factory("filters", filters);
})();

(function () {
    'use strict';
    function filtersToDataQueriesAdapter(queryOperators, Filter) {
        /**
         * Converts a Filter object to its parallel DataQueryConditionTerm configuration
         * @param filterCollection
         */
        function filterCollectionToConditionTerm(filterCollection) {
            if (filterCollection.constructor.name !== "FilterCollection") {
                throw new TypeError("Invalid filterCollection, expected an instance of FilterCollection but got " +
                    filterCollection);
            }
            var conditionTerm = {
                operator: filterCollection.operator
            };
            conditionTerm.terms = filterCollection.filters.map(filterToConditionField);
            return conditionTerm;
        }
        var filterToConditionsMapping = {
            "DATE_TIME": {
                notEquals: function (filter) {
                    //filter. value has timeStart and timeEnd
                    //create 2 conditions: <timeStart and >timeEnd
                    //return conditionTerm
                    var startFilter = Filter.copy(filter);
                    startFilter.operator = queryOperators.operators.get("lesserThan");
                    startFilter.value = filter.value.timeStart;
                    var conditionFieldTimeStart = filterToConditionField(startFilter);
                    var endFilter = Filter.copy(filter);
                    endFilter.operator = queryOperators.operators.get("greaterThan");
                    endFilter.value = filter.value.timeEnd;
                    var conditionFieldTimeEnd = filterToConditionField(endFilter);
                    var conditionTerm = {
                        operator: "OR",
                        type: "term"
                    };
                    conditionTerm.terms = [conditionFieldTimeStart, conditionFieldTimeEnd];
                    return conditionTerm;
                },
                equals: function (filter) {
                    //filter. value has timeStart and timeEnd
                    //create range condition
                    var newFilter = Filter.copy(filter);
                    newFilter.operator = queryOperators.operators.get("dateRange");
                    return filterToConditionField(newFilter);
                }
            }
        };
        /**
         * Converts a Filter object to its parallel DataQueryConditionField configuration
         * @param filter
         * @returns {{type: string, id: *, operator: *, value: *}}
         */
        function filterToConditionField(filter) {
            if (filter.constructor.name !== "Filter") {
                throw new TypeError("Invalid filter, expected an instance of Filter but got " + filter);
            }
            if (filterToConditionsMapping[filter.field.type.id] &&
                filterToConditionsMapping[filter.field.type.id][filter.operator.id]) {
                //function that translate the filter to several conditions
                return filterToConditionsMapping[filter.field.type.id][filter.operator.id](filter);
            }
            var conditionField = {
                type: "field",
                id: filter.field.id,
                operator: filter.operator.id,
                entity: filter.field.entity.id
            };
            if (filter.valueField) {
                conditionField.valueField = { id: filter.valueField.id, entity: filter.valueField.entity.id };
            }
            else {
                conditionField.value = filter.value;
            }
            return conditionField;
        }
        return {
            filterCollectionToConditionTerm: filterCollectionToConditionTerm
        };
    }
    filtersToDataQueriesAdapter.$inject = ["queryOperators", "Filter"];
    angular.module("Explore.Filters").factory("filtersToDataQueriesAdapter", filtersToDataQueriesAdapter);
})();

(function () {
    'use strict';
    /**
     * The filters selection for the explore widget
     * @param Filter
     * @param FilterCollection
     * @param dataEntities
     * @param DataEntity
     */
    function exploreFiltersDirective(Filter, FilterCollection, dataEntities, DataEntity) {
        function linkFn(scope, element, attrs, ngModel) {
            function init() {
                filtersCollection = new FilterCollection();
                scope.filtersCollection = filtersCollection;
                scope.applyFilters = applyFilters;
                scope.toggleAddFilter = function () {
                    scope.showAddFilter = !scope.showAddFilter;
                };
                scope.addFilter = addFilter;
                scope.removeFilter = removeFilter;
                scope.$watch("entity", function (entity) {
                    if (entity !== scope.entity) {
                        scope.entity = entity;
                        setAvailableFields();
                    }
                });
                scope.$watch("excludedFields", setAvailableFields);
                if (ngModel) {
                    ngModel.$render = function () {
                        if (ngModel.$viewValue) {
                            filtersCollection = FilterCollection.copy(ngModel.$viewValue);
                            ngModel.$viewValue.onFiltersChange.subscribe(onModelChange);
                        }
                        else {
                            filtersCollection = new FilterCollection();
                        }
                        scope.filtersCollection = filtersCollection;
                    };
                }
            }
            /**
             * Get available fields for filters
             */
            function setAvailableFields() {
                if (!scope.entity) {
                    return;
                }
                scope.filterGroups = [getEntityFilterGroup(scope.entity)];
                if (scope.entity.linkedEntities) {
                    scope.entity.linkedEntities.forEach(function (linkedEntity) {
                        scope.filterGroups.push(getEntityFilterGroup(linkedEntity));
                    });
                }
            }
            function getEntityFilterGroup(linkedEntity) {
                var entity = linkedEntity instanceof DataEntity ? linkedEntity :
                    dataEntities.getEntityById(linkedEntity.entity);
                var availableFields = entity.fieldsArray;
                // remove internal fields
                availableFields = availableFields.filter(function (field) {
                    return !(~field.attributes.indexOf("internal"));
                });
                // exclude fields according to ID
                if (scope.excludedFields) {
                    availableFields = availableFields.filter(function (field) {
                        return !~scope.excludedFields.indexOf(field.id);
                    });
                }
                //exclude all fields that specific for users entity
                if (scope.entity.name !== "Users") {
                    availableFields = availableFields.filter(function (field) {
                        return !(field.shownForSpecificEntity !== undefined &&
                            field.entity.id === field.shownForSpecificEntity);
                    });
                }
                return { name: entity.name, fields: availableFields, isOpen: true };
            }
            function onModelChange() {
                scope.filtersCollection = filtersCollection = FilterCollection.copy(ngModel.$viewValue);
            }
            function applyFilters() {
                if (!filtersCollection.isDirty) {
                    return false;
                }
                ngModel.$setViewValue(filtersCollection);
                if (scope.onFiltersChange) {
                    scope.onFiltersChange({ filters: filtersCollection });
                }
                filtersCollection.unDirty();
            }
            function addFilter(dataEntityField) {
                var newFilter = new Filter(dataEntityField);
                filtersCollection.addFilter(newFilter);
                scope.showAddFilter = false;
            }
            function removeFilter(filter) {
                // Remove filter from local collection
                filtersCollection.removeFilter(filter);
                if (scope.onFiltersChange) {
                    // Add a flag indicating filters were removed from this collection
                    filtersCollection.filtersRemoved = true;
                    // Update URL and state parameters
                    scope.onFiltersChange({ filters: filtersCollection });
                }
            }
            var filtersCollection;
            init();
        }
        return {
            templateUrl: "scripts/modules/explore/filters/filters.directive/explore.filters.directive.template.html",
            restrict: 'E',
            require: '?ngModel',
            replace: true,
            scope: {
                entity: "=",
                excludedFields: "=",
                onFiltersChange: "&"
            },
            link: linkFn
        };
    }
    angular.module("Explore.Filters").directive("exploreFilters", ["Filter", "FilterCollection", "dataEntities", "DataEntity", exploreFiltersDirective]);
})();

(function () {
    'use strict';
    angular.module("FilterValidatorsModule", []).factory("FilterValidators", ["utils", function (utils) {
            function NumberRangeValidator(validationObj) {
                this.validationObj = validationObj;
                this.validate = function () {
                    new RequiredValidator(this.validationObj.fromValue).validate();
                    new RequiredValidator(this.validationObj.toValue).validate();
                    var toValueAsNumber = parseFloat(this.validationObj.toValue);
                    var fromValueAsNumber = parseFloat(this.validationObj.fromValue);
                    if (toValueAsNumber < fromValueAsNumber) {
                        throw new Error("Low value greater than the high value");
                    }
                    if (this.validationObj.min && fromValueAsNumber < this.validationObj.min) {
                        throw new Error("Minimum value allowed is " + this.validationObj.min);
                    }
                    if (this.validationObj.max && toValueAsNumber > this.validationObj.max) {
                        throw new Error("Minimum value allowed is " + this.validationObj.max);
                    }
                };
            }
            function RequiredValidator(val) {
                this.val = val;
                this.validate = function () {
                    if (this.isEmpty(this.val)) {
                        throw new Error("The value is required");
                    }
                };
                this.isEmpty = function (val) {
                    return val === undefined || val === null || val === "";
                };
            }
            function DateValidator(dateVal) {
                this.dateVal = dateVal;
                this.validate = function () {
                    // momentjs returns a valid object if dateVal is just a literal object! Stupid!
                    if (angular.isObject(this.dateVal) && this.dateVal.timeStart && this.dateVal.timeEnd) {
                        if (!utils.date.getMoment(this.dateVal.timeStart).isValid() ||
                            !utils.date.getMoment(this.dateVal.timeEnd).isValid() ||
                            utils.date.getDatesSpan(this.dateVal.timeStart, this.dateVal.timeEnd).length !== 0) {
                            throw new Error("Not a valid date");
                        }
                    }
                    if (!utils.date.getMoment(this.dateVal).isValid()) {
                        throw new Error("Not a valid date");
                    }
                };
            }
            function DateRangeValidator(dateVal) {
                this.dateVal = dateVal;
                this.validate = function () {
                    if (angular.isObject(this.dateVal)) {
                        if (!this.dateVal.timeStart || !this.dateVal.timeEnd) {
                            throw new ReferenceError("Time object must have timeStart and timeEnd");
                        }
                        if (!utils.date.getMoment(this.dateVal.timeStart).isValid() ||
                            !utils.date.getMoment(this.dateVal.timeEnd).isValid()) {
                            throw new RangeError("Not a valid date range");
                        }
                        return;
                    }
                    // dateVal is not an object
                    if (!utils.date.getMoment(this.dateVal).isValid()) {
                        throw new RangeError("Not a valid date range");
                    }
                };
            }
            function IsArrayValidator(val) {
                this.val = val;
                this.validate = function () {
                    if (!angular.isArray(this.val)) {
                        throw new Error("The value must be array");
                    }
                };
            }
            function IsDurationValidator(val) {
                this.val = val;
                this.validate = function () {
                    //regexp pattern for duration in the format hh:mm or hh:mm:ss
                    var pattern = /^(([01]\d)|(2[0-3]))(:[0-5]\d){1,2}$/;
                    if (!pattern.test(val)) {
                        throw new Error("The value is not hh:mm:ss format");
                    }
                };
            }
            var validators = {
                "numberRangeValidator": NumberRangeValidator,
                "dateRangeValidator": DateRangeValidator,
                "requiredValidator": RequiredValidator,
                "dateValidator": DateValidator,
                "isArrayValidator": IsArrayValidator,
                "isDurationValidator": IsDurationValidator
            };
            return {
                getValidator: function (validatorName, validatorValue) {
                    var Validator = validators[validatorName];
                    return new Validator(validatorValue);
                }
            };
        }]);
}());

angular.module("Explore", ["Utils", "DataEntities", "DataQueries", "State", "Explore.Filters", "Explore.DataViews"]);

(function () {
    "use strict";
    function ExploreClass(appConfig, FilterCollection, DataEntity, TableDataView, state, queryOperators, Filter, graphs, dataViewTypes, Graph, utils) {
        /**
         * Gets the default filters collection for the Explore model
         * @param explore
         * @param existingFilters Existing filters collection, i.e from params, to use in the default filters. If
         *     something is missing from the existing filters, it's added here.
         * @returns {*}
         */
        function getDefaultFilters(explore, existingFilters) {
            if (!explore.dataEntity.performanceField) {
                return null;
            }
            var defaultFilters = existingFilters || new FilterCollection();
            // The first is for events, the second for sessions:
            var timeField = explore.dataEntity.fields.get("event_time_utc") ||
                explore.dataEntity.fields.get("session_time_utc");
            var eventScoreField = explore.dataEntity.performanceField.field;
            if (!defaultFilters.hasFilterForField(timeField)) {
                var timeFilter = new Filter(timeField);
                var daysAgo = appConfig.getConfigValue('ui.explore', 'daysRange');
                timeFilter.value = {
                    timeStart: utils.date.getMoment('-' + daysAgo + 'days').startOf("day").toDate(),
                    timeEnd: utils.date.getMoment('now').endOf("day").toDate()
                };
                timeFilter.operator = queryOperators.operators.get("dateRange");
                defaultFilters.addFilter(timeFilter, 0);
            }
            if (!defaultFilters.hasFilterForField(eventScoreField)) {
                var scoreFilter = new Filter(eventScoreField);
                scoreFilter.value = explore.dataEntity.performanceField.value;
                scoreFilter.operator = queryOperators.operators.get("greaterThanOrEquals");
                defaultFilters.addFilter(scoreFilter, 1);
            }
            //make sure the score filter value is formatted as a number
            defaultFilters.filters.forEach(function (filter) {
                if (filter.field.id.indexOf("score") > -1) {
                    filter.value = Number(filter.value);
                }
            });
            defaultFilters.unDirty();
            return defaultFilters;
        }
        /**
         * Returns the IDs of fields that are in default filters. To be used by the filters directive, which should
         * exclude them.
         * @returns {*|Array}
         */
        function getDefaultFilterFieldIds(explore) {
            var defaultFilterIds = explore.defaultFilters && explore.defaultFilters.filters.map(function (filter) {
                return filter.field.id;
            });
            // TODO: This is a bit ugly, should be replaced to use only event_time.
            //(hack) The defaultFilterIds is used originally for the default filters, but it is used here for excluding
            // filters from being manually added.
            if (defaultFilterIds && ~defaultFilterIds.indexOf("event_time_utc")) {
                defaultFilterIds.push("event_time");
            }
            if (defaultFilterIds && ~defaultFilterIds.indexOf("session_time_utc")) {
                ["start_time", "start_time_utc", "end_time", "end_time_utc"].forEach(function (value) {
                    defaultFilterIds.push(value);
                });
            }
            return defaultFilterIds;
        }
        /**
         * Since filters are provided in the URL as a single string, there's a need to parse them into an object that
         * the FilterCollection can read. getFilterParams does just that.
         * @param filterParams
         * @returns {*}
         */
        function getFilterParams(filterParams) {
            // no filters
            if (filterParams === null) {
                filterParams = [];
            }
            // In case we got string instead of array, we need to parse it into an array
            if (filterParams && typeof (filterParams) === "string") {
                // split the string of the filters to array of filters. The format is:
                // entity.field=value(,entity.field=value)* Please note that the value might contains commas
                var filterParamsArr = filterParams.split(",");
                filterParams = [];
                for (var i = 0; i < filterParamsArr.length; i++) {
                    var rawFilter = filterParamsArr[i];
                    if (rawFilter) {
                        //each filter looks like this: <filter Name>=<filterValue> .the operator is part of filterValue
                        // (only if different than '=').
                        var rawFilterParts = rawFilter.match(/^(\w+\.\w+)=(.+)$/);
                        if (rawFilterParts) {
                            // add filter part to result
                            var obj = {};
                            obj[rawFilterParts[1]] = rawFilterParts[2] === "_null_" ? null : rawFilterParts[2];
                            filterParams[filterParams.length] = obj;
                        }
                        else {
                            // the filter is part of previous filter
                            if (filterParams.length > 0) {
                                // add it as part of the value of the previous part
                                var prevObj = filterParams[filterParams.length - 1];
                                prevObj[Object.keys(prevObj)[0]] += "," + rawFilter;
                            }
                            else {
                                console.warn("Invalid filter param, '" + rawFilter + "', ignoring.");
                            }
                        }
                    }
                }
            }
            return filterParams;
        }
        function validateSettings(settings) {
            for (var settingName in settings) {
                if (settings.hasOwnProperty(settingName)) {
                    if (!settingProperties.has(settingName)) {
                        throw new Error("Unknown setting for Explore, '" + settingName + "'.");
                    }
                }
            }
        }
        function setDataViews(explore) {
            if (explore.mode === dataViewTypes.types.table) {
                // table view
                explore.dataViews = [new TableDataView(explore)];
            }
            else {
                // graphs view
                if (explore.addedGraphs) {
                    // go over existing graph and refresh the data
                    explore.dataViews = explore.addedGraphs.map(function (dataView) {
                        dataView.updateReport(true);
                        return dataView;
                    });
                }
                else {
                    explore.dataViews = [];
                }
            }
        }
        function getGraphsParams(explore) {
            var graphIds = explore.addedGraphs && explore.addedGraphs.length ?
                explore.addedGraphs.map(function (dataView) {
                    return dataView.graph.id;
                }).join(",") :
                null;
            return { graphs: graphIds };
        }
        function getGraphsParamsId(explore) {
            var graphIds = explore.addedGraphs && explore.addedGraphs.length ?
                explore.addedGraphs.map(function (dataView) {
                    return dataView.graph.id;
                }).join(",") :
                null;
            return graphIds;
        }
        function setGraphsParam(explore) {
            state.setParams(getGraphsParams(explore));
        }
        // viewOnly for packages: to remove filtering and export
        var settingProperties = new Set(["viewOnly", "includeExport"]);
        /**
         * Constructor for Explore model objects
         * @param dataEntity
         * @param settings
         * @param params
         * @constructor
         */
        function Explore(dataEntity, settings, params) {
            var explore = this;
            if (dataEntity) {
                if (!(dataEntity instanceof DataEntity)) {
                    throw new TypeError("Invalid data entity for Explore object. Expected an instance of DataEntity.");
                }
                this.dataEntity = dataEntity;
                // Do not update URL (setToUrl = false)
                state.setParams({ "eventsEntity": dataEntity.eventsEntity }, false);
                this._mode = dataViewTypes.types[params.mode || "table"];
                // setting properties
                this.includeExport = settings.includeExport;
                this.viewOnly = settings.viewOnly;
                this.addedGraphs = [];
                graphs.getGraphsForDataEntity(dataEntity).then(function (entityGraphs) {
                    explore.graphs = entityGraphs.map(function (graph) {
                        graph.added = false;
                        return graph;
                    });
                    //This is for adding the graph from the params into the graph list of the explore
                    if (params.graphs && typeof (params.graphs) === "string") {
                        // calculate if we should move the the graphs tab
                        var changeViewToGraphs = shouldChangeViewToGraphs(params);
                        // Add the graphs to the explore (might be hidden)
                        params.graphs.split(",").forEach(function (graphId) {
                            explore.addGraph(graphId, false, changeViewToGraphs);
                        });
                    }
                });
            }
            else {
                throw new Error("Can't create Explore object, missing dataEntityId.");
            }
            this.filters = new FilterCollection();
            if (settings) {
                validateSettings(settings);
            }
            this.settings = settings || {};
            this.defaultFilters = getDefaultFilters(this);
            this.defaultFilterFieldIds = getDefaultFilterFieldIds(this);
            this.addedAllGraphs = false;
            /*
             * First create the data views of the explore page,
             * then set the page's parameters using setParams
             * (which recursively sets the child data views' params).
             */
            setDataViews(this);
            if (params) {
                explore.setParams(params);
            }
        }
        Explore.prototype.__defineGetter__("mode", function () {
            return this._mode;
        });
        Explore.prototype.__defineSetter__("mode", function (mode) {
            if (mode !== this._mode) {
                this._mode = mode;
                setDataViews(this);
                state.setParams({ mode: mode.id });
            }
        });
        Explore.prototype.getParams = function () {
            var params = {
                filters: this.filters.getParams(),
                graphs: getGraphsParamsId(this)
            };
            if (this.defaultFilters) {
                params.default_filters = this.defaultFilters.getParams();
            }
            return params;
        };
        Explore.prototype.getState = function () {
            return state.currentParams;
        };
        /**
         * calculate if we should move the the graphs tab
         * @param obj the container of the mode
         * @returns {*|boolean} true if we should use the graphs view
         */
        function shouldChangeViewToGraphs(obj) {
            return obj.mode && (obj.mode === "graphs" || obj.mode === dataViewTypes.types.graphs);
        }
        Explore.prototype.setParams = function (params) {
            var filterParams;
            var defaultFilterParams;
            if (!params) {
                return this;
            }
            if (params.filters !== undefined) {
                // Get new filters
                filterParams = getFilterParams(params.filters);
            }
            else if (params.initFilters) {
                // Reset flag
                params.initFilters = false;
                // Empty filters
                filterParams = [];
            }
            // If defined, set new filters
            if (filterParams) {
                this.filters.setParams(filterParams);
            }
            if (params.default_filters !== undefined) {
                // Get new default filters
                defaultFilterParams = getFilterParams(params.default_filters);
            }
            else if (params.initDefaultFilters) {
                // Reset flag
                params.initDefaultFilters = false;
                // Empty default filters
                defaultFilterParams = [];
            }
            // If defined, set new default filters
            if (defaultFilterParams && this.defaultFilters) {
                this.defaultFilters = getDefaultFilters(this, this.defaultFilters.setParams(defaultFilterParams));
            }
            if (this.dataViews) {
                this.dataViews.forEach(function (dataView) {
                    if (params.initParams) {
                        params.initParams = false;
                        // Override with default parameters
                        params = dataView.getDefaultParams();
                    }
                    var dataViewChanged = dataView.setParams(params);
                    if (dataViewChanged || filterParams || defaultFilterParams) {
                        dataView.update();
                    }
                });
            }
            if (params.graphs && typeof (params.graphs) === "string") {
                var explore = this;
                // calculate if we should move the the graphs tab
                var changeViewToGraphs = shouldChangeViewToGraphs(explore);
                // Add the graphs to the explore (might be hidden)
                params.graphs.split(",").forEach(function (graphId) {
                    explore.addGraph(graphId, false, changeViewToGraphs);
                });
            }
            return this;
        };
        Explore.prototype.unDirty = function () {
            this.filters.unDirty();
            if (this.defaultFilters) {
                this.defaultFilters.unDirty();
            }
        };
        Explore.prototype.updateView = function () {
            if (this.dataViews) {
                this.dataViews.forEach(function (dataView) {
                    dataView.update();
                });
            }
            return this;
        };
        /**
         * Gets the DataQuery config (conditions only) relevant to the filters and default filters of the Explore
         * object.
         * @returns {{conditions: (*|Array|string)}}
         */
        Explore.prototype.getFiltersDataQuery = function () {
            var filtersConditions = this.filters.getDataQuery().conditions, defaultFiltersConditions = this.defaultFilters && this.defaultFilters.getDataQuery().conditions;
            var dataQueryConfig = {
                conditions: filtersConditions
            };
            if (!filtersConditions) {
                dataQueryConfig.conditions = defaultFiltersConditions;
            }
            else if (defaultFiltersConditions) {
                dataQueryConfig.conditions.terms =
                    dataQueryConfig.conditions.terms.concat(defaultFiltersConditions.terms);
            }
            return dataQueryConfig;
        };
        /**
         * Adds a graph to the dataViews of the Explore object.
         * @param graph
         * @param updateParams
         * @param changeViewToGraphs
         * @changeViewToGraphs true if we want to change the view to graphs
         */
        Explore.prototype.addGraph = function (graph, updateParams, changeViewToGraphs) {
            if (typeof (graph) === "string") {
                graph = this.getGraphById(graph);
            }
            if (!graph) {
                return this;
            }
            if (!(graph instanceof Graph)) {
                throw new TypeError("Can't add graph to explore, expected an instance of Graph.");
            }
            if (graphExistsInExplore(this, graph.id)) {
                return this;
            }
            graph.dataView = graph.getDataView(this);
            // The default is to change the view (if the changeViewToGraphs is undefined)
            if (changeViewToGraphs === undefined || changeViewToGraphs) {
                this.dataViews.splice(0, 0, graph.dataView);
            }
            this.addedGraphs.splice(0, 0, graph.dataView);
            if (this.addedGraphs.length === this.graphs.length) {
                this.addedAllGraphs = true;
            }
            if (updateParams !== false) {
                setGraphsParam(this);
            }
            graph.added = true;
            return this;
        };
        function graphExistsInExplore(explore, graphId) {
            return explore.addedGraphs.some(function (graphDataView) {
                return graphDataView.graph.id === graphId;
            });
        }
        /**
         * Removes a graph that was added to the Explore object
         * @param graph
         * @returns {Explore}
         */
        Explore.prototype.removeGraph = function (graph) {
            if (!graph) {
                return this;
            }
            if (!(graph instanceof Graph)) {
                throw new TypeError("Can't add graph to explore, expected an instance of Graph.");
            }
            this.dataViews.splice(this.dataViews.indexOf(graph.dataView), 1);
            this.addedGraphs.splice(this.addedGraphs.indexOf(graph.dataView), 1);
            graph.added = false;
            this.addedAllGraphs = false;
            setGraphsParam(this);
            return this;
        };
        Explore.prototype.getGraphById = function (graphId) {
            if (!this.graphs) {
                return null;
            }
            for (var _i = 0, _a = this.graphs; _i < _a.length; _i++) {
                var graphDataView = _a[_i];
                if (graphDataView.id === graphId) {
                    return graphDataView;
                }
            }
            return null;
        };
        return Explore;
    }
    ExploreClass.$inject =
        ["appConfig", "FilterCollection", "DataEntity", "TableDataView", "state", "queryOperators", "Filter", "graphs",
            "dataViewTypes", "Graph", "utils"];
    angular.module("Explore").factory("Explore", ExploreClass);
})();

(function () {
    'use strict';
    angular.module("ExploreWidget", ["Explore", "Explore.Filters", "Widgets"]).run(["widgetViews",
        function (widgetViews) {
            widgetViews.registerView("explore");
        }]);
}());

(function () {
    'use strict';
    function ExploreController($scope, $timeout, Explore, dataEntities, state, dataViewTypes, utils, popupConditions) {
        var vm = this, lockStateOnChange, stateChangeTimeout;
        function onEntityChange(dataEntity) {
            // init();
            window.location.hash = "#/d/explore/" + dataEntity.id;
        }
        function setDataEntity(dataEntityId) {
            vm.selectedEntity = dataEntities.getEntityById(dataEntityId);
            vm.explore = new Explore(vm.selectedEntity, $scope.view.settings, $scope.widget.getState());
            vm.explore.unDirty();
            state.__explore__ = vm.explore;
        }
        function onFiltersChange(filters) {
            // Filters were deleted
            if (filters && filters.filtersRemoved) {
                // Reset flag
                filters.filtersRemoved = false;
            }
            else {
                var popupMessage = popupConditions.shouldNotifyPopup(vm.explore.defaultFilters);
                if (popupMessage !== "") {
                    /* jshint undef:false */
                    bootbox.confirm({
                        message: popupMessage,
                        buttons: {
                            'cancel': {
                                label: 'No'
                            },
                            'confirm': {
                                label: 'Yes'
                            }
                        },
                        callback: function (result) {
                            if (result) {
                                state.setParams(vm.explore.getParams());
                            }
                        }
                    });
                }
                else {
                    state.setParams(vm.explore.getParams());
                }
            }
        }
        function applyDefaultFilters() {
            onFiltersChange();
            vm.explore.defaultFilters.unDirty();
        }
        function onStateChange(e, data) {
            if (lockStateOnChange) {
                lockStateOnChange = false;
            }
            else {
                stateChangeTimeout = $timeout(function () {
                    if (data.params && data.params.entityId) {
                        setDataEntity(data.params.entityId);
                    }
                    if (vm.explore) {
                        // Reset page number if any kind of filters were changed
                        if (data.params.filters || data.params.default_filters) {
                            data.params.tableview_page = 1;
                        }
                        vm.explore.setParams(data.params);
                        vm.explore.unDirty();
                    }
                }, 40);
            }
        }
        function init() {
            var allDataEntities = dataEntities.getAllEntities();
            vm.dataEntities = [];
            for (var _i = 0, allDataEntities_1 = allDataEntities; _i < allDataEntities_1.length; _i++) {
                var entity = allDataEntities_1[_i];
                if (entity.showInExplore && !entity.isAbstract) {
                    vm.dataEntities.push(entity);
                }
            }
            vm.onEntityChange = onEntityChange;
            vm.onFiltersChange = onFiltersChange;
            vm.applyDefaultFilters = applyDefaultFilters;
            vm.modes = dataViewTypes.typesArray;
            state.onStateChange.subscribe(onStateChange);
            var entityId = $scope.widget.getState().entityId;
            if (entityId) {
                setDataEntity(entityId);
            }
        }
        /**
         * Init
         */
        init();
        /**
         * Cleanup
         */
        $scope.$on("$destroy", function () {
            $timeout.cancel(stateChangeTimeout);
            state.onStateChange.unsubscribe(onStateChange);
        });
        /*
         * Update Explore data views upon URL change.
         */
        $scope.$on("locationChange", function (event, args) {
            var callStateChange = false;
            // Make sure Explore instance exists
            if (vm && vm.explore) {
                // Parse params of both URLs
                var newParams = utils.url.parseUrlParams(args.newUrl);
                var oldParams = utils.url.parseUrlParams(args.oldUrl);
                if (Object.keys(newParams).length === 0) {
                    // Trigger state change if URL has no params, so defaults will be set
                    callStateChange =
                        newParams.initParams = newParams.initDefaultFilters = newParams.initFilters = true;
                }
                else {
                    // If default filters were removed, initialize them
                    if (!newParams.default_filters && oldParams.default_filters) {
                        callStateChange = newParams.initDefaultFilters = true;
                    }
                    // If filters were removed, initialize as well
                    if (!newParams.filters && oldParams.filters) {
                        callStateChange = newParams.initFilters = true;
                    }
                }
                if (callStateChange) {
                    onStateChange(null, { "params": newParams });
                }
            }
        });
    }
    ExploreController.$inject =
        ["$scope", "$timeout", "Explore", "dataEntities", "state", "dataViewTypes", "utils",
            "popupConditions"];
    angular.module("ExploreWidget").controller("ExploreController", ExploreController);
})();

angular.module("Explore.DataViews", ["DataEntities", "Widgets", "Reports", "Utils", "Menus"]);

(function () {
    'use strict';
    function DataView(Widget, utils) {
        return {
            /**
             * Returns the join property of the dataQuery, if required, otherwise returns null;
             * @param dataQueryConfig
             * @param currExplore
             */
            getDataQueryJoin: function (dataQueryConfig, currExplore) {
                //At this case if we have currExplore its mean that we must be consist with him and not with the one
                // that exist in "this" cause he keep the old explore that can be related to other entity
                if (currExplore) {
                    this.explore = currExplore;
                }
                var dataView = this;
                var entitiesJoinIndex = {};
                if (dataView.explore.dataEntity.linkedEntities) {
                    dataView.explore.dataEntity.linkedEntities.forEach(function (linkedEntity) {
                        entitiesJoinIndex[linkedEntity.entity] = linkedEntity;
                    });
                }
                if (!Object.keys(entitiesJoinIndex).length) {
                    return null;
                }
                return utils.objects.toArray(entitiesJoinIndex);
            },
            getDataQueryReport: function (dataQueryConfig, mockDataName, api) {
                return {
                    endpoint: {
                        api: api || "dataQuery",
                        dataQuery: dataQueryConfig
                    },
                    mock_data: "explore." + (mockDataName || dataQueryConfig.entity)
                };
            },
            /**
             * Given a string, returns the paramName relevant to this DataView, using the DataView's explore ID.
             * @param param
             * @returns {*|string}
             */
            getParamName: function (param) {
                var paramName = this.explore.settings.id || "";
                if (paramName) {
                    paramName += ".";
                }
                paramName += param;
                return paramName;
            },
            getWidgetFlags: function () {
                return {};
            },
            setParams: function () {
                // Implement this in each view, the view should be updated if the params are relevant to the view.
            },
            init: function (explore) {
                if (explore.constructor.name !== "Explore") {
                    throw new TypeError("Can't initialize DataView, expected an instance of Explore.");
                }
                this.explore = explore;
                this.setParams(explore.getState(), false);
            },
            /**
             * Interface only, should be implemented in objects that use DataView as prototype.
             */
            update: function () {
                throw new Error("update is not implemented for this dataView.");
            },
            get widget() {
                return this._widget;
            },
            set widget(widget) {
                if (!(widget instanceof Widget)) {
                    throw new TypeError("Invalid widget, expected an instance of Widget.");
                }
                this._widget = widget;
            }
        };
    }
    DataView.$inject = ["Widget", "utils"];
    angular.module("Explore.DataViews").factory("DataView", DataView);
})();

(function () {
    'use strict';
    function DataViewTypeClass() {
        function DataViewType(config) {
            this.name = config.name;
            this.id = config.id;
            this.icon = config.icon;
        }
        return DataViewType;
    }
    angular.module("Explore.DataViews").factory("DataViewType", DataViewTypeClass);
})();

(function () {
    'use strict';
    function TableDataViewClass(DataView, Widget, utils, dataEntityFieldTypes, state, menus, dataEntities, Report) {
        // This next code is scary! We should definitely look into it when we have time, and kick the use of __proto__.
        // TODO!!
        /* jshint ignore:start */
        TableDataView.prototype.__proto__ = DataView;
        /* jshint ignore:end */
        var DEFAULT_PAGE_SIZE = 20;
        var pageSizes = [10, 20, 50, 100];
        var paramNames = {
            PAGE: "tableview_page",
            PAGE_SIZE: "tableview_pagesize",
            FIELDS: "tableview_fields",
            SORT_FIELD: "tableview_sort",
            SORT_FIELD_DIR: "tableview_sort_dir"
        };
        var formatMap = {
            "minutes": ":diffToPrettyTime:minutes",
            "hours": ":diffToPrettyTime:hours",
            "seconds": ":diffToPrettyTime:seconds",
            "sizeBytes": ":bytesCount",
            "sizeBytesForTime": ":bytesPerSecCount"
        };
        function TableDataView(explore) {
            this.pageSize = DEFAULT_PAGE_SIZE;
            this.page = 1;
            this.init(explore);
            if (!this.selectedFields) {
                this.selectedFields = getTableFields(this);
            }
            if (!this.sort && explore.dataEntity.defaultSort && explore.dataEntity.defaultSort.length) {
                this.sort = explore.dataEntity.defaultSort[0];
            }
            this.widget = createWidget(this);
        }
        TableDataView.prototype.update = function () {
            if (this.widget) {
                this.widget.clearEventListeners();
            }
            this.widget = createWidget(this);
        };
        /**
         * Gets the table field for displaying the specified DataEntityField
         * @param dataEntityField
         * @returns {{name: *, field: *}}
         */
        function getTableFieldConfig(dataEntityField) {
            /* jshint validthis: true */
            var tableDataView = this;
            var fieldConfig = {
                name: dataEntityField.name,
                field: dataEntityField.id,
                noValueDisplay: "N/A"
            };
            var scoreField = dataEntityField.scoreField;
            if (!scoreField && /_score$/.test(dataEntityField.id)) {
                scoreField = dataEntityField;
            }
            // For fields with score
            if (scoreField) {
                // Add icon
                fieldConfig.icon = {
                    "preset": "scoreBox",
                    "presetParams": {
                        "value": scoreField.id
                    },
                    "style": "score",
                    "styleParams": {
                        "value": scoreField.id
                    }
                };
                // add tooltip
                var suffix = "Score";
                var toolTipText = fieldConfig.name;
                //if field name does not end with the suffix "Score" - add it
                if (fieldConfig.name.indexOf(suffix, fieldConfig.name.length - suffix.length) === -1) {
                    toolTipText += " " + suffix;
                }
                toolTipText += ": {{" + scoreField.id + ":toFixed:2}}";
                fieldConfig.valueTooltip = toolTipText;
            }
            // If field format is set, use it
            if (dataEntityField.format && formatMap[dataEntityField.format]) {
                fieldConfig.value = "{{" + dataEntityField.id + formatMap[dataEntityField.format] + "}}";
                delete fieldConfig.field;
            }
            else if (dataEntityField.type === dataEntityFieldTypes.date_time ||
                dataEntityField.type === dataEntityFieldTypes.timestamp) {
                fieldConfig.value = "{{" + dataEntityField.id + ":date}}";
                delete fieldConfig.field;
            }
            fieldConfig.sortBy = tableDataView.getFieldTableDataViewId(dataEntityField);
            if (fieldConfig.sortBy === tableDataView.sort.field) {
                fieldConfig.sortDirection = tableDataView.sort.direction === "ASC" ? 1 : -1;
            }
            fieldConfig.menu = {
                items: [],
                "params": {
                    "value": "{{" + dataEntityField.id + "}}",
                    "displayValue": "{{" + dataEntityField.id + formatMap[dataEntityField.format] + "}}",
                    "fieldId": dataEntityField.id,
                    "entityId": dataEntityField.entity.id
                }
            };
            // If not view-only - add the filters to the menu
            if (!tableDataView.explore.viewOnly) {
                //when filter exists in default filters we do not add it to the dropdown filters
                if (tableDataView.explore.defaultFilterFieldIds === null ||
                    tableDataView.explore.defaultFilterFieldIds.indexOf(dataEntityField.id) < 0) {
                    //menu items should be treated the same as field items
                    var valueStr = 'displayValue || value';
                    if (dataEntityField.type === dataEntityFieldTypes.date_time ||
                        dataEntityField.type === dataEntityFieldTypes.timestamp) {
                        valueStr = valueStr + ":date";
                    }
                    fieldConfig.menu.items.push({
                        text: "Add filter: " + dataEntityField.name + " = '{{" + valueStr + "}}'",
                        "onSelect": {
                            "action": "setParams",
                            "actionOptions": {
                                "addToParam": true,
                                "updateUrl": true,
                                "params": {
                                    "filters": "{{entityId}}.{{fieldId}}={{value}}"
                                }
                            }
                        }
                    });
                    fieldConfig.menu.items.push({
                        text: "Clear all filters and create: " + dataEntityField.name + " = '{{" + valueStr + "}}'",
                        "onSelect": {
                            "action": "setParams",
                            "actionOptions": {
                                "updateUrl": true,
                                "params": {
                                    "filters": "{{entityId}}.{{fieldId}}={{value}}"
                                }
                            }
                        }
                    });
                }
            }
            if (dataEntityField.attributes) {
                dataEntityField.attributes.forEach(function (attribute) {
                    menus.getMenuById(attribute).then(function (menu) {
                        fieldConfig.menu.items = fieldConfig.menu.items.concat(menu.items);
                    });
                });
            }
            if (dataEntityField.tags) {
                dataEntityField.tags.forEach(function (tag) {
                    fieldConfig.tags = { "name": tag };
                });
            }
            return fieldConfig;
        }
        function getTableSettings(tableDataView) {
            return {
                "sortParam": tableDataView.getParamName(paramNames.SORT_FIELD),
                "fields": tableDataView.selectedFields.map(getTableFieldConfig.bind(tableDataView))
            };
        }
        /*
         * Returns the default parameters for a Table Data View.
         */
        TableDataView.prototype.getDefaultParams = function () {
            var defaults = {};
            // Page number
            defaults[this.getParamName(paramNames.PAGE)] = 1;
            // Rows per page
            defaults[this.getParamName(paramNames.PAGE_SIZE)] = DEFAULT_PAGE_SIZE;
            // Table columns
            var tableFields = getTableFields(this);
            for (var i = 0; i < tableFields.length; i++) {
                tableFields[i] = this.getFieldTableDataViewId(tableFields[i]);
            }
            defaults[this.getParamName(paramNames.FIELDS)] = tableFields.join(",");
            return defaults;
        };
        TableDataView.prototype.setParams = function (params, updateOnChange) {
            function filterFieldIds(field) {
                /* jshint validthis:true */
                return ~fieldIds.indexOf(this.getFieldTableDataViewId(field));
            }
            var changed = false;
            var pageSize = params[this.getParamName(paramNames.PAGE_SIZE)], page = params[this.getParamName(paramNames.PAGE)], fieldIds = params[this.getParamName(paramNames.FIELDS)], sortField = params[this.getParamName(paramNames.SORT_FIELD)], sortFieldDir = params[this.getParamName(paramNames.SORT_FIELD_DIR)];
            if (pageSize !== undefined) {
                pageSize = Number(pageSize);
                if (pageSize !== this.pageSize) {
                    this.pageSize = pageSize;
                    if (isNaN(this.pageSize)) {
                        this.pageSize = DEFAULT_PAGE_SIZE;
                    }
                    this.resetPaging();
                    changed = true;
                }
            }
            if (page !== undefined) {
                page = Number(page);
                if (this.page !== page) {
                    this.page = page;
                    if (isNaN(this.page)) {
                        this.resetPaging();
                    }
                    changed = true;
                }
            }
            if (sortField || sortFieldDir) {
                if (!this.sort) {
                    this.sort = {};
                }
                if (sortField) {
                    this.sort.field = sortField;
                }
                if (sortFieldDir) {
                    this.sort.direction = sortFieldDir === -1 || sortFieldDir === "-1" ? "DESC" : "ASC";
                }
                changed = true;
            }
            if (fieldIds !== undefined) {
                if (fieldIds === null) {
                    this.selectedFields = null;
                }
                fieldIds = fieldIds ? fieldIds.split(",") : [];
                this.selectedFields = this.explore.dataEntity.fieldsArray.filter(function (field) {
                    return ~fieldIds.indexOf(this.getFieldTableDataViewId(field));
                }.bind(this));
                if (this.selectedFields.length < fieldIds.length && this.explore.dataEntity.linkedEntities) {
                    for (var linkedEntity, i = 0; i < this.explore.dataEntity.linkedEntities.length &&
                        this.selectedFields.length < fieldIds.length; i++) {
                        linkedEntity = dataEntities.getEntityById(this.explore.dataEntity.linkedEntities[i].entity);
                        this.selectedFields =
                            this.selectedFields.concat(linkedEntity.fieldsArray.filter(filterFieldIds.bind(this)));
                    }
                }
                if (!this.selectedFields.length) {
                    this.selectedFields = getTableFields(this);
                }
                if (this.widget) {
                    this.widget.views[0].settings = getTableSettings(this);
                    this.widget.update();
                }
            }
            if (changed && updateOnChange !== false) {
                this.update();
            }
            return changed;
        };
        /**
         * Gets the ID of a field to use inside the tableDataView, in selected field IDs
         * If the field is not from the current explore's dataEntity, the ID is the full path (entityId.fieldId),
         * otherwise the fieldID only is used, for simplicity.
         * @param dataEntityField
         */
        TableDataView.prototype.getFieldTableDataViewId = function (dataEntityField) {
            if (dataEntityField.entity === this.explore.dataEntity) {
                return dataEntityField.id;
            }
            return dataEntityField.entity.id + "." + dataEntityField.id;
        };
        TableDataView.prototype.resetPaging = function () {
            this.page = 1;
            var pageParam = {};
            pageParam[this.getParamName(paramNames.PAGE)] = 1;
            state.setParams(pageParam);
        };
        function getControlsTitle(tableDataView) {
            var firstResultIndex = (tableDataView.page - 1) * tableDataView.pageSize + 1;
            return "Displaying " + firstResultIndex + " - {{total:min:" +
                (tableDataView.page * tableDataView.pageSize) + "}} of {{total}} results";
        }
        function createWidget(tableDataView) {
            function onStateChange(e, data) {
                tableDataView.setParams(data.params, true);
            }
            function runExport() {
                var reportConfig = createReport(tableDataView, "exportEvents");
                var report = new Report(reportConfig);
                report.openInIframe = true;
                report.options = {};
                //in case of using time zone shifting (in the feature we want to able to support UTC and local time )
                //report.options.timezoneOffsetMins=utils.date.timezone * 60;
                //for 1.2.0 we don't want to support time zone shifting
                report.options.timezoneOffsetMins = 0;
                // In case the user selected specific fields, we want to send them to the server in order to export
                // only them
                if (state && state.currentParams && state.currentParams.tableview_fields) {
                    report.options.returnFields = state.currentParams.tableview_fields;
                }
                report.run({});
            }
            var widgetConfig = {
                report: createReport(tableDataView),
                flags: utils.objects.extend(tableDataView.getWidgetFlags(), {
                    stretchVertically: true
                }),
                title: getControlsTitle(tableDataView),
                noDataTitle: "No results found",
                loadingTitle: "Loading Results...",
                "controls": [
                    {
                        "type": "multiSelect",
                        "label": "Fields",
                        "param": tableDataView.getParamName(paramNames.FIELDS),
                        "value": tableDataView.selectedFields.map(function (field) {
                            return tableDataView.getFieldTableDataViewId(field);
                        }),
                        "autoUpdate": true,
                        "settings": {
                            options: getFieldSelectionOptions(tableDataView),
                            maxLabels: 3,
                            buttonText: "Select fields <span class='caret'></span>"
                        }
                    },
                    {
                        "type": "select",
                        "label": "Rows per page",
                        "param": tableDataView.getParamName(paramNames.PAGE_SIZE),
                        "value": tableDataView.pageSize ? tableDataView.pageSize.toString() :
                            state.currentParams[tableDataView.getParamName(paramNames.PAGE_SIZE)] ||
                                DEFAULT_PAGE_SIZE.toString(),
                        "settings": {
                            "options": pageSizes
                        },
                        "autoUpdate": true,
                        "isRequired": true
                    },
                    {
                        "type": "simplePagination",
                        "value": tableDataView.page,
                        "settings": {
                            "pageSize": tableDataView.pageSize
                        },
                        "autoUpdate": true,
                        "param": tableDataView.getParamName(paramNames.PAGE)
                    }
                ],
                views: [
                    {
                        "type": "table",
                        "settings": getTableSettings(tableDataView)
                    }
                ]
            };
            if (tableDataView.explore.includeExport) {
                widgetConfig.buttons = [
                    {
                        "text": "Export",
                        "icon": "#download-icon",
                        "onClick": runExport
                    }
                ];
            }
            var widget = new Widget(widgetConfig, tableDataView.explore);
            widget.onStateChange.subscribe(onStateChange);
            widget.clearEventListeners = function () {
                widget.onStateChange.unsubscribe(onStateChange);
            };
            return widget;
            // clicking on the "export" button will send a report to the exportEvent API and download a file into the
            // iframe
        }
        function getFieldSelectionOptions(tableDataView) {
            var fieldsSelection = tableDataView.explore.dataEntity.fieldsArray
                .filter(function (field) {
                // filter out internal fields (according to their attributes)
                return !(~field.attributes.indexOf("internal"));
            })
                .map(getFieldSelection.bind(tableDataView));
            if (tableDataView.explore.dataEntity.linkedEntities) {
                tableDataView.explore.dataEntity.linkedEntities.forEach(function (linkedEntity) {
                    var entity = dataEntities.getEntityById(linkedEntity.entity);
                    fieldsSelection = fieldsSelection.concat(entity.fieldsArray
                        .filter(function (field) {
                        // filter out internal fields (according to their attributes) or if thie mark to be
                        // oonly shown for linked entity and also field that specific to not the main entity
                        return !((~field.attributes.indexOf("internal")) ||
                            (field.shownForSpecificEntity !== undefined &&
                                field.entity.id === field.shownForSpecificEntity));
                    })
                        .map(getFieldSelection.bind(tableDataView)));
                });
            }
            return fieldsSelection;
        }
        function getFieldSelection(field) {
            /* jshint validthis: true */
            return {
                value: this.getFieldTableDataViewId(field),
                label: "<strong>" + field.entity.name + " <i class='icon-angle-right'></i></strong> " + field.name
            };
        }
        function createReport(tableDataView, api) {
            var dataQueryConfig = utils.objects.extend({
                fields: getReportFields(tableDataView),
                entity: tableDataView.explore.dataEntity.id,
                limit: tableDataView.pageSize,
                offset: tableDataView.pageSize * (tableDataView.page - 1),
                sort: tableDataView.sort || tableDataView.explore.dataEntity.defaultSort
            }, tableDataView.explore.getFiltersDataQuery());
            // If a JOIN is required, need to get fields from the joined entities as well:
            if (!!(dataQueryConfig.entitiesJoin = tableDataView.getDataQueryJoin(dataQueryConfig))) {
                dataQueryConfig.fields = [
                    {
                        entity: tableDataView.explore.dataEntity.id,
                        allFields: true
                    }
                ].concat(dataQueryConfig.entitiesJoin.map(function (entityJoin) {
                    return {
                        entity: entityJoin.entity,
                        allFields: true
                    };
                }));
            }
            var report = tableDataView.getDataQueryReport(dataQueryConfig, null, api);
            if (!tableDataView.widget || !tableDataView.report || tableDataView.widget.total === undefined) {
                report.endpoint.requestTotal = "true";
            }
            return report;
        }
        function getReportFields(tableDataView) {
            var reportEntitiesIndex = {}, fields = [];
            tableDataView.selectedFields.forEach(function (field) {
                reportEntitiesIndex[field.entity.id] = true;
            });
            for (var entity in reportEntitiesIndex) {
                if (reportEntitiesIndex.hasOwnProperty(entity)) {
                    fields.push({
                        entity: entity,
                        allFields: true
                    });
                }
            }
            return fields;
        }
        function getTableFields(tableDataView) {
            return tableDataView.explore.dataEntity.fieldsArray.filter(function (field) {
                return field.isDefaultEnabled;
            });
        }
        return TableDataView;
    }
    TableDataViewClass.$inject =
        ["DataView", "Widget", "utils", "dataEntityFieldTypes", "state", "menus", "dataEntities", "Report"];
    angular.module("Explore.DataViews").factory("TableDataView", TableDataViewClass);
})();

(function () {
    "use strict";
    function GraphClass(dataEntities, GraphDataView) {
        var graphTypesArr = [
            { id: "scatterPlot", icon: "scatterPlot.svg", name: "Scatter Plot" },
            { id: "horizontalBars", icon: "vertical_bars.svg", name: "Horizontal Bar Chart" },
            { id: "verticalBars", icon: "horizontal_bars.svg", name: "Vertical Bar Chart" },
            { id: "lines", icon: "lines.svg", name: "Line Chart" },
            { id: "geo", icon: "geo.png", name: "Geolocation" },
            { id: "bubbles", icon: "bubbles.svg", name: "Bubbles" },
            { id: "heatmap", icon: "grid.png", name: "Heat Map" }
        ];
        var graphTypes = new Map();
        graphTypesArr.forEach(function (graphType) {
            graphTypes.set(graphType.id, new GraphType(graphType));
        });
        function Graph(config) {
            this.validate(config);
            this.id = config.id;
            this.name = config.name;
            this.type = graphTypes.get(config.type);
            // Graph.widget is just the widget's configuration, NOT the widget itself!
            this.widget = angular.extend(config.widget, { title: this.name, description: config.description });
            this.dataQuery = config.dataQuery;
            if (config.hide) {
                this.hide = config.hide;
            }
            //since each graph is defined for a list of entities
            //make sure each entity the graph is related to is a known entity in the current configuration brought from
            // the server
            if (config.entities) {
                config.entities = config.entities.filter(function (entity) {
                    return dataEntities.getEntityById(entity);
                });
                this.entities = config.entities.map(function (entityId) {
                    return dataEntities.getEntityById(entityId);
                });
            }
        }
        Graph.prototype.validate = function (config) {
            if (!config.id || typeof (config.id) !== "string") {
                throw new Error("Can't create Graph, a string 'id' property is required.");
            }
            if (!config.name || typeof (config.name) !== "string") {
                throw new Error("Can't create Graph, a string 'name' property is required.");
            }
            if (!config.type || typeof (config.type) !== "string") {
                throw new Error("Can't create Graph, a string 'type' property is required.");
            }
            if (!graphTypes.has(config.type)) {
                throw new Error("Unknown graph type, '" + config.type + "'.");
            }
            if (!config.widget || Object(config.widget) !== config.widget) {
                throw new Error("Can't create Graph, a 'widget' object is required.");
            }
            if (!config.dataQuery || !angular.isObject(config.dataQuery)) {
                throw new Error("Can't create graph, an object 'dataQuery' property is required.");
            }
            if (config.entities) {
                if (config.entities.constructor !== Array) {
                    throw new TypeError("Invalid 'entities' property for graph, expected an array but got " +
                        config.entities);
                }
            }
        };
        /**
         * Returns a new GraphDataView object for the specified Explore object
         * @param explore
         * @returns {GraphDataView}
         */
        Graph.prototype.getDataView = function (explore) {
            return new GraphDataView(this, explore);
        };
        function GraphType(config) {
            this.id = config.id;
            this.icon = "images/icons/charts/" + config.icon;
            this.name = config.name;
        }
        return Graph;
    }
    GraphClass.$inject = ["dataEntities", "GraphDataView"];
    angular.module("Explore.DataViews").factory("Graph", GraphClass);
})();

(function () {
    'use strict';
    function GraphDataViewClass(utils, DataView, Widget) {
        function createReport(graph, explore) {
            var dataQueryConfig = utils.objects.extend({
                entity: explore.dataEntity.id
            }, graph.dataQuery, explore.getFiltersDataQuery());
            if (!graph.dataView) {
                graph.dataView = graph.getDataView(explore);
            }
            dataQueryConfig.entitiesJoin = graph.dataView.getDataQueryJoin(dataQueryConfig, explore);
            var report = DataView.getDataQueryReport(dataQueryConfig, "graphs." + graph.id);
            return { report: report };
        }
        function GraphDataView(graph, explore) {
            var graphDataView = this;
            this.explore = explore;
            this.graph = utils.objects.copy(graph);
            Widget.loadWidget(this.graph.widget).then(function (widget) {
                graphDataView.widget = Widget.copy(widget);
                graphDataView.widget.setParent(explore);
                graphDataView.widget.setReport(createReport(graph, explore)).getData();
                //the includeExport is used to identify that we are coming from the Explore page - in the future if we
                // need different condition we can add another flag
                if (graphDataView.explore.includeExport) {
                    graphDataView.widget.buttons = [
                        {
                            icon: "#icon-remove",
                            title: "Remove graph",
                            onClick: function () {
                                explore.removeGraph(graph);
                            }
                        }
                    ];
                }
            });
        }
        // This next code is scary! We should definitely look into it when we have time, and kick the use of __proto__.
        // TODO!!
        /* jshint ignore:start */
        GraphDataView.prototype.__proto__ = DataView;
        /* jshint ignore:end */
        /*
         * Returns the default parameters for a Graph Data View.
         */
        GraphDataView.prototype.getDefaultParams = function () {
            return {};
        };
        GraphDataView.prototype.setParams = function (params, updateOnChange) {
            var needUpdate = false;
            if (params[this.getParamName("filters")] !== undefined ||
                params[this.getParamName("default_filters")] !== undefined) {
                needUpdate = this.updateReport();
            }
            if (updateOnChange && needUpdate) {
                this.update();
            }
            return needUpdate;
        };
        /**
         * Updates the dataView's report according to the current graph and explore states.
         * @param updateOnChange
         * @returns {boolean}
         */
        GraphDataView.prototype.updateReport = function (updateOnChange) {
            var needUpdate = false;
            var report = createReport(this.graph, this.explore);
            if (!utils.objects.areEqual(report, this.lastReport)) {
                this.widget.setReport(report);
                this.lastReport = report;
                needUpdate = true;
            }
            if (updateOnChange) {
                this.update();
            }
            return needUpdate;
        };
        GraphDataView.prototype.update = function () {
            this.widget.setParent(this.explore);
            this.widget.refresh();
        };
        return GraphDataView;
    }
    GraphDataViewClass.$inject = ["utils", "DataView", "Widget"];
    angular.module("Explore.DataViews").factory("GraphDataView", GraphDataViewClass);
})();

(function () {
    "use strict";
    function graphs($q, utils, Graph) {
        /**
         * Returns the configuration for all graphs that are available to the specified entity
         * @param dataEntity
         */
        function getGraphsForDataEntity(dataEntity) {
            return getGraphsConfig()
                .then(function () {
                var entityGraphs = [], currentEntity = dataEntity;
                do {
                    entityGraphs = (entitiesGraphs[currentEntity.id] || []).concat(entityGraphs);
                } while (!!(currentEntity = currentEntity.baseEntity));
                return entityGraphs;
            });
        }
        function getGraphsConfig() {
            if (!graphsConfig) {
                return utils.http.wrappedHttpGet("data/explore/graphs.json").then(function (graphsConfigData) {
                    graphsConfig = {};
                    entitiesGraphs = {};
                    var graph, allEntitiesGraphs = [];
                    function populateEntityGraphs(entity) {
                        var entityGraphs = entitiesGraphs[entity.id];
                        if (!entityGraphs) {
                            entityGraphs = entitiesGraphs[entity.id] = [];
                        }
                        entityGraphs.push(graph);
                    }
                    for (var graphId in graphsConfigData) {
                        if (graphsConfigData.hasOwnProperty(graphId)) {
                            graph = graphsConfig[graphId] = new Graph(graphsConfigData[graphId]);
                            if (graph.entities) {
                                graph.entities.forEach(populateEntityGraphs);
                            }
                            else {
                                allEntitiesGraphs.push(graph);
                            }
                        }
                    }
                    if (allEntitiesGraphs.length) {
                        for (var entityId in entitiesGraphs) {
                            if (entitiesGraphs.hasOwnProperty(entityId)) {
                                entitiesGraphs[entityId] = allEntitiesGraphs.concat(entitiesGraphs[entityId]);
                            }
                        }
                    }
                    return graphsConfig;
                });
            }
            return $q.when(graphsConfig);
        }
        var graphsConfig, entitiesGraphs;
        return {
            getGraphsForDataEntity: getGraphsForDataEntity
        };
    }
    graphs.$inject = ["$q", "utils", "Graph"];
    angular.module("Explore.DataViews").factory("graphs", graphs);
})();

(function () {
    "use strict";
    function dataViewTypes(DataViewType) {
        var types = [{ id: "table", name: "Table", icon: "#table-icon" },
            { id: "graphs", name: "Graphs", icon: "#graph-icon" }].map(function (typeConfig) {
            return new DataViewType(typeConfig);
        }), index = {};
        types.forEach(function (type) {
            index[type.id] = type;
        });
        return {
            typesArray: types,
            types: index
        };
    }
    dataViewTypes.$inject = ["DataViewType"];
    angular.module("Explore.DataViews").factory("dataViewTypes", dataViewTypes);
})();

(function () {
    'use strict';
    angular.module("Explore.DataViews")
        .filter('unAddedGraphs', function () {
        return function (graphs) {
            if (!graphs) {
                return graphs;
            }
            return graphs.filter(function (graph) {
                return !graph.added;
            });
        };
    })
        .filter('hideGraphs', function () {
        return function (graphs) {
            if (!graphs) {
                return graphs;
            }
            return graphs.filter(function (graph) {
                return !graph.hide;
            });
        };
    })
        .filter('addedGraphs', function () {
        return function (graphs) {
            if (!graphs) {
                return graphs;
            }
            return graphs.filter(function (graph) {
                return graph.added;
            });
        };
    });
}());

(function () {
    'use strict';
    angular.module("Chart", ["Colors", "Utils"]).factory('Chart', [
        "$injector", "$parse", "colors", "utils", "debounce", "config",
        function ($injector, $parse, colors, utils, debounce, config) {
            var constructor;
            function Chart($rootScope, defaultOptions, draw, $parse, colors, utils) {
                this.$rootScope = $rootScope;
                this.$parse = $parse;
                this.colors = colors;
                this.utils = utils;
                this.defaultOptions = defaultOptions || {};
                this._draw = draw;
            }
            Chart.prototype = {
                timeFormat: {
                    days: d3.time.format.multi([
                        ["%m/%d", function (d) {
                                return d.getFullYear() === utils.date.getMoment('now').year();
                            }],
                        ["%m/%d/%y", function () {
                                return true;
                            }]
                    ]),
                    "default": d3.time.format.multi([
                        [".%L", function (d) {
                                return d.getMilliseconds();
                            }],
                        [":%S", function (d) {
                                return d.getSeconds();
                            }],
                        ["%H:%M", function (d) {
                                return d.getMinutes();
                            }],
                        ["%H:00", function (d) {
                                return d.getHours();
                            }],
                        ["%a %d", function (d) {
                                return d.getDay() && d.getDate() !== 1;
                            }],
                        ["%b %d", function (d) {
                                return d.getDate() !== 1;
                            }],
                        ["%B", function (d) {
                                return d.getMonth();
                            }],
                        ["%Y", function () {
                                return true;
                            }]
                    ])
                },
                createBrush: function () {
                    function brushstart() {
                        self.svg.classed("selecting", true);
                    }
                    function brushmove() {
                        self.$rootScope.$apply(function () {
                            onBrush(self.scope, { extent: d3.event.target.extent() });
                        });
                    }
                    function brushend() {
                        self.svg.classed("selecting", !d3.event.target.empty());
                    }
                    var self = this, onBrush = this.attrs.onBrush ? this.$parse(this.attrs.onBrush) : null;
                    this.dataSvg.append("g")
                        .attr("class", "brush")
                        .call(d3.svg.brush().x(this.scale.x)
                        .on("brushstart", brushstart)
                        .on("brush", onBrush ? brushmove : null)
                        .on("brushend", brushend))
                        .selectAll("rect")
                        .attr("height", self.dataHeight);
                },
                createScales: function () {
                    if (this.scale) {
                        return;
                    }
                    var self = this;
                    this.scale = {};
                    var d3timeScale = config.alwaysUtc ? d3.time.scale.utc : d3.time.scale;
                    if (this.settings.scales.x) {
                        this.scale.x = this.settings.scales.x.type === "time" ? d3timeScale() : d3.scale.linear();
                        this.scale.x.range([0, this.width - this.options.axisWidth]);
                        if (this.settings.scales.x.domain) {
                            this.scale.x.domain(this.settings.scales.x.domain);
                        }
                        if (this.attrs.graphDomainX) {
                            this.unwatchers.push(this.scope.$watch(this.attrs.graphDomainX, function (value) {
                                if (value) {
                                    if (self.scale.x) {
                                        self.scale.x.domain(value);
                                    }
                                    if (self.onUpdateDomain) {
                                        self.onUpdateDomain.call(this, { x: value });
                                    }
                                    if (self.axes.x) {
                                        self.axes.x._element.call(self.axes.x);
                                        self.axes.x._grid.call(self.getGridAxis("x"));
                                    }
                                }
                            }));
                        }
                    }
                    if (this.settings.scales.y) {
                        this.scale.y = this.settings.scales.y.type === "time" ? d3timeScale() : d3.scale.linear();
                        this.scale.y.range([this.height - this.options.axisWidth, 0]);
                        this.scale.y.reverseScale =
                            this.settings.scales.y.type === "time" ? d3timeScale() : d3.scale.linear();
                        this.scale.y.reverseScale.range([0, this.height - this.options.axisWidth]);
                        if (this.settings.scales.y.domain) {
                            this.scale.y.domain(this.settings.scales.y.domain);
                            this.scale.y.reverseScale.domain(this.settings.scales.y.domain);
                        }
                        if (this.attrs.graphDomainY) {
                            this.unwatchers.push(this.scope.$watch(this.attrs.graphDomainY, function (value) {
                                if (value) {
                                    if (self.scale.x) {
                                        self.scale.x.domain(value);
                                    }
                                    if (self.onUpdateDomain) {
                                        self.onUpdateDomain.call(this, { y: value });
                                    }
                                }
                            }));
                        }
                    }
                    this.setScaleRanges = function (ranges) {
                        if (!ranges) {
                            return;
                        }
                        if (ranges.x && this.scale.x) {
                            this.scale.x.range(ranges.x);
                        }
                        if (ranges.y && this.scale.y) {
                            this.scale.y.range(ranges.y);
                            this.scale.y.reverseScale.range([ranges.y[1], ranges.y[0]]);
                        }
                    };
                    this.setScaleDomains = function (domains) {
                        if (!domains) {
                            return;
                        }
                        if (domains.x && this.scale.x) {
                            this.scale.x.domain(domains.x);
                        }
                        if (domains.y && this.scale.y) {
                            this.scale.y.domain(domains.y);
                            this.scale.y.reverseScale.domain(domains.y);
                        }
                    };
                },
                createAxes: function () {
                    if (!this.settings.axes) {
                        return;
                    }
                    var self = this;
                    this.axes = {};
                    var d3timeFormat = config.alwaysUtc ? d3.time.format.utc : d3.time.format;
                    var axes = this.svg.append("g").attr("class", "axes"), marginLeft = this.options.margins.left + (this.settings.axes.y ? this.options.axisWidth : 0), grids = this.svg.insert("g", ".graph-data").attr("class", "grids");
                    if (this.settings.axes.x) {
                        this.axes.x = d3.svg.axis()
                            .scale(this.scale.x)
                            .orient("bottom");
                        if (this.settings.axes.x.ticks) {
                            this.axes.x.ticks(d3.time[this.settings.axes.x.ticks.unit], this.settings.axes.x.ticks.interval);
                        }
                        else {
                            //When letting D3 create the X-axis ticks automatically,
                            // we may get duplicate entries. so we remove them.
                            this.axes.x.tickValues(this.removeDuplicateTicks(this.scale.x.ticks(), this.dateFormatter));
                        }
                        if (this.settings.axes.x.tickFormat) {
                            var xScaleTickFormatter = this.settings.axes.x.type === "time" ? d3timeFormat : d3.format, xScaleTickFormat = xScaleTickFormatter(this.settings.axes.x.tickFormat);
                            this.axes.x.tickFormat(xScaleTickFormat);
                        }
                        else if (this.settings.axes.x.type === "time") {
                            var timeFormat = this.timeFormat[this.settings.axes.x.timeFormat] ||
                                this.timeFormat.default;
                            this.axes.x.tickFormat(timeFormat);
                        }
                        this.axes.x._grid = grids.append("g")
                            .attr("class", "grid")
                            .attr("transform", "translate(" + (marginLeft + 1) + ", " + this.options.margins.top + ")")
                            .call(self.getGridAxis("x"));
                        this.axes.x._element = axes.append("g")
                            .attr("class", "x axis")
                            .attr("transform", "translate(" + (marginLeft + 1) + "," + (this.height - this.options.margins.top) + ")")
                            .call(this.axes.x);
                        if (this.settings.axes.x.label) {
                            this.axes.x._label = this.axes.x._element.append("text")
                                .attr("class", "graph-axis-label")
                                .attr("x", this.dataWidth / 2)
                                .attr("dy", self.options.axisLabelsWidth.x + 10)
                                .style("text-anchor", "middle")
                                .text(this.settings.axes.x.label || "");
                        }
                    }
                    if (this.settings.axes.y) {
                        var yScaleTickFormatter, yScaleTickFormat;
                        this.axes.y = d3.svg.axis()
                            .scale(this.scale.y)
                            .orient("left")
                            .ticks(this.settings.axes.y.ticks);
                        if (this.settings.axes.y.tickFormat) {
                            if (~this.settings.axes.y.tickFormat.indexOf("{{")) {
                                var yTickFormat = this.settings.axes.y.tickFormat;
                                yScaleTickFormat = function (d) {
                                    return self.utils.strings.parseValue(yTickFormat, { value: d });
                                };
                            }
                            else {
                                yScaleTickFormatter = this.settings.axes.y.type === "time" ? d3timeFormat :
                                    d3.format;
                                yScaleTickFormat = yScaleTickFormatter(this.settings.axes.y.tickFormat);
                            }
                            this.axes.y.tickFormat(yScaleTickFormat);
                        }
                        this.axes.y._grid = grids.append("g")
                            .attr("class", "grid")
                            .attr("transform", "translate(" + marginLeft + ", " + this.options.margins.top + ")")
                            .call(self.getGridAxis("y"));
                        this.axes.y._element = axes.append("g")
                            .attr("class", "y axis")
                            .attr("transform", "translate(" + marginLeft + ", " + this.options.margins.top + ")")
                            .call(this.axes.y);
                        if (this.settings.axes.y.label) {
                            this.axes.y._label = this.axes.y._element.append("text")
                                .attr("class", "graph-axis-label")
                                .attr("transform", "rotate(-90)")
                                .attr("x", this.dataHeight / -2)
                                .attr("dy", self.options.axisLabelsWidth.y * -1 - 5)
                                .style("text-anchor", "middle")
                                .text(this.settings.axes.y.label || "");
                        }
                    }
                },
                _createLegend: function () {
                    var circleRadius = 8, margin = 12, textMargin = margin + 4;
                    this.elements.legend = this.svg.append("g")
                        .attr("class", "legend")
                        .attr("transform", "translate(0, " + this.options.margins.top + ")");
                    this.elements.legendItems = this.elements.legend.selectAll(".legend-item").data(this.legendData)
                        .enter().append("g")
                        .attr("transform", function (d, i) {
                        return "translate(0, " + (margin + circleRadius) * 2 * i + ")";
                    })
                        .attr("class", "legend-item");
                    var legendItems = this.elements.legendItems.append("g")
                        .attr("class", "legend-item-bullet")
                        .style("fill", function (d) {
                        return d.color;
                    });
                    legendItems.append("path").attr("d", function (d) {
                        return d3.svg.symbol().type(d.symbol).size(circleRadius * 10)();
                    })
                        .attr("fill", function (d) {
                        return d.color || "steelblue";
                    });
                    this.elements.legendItems.append("text")
                        .attr("class", "legend-item-text")
                        .text(function (d) {
                        return d.text;
                    })
                        .attr("transform", "translate(" + textMargin + ", 0)")
                        .attr("dy", ".3em");
                    if (this.settings.legend.position === "right") {
                        var legendWidth = this.elements.legend[0][0].getBoundingClientRect().width;
                        this.elements.legend._width = legendWidth + margin;
                        this.elements.legend.attr("transform", "translate(" + (this.width - this.elements.legend._width) + ", " +
                            (this.options.margins.top + margin) + ")");
                    }
                },
                getGridAxis: function (xy) {
                    var oppositeScale = this.scale[xy === "x" ? "y" : "x"];
                    var oppositeRange = oppositeScale && oppositeScale.range() || [0], axis = d3.svg.axis().scale(this.scale[xy]).orient(xy === "x" ? "top" : "left")
                        .tickSize(-(Math.max.apply(this, oppositeRange)), 0, 0)
                        .tickFormat("")
                        .ticks(this.settings.axes[xy].ticks);
                    if (this.settings.axes[xy] && this.settings.axes[xy].ticks) {
                        axis.ticks(d3.time[this.settings.axes[xy].ticks.unit], this.settings.scales[xy].interval);
                    }
                    return axis;
                },
                createTooltip: function () {
                    var self = this;
                    var tooltip = this.tooltip = this.svg.append("g")
                        .attr("class", "graph-tooltip")
                        .attr("style", "display: none");
                    var tooltipBackground = tooltip.append("rect")
                        .attr("width", 100)
                        .attr("height", 30)
                        .attr("fill", "rgba(0,0,0,.8")
                        .attr("rx", 4)
                        .attr("ry", 4);
                    var mouseOutTimeout, elementWidth, elementHeight, elementBoundingRect;
                    if (this.getTooltipText) {
                        this.element.on("mouseover", "[data-tooltip]", function (e) {
                            var tooltipData = e.target.__data__, tooltipText = self.getTooltipText(tooltipData, $(e.target).closest("[data-tooltip]").attr("data-tooltip"));
                            if (tooltipText) {
                                elementBoundingRect = self.svg[0][0].getBoundingClientRect();
                                elementWidth = elementBoundingRect.width;
                                elementHeight = elementBoundingRect.height;
                                setTooltipText(tooltipText);
                                showTooltip(elementBoundingRect);
                                window.addEventListener("mousemove", tooltipMoveHandler);
                            }
                        });
                        this.element.on("mouseout", "[data-tooltip]", function () {
                            hideTooltip();
                        });
                    }
                    function setTooltipText(text) {
                        var tspanTexts = text.split("|");
                        tooltip.selectAll("text").remove();
                        var textElement = tooltip.selectAll("text")
                            .data(tspanTexts)
                            .enter()
                            .append("text");
                        textElement.text(function (d) {
                            return d;
                        })
                            .attr("fill", "White")
                            .attr("font-size", "14px")
                            .attr("transform", function (d, i) {
                            return "translate(15, " + (20 * (i + 1)) + ")";
                        });
                        tooltipBackground.attr("width", textElement[0][0].getBoundingClientRect().width + 30);
                        tooltipBackground.attr("height", 20 * tspanTexts.length + 10);
                    }
                    function hideTooltip() {
                        tooltip[0][0].style.display = "none";
                    }
                    function showTooltip() {
                        clearTimeout(mouseOutTimeout);
                        tooltip[0][0].style.removeProperty("display");
                    }
                    function tooltipMoveHandler(e) {
                        setTooltipPosition({
                            x: (e.x || e.clientX) - elementBoundingRect.left,
                            y: (e.y || e.clientY) - elementBoundingRect.top
                        });
                    }
                    function setTooltipPosition(position) {
                        var tooltipPositionX = position.x + 5, tooltipPositionY = position.y, tooltipWidth = parseInt(tooltipBackground[0][0].getAttribute("width")), tooltipHeight = parseInt(tooltipBackground[0][0].getAttribute("height"));
                        if (tooltipPositionX + tooltipWidth > elementWidth) {
                            tooltipPositionX = position.x - tooltipWidth - 5;
                            if (tooltipPositionX < 0) {
                                tooltipPositionX = 0;
                            }
                        }
                        if (tooltipPositionY + tooltipHeight > elementHeight - 20) {
                            tooltipPositionY = position.y - tooltipHeight - 5;
                            if (tooltipPositionY < 0) {
                                tooltipPositionY = 0;
                            }
                        }
                        tooltip.attr("transform", "translate(" + tooltipPositionX + "," + tooltipPositionY + ")");
                    }
                },
                draw: function () {
                    if (this._draw() !== false) {
                        if (this.settings.axes) {
                            this.createAxes();
                        }
                        if (this.createLegend) {
                            this.createLegend();
                        }
                        this.createTooltip();
                        if (this.postRender) {
                            this.postRender();
                        }
                    }
                },
                getColorScale: function (colorSettings) {
                    return this.colors.getScale(colorSettings || this.settings.color);
                },
                getData: function () {
                    if (this.graphFilter) {
                        if (this.filteredData) {
                            return this.filteredData;
                        }
                        this.filteredData = this.graphFilter(this.data);
                        return this.filteredData;
                    }
                    return this.data;
                },
                init: function (scope, element, attrs) {
                    var self = this, defaults = {
                        axisWidth: 20,
                        axisLabelsWidth: { y: 25, x: 25 },
                        margins: { top: 10, left: 20, right: 20, bottom: 10 }
                    };
                    this.element = element;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.unwatchers = [];
                    scope.$on("$destroy", function () {
                        if (self.dataSvg) {
                            self.dataSvg.empty();
                            self.dataSvg.remove();
                            self.dataSvg = null; // major memory performance improvement.
                        }
                        element.off();
                        element.empty();
                        self.unwatchers.forEach(function (unwatcher) {
                            unwatcher();
                        });
                        self.unwatchers = [];
                    });
                    this.unwatchers.push(scope.$on("resize", this.resize.bind(this)));
                    if (attrs.graphFilter) {
                        self.unwatchers.push(scope.$watch(attrs.graphFilter, function (value) {
                            var previousData = self.data;
                            self.graphFilter = value;
                            self.filteredData = null;
                            self.refresh(previousData);
                        }));
                    }
                    self.unwatchers.push(scope.$watch(attrs.ngModel, function (chartData) {
                        var previousData = self.data;
                        self.data = chartData;
                        if (self.formatData) {
                            self.formattedData = self.formatData(chartData);
                        }
                        self.refresh(previousData);
                    }));
                    self.unwatchers.push(scope.$watch(attrs.graphSettings, function (value) {
                        if (value) {
                            self.scale = null;
                            self.settings = value;
                            self.options = angular.extend({}, defaults, self.defaultOptions, self.settings.options);
                            self.render();
                        }
                    }));
                },
                refresh: function (previousData) {
                    if (this.loaded && this.update) {
                        this.update(this.getData(), previousData);
                    }
                    else {
                        this.loaded = this.render();
                    }
                },
                render: function () {
                    var self = this;
                    this.element.empty();
                    this.element.off();
                    this.element.addClass("widget-graph");
                    if (!this.settings || !this.data || !this._draw) {
                        return false;
                    }
                    this.elements = {};
                    this.svg = d3.select(this.element[0])
                        .append("svg:svg")
                        .attr("class", "graph")
                        .attr("width", this.options.width || "100%")
                        .attr("height", this.options.height || "100%");
                    // The SVG has no height and width if it's hidden, which happens when transitioning widget state
                    // due to no data and then data. In this case, wait and try again:
                    if (!this.svg[0][0].clientHeight && !this.svg[0][0].clientWidth) {
                        if (this.renderRetry === 5) {
                            this.renderRetry = 0;
                            return;
                        }
                        else {
                            if (this.renderRetry === undefined) {
                                this.renderRetry = 0;
                            }
                            else {
                                this.renderRetry++;
                            }
                            setTimeout(this.render.bind(this), 50);
                        }
                        return;
                    }
                    else if (this.renderRetry) {
                        this.renderRetry = 0;
                    }
                    if (this.preRender) {
                        this.preRender();
                    }
                    this.width = this.element.innerWidth();
                    this.height = this.element.innerHeight();
                    if (this.settings.legend && this.legendData) {
                        this._createLegend();
                        if (this.settings.legend.position === "right" || this.settings.legend.position === "left") {
                            var legendWidth = this.elements.legend[0][0].getBoundingClientRect().width;
                            this.width -= legendWidth;
                        }
                    }
                    if (typeof (this.options.margins) === "number") {
                        this.options.margins = {
                            top: this.options.margins,
                            bottom: this.options.margins,
                            left: this.options.margins,
                            right: this.options.margins
                        };
                    }
                    this.width -= this.options.margins.left + this.options.margins.right;
                    this.height -= this.options.margins.top + this.options.margins.bottom;
                    if (this.settings.axes) {
                        if (this.settings.axes.y && this.settings.axes.y.label) {
                            this.width -= this.options.axisLabelsWidth.y;
                            if (!this.loaded) {
                                this.options.margins.left += this.options.axisLabelsWidth.y - 5;
                            }
                        }
                        if (this.settings.axes.x && this.settings.axes.x.label) {
                            this.height -= this.options.axisLabelsWidth.x;
                        }
                    }
                    this.dataWidth = this.width;
                    this.dataHeight = this.height;
                    this.dataSvg = this.svg.append("g").attr("class", "graph-data");
                    if (this.settings.axes) {
                        if (this.settings.axes.x) {
                            this.dataHeight -= this.options.axisWidth;
                        }
                        if (this.settings.axes.y) {
                            this.dataWidth -= this.options.axisWidth;
                        }
                        this.dataSvg.attr("transform", "translate(" +
                            ((this.settings.axes.y ? this.options.axisWidth + 1 : 0) + this.options.margins.left) +
                            ", " + this.options.margins.top + ")");
                    }
                    else {
                        this.dataSvg.attr("transform", "translate(" + this.options.margins.left + ", " + this.options.margins.top + ")");
                    }
                    if (this.settings.shapes && this.settings.shapes.map) {
                        this.dataHeight -= 20;
                    }
                    if (this.settings.scales) {
                        this.createScales();
                    }
                    this.draw();
                    if (this.settings.onSelect) {
                        this.element.on("click", "[data-selectable]", function (e) {
                            self.scope.$apply(function () {
                                var event = angular.copy(self.settings.onSelect);
                                event.actionOptions.event = e;
                                event.actionOptions.position = {
                                    top: e.pageY,
                                    left: e.pageX
                                };
                                self.scope.$emit("dashboardEvent", {
                                    event: event,
                                    data: e.target.__data__,
                                    params: self.scope.widget.getState ? self.scope.widget.getState() :
                                        self.scope.getWidgetParams()
                                });
                            });
                        });
                    }
                    if (this.settings.brush) {
                        this.createBrush();
                    }
                    var selfResize = this.resize.bind(this);
                    // Debounce the handler to prevent overload
                    var resizeHandler = debounce(100, function () {
                        self.$rootScope.safeApply(selfResize);
                    });
                    window.addEventListener("resize", resizeHandler);
                    this.loaded = true;
                    return true;
                },
                resize: function () {
                    // Make sure the chart is visible
                    if (!angular.element(this.element).is(':visible')) {
                        return;
                    }
                    var legendWidth = this.elements.legend && this.elements.legend._width;
                    this.width = this.element.innerWidth();
                    this.height = this.element.innerHeight();
                    this.width -= this.options.margins.left + this.options.margins.right;
                    this.height -= this.options.margins.top + this.options.margins.bottom;
                    if (this.settings.axes) {
                        if (this.settings.axes.y && this.settings.axes.y.label) {
                            this.width -= this.options.axisLabelsWidth.y;
                        }
                        if (this.settings.axes.x && this.settings.axes.x.label) {
                            this.height -= this.options.axisLabelsWidth.x;
                        }
                    }
                    this.dataWidth = this.width;
                    this.dataHeight = this.height;
                    if (this.settings.axes) {
                        if (this.settings.axes.x) {
                            this.dataHeight -= this.options.axisWidth;
                        }
                        if (this.settings.axes.y) {
                            this.dataWidth -= this.options.axisWidth;
                        }
                    }
                    if (this.settings.scales) {
                        if (this.settings.scales.x) {
                            this.scale.x.range([0, this.width - this.options.axisWidth -
                                    (legendWidth ? legendWidth - this.options.margins.right : 0)]);
                        }
                        if (this.settings.scales.y) {
                            this.scale.y.range([this.height - this.options.axisWidth, 0]);
                            this.scale.y.reverseScale.range([0, this.height - this.options.axisWidth]);
                        }
                    }
                    if (legendWidth) {
                        //this.dataWidth -= this.elements.legend._width;
                        this.elements.legend.attr("transform", "translate(" +
                            (this.svg[0][0].getBoundingClientRect().width - this.elements.legend._width) + ", " +
                            (this.options.margins.top + 6) + ")");
                        this.dataWidth -= this.elements.legend._width;
                    }
                    if (this.onResize) {
                        this.onResize();
                    }
                    if (this.settings.axes) {
                        var marginLeft = this.options.margins.left +
                            (this.settings.axes.y ? this.options.axisWidth : 0);
                        if (this.axes.x) {
                            this.axes.x._grid.attr("transform", "translate(" + marginLeft + ", " + this.options.margins.top + ")")
                                .call(this.getGridAxis("x"));
                            this.axes.x._element.attr("transform", "translate(" + marginLeft + "," + (this.height - this.options.margins.top) + ")")
                                .call(this.axes.x);
                            if (this.settings.axes.x.label) {
                                this.axes.x._label.attr("x", this.dataWidth / 2);
                            }
                        }
                        if (this.axes.y) {
                            this.axes.y._grid.attr("transform", "translate(" + marginLeft + ", " + this.options.margins.top + ")")
                                .call(this.getGridAxis("y"));
                            this.axes.y._element.attr("transform", "translate(" + marginLeft + ", " + this.options.margins.top + ")")
                                .call(this.axes.y);
                        }
                    }
                },
                get yAxisWidth() {
                    return 20;
                },
                get xAxisHeight() {
                    return 16;
                },
                /**
                 * remove duplicate entries from the X axis in graphs. this is when we want the ability to change time
                 * scale and to let the scale change accordingle without creating any duplicates.
                 * @param ticks
                 * @param formatter
                 * @returns array of non-duplicated ticks
                 */
                removeDuplicateTicks: function (ticks, formatter) {
                    if (ticks === undefined || ticks === null || !angular.isArray(ticks)) {
                        return ticks;
                    }
                    var nonDuplicateTickValues = [];
                    for (var i = 0; i < ticks.length; i++) {
                        var tickVal = ticks[i];
                        if (!this.tickAlreadyExists(nonDuplicateTickValues, tickVal, formatter)) {
                            nonDuplicateTickValues.push(tickVal);
                        }
                    }
                    return nonDuplicateTickValues;
                },
                /**
                 * Helper function that finds wheter an entry already entered into the list of unique entries
                 * @param nonDuplicateTickValues
                 * @param tickValIn
                 * @param formatter
                 * @returns {boolean}
                 */
                tickAlreadyExists: function (nonDuplicateTickValues, tickValIn, formatter) {
                    for (var i = 0; i < nonDuplicateTickValues.length; i++) {
                        var t = nonDuplicateTickValues[i];
                        var formattedTickValIn = formatter(tickValIn);
                        var formattedTickVal = formatter(t);
                        if (formattedTickValIn === formattedTickVal) {
                            return true;
                        }
                    }
                    return false;
                },
                dateFormatter: function (d) {
                    var d3timeFormat = config.alwaysUtc ? d3.time.format.utc : d3.time.format;
                    var format = d3timeFormat("%d-%b-%y");
                    return format(d);
                }
            };
            constructor = function (options, draw) {
                return $injector.instantiate(Chart, {
                    defaultOptions: options,
                    draw: draw,
                    $parse: $parse,
                    colors: colors,
                    utils: utils
                });
            };
            return constructor;
        }]);
}());

(function () {
    'use strict';
    function tableWidget($q, utils, transforms, icons, conditions, menus, tags, widgetViews, TableWidgetConfig) {
        function tableConfigValidate(settings) {
            var tableConfig = new TableWidgetConfig(settings);
            return !!tableConfig;
        }
        function tableDataParser(view, data, params) {
            function getTableData() {
                var viewData = { rows: [] }, fieldSpans = {}, loadPromises = [], iconParsers = {}, menuIds = {};
                angular.forEach(tableConfig.fields, function (field, fieldIndex) {
                    field.__index = fieldIndex;
                    if (field.icon) {
                        loadPromises.push(icons.getParseIconFunction(field.icon).then(function (iconParser) {
                            iconParsers[fieldIndex] = iconParser;
                        }));
                    }
                    if (field.menu && field.menu.id) {
                        menuIds[field.menu.id] = true;
                        loadPromises.push(menus.getMenuParser(field.menu).then(function (menuParser) {
                            field.getMenu = menuParser;
                        }));
                    }
                    loadPromises.push(menus.initMenus(Object.keys(menuIds)));
                });
                if (tableConfig.caption) {
                    viewData.caption = utils.strings.parseValue(tableConfig.caption, data, params);
                }
                function getField(row, rowIndex, field) {
                    var fieldData = {
                        display: field.value && utils.strings.parseValue(field.value, row, params, rowIndex) || "",
                        field: field
                    };
                    if (!fieldData.display && field.field) {
                        fieldData.display = row[field.field];
                    }
                    if (field.transform && field.transform.method) {
                        fieldData.display =
                            transforms[field.transform.method](field.field ? row[field.field] : fieldData.display, field.transform.options);
                    }
                    if (field.externalLinks) {
                        fieldData.externalLinks = field.externalLinks;
                    }
                    if (fieldData.display !== null && typeof (fieldData.display) !== "string") {
                        fieldData.display = String(fieldData.display);
                    }
                    if (field.link) {
                        fieldData.link = utils.strings.parseValue(field.link, row, params, rowIndex);
                    }
                    if (field.valueTooltip) {
                        if (angular.isString(field.valueTooltip)) {
                            fieldData.tooltip = utils.strings.parseValue(field.valueTooltip, row, params, rowIndex);
                        }
                        else if (field.valueTooltip.transform) {
                            fieldData.tooltip =
                                transforms[field.valueTooltip.transform.method](row[field.valueTooltip.field], field.valueTooltip.transform.options);
                        }
                    }
                    if (fieldData.display) {
                        if (field.map) {
                            var mapValue = field.map[fieldData.display] || field.map._default;
                            if (mapValue) {
                                fieldData.display = utils.strings.parseValue(mapValue, row, params, rowIndex);
                            }
                        }
                    }
                    else if (field.noValueDisplay) {
                        fieldData.display = field.noValueDisplay;
                        fieldData.noValue = true;
                    }
                    else if (fieldData.display === "") {
                        fieldData.display = "N/A";
                        fieldData.noValue = true;
                    }
                    if (field.icon) {
                        fieldData.icon = iconParsers[field.__index](row);
                    }
                    if (field.renderHeader === false) {
                        fieldData.renderHeader = false;
                    }
                    if (field.events) {
                        fieldData.id = field.name.replace(/\s/g, "_");
                    }
                    if (field.switch) {
                        for (var i = 0, switchItem; !!(switchItem = field.switch[i]); i++) {
                            if (!switchItem.conditions ||
                                conditions.validateConditions(switchItem.conditions, row, params)) {
                                angular.extend(fieldData, getField(row, rowIndex, switchItem.field));
                                break;
                            }
                        }
                    }
                    if (field.tags) {
                        fieldData.tags = tags.getTagsSync(field.tags, row);
                    }
                    if (field.menu) {
                        if (field.getMenu && (!fieldData.noValue || field.menu.renderForEmptyCell)) {
                            fieldData.menu = field.getMenu(row, params);
                        }
                        else if (!fieldData.noValue) {
                            fieldData.menu = menus.getMenu(field.menu, row, params);
                        }
                    }
                    if (field.externalLinks) {
                        fieldData.externalLinks = angular.copy(field.externalLinks);
                        angular.forEach(fieldData.externalLinks, function (externalLink) {
                            if (externalLink.pinConditions) {
                                if (conditions.validateConditions(externalLink.pinConditions, row, params)) {
                                    externalLink.pinned = true;
                                    if (externalLink.pinnedTooltip) {
                                        externalLink.currentTooltip = externalLink.pinnedTooltip;
                                    }
                                }
                            }
                            if (externalLink.url) {
                                externalLink.href = utils.strings.parseValue(externalLink.url, row, params);
                            }
                            if (externalLink.tooltip) {
                                externalLink.tooltip = utils.strings.parseValue(externalLink.tooltip, row, params);
                            }
                        });
                    }
                    return fieldData;
                }
                function getRow(row, rowIndex) {
                    var rowData = { display: [] };
                    angular.forEach(tableConfig.fields, function (field, fieldIndex) {
                        var fieldData = getField(row, rowIndex, field);
                        if (field.spanRowsIfEqual) {
                            var fieldSpan = fieldSpans[String(fieldIndex)];
                            if (fieldSpan === undefined) {
                                fieldData.rowSpan = 1;
                                fieldSpans[String(fieldIndex)] = fieldData;
                                rowData.display.push(fieldData);
                            }
                            else {
                                if (fieldSpan.display === fieldData.display) {
                                    fieldSpan.rowSpan++;
                                }
                                else {
                                    fieldData.rowSpan = 1;
                                    fieldSpans[String(fieldIndex)] = fieldData;
                                    rowData.display.push(fieldData);
                                }
                            }
                        }
                        else {
                            rowData.display.push(fieldData);
                        }
                    });
                    return rowData;
                }
                function doGetData() {
                    if (tableConfig.dataField) {
                        if (angular.isArray(data)) {
                            angular.forEach(data, function (item, itemIndex) {
                                angular.forEach(item[tableConfig.dataField], function (row, rowIndex) {
                                    viewData.rows.push(getRow(row, itemIndex + rowIndex + 1));
                                });
                            });
                        }
                        else {
                            angular.forEach(data[tableConfig.dataField], function (item, itemIndex) {
                                viewData.rows.push(getRow(item, itemIndex + 1));
                            });
                        }
                    }
                    else {
                        angular.forEach(data, function (item, itemIndex) {
                            viewData.rows.push(getRow(item, itemIndex + 1));
                        });
                    }
                    return viewData;
                }
                return $q.all(loadPromises).then(doGetData);
            }
            var tableConfig = new TableWidgetConfig(view.settings);
            return tags.initTags().then(getTableData);
        }
        widgetViews.registerView("table", { dataParser: tableDataParser, validate: tableConfigValidate });
    }
    tableWidget.$inject = ["$q", "utils", "transforms", "icons", "conditions", "menus", "tags", "widgetViews",
        "TableWidgetConfig"];
    angular.module("TableWidget", ["Utils", "Transforms", "Styles", "Icons", "Conditions", "Widgets"]).run(tableWidget);
})();

(function () {
    'use strict';
    angular.module("TableWidget").controller("TableWidgetController", ["$scope", "utils", "state", "events", function ($scope, utils, state, events) {
            var currentSortField, sortDirection = 1, sortByField;
            $scope.sortTable = function (field) {
                if (!field.sortBy || field.sortDisabled) {
                    return;
                }
                if (field.sortBy === currentSortField) {
                    sortDirection *= -1;
                }
                else {
                    sortDirection = field.defaultSortDirection || 1;
                    currentSortField = field.sortBy;
                    if (sortByField) {
                        sortByField.sortDirection = 0;
                    }
                    sortByField = field;
                }
                field.sortDirection = sortDirection;
                $scope.$emit("tableSort", { direction: sortDirection, field: currentSortField });
                $scope.$emit("widgetDataSort", { orderBy: currentSortField, orderByDirection: sortDirection === -1 ? "DESC" : "ASC" });
                if ($scope.view.settings.sortParam) {
                    var sortParams = {};
                    sortParams[$scope.view.settings.sortParam] = currentSortField;
                    sortParams[$scope.view.settings.sortParam + "_dir"] = sortDirection;
                    state.setParams(sortParams);
                }
            };
            $scope.tableFieldClick = function ($event, fieldData, fieldIndex, row, rowDataIndex) {
                var field = fieldData.field, rowData = $scope.widget.rawData[rowDataIndex];
                $scope.$emit("tableClick", {
                    $event: $event,
                    field: field,
                    data: fieldData,
                    rawData: rowData[fieldData.field.id],
                    index: fieldIndex
                });
                if (field.events) {
                    if (field.events.click) {
                        $event.preventDefault();
                        if (field.events.click.action) {
                            events.triggerDashboardEvent(field.events.click, rowData, state.currentParams);
                        }
                        return false;
                    }
                }
            };
            $scope.initFilter = function (field) {
                if (!field.filter) {
                    return;
                }
                if (field.filter.defaultValue !== undefined) {
                    $scope.widget.params[field.filter.dashboardParam] = field.filter.value = field.filter.defaultValue;
                    field.filter.enabled = true;
                }
            };
            $scope.filterTable = function (field) {
                if (!field.filter) {
                    return;
                }
                $scope.widget.params[field.filter.dashboardParam] = field.filter.value;
                if (field.filter.value !== undefined) {
                    field.filter.enabled = true;
                }
                field.filter.lastAppliedValue = field.filter.value;
                if (!$scope.widget.query.options) {
                    $scope.widget.query.options = {};
                }
                $scope.widget.report.options.offset = 0;
                field.filter.enabled = field.filter.value !== field.filter.noFilterValue;
                $scope.runWidgetReport($scope.widget, true);
            };
            $scope.filterInputKeyDown = function (field, e) {
                if (e.keyCode === 13) {
                    $scope.filterTable(field);
                }
                else if (e.keyCode === 27) {
                    $scope.closeFilter(field);
                }
            };
            $scope.toggleFilter = function (field) {
                if (!!(field.filter.open = !field.filter.open)) {
                    $scope.currentFilter = field.filter;
                }
                else {
                    $scope.currentFilter = null;
                }
            };
            $scope.closeFilter = function (field) {
                field.filter.open = false;
                field.filter.value = field.filter.lastAppliedValue !== undefined ? field.filter.lastAppliedValue :
                    field.filter.defaultValue;
                $scope.currentFilter = null;
                field.filter.enabled = field.filter.value !== field.filter.noFilterValue;
            };
            $scope.resetFilterTable = function (field) {
                if (!field.filter) {
                    return;
                }
                field.filter.lastAppliedValue =
                    field.filter.value = $scope.widget.params[field.filter.dashboardParam] = field.filter.noFilterValue;
                field.filter.enabled = false;
                $scope.widget.report.options.offset = 0;
                $scope.runWidgetReport($scope.widget, true);
                field.filter.open = false;
                $scope.currentFilter = null;
            };
            $scope.pageTable = function () {
                $scope.$emit("pageData", {
                    page: $scope.tablePagingData.currentPage,
                    pageSize: $scope.tablePagingData.itemsPerPage,
                    offset: ($scope.tablePagingData.currentPage - 1) * $scope.tablePagingData.itemsPerPage
                });
            };
            function init() {
                angular.forEach($scope.view.settings.fields, function (field) {
                    if (field.sortBy && field.sortDirection) {
                        sortByField = field;
                        currentSortField = field.sortBy;
                        sortDirection = field.sortDirection;
                    }
                });
                if ($scope.view.settings.allowPaging) {
                    $scope.$watch("widget.totalResults", setPaginationData);
                    $scope.$watch("view.dataTotalResults", setPaginationData);
                }
            }
            init();
            function setPaginationData() {
                if (($scope.widget && $scope.widget.totalResults) || $scope.view.dataTotalResults) {
                    $scope.tablePagingData = {
                        itemsPerPage: $scope.view.settings.pageSize,
                        totalCount: $scope.widget.totalResults || $scope.view.dataTotalResults,
                        currentPage: $scope.view.settings.page || 1
                    };
                }
                if ($scope.view.settings.onDragStart) {
                    var onDragStart = $scope.view.settings.onDragStart;
                    $scope.view.settings.onDragStart = function (event, table) {
                        onDragStart(event, { data: $scope.view.data.rows[table.rowIndex] });
                    };
                }
            }
        }]);
}());

(function () {
    'use strict';
    angular.module('TableWidget')
        .directive('tableData', ["widgets", "$compile", function (widgets, $compile) {
            return {
                restrict: 'A',
                require: "?ngModel",
                link: function postLink(scope, element, attrs) {
                    var data, settings, table = d3.select(element[0]), classes = {
                        headerSortEnabled: "widget-table-sort-visible"
                    }, dataUnWatcher, settingsUnWatcher;
                    scope.$on("$destroy", function () {
                        element.find("*").addBack().off();
                        element.off();
                        dataUnWatcher();
                        settingsUnWatcher();
                        element.empty();
                    });
                    dataUnWatcher = scope.$watch(attrs.tableData, function (value) {
                        if (!value) {
                            element.empty();
                            element.off();
                        }
                        else {
                            data = value;
                            render();
                        }
                    });
                    settingsUnWatcher = scope.$watch(attrs.tableSettings, function (value) {
                        if (value) {
                            settings = value;
                            render();
                        }
                    });
                    function render() {
                        element.empty();
                        if (!data || !settings) {
                            return;
                        }
                        if (data.caption) {
                            element.append($("<caption></caption>").text(data.caption));
                        }
                        if (data.rows && data.rows.length) {
                            createHeader();
                            createBody();
                        }
                        $compile(element.contents())(scope);
                    }
                    function createHeader() {
                        var headerRow = table.append("thead").append("tr");
                        headerRow.selectAll("th").data(settings.fields).enter().append("th")
                            .attr("class", function (field) {
                            return field.sortBy ? 'widget-table-header-sortable' : '';
                        })
                            .attr("colspan", function (field) {
                            return field.headerColspan;
                        })
                            .style("width", function (field) {
                            return field.width;
                        });
                        headerRow.selectAll("th").each(function (field, fieldIndex) {
                            var th = d3.select(this);
                            if (field.sortBy) {
                                th.append("a")
                                    .attr("class", "widget-table-sort-link" +
                                    (field.sortDirection && !field.sortDisabled ? " widget-table-sort-enabled" : "") +
                                    (field.sortDisabled ? " sort-disabled" : ""))
                                    .attr("ng-click", "sortTable(view.settings.fields[" + fieldIndex +
                                    "], view, getWidgetParams(widget))")
                                    .text(field.name)
                                    .append(getFieldHeaderSort);
                            }
                            else {
                                if (field.headerIcon) {
                                    th.append("i")
                                        .attr("class", "table-widget-header-icon icon-" + field.headerIcon)
                                        .attr("title", field.name);
                                }
                                else if (field.name) {
                                    th.text(field.name);
                                }
                                if (field.tooltip) {
                                    th.append("i")
                                        .attr("class", "icon-question-sign tooltip-icon")
                                        .attr("title", field.tooltip);
                                }
                            }
                        });
                    }
                    function createBody() {
                        if (scope.widget.isLoading) {
                            return;
                        }
                        var rows = table.append("tbody").selectAll("tr").data(data.rows).enter().append("tr");
                        rows.each(function (rowData, rowIndex) {
                            var cells = d3.select(this).selectAll("td").data(function (row) {
                                return row.display;
                            }).enter().append("td")
                                .attr("class", function (d, i) {
                                try {
                                    return d.noValue ? 'widget-table-cell-no-value' :
                                        settings.fields[i].className || null;
                                }
                                catch (e) {
                                }
                            })
                                .attr("rowspan", function (d) {
                                return d.rowSpan || null;
                            })
                                .attr("colspan", function (d) {
                                return d.colspan;
                            });
                            cells.each(function (cellData, cellIndex) {
                                var cell = d3.select(this);
                                cell.append(cellData.link || cellData.field.events && cellData.field.events.click ?
                                    function (d) {
                                        return getCellLink(d, rowIndex, cellIndex);
                                    } : getCellText);
                                if (cellData.externalLinks) {
                                    cell.append(function (d) {
                                        return getCellExternalLinks(d, rowIndex, cellIndex);
                                    });
                                }
                                if (cellData.tags) {
                                    cell.append(function (d) {
                                        return getCellTags(d);
                                    });
                                }
                                if (cellData.menu && cellData.menu.items) {
                                    cell.append(function (d) {
                                        return getCellMenu(d, rowIndex, cellIndex);
                                    });
                                }
                            });
                        });
                    }
                    function getFieldHeaderSort(field) {
                        var sort = document.createElement("span"), caretUp = document.createElement("i"), caretDown = document.createElement("i");
                        sort.className = "widget-table-sort";
                        if (field.sortDirection) {
                            if (field.sortDirection === 1) {
                                sort.classList.add("widget-table-sort-up");
                            }
                            else if (field.sortDirection === -1) {
                                sort.classList.add("widget-table-sort-down");
                            }
                        }
                        caretUp.className = "fa fa-caret-up";
                        caretDown.className = "fa fa-caret-down";
                        if (!field.sortDirection) {
                            caretUp.classList.add(classes.headerSortEnabled);
                            caretDown.classList.add(classes.headerSortEnabled);
                        }
                        else if (field.sortDirection === 1) {
                            caretUp.classList.add(classes.headerSortEnabled);
                        }
                        else if (field.sortDirection === -1) {
                            caretDown.classList.add(classes.headerSortEnabled);
                        }
                        sort.appendChild(caretUp);
                        sort.appendChild(caretDown);
                        return sort;
                    }
                    function getCellIcon(d) {
                        var icon = d3.select(document.createElement("span"));
                        icon.style(d.icon.style)
                            .attr("title", d.icon.tooltip || d.tooltip);
                        icon.append("i").attr("class", "fa fa-" + d.icon.type);
                        return icon[0][0];
                    }
                    function getCellTags(field) {
                        var tags = d3.select(document.createElement("div"));
                        tags.attr("class", "widget-table-tags");
                        tags.selectAll(".tag").data(field.tags).enter().append("span")
                            .attr("class", function (d) {
                            return "tag " + (d.className || "widget-table-tag");
                        })
                            .attr("title", function (d) {
                            return d.name;
                        })
                            .text(function (d) {
                            return d.text;
                        });
                        return tags[0][0];
                    }
                    function getCellText(d) {
                        var text = document.createElement("span");
                        if (d.tooltip) {
                            text.setAttribute("title", d.tooltip);
                        }
                        if (d.icon && d.icon.type) {
                            text.appendChild(getCellIcon(d));
                        }
                        text.innerHTML = text.innerHTML + d.display;
                        return text;
                    }
                    function getCellLink(d, rowIndex, cellIndex) {
                        var link = document.createElement("a");
                        if (d.style && d.style.color) {
                            link.style.color = d.style.color;
                        }
                        if (settings.dragContents) {
                            link.classList.add("draggable");
                        }
                        if (d.field.events && d.field.events.click) {
                            link.setAttribute("ng-click", "tableFieldClick($event, view.data.rows[" + rowIndex + "].display[" + cellIndex +
                                "], " + cellIndex + ", view.data.rows[" + rowIndex + "], " + rowIndex + ")");
                        }
                        else {
                            link.setAttribute("href", d.link);
                        }
                        if (d.tooltip) {
                            link.setAttribute("title", d.tooltip);
                        }
                        if (d.icon && d.icon.type) {
                            link.appendChild(getCellIcon(d));
                        }
                        var linkSpan = document.createElement("span");
                        linkSpan.innerHTML = d.display;
                        link.appendChild(linkSpan);
                        return link;
                    }
                    function getCellExternalLinks(d, rowIndex, cellIndex) {
                        var externalLinksContainer = d3.select(document.createElement("span")), externalLinks = externalLinksContainer.selectAll("a").data(d.externalLinks).enter()
                            .append("a")
                            .attr("href", function (externalLink) {
                            return externalLink.href || externalLink.link;
                        })
                            .attr("ng-click", function (externalLink, i) {
                            return externalLink.href || externalLink.link ? null :
                                "externalLinkClick($event, view.data.rows[" + rowIndex + "].display[" + cellIndex +
                                    "].externalLinks[" + i + "], widget.rawData[" + rowIndex + "])";
                        })
                            .attr("class", function (externalLink) {
                            return "table-external-link" +
                                (externalLink.pinned ? " table-external-link-pinned" : "");
                        })
                            .attr("title", function (externalLink) {
                            return externalLink.currentTooltip || externalLink.tooltip;
                        });
                        externalLinks.each(function (d) {
                            var linkElement = d3.select(this);
                            if (d.icon) {
                                linkElement.append("i")
                                    .attr("class", "icon-" + d.icon);
                            }
                            else if (d.text) {
                                linkElement.append("span").text(d.text);
                            }
                        });
                        return externalLinksContainer[0][0];
                    }
                    function getCellMenu(d, rowIndex) {
                        var menu = $('<menu class="dropdown dropdown-directive"><a class="clickable dropdown-toggle ' +
                            'dropdown-delegate-toggle hidden-phone"><b class="caret"></a></menu>')[0];
                        menu.menu = d.menu;
                        menu.data = scope.widget.rawData[rowIndex];
                        return menu;
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    function TableWidgetConfigFactory() {
        function TableConfig(config) {
            this.validate(config);
            this.fields = config.fields.map(function (field) {
                return new TableFieldConfig(field);
            });
            this.caption = config.caption;
            /**
             * dataField is used for arrays within a data item, to render all the inner rows.
             */
            this.dataField = config.dataField;
            this.sortParam = config.sortParam;
        }
        TableConfig.prototype.validate = function (config) {
            var ERROR_PREFIX = "Can't create TableConfig, ";
            if (!config) {
                throw new Error(ERROR_PREFIX + "missing the config object.");
            }
            if (Object(config) !== config) {
                throw new TypeError(ERROR_PREFIX + "config isn't an object.");
            }
            if (!config.fields) {
                throw new Error(ERROR_PREFIX + "missing the fields property.");
            }
            if (config.fields.constructor !== Array) {
                throw new TypeError(ERROR_PREFIX + "fields must be an array.");
            }
            if (config.caption && typeof (config.caption) !== "string") {
                throw new TypeError(ERROR_PREFIX + "invalid caption field. Expected string but got " +
                    typeof (config.caption));
            }
            if (config.dataField && typeof (config.dataField) !== "string") {
                throw new TypeError(ERROR_PREFIX + "invalid dataField field. Expected string but got " +
                    typeof (config.dataField));
            }
        };
        function TableFieldConfig(config) {
            this.validate(config);
            this.name = config.name;
            this.field = config.field;
            this.value = config.value;
            this.link = config.link;
            this.noValueDisplay = config.noValueDisplay;
            this.spanRowsIfEqual = config.spanRowsIfEqual;
            this.menu = config.menu;
            this.tags = config.tags; // TODO: Create a tags class and use it here.
            this.icon = config.icon; // TODO: Create an Icon class and use it here.
            this.valueTooltip = config.valueTooltip;
            this.map = config.map; // TODO: validate this
            this.renderHeader = config.renderHeader !== false;
            this.sortBy = config.sortBy;
            this.sortDirection = config.sortDirection;
            this.externalLinks = config.externalLinks;
        }
        TableFieldConfig.prototype.validate = function (config) {
            var ERROR_PREFIX = "Invalid field for table, ";
            if (!config) {
                throw new Error(ERROR_PREFIX + "no configuration specified.");
            }
            if (Object(config) !== config) {
                throw new TypeError(ERROR_PREFIX + "config isn't an object.");
            }
            if (!config.name || typeof (config.name) !== "string") {
                throw new Error(ERROR_PREFIX + "expected a string field 'name' but got " + String(config.name));
            }
            if (!config.field && !config.value) {
                throw new Error(ERROR_PREFIX + "missing a 'field' or 'value' property.");
            }
            if (config.field && typeof (config.field) !== "string") {
                throw new TypeError(ERROR_PREFIX + "expected a string 'field' property, but got " +
                    typeof (config.field));
            }
            if (config.value && typeof (config.value) !== "string") {
                throw new TypeError(ERROR_PREFIX + "expected a string 'value' property, but got " +
                    typeof (config.value));
            }
            if (config.link && typeof (config.link) !== "string") {
                throw new TypeError(ERROR_PREFIX + "expected a string 'link' property, but got " + typeof (config.link));
            }
            if (config.noValueDisplay && typeof (config.noValueDisplay) !== "string") {
                throw new TypeError(ERROR_PREFIX + "expected a string 'noValueDisplay' property, but got " +
                    typeof (config.noValueDisplay));
            }
            if (config.spanRowsIfEqual && typeof (config.spanRowsIfEqual) !== "boolean") {
                throw new TypeError(ERROR_PREFIX + "expected a boolean 'spanRowsIfEqual' property, but got " +
                    typeof (config.spanRowsIfEqual));
            }
        };
        return TableConfig;
    }
    angular.module("TableWidget").factory("TableWidgetConfig", TableWidgetConfigFactory);
})();

(function () {
    'use strict';
    angular.module("BubblesWidget", ["Utils", "Chart", "Widgets"]).run(["utils", "widgetViews",
        function (utils, widgetViews) {
            /**
             *
             * @param {{settings: {noValueLabel, childIdField}}} view
             * @param data
             * @param params
             * @returns {{children: Array}}
             */
            function bubblesDataParser(view, data, params) {
                var parsedData = [], itemsIndex = {}, membersIndex = {}, membersCount = 0;
                angular.forEach(data, function (item) {
                    var itemName = utils.strings.parseValue(view.settings.label, item, params) ||
                        view.settings.noValueLabel || "N/A", indexedItem = itemsIndex[itemName];
                    if (!indexedItem) {
                        indexedItem = itemsIndex[itemName] = { name: itemName, membersIndex: {}, members: [], value: 0 };
                        if (view.settings.highlight && indexedItem.name === view.settings.highlight) {
                            indexedItem.highlight = true;
                        }
                    }
                    if (view.settings.childIdField) {
                        var childId = item[view.settings.childIdField];
                        if (!indexedItem.membersIndex[childId]) {
                            indexedItem.membersIndex[childId] = item;
                            if (!membersIndex[childId]) {
                                membersIndex[childId] = true;
                                membersCount++;
                            }
                        }
                    }
                    else {
                        membersCount += view.settings.value ? item[view.settings.value] : 0;
                    }
                    indexedItem.value += view.settings.value ? item[view.settings.value] : 1;
                });
                var item;
                for (var itemName in itemsIndex) {
                    if (itemsIndex.hasOwnProperty(itemName)) {
                        item = itemsIndex[itemName];
                        for (var childId in item.membersIndex) {
                            if (item.membersIndex.hasOwnProperty(childId)) {
                                item.members.push(item.membersIndex[childId]);
                            }
                        }
                        delete item.membersIndex;
                        parsedData.push(itemsIndex[itemName]);
                        item._percent = 100 * (item.members.length || item.value) / membersCount;
                    }
                }
                return { children: parsedData };
            }
            widgetViews.registerView("bubbles", { dataParser: bubblesDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('BubblesWidget')
        .directive('bubbles', ["Chart", "utils", function (Chart, utils) {
            return {
                template: '<div class="widget-bubbles"></div>',
                restrict: 'E',
                require: "?ngModel",
                replace: true,
                link: function postLink(scope, element, attrs) {
                    /* jshint validthis: true */
                    function draw() {
                        var self = this, svg = this.dataSvg, diameter = Math.min(this.dataWidth, this.dataHeight);
                        this.svg.attr("width", diameter);
                        var bubble = d3.layout.pack()
                            .sort(null)
                            .size([diameter - this.options.margins.left - this.options.margins.right,
                            diameter - this.options.margins.top - this.options.margins.bottom])
                            .padding(1.5);
                        this.elements.nodes = svg.selectAll(".node")
                            .data(bubble.nodes(self.data).filter(function (d) {
                            return !d.children;
                        }))
                            .enter()
                            .append("g")
                            .attr("class", "node")
                            .attr("data-tooltip", "")
                            .attr("transform", function (d) {
                            return "translate(" + d.x + "," + d.y + ")";
                        })
                            .attr("data-selectable", this.settings.onSelect ? "" : null);
                        this.elements.circles = this.elements.nodes.append("circle")
                            .attr("r", function (d) {
                            return d.r;
                        });
                        this.elements.circles = this.elements.nodes.append("text")
                            .attr("dy", ".3em")
                            .style("text-anchor", "middle")
                            .attr("font-family", "Roboto, sans-serif")
                            .attr("font-size", "14px")
                            .attr("font-weight", "bold")
                            .text(function (d) {
                            return d.name.substring(0, d.r / 4.5);
                        });
                    }
                    var defaultOptions = {
                        circleStrokeWidth: 2
                    }, graph = new Chart(defaultOptions, draw);
                    element.css("height", "100%");
                    graph.getTooltipText = function (d) {
                        return graph.settings.tooltipText ? utils.strings.parseValue(graph.settings.tooltipText, d) :
                            d.data[graph.settings.label] + ": " + d.data[graph.settings.value] + " (" +
                                Math.round(d.data._percent) + "%)";
                    };
                    graph.init(scope, element, attrs);
                    scope.$on("$destroy", function () {
                        element.off();
                        element.empty();
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("HeatMapWidget", ["Utils", "Colors", "Widgets"]).run(["utils", "widgetViews",
        function (utils, widgetViews) {
            /**
             * Return the items of the legend from the widget settings
             * @param view
             * @returns {*|Array}
             */
            function getLegendItems(view) {
                return view.settings.legend || [];
            }
            function heatMapDataParser(view, data, params) {
                var allColumnsArr = getColumnsObj(view, data, params);
                verifyThatAllHoursExists(view, allColumnsArr, data);
                var rowsArr = getRowsArr(view, data, params, allColumnsArr);
                return {
                    columns: allColumnsArr,
                    rows: rowsArr,
                    columnsOnePercentValue: getColumnsPercentValue(allColumnsArr, view.settings.behavior.columns.percentCalculationMethod),
                    legend: {
                        items: getLegendItems(view)
                    }
                };
            }
            /**
             * This function creates an array of columns by the data that being retrieved from the DB
             * This array is being used for building the columns, and a copy of the array is being
             * created in each of the row object
             * @param view
             * @param data
             * @param params
             * @returns {Array}
             */
            function getColumnsObj(view, data, params) {
                var columnsObj = {}, arrToReturn = [];
                for (var i = 0; i < data.length; i++) {
                    var item = data[i];
                    var columnName = utils.strings.parseValue(view.settings.column, item, params);
                    if (!columnsObj[columnName]) {
                        // we do this only to check that we are not repeating ourselves
                        columnsObj[columnName] = { name: columnName || "Unknown", value: 0, valueSum: 0, count: 0 };
                        arrToReturn.push(columnsObj[columnName]);
                    }
                }
                return arrToReturn;
            }
            /**
             * This function creates the array of rows by using the data that being retrieved from the DB
             * @param view
             * @param data
             * @param params
             * @param allColumnsArr
             * @returns {Array}
             */
            function getRowsArr(view, data, params, allColumnsArr) {
                var rowsArr = [], rowsObj = {};
                angular.forEach(data, function (item) {
                    if (typeof view.settings.row === "object") {
                        // we don't specifically declare the row labels, every object in the json object which is not
                        // label is a row
                        angular.forEach(item, function (value, key) {
                            if (view.settings.row[key]) {
                                var rowItem = {
                                    key: key,
                                    name: view.settings.row[key],
                                    count: 0,
                                    columns: angular.copy(allColumnsArr)
                                };
                                var columnName = utils.strings.parseValue(view.settings.column, item, params);
                                if (!rowsObj[rowItem.name]) {
                                    rowsObj[rowItem.name] = true;
                                    setColumnsValue(view, rowItem, columnName, item, allColumnsArr);
                                    rowsArr.push(rowItem);
                                }
                                else {
                                    var rowToChange = rowsArr.filter(function (row) {
                                        return row.name === rowItem.name;
                                    })[0];
                                    setColumnsValue(view, rowToChange, columnName, item, allColumnsArr);
                                }
                            }
                        });
                    }
                    else {
                        //This mean we specifically declare the value of the rows
                        // like this feature was designed in the first time
                        // we building the row item and adding a copy of the "all columns object" to it
                        var rowItem = {
                            name: utils.strings.parseValue(view.settings.row, item, params),
                            count: 0,
                            columns: angular.copy(allColumnsArr)
                        };
                        // we use the current column name  and send it to the setColumnsValue()
                        var columnName = utils.strings.parseValue(view.settings.column, item, params);
                        if (!rowsObj[rowItem.name]) {
                            rowsObj[rowItem.name] = true;
                            setColumnsValue(view, rowItem, columnName, item, allColumnsArr);
                            rowsArr.push(rowItem);
                        }
                        else {
                            var rowToChange = rowsArr.filter(function (row) {
                                return row.name === rowItem.name;
                            })[0];
                            setColumnsValue(view, rowToChange, columnName, item, allColumnsArr);
                        }
                    }
                });
                return rowsArr;
            }
            /**
             * This function used the row and mark the values of the heat in each row.columns[n]
             * when there is no value it will mark 1, the idea is that the colors spectrum will be
             * from 0-1.
             * @param view
             * @param rowItem
             * @param columnName
             * @param dataItem
             * @param allColumnsArr
             */
            function setColumnsValue(view, rowItem, columnName, dataItem, allColumnsArr) {
                rowItem.columns.map(function (column) {
                    if (column.name === columnName) {
                        var value;
                        if (typeof view.settings.row === "object") {
                            value = dataItem[rowItem.key];
                        }
                        else {
                            value = utils.strings.parseValue(view.settings.value, dataItem);
                        }
                        rowItem.count++;
                        if (value !== "") {
                            column.value = Number(value);
                        }
                        else {
                            column.value = 1;
                        }
                        if (column.value > 0) {
                            // we updating the value in the main column object
                            allColumnsArr.map(function (c) {
                                if (c.name === columnName) {
                                    c.count++;
                                    c.valueSum += column.value;
                                }
                            });
                        }
                    }
                    column.rowName = rowItem.name;
                });
            }
            /**
             * When defined at the settings, we calculate the percent of each column and
             * return it's value
             * @param allColumnsArr
             * @param percentCalculationMethod
             * @returns {number}
             */
            function getColumnsPercentValue(allColumnsArr, percentCalculationMethod) {
                var sum = 0;
                angular.forEach(allColumnsArr, function (c) {
                    sum += c[percentCalculationMethod];
                });
                return Math.round(100 / sum);
            }
            /**
             * This function related to vpn hours display only,
             * It basically add columns of hours where there are non to make the board (heat map) look like
             * a 24 hours board instead of dependency over the data.
             * @param view
             * @param columns
             */
            function verifyThatAllHoursExists(view, columns) {
                if (view.settings.showHours === true) {
                    var hours = {
                        "00:00": 0, "01:00": 0, "02:00": 0, "03:00": 0, "04:00": 0, "05:00": 0,
                        "06:00": 0, "07:00": 0, "08:00": 0, "09:00": 0, "10:00": 0, "11:00": 0,
                        "12:00": 0, "13:00": 0, "14:00": 0, "15:00": 0, "16:00": 0, "17:00": 0,
                        "18:00": 0, "19:00": 0, "20:00": 0, "21:00": 0, "22:00": 0, "23:00": 0
                    };
                    angular.forEach(columns, function (c) {
                        hours[c.name] = 1;
                    });
                    var count = 0;
                    angular.forEach(hours, function (value, key) {
                        if (value === 0) {
                            var column = {
                                count: 0,
                                name: key,
                                value: 0,
                                valueSum: 0
                            };
                            columns.splice(count, 0, column);
                        }
                        count++;
                    });
                }
            }
            widgetViews.registerView("heatMap", { dataParser: heatMapDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('HeatMapWidget')
        .directive('heatMap', ["utils", "colors", "Chart", function (utils, colors, Chart) {
            return {
                template: '<div class="widget-heat-map chart"></div>',
                restrict: 'E',
                require: "?ngModel",
                replace: true,
                link: function postLink(scope, element, attrs, ngModel) {
                    /**
                     * This function draw the heat map table
                     */
                    function draw() {
                        //Start scrolling handling
                        /**
                         * Add scrolling SVG item
                         * graphHeight - The  height of the graph - include the labels and all cells
                         */
                        function setScrolling(graphHeight) {
                            //Add rect item to SVG for scrolling, and set the location to be marings.top
                            //and other parameters
                            graph.scroll = { position: 0, scrollBarPosition: graph.options.margins.top };
                            graph.scroll.container = graph.svg.append("svg:g")
                                .attr("class", "scrollbar scrollbar-v")
                                .attr("transform", "translate(" + (element.width() - graph.options.margins.right) + ", " +
                                graph.options.margins.top + ")");
                            graph.scroll.scrollBar = graph.scroll.container.append("rect")
                                .attr("class", "scrollbar")
                                .attr("x", "-20px")
                                .attr("y", graph.options.margins.top)
                                .attr("rx", "4px")
                                .attr("width", graph.options.scrollBarWidth = 8)
                                .attr("height", graph.scroll.scrollBarHeight = 60);
                            //Event listener to dragging the rect item which represent the scroller
                            var scrollDrag = d3.behavior.drag().on("drag", function () {
                                scrollDragMove(d3.event.dy);
                            });
                            //Event listener of scrolling with mouse wheel
                            graph.svg.on("mousewheel", function () {
                                var deltaY = Math.ceil(d3.event.wheelDelta / -80);
                                d3.event.preventDefault();
                                graph.scroll.scrollBar.attr("y", graph.scroll.scrollBarPosition += deltaY);
                                scrollDragMove(deltaY);
                            });
                            graph.scroll.scrollBar.call(scrollDrag);
                            //The scroll length is function of the ration and minScrollBarPosition
                            //Scroll bar possition should be equals to the chart height
                            graph.scroll.ratio = -0.66;
                            graph.scroll.minScrollBarPosition =
                                // (graph.height  - graph.scroll.scrollBarHeight - graph.options.margins.top -
                                // graph.options.margins.bottom/2 )*10;
                                graphHeight - graph.scroll.scrollBarHeight - graph.options.margins.bottom;
                            graph.scroll.scrollBarPosition = graph.options.margins.top;
                            //This function move the location of scroller rect and change the visible part of the
                            // SVG component
                            function scrollDragMove(deltaY) {
                                graph.scroll.scrollBarPosition = Math.max(0, Math.min(graph.scroll.minScrollBarPosition, graph.scroll.scrollBarPosition + deltaY));
                                graph.scroll.scrollBar.attr("y", graph.scroll.scrollBarPosition);
                                graph.scroll.position = graph.scroll.scrollBarPosition * graph.scroll.ratio;
                                rootScrollableContainer.attr("transform", "translate(0," + graph.scroll.position + ")");
                            }
                        }
                        function removeScrolling() {
                            //Currently don't do nothing
                        }
                        element.css("width", "100%");
                        element.css("height", "100%");
                        //Set max page size
                        //The internal height of window with 'px'
                        var maxHeight = element.closest('.widget-view-wrap').css('height');
                        //Convert to number
                        maxHeight = Number(maxHeight.substring(0, maxHeight.length - 2));
                        /* jshint validthis: true */
                        if (this.height < 100) {
                            element.empty();
                            element.off();
                            graph.init(scope, element, attrs);
                        }
                        else {
                            var self = this, maxCellSize = element.width() / 35, data = angular.copy(graph.data), colorSettings = scope.view.settings.behavior.color || { domain: getValuesExtent(data) }, maxLabelSize = 25, gapBetweenCells = 1, animationDuration = 1500, columnLabelPosition = scope.view.settings.behavior.columns.position || "top";
                            var margin = getMargin(data, self, maxLabelSize, gapBetweenCells, columnLabelPosition);
                            self.scaleX = d3.scale.linear()
                                .domain([0, data.columns.length])
                                .range([0, self.width - (margin.right + margin.left)]);
                            var cellSize = self.scaleX(1);
                            cellSize = (cellSize < maxCellSize) ? cellSize : maxCellSize;
                            var fontScale = d3.scale.linear()
                                .domain([0, maxCellSize])
                                .range([0.9, 0.9]);
                            self.heatMapProperties = {
                                margin: margin,
                                cellSize: cellSize,
                                colorScale: colors.getScale(colorSettings),
                                fontSize: fontScale(cellSize),
                                gapBeweenCells: gapBetweenCells,
                                columnLabelPosition: columnLabelPosition,
                                animationDuration: animationDuration
                            };
                            var realGraphHeight = graph.heatMapProperties.margin.top +
                                graph.heatMapProperties.margin.bottom + (cellSize * (graph.data.rows.length + 1));
                            //End scrolling handling
                            graph.data = createJsonArr();
                            buildHeatMapForTheFirstTime(graph.data);
                            var newHeight = Math.min(maxHeight, realGraphHeight);
                            //If the graph size + the mergin bigger then maxHeight (the white space) we should add
                            // scrolling
                            var graphHeight = (cellSize * (graph.data.rows.length + 1)) + maxLabelSize +
                                graph.heatMapProperties.margin.top;
                            if (graphHeight > maxHeight) {
                                setScrolling(maxHeight - graph.options.margins.bottom);
                            }
                            else {
                                removeScrolling();
                            }
                            element.css("height", newHeight + "px");
                            $(element).parents(".widget-view-container").css("height", "inherit");
                            var legendX = calculateCenter() +
                                (cellSize + graph.heatMapProperties.gapBeweenCells) * (graph.data.columns.length) +
                                graph.heatMapProperties.margin.left / 2;
                            var legendHeight = (cellSize + graph.heatMapProperties.gapBeweenCells) *
                                graph.data.rows.length;
                            legendHeight = (legendHeight < 200) ? legendHeight : 150;
                            addLegend(legendX, graph.heatMapProperties.margin.top, 10, legendHeight, getValuesExtent(data), scope.view.settings.legend, scope.view.settings.behavior.color || "range");
                        }
                    }
                    var defaultOptions = {
                        direction: "vertical"
                    }, graph = new Chart(defaultOptions, draw);
                    element.css("height", "100%");
                    element.css("width", "100%");
                    scope.$watch(element, function () {
                        graph.init(scope, element, attrs);
                    });
                    element.parents(".dataView").addClass("heatMapView");
                    var lastItemNameClicked;
                    var rootScrollableContainer;
                    /**
                     * This function sort the rows of the heatmap when the user click on the head of a column
                     * @param column
                     */
                    function sortByColumn(column) {
                        if (column.name !== lastItemNameClicked) {
                            lastItemNameClicked = column.name;
                            var myData = d3.values(angular.copy(graph.data));
                            myData[1].sort(function (a, b) {
                                var aVal = a.columns.filter(function (col) {
                                    if (col.name === column.name) {
                                        col.lastSortedItem = true;
                                    }
                                    return col.name === column.name;
                                });
                                var bVal = b.columns.filter(function (col) {
                                    return col.name === column.name;
                                });
                                if (aVal[0].value < bVal[0].value) {
                                    return 1;
                                }
                                else {
                                    return -1;
                                }
                            });
                            graph.data.rows = (graph.heatMapProperties.columnLabelPosition === "top") ? myData[1] :
                                myData[1].reverse();
                            animateHeatmap();
                        }
                    }
                    /**
                     * This function sorts the columns of the heatmap when the user click on a row
                     * It basically sorts all columns objects that belong to the rows so there will be similarity
                     * Process:
                     * 1. sort the columns of the row object that was clicked
                     * 2. according to the this creates new array of columns object to each one of the rows
                     * 3. sort the rows by similarity to create the best heatmap that the user can learn something from
                     *
                     * @param row
                     */
                    function sortByRow(row) {
                        if (row.name !== lastItemNameClicked) {
                            lastItemNameClicked = row.name;
                            var myData = d3.values(angular.copy(graph.data)), 
                            //first we are sorting the selected row;
                            selectedRowArr = row.columns.sort(function (a, b) {
                                if (a.value < b.value) {
                                    return 1;
                                }
                                else {
                                    return -1;
                                }
                                //return d3.descending(b.value);
                            });
                            // then we create rowObjects for each existing row and we sort it
                            angular.forEach(myData[1], function (r) {
                                var newArr = [];
                                angular.forEach(selectedRowArr, function (sra) {
                                    var myColumn = r.columns.filter(function (obj) {
                                        return obj.name === sra.name;
                                    })[0];
                                    var newRow = {
                                        name: sra.name,
                                        value: myColumn.value,
                                        id: myColumn.id,
                                        x: myColumn.x,
                                        y: myColumn.y
                                    };
                                    newArr.push(newRow);
                                });
                                r.columns = angular.copy(newArr);
                            });
                            row.lastSortedItem = true; // adding true will show the selected row
                            row.columns = setColumnsValue(row.columns);
                            graph.data.columns = angular.copy(row.columns);
                            graph.data.rows = myData[1];
                            animateHeatmap();
                        }
                    }
                    /**
                     * Run over all columns of a row in order to return the value
                     * @param columns
                     * @returns {*}
                     */
                    function setColumnsValue(columns) {
                        angular.forEach(graph.data.columns, function (col) {
                            columns.map(function (c) {
                                if (c.name === col.name) {
                                    c.valueSum = col.valueSum;
                                    c.count = col.count;
                                }
                            });
                        });
                        return columns;
                    }
                    graph.getTooltipText = function (d, attrValue) {
                        return attrValue ? utils.strings.parseValue(attrValue, d) : "";
                    };
                    /**
                     * This function related to the colors' gradient of the heat map.
                     * since we should define the gradient according to the lowest and highest minimum value
                     * we check the poles of the data and send it to the ColorService
                     * @param data
                     * @returns {*[]}
                     */
                    function getValuesExtent(data) {
                        var myExt = [null, 0];
                        angular.forEach(data.rows, function (d) {
                            var ext = d3.extent(d.columns, function (e) {
                                return e.value;
                            });
                            myExt[0] = Math.min(ext[0], myExt[0] || ext[0]);
                            myExt[1] = Math.max(ext[1], myExt[1]);
                        });
                        // in case that the min and max are equals keep the min lower
                        if (myExt[0] === myExt[1]) {
                            myExt[0] = 0;
                        }
                        return myExt;
                    }
                    function calculateCenter() {
                        var mapWidth = (graph.heatMapProperties.cellSize + graph.heatMapProperties.gapBeweenCells) *
                            graph.data.columns.length + graph.heatMapProperties.margin.left, left = (graph.width - mapWidth) / 2;
                        return (left < graph.heatMapProperties.margin.left) ? graph.heatMapProperties.margin.left :
                            left;
                    }
                    function buildHeatMapForTheFirstTime(data) {
                        var container = graph.dataSvg.append("g")
                            .attr("transform", "translate(" + calculateCenter() + "," + graph.heatMapProperties.margin.top + ")");
                        //This is the area that we wish to scroll, if scroll required
                        rootScrollableContainer = container.append("g");
                        rootScrollableContainer.append("g")
                            .selectAll(".rowLabel")
                            .data(data.rows)
                            .enter()
                            .append("text")
                            .text(function (d) {
                            return d.name;
                        })
                            .style("font-size", graph.heatMapProperties.fontSize + "em")
                            .attr("x", function (d) {
                            return d.x;
                        })
                            .attr("y", function (d) {
                            return d.y;
                        })
                            .style("text-anchor", "end")
                            .attr("data-tooltip", scope.view.settings.behavior.rows.tooltip)
                            .attr("transform", function () {
                            return " translate(-10,0)";
                        })
                            .attr("rowIndex", function (d, i) {
                            return i;
                        })
                            .attr("class", function (d) {
                            return "rowLabel mono " + d.headerId;
                        })
                            .on("mouseover", function () {
                            d3.select(this).classed("text-hover", true);
                        })
                            .on("mouseout", function () {
                            d3.select(this).classed("text-hover", false);
                        })
                            .on("click", function (row) {
                            if (scope.view.settings.behavior.rows.isSortingEnabled === null ||
                                scope.view.settings.behavior.rows.isSortingEnabled !== false) {
                                sortByRow(row);
                            }
                        });
                        rootScrollableContainer.append("g")
                            .selectAll(".colLabel")
                            .data(data.columns)
                            .enter()
                            .append("text")
                            .text(function (d) {
                            return d.name;
                        })
                            .attr("x", 0)
                            .attr("y", function (d) {
                            return d.x;
                        })
                            .style("font-size", graph.heatMapProperties.fontSize + "em")
                            .style("text-anchor", "left")
                            .attr("transform", function (d) {
                            return " translate(0," + d.translateY + ") rotate (-90)";
                        })
                            .attr("text-anchor", function (d) {
                            return d.textAnchor;
                        })
                            .attr("data-tooltip", scope.view.settings.behavior.columns.tooltip)
                            .attr("class", function (d, i) {
                            return "colLabel mono c" + i + " " + d.headerId;
                        })
                            .on("click", function (column) {
                            sortByColumn(column);
                        })
                            .on("mouseover", function () {
                            d3.select(this).classed("text-hover", true);
                        })
                            .on("mouseout", function () {
                            d3.select(this).classed("text-hover", false);
                        });
                        var row = rootScrollableContainer.append("g").attr("class", "g3")
                            .selectAll(".cellsGroup")
                            .data(data.rows)
                            .enter()
                            .append("g")
                            .attr("class", "row")
                            .attr("index", function (d, i) {
                            return i.toString();
                        });
                        row
                            .selectAll("rect")
                            .data(function (d) {
                            return d.columns;
                        })
                            .enter()
                            .append("rect")
                            .attr("x", function (d) {
                            return d.x;
                        })
                            .attr("y", function (d) {
                            return d.y;
                        })
                            .attr("rowIndedx", function () {
                            return this.parentNode.attributes.index.value;
                        })
                            .attr("class", function (d) {
                            return d.id;
                        })
                            .attr("width", graph.heatMapProperties.cellSize)
                            .attr("height", graph.heatMapProperties.cellSize)
                            .attr("data-tooltip", function (d) {
                            if (d.value > 0) {
                                return scope.view.settings.behavior.cell.tooltip;
                            }
                        })
                            .style("fill", function (d) {
                            return graph.heatMapProperties.colorScale(d.value);
                        })
                            .on("mouseover", function (d) {
                            //highlight text
                            d3.select(this).classed("cell-hover", true);
                            var _this = this;
                            d3.selectAll(".rowLabel").classed("text-highlight", function () {
                                return this.attributes.rowIndex.value === _this.parentNode.attributes.index.value;
                            });
                            d3.selectAll(".colLabel").classed("text-highlight", function (c) {
                                return c.name === (d.name);
                            });
                        })
                            .on("mouseout", function () {
                            d3.select(this).classed("cell-hover", false);
                            d3.selectAll(".rowLabel").classed("text-highlight", false);
                            d3.selectAll(".colLabel").classed("text-highlight", false);
                        });
                    }
                    function createJsonArr() {
                        var myData = angular.copy(graph.data);
                        angular.forEach(myData.columns, function (column, i) {
                            if (!column.headerId) {
                                column.headerId = "header-" + i;
                            }
                            delete column.x;
                            delete column.y;
                            delete column.translateY;
                            column.translateY = (graph.heatMapProperties.columnLabelPosition === "top") ? -10 :
                                (graph.heatMapProperties.cellSize + graph.heatMapProperties.gapBeweenCells) *
                                    graph.data.rows.length + 10;
                            column.textAnchor =
                                (graph.heatMapProperties.columnLabelPosition === "top") ? "start" : "end";
                            column.y = 0;
                            column.x = (graph.heatMapProperties.cellSize + graph.heatMapProperties.gapBeweenCells) * i;
                            //fix to middle
                            column.x += graph.heatMapProperties.cellSize / 1.8;
                        });
                        angular.forEach(myData.rows, function (row, i) {
                            row.x = 0;
                            row.y = graph.heatMapProperties.cellSize * i + (i * graph.heatMapProperties.gapBeweenCells);
                            //fixiToMiddle
                            row.y += graph.heatMapProperties.cellSize / 1.5;
                            if (!row.headerId) {
                                row.headerId = "row-" + i;
                            }
                            angular.forEach(row.columns, function (column, j) {
                                if (!column.id) {
                                    column.id = "heatmap" + i + "-" + j;
                                    column.headerId = "header-" + j;
                                }
                                column.x =
                                    graph.heatMapProperties.cellSize * j + (j * graph.heatMapProperties.gapBeweenCells);
                                column.y =
                                    graph.heatMapProperties.cellSize * i + (i * graph.heatMapProperties.gapBeweenCells);
                            });
                        });
                        return myData;
                    }
                    function animateHeatmap() {
                        var myData = createJsonArr();
                        var t = graph.dataSvg.transition().duration(graph.heatMapProperties.animationDuration);
                        angular.forEach(myData.columns, function (column) {
                            t.selectAll("." + column.headerId)
                                .attr("y", function () {
                                return column.x;
                            })
                                .attr("x", 0);
                        });
                        angular.forEach(myData.rows, function (row) {
                            angular.forEach(row.columns, function (column) {
                                t.selectAll("." + column.id)
                                    .attr("y", function () {
                                    return column.y;
                                })
                                    .attr("x", function () {
                                    return column.x;
                                });
                            });
                            t.selectAll("." + row.headerId)
                                .attr("y", function () {
                                return row.y;
                            })
                                .attr("x", 0);
                        });
                    }
                    function getMargin(data, self, maxLebelSize, gapBetweenCels, columnLabelPosition) {
                        var rowsMaxLabelSize = 0;
                        var columnsMaxLabelSize = 0;
                        var margin = { top: 0, right: 0, bottom: 100, left: 0 };
                        angular.forEach(data.rows, function (row) {
                            if (!rowsMaxLabelSize) {
                                rowsMaxLabelSize = row.name.length;
                            }
                            else {
                                rowsMaxLabelSize = Math.max(row.name.length, rowsMaxLabelSize);
                            }
                        });
                        angular.forEach(data.columns, function (column) {
                            if (!columnsMaxLabelSize) {
                                columnsMaxLabelSize = column.name.length;
                            }
                            else {
                                columnsMaxLabelSize = Math.max(column.name.length, columnsMaxLabelSize);
                            }
                        });
                        columnsMaxLabelSize = (columnsMaxLabelSize > maxLebelSize) ? maxLebelSize : columnsMaxLabelSize;
                        rowsMaxLabelSize = (rowsMaxLabelSize > maxLebelSize) ? maxLebelSize : rowsMaxLabelSize;
                        var labelWidthScale = d3.scale.linear()
                            .domain([0, self.width])
                            .range([0, maxLebelSize]);
                        margin.left = labelWidthScale(rowsMaxLabelSize) * self.width / 3;
                        var labelHeightScale = d3.scale.linear()
                            .domain([0, self.height])
                            .range([0, maxLebelSize]);
                        var marginForColumnsLabel = labelHeightScale(columnsMaxLabelSize) * self.height / 2;
                        margin.top = (columnLabelPosition === "top") ? marginForColumnsLabel : 30;
                        margin.bottom = (columnLabelPosition === "top") ? 100 : marginForColumnsLabel;
                        margin.right = (scope.view.settings.legend) ?
                            (graph.width + gapBetweenCels * graph.data.columns.length) / 10 : 0;
                        return margin;
                    }
                    function createColorDef(legend) {
                        var colorStopCount = legend.items.length;
                        var legendColors = colors.getColors("scale");
                        var gradient = graph.dataSvg.append("defs").append("linearGradient")
                            .attr("id", "legendGradientHeatMap")
                            .attr("x1", 0).attr("x2", 0).attr("y1", 1).attr("y2", 0);
                        gradient.selectAll("stop")
                            .data(legendColors)
                            .enter().append("stop")
                            .attr("stop-color", function (d) {
                            return d;
                        })
                            .attr("offset", function (d, i) {
                            return (100 * i / colorStopCount) + "%";
                        });
                    }
                    function addLegend(x, y, width, height, extent, legendObject, colorsType) {
                        var dataExtent = extent, legendWidth = width, rectHeight = height, legend = graph.dataSvg.append("g")
                            .attr("class", "legend")
                            .attr("transform", "translate(" + (x + legendWidth / 2) + ", " + y + ")");
                        function addGradientLegend() {
                            createColorDef(legendObject);
                            legend.append("rect")
                                .attr("fill", "url(#legendGradientHeatMap)")
                                .attr("width", legendWidth)
                                .attr("height", rectHeight);
                            legend.append("text")
                                .text(dataExtent[1])
                                .attr("data-tooltip", legendObject.items[1].value)
                                .attr("transform", "translate(" + (width / 2) + ", " + (-10) + ")")
                                .attr("text-anchor", "middle");
                            if (dataExtent[0] !== dataExtent[1]) {
                                legend.append("text")
                                    .attr("data-tooltip", legendObject.items[0].value)
                                    .text(dataExtent[0])
                                    .attr("transform", "translate(" + (width / 2) + ", " + (rectHeight + 20) + ")")
                                    .attr("text-anchor", "middle");
                            }
                        }
                        function addTopicsLegend() {
                            var legendColors = colors.getColors(colorsType);
                            var itemGroup = legend
                                .selectAll("g")
                                .data(legendObject.items)
                                .enter()
                                .append("g")
                                .attr("class", "legend")
                                .attr("transform", function (d, i) {
                                return "translate(0, " + ((width + 10) * i) + ")";
                            });
                            itemGroup.append("rect")
                                .attr("width", width)
                                .attr("height", width)
                                .style("fill", function (d) {
                                return legendColors[d.color] || legendColors[1]; // if binary we return the colored
                                // value
                            });
                            itemGroup.append("text")
                                .text(function (d) {
                                return d.value;
                            })
                                .attr("text-anchor", "left")
                                .attr("transform", function () {
                                return "translate(" + (width + 5) + ", " + (width) + ")";
                            });
                        }
                        switch (legendObject.items.length) {
                            case 2:
                                addGradientLegend();
                                break;
                            default:
                                addTopicsLegend();
                                break;
                        }
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("BarsChartWidget", ["Utils", "ChartWidgets", "Widgets"]).run(["chartWidgetsData", "widgetViews",
        function (chartWidgetsData, widgetViews) {
            widgetViews.registerView("barsChart", { dataParser: chartWidgetsData.getData });
        }]);
}());

(function () {
    'use strict';
    angular.module("BarsChartWidget").directive("yoxigenBarChart", ["$parse", "$timeout", function ($parse, $timeout) {
            return {
                template: "<div class='chart yoxigen-bar-chart' style='width: 100%; height: 100%'></div>",
                restrict: 'E',
                scope: true,
                replace: true,
                link: function postLink(scope, element, attrs) {
                    var data, settings;
                    var resizeEventListenerEnabled;
                    var selectedBarGroup = null;
                    var labelTexts, labelBoxes;
                    var selectItem;
                    var tooltip, tooltipText, tooltipRect;
                    var defaultOptions = {
                        height: "200px",
                        width: "100%",
                        spacing: { min: 0, max: 40 },
                        padding: { top: 10, right: 50, left: 50, bottom: 0 },
                        selectable: false,
                        highlightSelectedItem: true,
                        barLabels: {
                            height: 30,
                            margin: 11
                        },
                        barLabelsFont: {
                            color: "#000000",
                            size: 14,
                            weight: "bold",
                            family: "sans-serif"
                        },
                        borderWidth: 1,
                        labels: {
                            height: 32,
                            margin: 12,
                            handleEvents: true
                        },
                        labelsFont: {
                            color: "#000000",
                            size: "14px",
                            weight: "bold",
                            family: "sans-serif"
                        },
                        selectionBar: {
                            barHeight: 5,
                            arrowHeight: 10,
                            arrowWidth: 21,
                            margin: 8,
                            defaultColor: "#333"
                        },
                        gridSize: 13,
                        barsHandleEvents: true,
                        colors: ["#98A3AC", "#7a92a3"],
                        minHeight: 100,
                        maxWidth: 200,
                        createAxes: false,
                        createLabels: true,
                        selectLabels: true,
                        showSelectionBar: false,
                        refreshOnResize: true,
                        tooltip: "{{seriesLabel}}'s {{barLabel}} score: {{barValue}}"
                    }, options;
                    var renderTimeoutPromise;
                    scope.$watch(attrs.ngModel, function (chartData) {
                        if (chartData) {
                            $timeout.cancel(renderTimeoutPromise);
                            renderTimeoutPromise = $timeout(function () {
                                data = chartData;
                                drawChart();
                            }, 40);
                        }
                    });
                    scope.$watch(attrs.settings, function (value) {
                        settings = value;
                        options = angular.extend({}, defaultOptions, settings.options);
                        if (settings.selectedIndex !== undefined) {
                            selectedBarGroup = settings.selectedIndex;
                        }
                        drawChart();
                        if (options.refreshOnResize && !resizeEventListenerEnabled) {
                            window.addEventListener("resize", function () {
                                drawChart(false);
                            });
                        }
                        else if (!options.refreshOnResize && resizeEventListenerEnabled) {
                            window.removeEventListener("resize", drawChart);
                        }
                        if (settings.events) {
                            angular.forEach(settings.events, function (eventSettings) {
                                element.on(eventSettings.eventName, ".handle-events", function (e) {
                                    scope.$apply(function () {
                                        scope.$emit("widgetEvent", { event: eventSettings, data: e.currentTarget.__data__, widget: scope.widget });
                                    });
                                });
                            });
                        }
                        element.on("mouseover", ".vertical-bar", function (e) {
                            setTooltipText(getTooltipText(e.target));
                            showTooltip();
                            window.addEventListener("mousemove", tooltipMoveHandler);
                        });
                        element.on("mouseout", ".vertical-bar", function () {
                            hideTooltip();
                            window.removeEventListener("mousemove", tooltipMoveHandler);
                        });
                        if (options.selectable && !element.clickHandlerAdded) {
                            element.on("click", ".handle-events", function (e) {
                                var targetData = e.currentTarget.__data__, targetIndex = data.indexOf(targetData);
                                if ((targetIndex !== selectedBarGroup) && selectItem) {
                                    selectItem(targetData, targetIndex);
                                }
                            });
                            element.clickHandlerAdded = true;
                        }
                    });
                    scope.$on("$destroy", function () {
                        $timeout.cancel(renderTimeoutPromise);
                        $timeout.cancel(showTimeoutPromise);
                        element.empty();
                        element.off();
                    });
                    function getBarIndexForSelection(dataSelection) {
                        for (var i = 0; i < data.length; i++) {
                            if (dataMemberMatchesSelection(dataSelection, data[i])) {
                                return i;
                            }
                        }
                        if (settings.selectedIndex !== undefined) {
                            return settings.selectedIndex;
                        }
                        return null;
                    }
                    function dataMemberMatchesSelection(dataSelection, dataMember) {
                        for (var property in dataSelection) {
                            if (dataSelection.hasOwnProperty(property)) {
                                if (String(dataMember[property]) !== dataSelection[property]) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                    function getTooltipText(barElement) {
                        var series = settings.series[parseInt(barElement.getAttribute("data-seriesIndex"))], barLabel = data[parseInt(barElement.getAttribute("data-index"))]._label, barValue = barElement.__data__[series.field];
                        return options.tooltip
                            .replace("{{seriesLabel}}", series._label)
                            .replace("{{barLabel}}", barLabel)
                            .replace("{{barValue}}", barValue);
                    }
                    function getMinValue() {
                        return d3.min(data, function (d) {
                            var fields = [];
                            angular.forEach(settings.series, function (series) {
                                fields.push(d[series.field]);
                            });
                            return d3.min(fields);
                        });
                    }
                    function getMaxValue() {
                        return d3.max(data, function (d) {
                            var fields = [];
                            angular.forEach(settings.series, function (series) {
                                fields.push(d[series.field]);
                            });
                            return d3.max(fields);
                        });
                    }
                    function tooltipMoveHandler(e) {
                        var boundingClientRect = element[0].getBoundingClientRect();
                        setTooltipPosition({
                            x: (e.x || e.clientX) - boundingClientRect.left,
                            y: (e.y || e.clientY) - boundingClientRect.top
                        });
                    }
                    function setTooltipText(text) {
                        tooltipText.text(text);
                        var textClientRect = tooltipText[0][0].getBoundingClientRect();
                        tooltipRect.attr("width", textClientRect.width + 20);
                        tooltipRect.attr("height", textClientRect.height + 10);
                    }
                    var hideTooltipTimeout;
                    function hideTooltip() {
                        clearTimeout(hideTooltipTimeout);
                        hideTooltipTimeout = setTimeout(function () {
                            tooltip[0][0].style.display = "none";
                        }, 50);
                    }
                    function showTooltip() {
                        clearTimeout(hideTooltipTimeout);
                        tooltip[0][0].style.removeProperty("display");
                    }
                    function setTooltipPosition(position) {
                        var tooltipPositionX = position.x + 10, tooltipWidth = parseInt(tooltipRect[0][0].getAttribute("width"));
                        if (tooltipPositionX + tooltipWidth > element[0].clientWidth) {
                            tooltipPositionX = position.x - 10 - tooltipWidth;
                        }
                        tooltipRect
                            .attr("x", tooltipPositionX)
                            .attr("y", position.y);
                        tooltipText
                            .attr("x", tooltipPositionX + 10)
                            .attr("y", position.y + 20);
                    }
                    function setLabelFill(labelData, labelIndex) {
                        if (labelIndex === selectedBarGroup) {
                            return "White";
                        }
                        if (!labelData) {
                            return options.labelsFont.color;
                        }
                        var color = labelData._style && labelData._style[settings.labels.styleField] &&
                            labelData._style[settings.labels.styleField].color;
                        return color || options.labelsFont.color;
                    }
                    function getSelectionBarColor(itemData) {
                        var color = itemData && itemData._style && itemData._style[settings.selectionBar.styleField] &&
                            itemData._style[settings.selectionBar.styleField].color;
                        return color || options.selectable.defaultColor;
                    }
                    var showTimeoutPromise;
                    scope.$on("show", function () {
                        $timeout.cancel(showTimeoutPromise);
                        showTimeoutPromise = $timeout(function () {
                            drawChart(false);
                        });
                    });
                    function drawChart(selectBar) {
                        if (!data || !settings) {
                            return;
                        }
                        element.css({
                            height: options.height,
                            width: "100%"
                        });
                        element[0].innerHTML = "";
                        var domainMinMax = options.values || {};
                        if (domainMinMax.min === undefined) {
                            domainMinMax.min = getMinValue();
                        }
                        if (domainMinMax.max === undefined) {
                            domainMinMax.max = getMaxValue();
                        }
                        var scale = d3.scale.linear()
                            .domain([domainMinMax.min, domainMinMax.max]);
                        var patterns = {};
                        if (settings.selectedData) {
                            selectedBarGroup = getBarIndexForSelection(settings.selectedData);
                        }
                        if (selectedBarGroup === "last") {
                            selectedBarGroup = data.length - 1;
                        }
                        var width = element.width(), height = element.height(), gridSize = options.gridSize, leftPadding = options.padding.left, rightPadding = options.padding.right, selectionBarTotalHeight = options.showSelectionBar ?
                            options.selectionBar.barHeight + options.selectionBar.arrowHeight +
                                options.selectionBar.margin : 0, bottomReservedSpace = options.padding.bottom +
                            (options.createLabels ? options.labels.height + options.labels.margin : 0) +
                            selectionBarTotalHeight, barsSpacing = (width / data.length) / (data.length - 1), barsArea = {
                            width: width - 2 * options.borderWidth,
                            height: height - bottomReservedSpace - options.borderWidth * 2
                        }, heightGridRemainder = barsArea.height % gridSize, widthGridRemainder = barsArea.width % gridSize, selectionBar, selectionBarArrow;
                        if (heightGridRemainder) {
                            barsArea.height += (gridSize - heightGridRemainder);
                            bottomReservedSpace -= heightGridRemainder;
                        }
                        if (widthGridRemainder) {
                            barsArea.width -= widthGridRemainder;
                            leftPadding += Math.floor(widthGridRemainder / 2);
                            rightPadding += Math.floor(widthGridRemainder / 2);
                        }
                        barsSpacing = Math.max(barsSpacing, options.spacing.min);
                        barsSpacing = Math.min(barsSpacing, options.spacing.max);
                        scale.range([10, barsArea.height - options.barLabels.height - options.barLabels.margin]);
                        var svg = d3.select(element[0])
                            .append("svg")
                            .attr("height", "100%")
                            .attr("width", "100%");
                        var defs = svg.append('svg:defs');
                        var totalRectWidth = Math.min((width - leftPadding - rightPadding + barsSpacing) / data.length, options.maxWidth * settings.series.length), rectWidth = (totalRectWidth - barsSpacing) / settings.series.length, barRemainder = rectWidth % gridSize;
                        if (options.highlightSelectedItem) {
                            selectItem = function (itemData, itemIndex) {
                                var color = getSelectionBarColor(itemData), previousSelectedIndex = selectedBarGroup;
                                if (labelBoxes) {
                                    d3.select(labelBoxes[0][selectedBarGroup]).classed("selected", false);
                                }
                                selectedBarGroup = itemIndex;
                                if (labelBoxes && options.selectLabels) {
                                    d3.select(labelTexts[0][selectedBarGroup]).attr("fill", setLabelFill(itemData, selectedBarGroup));
                                    d3.select(labelTexts[0][previousSelectedIndex]).attr("fill", setLabelFill(data[previousSelectedIndex], previousSelectedIndex));
                                    d3.select(labelBoxes[0][selectedBarGroup]).classed("selected", true);
                                }
                                if (selectionBar) {
                                    selectionBar.attr("fill", color);
                                    selectionBarArrow.attr("fill", color);
                                    moveSelectionBarArrowTo(itemIndex * totalRectWidth + leftPadding +
                                        (totalRectWidth - barsSpacing) / 2);
                                }
                            };
                        }
                        if (barRemainder) {
                            var halfGrid = Math.floor(gridSize / 2);
                            if (barRemainder < halfGrid) {
                                rectWidth -= barRemainder;
                            }
                            else {
                                rectWidth += gridSize - barRemainder;
                            }
                        }
                        var xScale = d3.scale.linear()
                            .domain([0, data.length])
                            .range([0, totalRectWidth * data.length]);
                        function createAxes() {
                            var xAxis = d3.svg.axis()
                                .scale(xScale)
                                .orient("bottom");
                            svg.append("g")
                                .attr("class", "axis")
                                .attr("transform", "translate(" + leftPadding + "," + (height - options.padding.top) + ")")
                                .call(xAxis);
                            var yAxis = d3.svg.axis()
                                .scale(scale)
                                .orient("left");
                            //Create Y axis
                            svg.append("g")
                                .attr("class", "axis")
                                .attr("transform", "translate(" + options.padding.top + ",0)")
                                .call(yAxis);
                        }
                        function createTooltip() {
                            tooltip = svg.append("g")
                                .attr("style", "display: none");
                            tooltipRect = tooltip.append("rect")
                                .attr("width", 100)
                                .attr("height", 50)
                                .attr("fill", "#333333")
                                .attr("x", 0).attr("y", 0);
                            tooltipText = tooltip.append("text")
                                .attr("fill", "White")
                                .attr("font-size", "16px")
                                .attr("x", 0).attr("y", 0);
                        }
                        function getPatternFill(backgroundColor) {
                            var patternId = "pattern-" + backgroundColor.match(/[^\(\)\.#]/g).join("").replace(/\,/g, "_");
                            if (!patterns[patternId]) {
                                var pattern = defs.append('svg:pattern')
                                    .attr('id', patternId)
                                    .attr('width', gridSize)
                                    .attr('height', gridSize)
                                    .attr('patternUnits', 'userSpaceOnUse');
                                pattern
                                    .append('svg:rect')
                                    .attr('width', gridSize)
                                    .attr('height', gridSize)
                                    .attr('fill', backgroundColor)
                                    .attr("stroke", "rgba(0,0,0,0.2)")
                                    .attr("stroke-dasharray", (gridSize * 2) + "px, " + (gridSize * 2) + "px");
                                patterns[patternId] = "url(#" + patternId + ")";
                            }
                            return patterns[patternId];
                        }
                        function createBackground() {
                            svg.append("svg:rect")
                                .attr("width", barsArea.width)
                                .attr("height", barsArea.height)
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("fill", "rgba(0,0,0,0)")
                                .attr("stroke", "#ddd")
                                .attr("class", "crisp")
                                .attr("stroke-width", "1px");
                            svg.append("svg:rect")
                                .attr("width", barsArea.width - options.borderWidth * 2)
                                .attr("height", barsArea.height)
                                .attr("x", options.borderWidth)
                                .attr("y", options.borderWidth)
                                .attr("fill", getPatternFill("rgba(0,0,0,0)"));
                        }
                        function moveSelectionBarArrowTo(horizontalPosition) {
                            selectionBarArrow.attr("d", [
                                "M" + horizontalPosition,
                                height - options.selectionBar.barHeight - options.selectionBar.arrowHeight,
                                "L" + (horizontalPosition - options.selectionBar.arrowWidth / 2),
                                height - options.selectionBar.barHeight,
                                "L" + (horizontalPosition + options.selectionBar.arrowWidth / 2),
                                height - options.selectionBar.barHeight,
                                "Z"
                            ].join(" "));
                        }
                        function createSelectionBar() {
                            selectionBar = svg.append("svg:rect")
                                .attr("width", width)
                                .attr("height", options.selectionBar.barHeight)
                                .attr("x", 0)
                                .attr("y", height - options.selectionBar.barHeight);
                            selectionBarArrow = svg.append("svg:path");
                        }
                        function fitToGrid(size) {
                            var gridRemainder = size % gridSize;
                            if (gridRemainder) {
                                return size - gridRemainder;
                            }
                            return size;
                        }
                        function createSeries(series, seriesIndex) {
                            var rects = svg.selectAll("rect.series_" + seriesIndex)
                                .data(data)
                                .enter()
                                .append("rect")
                                .attr("class", "crisp bars vertical-bar series_" + seriesIndex +
                                (options.barsHandleEvents ? " handle-events" : ""));
                            function getDataColor(d) {
                                return d._style && d._style[series.field] && d._style[series.field].color;
                            }
                            rects
                                .attr("width", Math.max(0, rectWidth))
                                .attr("height", function (d) {
                                var value = d[series.field];
                                if (value === null) {
                                    return 0;
                                }
                                return Math.max(gridSize, fitToGrid(scale(value)));
                            })
                                .attr("x", function (d, i) {
                                return fitToGrid(i * totalRectWidth + leftPadding + seriesIndex * rectWidth +
                                    options.borderWidth);
                            })
                                .attr("y", function (d) {
                                var value = d[series.field], height;
                                height = value === null ? 0 : Math.max(gridSize, fitToGrid(scale(value)));
                                return barsArea.height + options.borderWidth - height;
                            })
                                .attr("fill", function (d) {
                                return getPatternFill(getDataColor(d) || series.color || options.colors[seriesIndex]);
                            })
                                .attr("data-seriesIndex", seriesIndex)
                                .attr("data-index", function (d, i) {
                                return i;
                            });
                            if (series.nullDisplay) {
                                angular.forEach(data, function (item, itemIndex) {
                                    if (item[series.field] === null) {
                                        svg.append("text")
                                            .text(series.nullDisplay)
                                            .attr("x", fitToGrid(itemIndex * totalRectWidth + leftPadding) +
                                            (totalRectWidth - barsSpacing) / 2)
                                            .attr("y", barsArea.height + options.borderWidth - gridSize - 2)
                                            .attr("font-family", options.barLabelsFont.family)
                                            .attr("font-size", "14px")
                                            .attr("font-weight", options.barLabelsFont.weight)
                                            .attr("fill", "#666666")
                                            .attr("text-anchor", "middle");
                                    }
                                });
                            }
                            var textMargins = 4, fontSize = Math.max(10, Math.min(rectWidth - textMargins * 2, options.barLabelsFont.size)) +
                                "px";
                            svg.selectAll("text.series_" + seriesIndex)
                                .data(data)
                                .enter()
                                .append("text")
                                .attr("class", "series_" + seriesIndex + (options.barsHandleEvents ? " handle-events" : ""))
                                .text(function (d) {
                                return d[series.field];
                            })
                                .attr("x", function (d, i) {
                                return fitToGrid(i * totalRectWidth + leftPadding) + rectWidth / 2 +
                                    seriesIndex * rectWidth;
                            })
                                .attr("y", function (d) {
                                return barsArea.height + options.borderWidth -
                                    Math.max(gridSize, fitToGrid(scale(d[series.field]))) - gridSize;
                            })
                                .attr("font-family", options.barLabelsFont.family)
                                .attr("font-size", fontSize)
                                .attr("font-weight", options.barLabelsFont.weight)
                                .attr("fill", function (d) {
                                return getDataColor(d) || series.barLabelsColor || options.barLabelsFont.color;
                            })
                                .attr("text-anchor", "middle");
                        }
                        function createLabels() {
                            var handleEventsClass = options.labels.handleEvents ? " handle-events" : "", labelWidth = totalRectWidth - barsSpacing;
                            if (labelWidth <= 0) {
                                return;
                            }
                            labelBoxes = svg.selectAll("rect.label-box" + handleEventsClass)
                                .data(data)
                                .enter()
                                .append("rect")
                                .attr("class", "label-box" + handleEventsClass)
                                .attr("width", totalRectWidth - barsSpacing)
                                .attr("height", options.labels.height)
                                .attr("x", function (d, i) {
                                return i * totalRectWidth + leftPadding;
                            })
                                .attr("rx", Math.floor(options.labels.height / 2) + "px")
                                .attr("y", height - options.labels.height - selectionBarTotalHeight)
                                .attr("fill", function (d) {
                                var color = d._style && d._style[settings.labels.styleField] &&
                                    d._style[settings.labels.styleField].color;
                                return color || options.labelsFont.color;
                            });
                            labelTexts = svg.selectAll("text.labels" + handleEventsClass)
                                .data(data)
                                .enter()
                                .append("text")
                                .attr("class", "labels" + handleEventsClass)
                                .text(function (d) {
                                return d._label;
                            })
                                .attr("x", function (d, i) {
                                return (i + 0.5) * totalRectWidth + leftPadding - barsSpacing / 2;
                            })
                                .attr("y", height - options.labels.height - selectionBarTotalHeight +
                                parseInt(options.labelsFont.size, 10) + 1)
                                .attr("font-family", options.labelsFont.family)
                                .attr("font-size", options.labelsFont.size)
                                .attr("font-weight", options.labelsFont.weight)
                                .attr("fill", setLabelFill)
                                .attr("text-anchor", "middle");
                        }
                        createBackground();
                        angular.forEach(settings.series, createSeries);
                        if (options.createAxes) {
                            createAxes();
                        }
                        if (options.createLabels) {
                            createLabels();
                        }
                        if (options.showSelectionBar) {
                            createSelectionBar();
                        }
                        if (selectedBarGroup !== undefined && selectItem) {
                            selectItem(data[selectedBarGroup], selectedBarGroup);
                            if (settings.selectedIndex && selectBar !== false) {
                                angular.forEach(settings.events, function (eventSettings) {
                                    var eventSettingsCopy = angular.copy(eventSettings);
                                    if (eventSettingsCopy.actionOptions) {
                                        eventSettingsCopy.actionOptions.updateUrl = false;
                                    }
                                    if (eventSettings.eventName === "click") {
                                        scope.$emit("widgetEvent", { event: eventSettingsCopy, data: data[selectedBarGroup], widget: scope.widget });
                                    }
                                });
                            }
                        }
                        createTooltip();
                        if (options.selectFirstOnLoad && selectItem) {
                            selectItem(data[0], 0);
                        }
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("PercentChartWidget", ["Utils", "ChartWidgets", "Widgets"]).run(["chartWidgetsData", "widgetViews",
        function (chartWidgetsData, widgetViews) {
            widgetViews.registerView("percentChart", { dataParser: chartWidgetsData.getData });
        }]);
}());

(function () {
    'use strict';
    angular.module("PercentChartWidget").directive("yoxigenPercentChart", ["$rootScope", function ($rootScope) {
            return {
                template: "<div class='chart yoxigen-percent-chart' style='width: 100%; height: 100%'></div>",
                restrict: 'E',
                scope: true,
                replace: true,
                link: function postLink(scope, element, attrs) {
                    var data, settings;
                    var resizeEventListenerEnabled;
                    var selectedBarGroup = null;
                    var labelTexts, labelBoxes;
                    var selectItem;
                    var rects;
                    var selectedOnLoad;
                    var defaultOptions = {
                        selectable: false,
                        labels: {
                            height: 32,
                            margin: 12,
                            handleEvents: true
                        },
                        labelsFont: {
                            color: "#000000",
                            size: "14px",
                            weight: "bold",
                            family: "sans-serif"
                        },
                        selectionBar: {
                            barHeight: 5,
                            arrowHeight: 10,
                            arrowWidth: 21,
                            margin: 8,
                            defaultColor: "#333"
                        },
                        borderWidth: 1,
                        gridSize: 13,
                        minGridSize: 8,
                        maxGridSize: 16,
                        barsHandleEvents: true,
                        colors: ["#0b62a4", "#7a92a3"],
                        createLabels: true,
                        showSelectionBar: false,
                        refreshOnResize: true
                    }, options;
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                    scope.$watch(attrs.ngModel, function (chartData) {
                        data = chartData;
                        drawChart();
                    });
                    scope.$watch(attrs.settings, function (value) {
                        settings = value;
                        options = angular.extend({}, defaultOptions, settings.options);
                        if (settings.selectedIndex !== undefined) {
                            selectedBarGroup = settings.selectedIndex;
                        }
                        drawChart();
                        if (options.refreshOnResize && !resizeEventListenerEnabled) {
                            window.addEventListener("resize", drawChart);
                        }
                        else if (!options.refreshOnResize && resizeEventListenerEnabled) {
                            window.removeEventListener("resize", drawChart);
                        }
                        if (settings.events) {
                            angular.forEach(settings.events, function (eventSettings) {
                                element.on(eventSettings.eventName, ".handle-events", function (e) {
                                    scope.safeApply(function () {
                                        scope.$emit("widgetEvent", { event: eventSettings, data: e.currentTarget.__data__, widget: scope.widget });
                                    });
                                });
                            });
                        }
                        if (options.selectable) {
                            element.on("click", ".handle-events", function (e) {
                                var targetData = e.currentTarget.__data__, targetIndex = data.indexOf(targetData);
                                if ((targetIndex !== selectedBarGroup) && selectItem) {
                                    selectItem(targetData, targetIndex);
                                }
                            });
                        }
                    });
                    function removeEmptyData(data) {
                        var copiedData = angular.copy(data);
                        for (var i = copiedData.length - 1; i >= 0; i--) {
                            if (!copiedData[i][settings.series[0].field]) {
                                copiedData.splice(i, 1);
                            }
                        }
                        return copiedData;
                    }
                    function setLabelFill(labelData, labelIndex) {
                        if (labelIndex === selectedBarGroup) {
                            return "White";
                        }
                        var color = labelData._style && labelData._style[settings.labels.styleField] &&
                            labelData._style[settings.labels.styleField].color;
                        return color || options.labelsFont.color;
                    }
                    function getSelectionBarColor(itemData) {
                        var color = itemData._style && itemData._style[settings.selectionBar.styleField] &&
                            itemData._style[settings.selectionBar.styleField].color;
                        return color || options.selectable.defaultColor;
                    }
                    function drawChart() {
                        function getBarWidth(barIndex) {
                            var barWidth = barsWidth[barIndex];
                            if (barWidth !== undefined) {
                                return barWidth;
                            }
                            barWidth = fitToGrid(scale(data[barIndex][settings.series[0].field]));
                            barsWidth[barIndex] = barWidth;
                            return barWidth;
                        }
                        function getPatternFill(backgroundColor) {
                            var patternId = "pattern-" + backgroundColor.match(/[^\(\)\.#]/g).join("").replace(/\,/g, "_");
                            if (!patterns[patternId]) {
                                var pattern = defs.append('svg:pattern')
                                    .attr('id', patternId)
                                    .attr('width', gridSize)
                                    .attr('height', gridSize)
                                    .attr('patternUnits', 'userSpaceOnUse');
                                pattern
                                    .append('svg:rect')
                                    .attr('width', gridSize)
                                    .attr('height', gridSize)
                                    .attr('fill', backgroundColor)
                                    .attr("stroke", "rgba(0,0,0,0.2)")
                                    .attr("stroke-dasharray", (gridSize * 2) + "px, " + (gridSize * 2) + "px");
                                patterns[patternId] = "url(#" + patternId + ")";
                            }
                            return patterns[patternId];
                        }
                        function createBackground() {
                            svg.append("svg:rect")
                                .attr("class", "crisp")
                                .attr("width", barsArea.width + 2 * gridSize - 2 * options.borderWidth)
                                .attr("height", barsArea.height + 2 * gridSize)
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("stroke", "rgb(204,204,204)")
                                .attr("fill", getPatternFill("#ffffff"));
                        }
                        function moveSelectionBarArrowTo(itemIndex) {
                            var arrowPosition = leftPadding, itemWidth;
                            for (var i = 0; i < itemIndex; i++) {
                                itemWidth = getBarWidth(i);
                                arrowPosition += itemWidth + gridSize;
                            }
                            arrowPosition += getBarWidth(itemIndex) / 2;
                            selectionBarArrow.attr("d", [
                                "M" + arrowPosition,
                                height - options.selectionBar.barHeight - options.selectionBar.arrowHeight,
                                "L" + (arrowPosition - options.selectionBar.arrowWidth / 2),
                                height - options.selectionBar.barHeight,
                                "L" + (arrowPosition + options.selectionBar.arrowWidth / 2),
                                height - options.selectionBar.barHeight,
                                "Z"
                            ].join(" "));
                        }
                        function createSelectionBar() {
                            selectionBar = svg.append("svg:rect")
                                .attr("width", width)
                                .attr("height", options.selectionBar.barHeight)
                                .attr("x", 0)
                                .attr("y", height - options.selectionBar.barHeight);
                            selectionBarArrow = svg.append("svg:path");
                        }
                        function fitToGrid(size) {
                            if (size < gridSize) {
                                return gridSize;
                            }
                            var gridRemainder = size % gridSize;
                            if (gridRemainder) {
                                return size - gridRemainder;
                            }
                            return size;
                        }
                        function createBars(series) {
                            rects = svg.selectAll("rect.bars")
                                .data(data)
                                .enter()
                                .append("rect")
                                .attr("class", "crisp bars percent-bars" + (options.barsHandleEvents ? " handle-events" : ""));
                            var totalWidth = leftPadding;
                            function getDataColor(d) {
                                return d._style && d._style[series.field] && d._style[series.field].color;
                            }
                            rects
                                .attr("x", function (d, i) {
                                var currentTotalWidth = totalWidth;
                                totalWidth += getBarWidth(i) + gridSize;
                                return currentTotalWidth;
                            })
                                .attr("width", function (d, i) {
                                return getBarWidth(i);
                            })
                                .attr("height", barsArea.height + "px")
                                .attr("y", gridSize)
                                .attr("fill", function (d, i) {
                                return getPatternFill(getDataColor(d) || series.color || options.colors[i]);
                            })
                                .append("title").text(function (d) {
                                return d.tooltip;
                            });
                        }
                        function createLabels() {
                            var handleEventsClass = options.labels.handleEvents ? " handle-events" : "", totalWidth = leftPadding;
                            labelBoxes = svg.selectAll("rect.label-box" + handleEventsClass)
                                .data(data)
                                .enter()
                                .append("rect")
                                .attr("class", "label-box" + handleEventsClass)
                                .attr("height", options.labels.height)
                                .attr("rx", "16px")
                                .attr("y", height - options.labels.height - selectionBarTotalHeight)
                                .attr("fill", function (d) {
                                var color = d._style && d._style[settings.labels.styleField] &&
                                    d._style[settings.labels.styleField].color;
                                return color || options.labelsFont.color;
                            });
                            labelTexts = svg.selectAll("text.labels" + handleEventsClass)
                                .data(data)
                                .enter()
                                .append("text")
                                .attr("class", "labels" + handleEventsClass)
                                .text(function (d) {
                                return (d._percent < 1 ? "< 1" : Math.round(d._percent)) + "%";
                            })
                                .attr("x", function (d, i) {
                                var currentItemWidth = getBarWidth(i), currentTotalWidth = totalWidth;
                                totalWidth += currentItemWidth + gridSize;
                                return currentTotalWidth + currentItemWidth / 2;
                            })
                                .attr("y", height - 10 - selectionBarTotalHeight)
                                .attr("font-family", options.labelsFont.family)
                                .attr("font-size", options.labelsFont.size)
                                .attr("font-weight", options.labelsFont.weight)
                                .attr("fill", setLabelFill)
                                .attr("text-anchor", "middle");
                            totalWidth = leftPadding;
                            labelBoxes
                                .attr("width", function (d, i) {
                                return labelTexts[0][i].clientWidth + 10;
                            })
                                .attr("x", function (d, i) {
                                var currentTotalWidth = totalWidth, itemWidth = getBarWidth(i);
                                totalWidth += getBarWidth(i) + gridSize;
                                return Math.max(0, currentTotalWidth + (itemWidth - this.getBoundingClientRect().width) / 2);
                            });
                        }
                        if (!data || !settings) {
                            return;
                        }
                        element.css({
                            height: options.height,
                            width: "100%"
                        });
                        element[0].innerHTML = "";
                        data = removeEmptyData(data);
                        var valueField = settings.series[0].field, scale = d3.scale.linear()
                            .domain([0, d3.sum(data, function (d) {
                                return d[valueField];
                            })]);
                        var patterns = {};
                        var width = element.width(), height = element.height(), gridSize = options.gridSize, leftPadding = gridSize, leftMargin = 0, selectionBarTotalHeight = options.showSelectionBar ?
                            options.selectionBar.barHeight + options.selectionBar.arrowHeight +
                                options.selectionBar.margin : 0, bottomReservedSpace = (options.createLabels ? options.labels.height + options.labels.margin :
                            0) + selectionBarTotalHeight, barsArea = { width: width - 2 * gridSize, height: height - gridSize * 2 - bottomReservedSpace }, heightGridRemainder = barsArea.height % gridSize, widthGridRemainder = barsArea.width % gridSize, selectionBar, selectionBarArrow, barsWidth = [];
                        if (heightGridRemainder) {
                            barsArea.height += (gridSize - heightGridRemainder);
                            bottomReservedSpace -= heightGridRemainder;
                        }
                        if (widthGridRemainder) {
                            leftMargin = widthGridRemainder / 2;
                            barsArea.width -= widthGridRemainder;
                        }
                        scale.range([0, barsArea.width - gridSize]);
                        var svg = d3.select(element[0])
                            .append("svg")
                            .attr("height", "100%")
                            .attr("width", "100%");
                        var defs = svg.append('svg:defs');
                        selectItem = function (itemData, itemIndex) {
                            var color = getSelectionBarColor(itemData), previousSelectedIndex = selectedBarGroup;
                            d3.select(labelBoxes[0][selectedBarGroup]).classed("selected", false);
                            selectedBarGroup = itemIndex;
                            d3.select(labelTexts[0][selectedBarGroup]).attr("fill", setLabelFill(itemData, selectedBarGroup));
                            if (previousSelectedIndex !== null) {
                                d3.select(labelTexts[0][previousSelectedIndex]).attr("fill", setLabelFill(data[previousSelectedIndex], previousSelectedIndex));
                            }
                            d3.select(labelBoxes[0][selectedBarGroup]).classed("selected", true);
                            selectionBar.attr("fill", color);
                            selectionBarArrow.attr("fill", color);
                            moveSelectionBarArrowTo(itemIndex);
                        };
                        createBackground();
                        createBars(settings.series[0]);
                        if (options.createLabels) {
                            createLabels();
                        }
                        if (options.showSelectionBar) {
                            createSelectionBar();
                        }
                        if (selectedBarGroup !== null && selectedBarGroup !== undefined && selectItem) {
                            selectItem(data[selectedBarGroup], selectedBarGroup);
                        }
                        if (!selectedOnLoad && options.selectFirstOnLoad && selectItem) {
                            setTimeout(function () {
                                $rootScope.$apply(function () {
                                    jQuery(rects[0][0]).click();
                                });
                            });
                            selectedOnLoad = true;
                        }
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("PropertiesWidget", ["Utils", "Format", "Icons", "Transforms", "Widgets"]).run(["$q", "utils",
        "format", "icons", "transforms", "menus", "widgetViews",
        function ($q, utils, format, icons, transforms, menus, widgetViews) {
            var defaultListItemDisplayCount = 5; // The default number of items to display initially in a list.
            function propertiesDataParser(view, data, params) {
                var viewData = [], promises = [], iconParserPromises = [], iconParsers = {};
                angular.forEach(view.settings.properties, function (property, propertyIndex) {
                    if (property.icon) {
                        iconParserPromises.push(icons.getParseIconFunction(property.icon).then(function (iconParser) {
                            iconParsers[propertyIndex] = iconParser;
                        }));
                    }
                });
                function doGetData() {
                    angular.forEach(data, function (item, itemIndex) {
                        var itemData = [];
                        var arrayValues;
                        angular.forEach(view.settings.properties, function (property, propertyIndex) {
                            var itemDataObj = {}, i;
                            if (property.array) {
                                arrayValues = [];
                                angular.forEach(item[property.array], function (member, memberIndex) {
                                    var memberValue = {
                                        value: utils.strings.parseValue(property.value, member, params, memberIndex)
                                    };
                                    if (memberValue.value) {
                                        if (property.link) {
                                            memberValue.link =
                                                utils.strings.parseValue(property.link, member, params, itemIndex);
                                        }
                                        arrayValues.push(memberValue);
                                    }
                                });
                            }
                            if (property.menu) {
                                if (property.menu.id) {
                                    promises.push(menus.getMenu(property.menu, item, params).then(function (menu) {
                                        if (menu) {
                                            itemDataObj.menu = angular.extend(menu, property.menu);
                                        }
                                    }));
                                }
                                else {
                                    itemDataObj.menu = {
                                        items: []
                                    };
                                    property.menu.items.forEach(function (menuItem, i) {
                                        var itemCopy = angular.copy(menuItem);
                                        itemCopy.text = utils.strings.parseValue(menuItem.text, item, params, i);
                                        itemDataObj.menu.items.push(itemCopy);
                                    });
                                }
                            }
                            var icon = iconParsers[propertyIndex](property.icon);
                            if (property.value) {
                                var itemValue = property.value && !arrayValues &&
                                    utils.strings.parseValue(property.value, item, params, itemIndex);
                                if (itemValue || (arrayValues && arrayValues.length)) {
                                    angular.extend(itemDataObj, {
                                        icon: icon,
                                        tooltip: utils.strings.parseValue(property.tooltip, item, params, itemIndex)
                                    });
                                    if (arrayValues) {
                                        itemDataObj.list = arrayValues;
                                        if (arrayValues.length > defaultListItemDisplayCount) {
                                            itemDataObj.enableShowAll = true;
                                            for (i = 0; i < defaultListItemDisplayCount; i++) {
                                                itemDataObj.list[i].enabled = true;
                                            }
                                        }
                                    }
                                    else {
                                        itemDataObj.value = format.formatItem(property, itemValue);
                                        if (property.transform) {
                                            itemDataObj.value =
                                                transforms.transformValue(itemDataObj.value, property.transform);
                                        }
                                        if (property.link) {
                                            itemDataObj.link =
                                                utils.strings.parseValue(property.link, item, params, itemIndex);
                                        }
                                    }
                                    itemData.push(itemDataObj);
                                }
                            }
                            else if (property.list) {
                                angular.extend(itemDataObj, {
                                    icon: icon,
                                    tooltip: utils.strings.parseValue(property.tooltip, item, params, itemIndex),
                                    list: []
                                });
                                angular.forEach(property.list, function (listItem, listItemIndex) {
                                    var listItemValue = utils.strings.parseValue(listItem.value, item, params, listItemIndex), listItemObj;
                                    if (listItemValue) {
                                        if (listItem.transform) {
                                            listItemValue =
                                                transforms.transformValue(listItemValue, listItem.transform);
                                        }
                                        if (listItem.link) {
                                            listItemValue = "<a href='" +
                                                utils.strings.parseValue(listItem.link, item, params, listItemIndex) +
                                                "'>" + listItemValue + "</a>";
                                        }
                                        listItemObj = {
                                            value: (listItem.label ? "<strong>" +
                                                utils.strings.parseValue(listItem.label, item, params, listItemIndex) +
                                                "</strong> " : "") + listItemValue
                                        };
                                        if (listItem.className) {
                                            listItemObj.className = listItem.className;
                                        }
                                        itemDataObj.list.push(listItemObj);
                                    }
                                });
                                if (itemDataObj.list.length > defaultListItemDisplayCount) {
                                    itemDataObj.enableShowAll = true;
                                    for (i = 0; i < defaultListItemDisplayCount; i++) {
                                        itemDataObj.list[i].enabled = true;
                                    }
                                }
                                itemData.push(itemDataObj);
                            }
                            else if (property.booleanList) {
                                var listItems = [];
                                angular.forEach(property.booleanList, function (member) {
                                    if (item[member.show]) {
                                        var boolItem = { value: member.label };
                                        if (member.link) {
                                            boolItem.link =
                                                utils.strings.parseValue(member.link, item, params, itemIndex);
                                        }
                                        listItems.push(boolItem);
                                    }
                                });
                                if (listItems.length) {
                                    itemData.push({
                                        icon: icon,
                                        tooltip: utils.strings.parseValue(property.tooltip, item, params, itemIndex),
                                        list: listItems
                                    });
                                }
                            }
                        });
                        viewData.push(itemData);
                    });
                    return viewData;
                }
                return $q.all(iconParserPromises).then(doGetData);
            }
            widgetViews.registerView("properties", { dataParser: propertiesDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("ForceChartWidget", ["Utils", "Widgets", "Events"]).run(["utils", "widgetViews",
        function (utils, widgetViews) {
            function forceDataParser(view, data, params) {
                var settings = view.settings;
                var newData = {
                    nodes: [],
                    links: []
                }, nodeIndexes = {};
                function getRowNodes(row) {
                    var nodeName, nodeLabel, nodeIndex, rowNodeIndexes = [], rowLinkKeys = {};
                    for (var i = 0, nodeSettings; !!(nodeSettings = settings.nodes[i]); i++) {
                        nodeName = row[nodeSettings.name];
                        nodeLabel =
                            nodeSettings.label ? utils.strings.parseValue(nodeSettings.label, row, params) : nodeName;
                        nodeIndex = nodeIndexes[nodeSettings.group + "_" + nodeLabel];
                        if (nodeIndex === undefined) {
                            nodeIndex = nodeIndexes[nodeSettings.group + "_" + nodeLabel] = newData.nodes.length;
                            newData.nodes.push({
                                name: nodeName,
                                count: parseInt(row[nodeSettings.size], 10),
                                group: nodeSettings.group,
                                weight: 0,
                                "userCount": true,
                                "label": nodeLabel,
                                unique: [nodeSettings.group, nodeLabel].join(":"),
                                isCurrentlyFocused: false,
                                field: nodeSettings.name,
                                custom: nodeSettings.custom
                            });
                        }
                        rowNodeIndexes.push(nodeIndex);
                    }
                    var currentLinkIndex, currentSubLinkIndex, linkKey, sourceNodeIndex, targetNodeIndex;
                    for (currentLinkIndex = 0; currentLinkIndex < rowNodeIndexes.length - 1; currentLinkIndex++) {
                        for (currentSubLinkIndex = currentLinkIndex + 1; currentSubLinkIndex < rowNodeIndexes.length; currentSubLinkIndex++) {
                            linkKey = [rowNodeIndexes[currentLinkIndex], rowNodeIndexes[currentSubLinkIndex]].join("_");
                            if (!rowLinkKeys[linkKey]) {
                                sourceNodeIndex = rowNodeIndexes[currentLinkIndex];
                                targetNodeIndex = rowNodeIndexes[currentSubLinkIndex];
                                newData.links.push({
                                    depth: 1,
                                    unique: [newData.nodes[sourceNodeIndex].unique,
                                        newData.nodes[targetNodeIndex].unique].join("_"),
                                    source: sourceNodeIndex,
                                    target: targetNodeIndex
                                });
                                rowLinkKeys[linkKey] = true;
                                newData.nodes[rowNodeIndexes[currentLinkIndex]].weight++;
                                newData.nodes[rowNodeIndexes[currentSubLinkIndex]].weight++;
                            }
                        }
                    }
                }
                angular.forEach(data, getRowNodes);
                return newData;
            }
            widgetViews.registerView("forceChart", { dataParser: forceDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('ForceChartWidget')
        .directive('forceChart', ["events", function (eventsService) {
            return {
                template: '<div class="widget-force-chart"></div>',
                restrict: 'E',
                require: "?ngModel",
                replace: true,
                link: function postLink(scope, element, attrs, ngModel) {
                    var defaultOptions = {
                        "radius": 2.5,
                        "fontSize": 9,
                        "labelFontSize": 9,
                        "gravity": 0,
                        "height": 800,
                        "nodeFocusColor": "black",
                        "nodeFocusRadius": 25,
                        "nodeFocus": true,
                        "linkDistance": 1250,
                        "charge": 0,
                        "nodeResize": "weight",
                        "linkName": "tag",
                        "minRadius": 3,
                        "maxRadius": 15,
                        "minScale": 1,
                        "maxScale": 3
                    }, data, dataChanged, events, settings, graphOptions, nodeClickInProgress, nodeClickTimeout, nodesData, linksData, selectedNodes = [];
                    // Load the Visualization API and the piechart package.
                    //google.load('visualization', '1.0', {'packages':['corechart']});
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                    scope.$watch(attrs.ngModel, function (chartData) {
                        data = chartData;
                        dataChanged = true;
                        drawChart();
                    });
                    scope.$watch(attrs.graphSettings, function (value) {
                        events = value.events;
                        settings = value;
                        graphOptions = angular.extend({}, defaultOptions, settings.graphOptions);
                        drawChart();
                    });
                    function drawChart() {
                        element[0].innerHTML = "";
                        if (!settings || !data || !data.nodes || !data.nodes.length || !dataChanged) {
                            return;
                        }
                        function addLinks() {
                            linksData = data.links.filter(function (d) {
                                return d.source.group !== d.target.group;
                            });
                            if (selectedNodes.length) {
                                linksData = linksData.filter(function (d) {
                                    return d.source.selected || d.target.selected;
                                });
                            }
                            force.links(linksData);
                            link = svg.selectAll("line.link")
                                .data(linksData, function (d) {
                                return d.unique;
                            });
                            link.enter().insert("svg:line", ".node").attr("class", "link");
                            link.exit().remove();
                        }
                        function addNodes() {
                            nodesData = [];
                            if (selectedNodes.length) {
                                selectedNodes.forEach(function (node) {
                                    nodesData.push(node);
                                });
                                linksData.forEach(function (d) {
                                    if (!~nodesData.indexOf(d.source)) {
                                        nodesData.push(d.source);
                                    }
                                    if (!~nodesData.indexOf(d.target)) {
                                        nodesData.push(d.target);
                                    }
                                });
                            }
                            else {
                                nodesData = data.nodes;
                            }
                            force.nodes(nodesData);
                            node = svg.selectAll(".node")
                                .data(nodesData, function (d) {
                                return d.unique;
                            });
                            node.enter().append("svg:g")
                                .attr("class", "node")
                                .on("click", function (d) {
                                if (d3.event.defaultPrevented) {
                                    return;
                                }
                                if (nodeClickInProgress) {
                                    nodeClickInProgress = false;
                                    clearTimeout(nodeClickTimeout);
                                    onDblClick(d);
                                }
                                else {
                                    nodeClickInProgress = true;
                                    nodeClickTimeout = setTimeout(function () {
                                        onClick(d);
                                        nodeClickInProgress = false;
                                    }, 200);
                                }
                            })
                                .call(drag);
                            if (settings.icons) {
                                node.append("svg:image")
                                    .attr("xlink:href", function (d) {
                                    return settings.icons[d.group];
                                })
                                    .attr("width", 25)
                                    .attr("height", 25)
                                    .attr("x", -8)
                                    .attr("y", -10)
                                    .style("fill", function (d) {
                                    return color(d.group);
                                });
                            }
                            else {
                                node.append("svg:circle")
                                    .attr("class", "node")
                                    .style("fill", function (d) {
                                    return color(d.group);
                                })
                                    .attr("r", function (d) {
                                    return Math.min(scale(d.weight), graphOptions.maxRadius);
                                });
                            }
                            node.append("text")
                                .attr("dx", 12)
                                .attr("dy", ".35em")
                                .text(function (d) {
                                return d.label;
                            });
                            node.append("title")
                                .text(function (d) {
                                return d.label;
                            });
                            node.exit().remove();
                        }
                        function onClick(d) {
                            if (d.selected) {
                                selectedNodes.splice(selectedNodes.indexOf(d), 1);
                            }
                            else {
                                selectedNodes.push(d);
                            }
                            d.selected = !d.selected;
                            addLinks();
                            addNodes();
                            force.resume();
                        }
                        function onDblClick(d) {
                            if (graphOptions.onDblClick) {
                                eventsService.triggerDashboardEvent(graphOptions.onDblClick, d);
                            }
                        }
                        function dragstart(d) {
                            /* jshint validthis: true */
                            d3.select(this).classed("fixed", d.fixed = true);
                        }
                        function tick() {
                            link.attr("x1", function (d) {
                                return d.source.x;
                            })
                                .attr("y1", function (d) {
                                return Math.min(height - 10, Math.max(10, d.source.y));
                            })
                                .attr("x2", function (d) {
                                return d.target.x;
                            })
                                .attr("y2", function (d) {
                                return Math.max(10, d.target.y);
                            });
                            node.attr("transform", function (d) {
                                return "translate(" + d.x + "," + Math.min(height - 10, Math.max(10, d.y)) + ")";
                            });
                        }
                        var width = element.innerWidth() - 30, height = graphOptions.height;
                        var link, node;
                        var scale = d3.scale.linear()
                            .range(settings.icons ? [graphOptions.minScale, graphOptions.maxScale] :
                            [graphOptions.minRadius, graphOptions.maxRadius])
                            .domain([1, 30]);
                        var color = d3.scale.category10();
                        var svg = d3.select(element[0])
                            .append("svg:svg")
                            .attr("width", width)
                            .attr("height", height);
                        d3.scale.linear().range([-120, 0]).domain([0, 10]);
                        d3.scale.linear().range([40, 300]).domain([0, 100]);
                        var force = d3.layout.force()
                            .linkDistance(60)
                            .charge(-220)
                            .gravity(0.02)
                            .size([width, height])
                            .nodes(data.nodes)
                            .links(data.links)
                            .on("tick", tick)
                            .start();
                        var drag = force.drag()
                            .on("dragstart", dragstart);
                        addLinks();
                        addNodes();
                        force.on("tick", tick);
                        force.tick();
                    }
                }
            };
        }]);
}());

angular.module("ScatterPlotWidget", ["Utils", "ChartWidgets", "Widgets"])
    .run(["utils", "widgetViews", function (utils, widgetViews) {
        'use strict';
        function scatterPlotDataParser(view, data, params) {
            var timeField = view.settings.timeField;
            if (timeField) {
                var hourFieldName = view.settings.timeFieldHour = timeField + "_hour";
                data.forEach(function (row) {
                    var timeValue = row[timeField];
                    var timeMoment;
                    if (timeValue) {
                        timeMoment = utils.date.getMoment(timeValue);
                        // Update time value to be a Date value
                        row[timeField] = timeMoment.isValid() ? timeMoment.toDate() : null;
                        // Add an hour value
                        row[hourFieldName] = timeMoment.hours() + (timeMoment.minutes() / 60);
                    }
                });
            }
            return data;
        }
        widgetViews.registerView("scatterPlot", {
            dataParser: scatterPlotDataParser
        });
    }]);

(function () {
    'use strict';
    angular.module("ScatterPlotWidget").directive("scatterPlot", ["$rootScope", "utils", "fsHighChartService", "SCORE_COLOR_META_DATA",
        function ($rootScope, utils, fsHighChartService, SCORE_COLOR_META_DATA) {
            //Constants Decleration
            var MIN_NUMBER_OF_DAYS = 7;
            var MILISECONDS_IN_DAY = 24 * 3600 * 1000;
            var symbols = [{
                    "shape": 'circle',
                    "color": '#DE07CC'
                },
                {
                    "shape": 'square',
                    "color": '#07874D'
                },
                {
                    "shape": 'triangle',
                    "color": '#3DDDF2'
                }, {
                    "shape": 'triangle-down',
                    "color": '#000000'
                }, {
                    "shape": 'diamond',
                    "color": '#1E25E8'
                }];
            /**
             * Note for the directive:
             *    Currently we are not using HIGHCHART-NG http://ngmodules.org/modules/highcharts-ng
             *    If you need extra watchers and data binding, or any other funcenelity consider using highcharts-ng
             *    instead of extending this code.
             */
            return {
                template: '<div class="highchart-chart-container" ></div>',
                restrict: 'E',
                scope: {
                    model: '=',
                    graphSettings: '='
                },
                //Link function update the UI elements
                controller: function ($scope) {
                    /**
                     *
                     * @returns {boolean} true axis X look only on the date part in a day resolution and ingore
                     *     hour/minute/second
                     */
                    var ctrl = this;
                    this.xAxisIgnoreHours = function () {
                        return !$scope.graphSettings.yField;
                    };
                    //Change the first and last days according to the data
                    this.rescaleXaxis = function (chartData, xField) {
                        var domain = d3.extent(chartData, function (d) {
                            return d[xField];
                        });
                        var m1 = utils.date.getMoment(domain[0]).startOf('day'), m2 = utils.date.getMoment(domain[1]).endOf('day'), diff = Math.abs(m1.diff(m2, "days"));
                        if (diff < MIN_NUMBER_OF_DAYS) {
                            var daysToAdd = Math.floor((MIN_NUMBER_OF_DAYS - diff) / 2);
                            m1.subtract(daysToAdd, "days");
                            m2.add(daysToAdd, "days");
                        }
                        domain[0] = m1.valueOf();
                        domain[1] = m2.valueOf();
                        $scope.chart.xAxis[0].update({
                            min: domain[0],
                            max: domain[1]
                        });
                    };
                    /**
                     * Iterate the array of SCORE_COLOR_META_DATA and return the name of the SCORE COLOR (LOW,
                     * MEDIUM, ETC...) which the given store match
                     * @param score
                     * @returns {string}
                     * @throws InternalError if given score is out of range
                     */
                    this.getRiskKeyByScore = function (score) {
                        for (var propertyName in SCORE_COLOR_META_DATA) {
                            if (SCORE_COLOR_META_DATA.hasOwnProperty(propertyName)) {
                                var scoreColorMetaData = SCORE_COLOR_META_DATA[propertyName];
                                if (score >= scoreColorMetaData.minScore &&
                                    score < scoreColorMetaData.maxScore) {
                                    return propertyName;
                                }
                            }
                        }
                        //If nothing match, throw error
                        throw new RangeError("Score must be 0-100");
                    };
                    /**
                     *
                     * @param data - array of point (x,y) for highchart
                     * @param color - the required color for the series - affect legend and points
                     * @param name - the name of the series- affect the legend
                     * @param markerSymbol - the symbole for the point
                     * @param seriesIndex - order of the series in the chart & legend. Start with 0.
                     */
                    this.addOrUpdateSeries = function (data, color, name, markerSymbol, seriesIndex) {
                        //Create the series object
                        var highchartSeriesObject = {
                            "data": data,
                            "color": color,
                            "name": name,
                            "marker": {
                                "symbol": markerSymbol
                            }
                        };
                        if ($scope.chart.series && $scope.chart.series[seriesIndex]) {
                            //Update series if series with the same index already exists
                            $scope.chart.series[seriesIndex].update(highchartSeriesObject);
                        }
                        else {
                            //Add new series if the index is not exists
                            $scope.chart.addSeries(highchartSeriesObject);
                        }
                    };
                    this.refreshData = function (chartData) {
                        function populateEntityTypePoints(point) {
                            entityTypePoints.push(point);
                        }
                        if (chartData && chartData.length > 0) {
                            /**
                             * xField, yField, colorField - column names which contain the name of columns which
                             * have the relevant data for each dimension
                             */
                            var xField = $scope.graphSettings.timeField;
                            var yField = $scope.graphSettings.yField || $scope.graphSettings.timeFieldHour;
                            var colorField = $scope.graphSettings.colorField;
                            //catagorizedData - The manipulated data will be stores in catagorizedData object.
                            // 					The structure of the data should be:
                            // catagorizedData.entityType[priority] When entityType is VPN Session, SSH, etc... and
                            // priority is 0..3 when 0 is critical and 3 is low
                            var catagorizedData = this._getDataCatagorized(chartData, xField, yField, colorField);
                            //Add / Update the series data
                            var entityTypesArr = Object.keys(catagorizedData);
                            var riskTypesArr = Object.keys(SCORE_COLOR_META_DATA);
                            var isMultiSeries = entityTypesArr.length > 1;
                            var i;
                            var data, color, name, symbol;
                            if (!isMultiSeries) {
                                //Case 1- single series (single data source)
                                //Get the all the risk series on the single data source
                                var entityTypeDataPerRisk = catagorizedData[entityTypesArr[0]];
                                for (i = 0; i < riskTypesArr.length; i++) {
                                    var riskName = [riskTypesArr[i]];
                                    data = entityTypeDataPerRisk[riskName];
                                    color = SCORE_COLOR_META_DATA[riskName].color;
                                    name = utils.strings.capitalize(SCORE_COLOR_META_DATA[riskName].name);
                                    symbol = symbols[0].shape;
                                    this.addOrUpdateSeries(data, color, name, symbol, i);
                                }
                            }
                            else {
                                //Case 2 - multi series (multi data source)
                                for (i = 0; i < entityTypesArr.length; i++) {
                                    var entityType = [entityTypesArr[i]];
                                    var entityTypePoints = [];
                                    //Aggregate all risk series into single array of the data source
                                    for (var j = 0; j < riskTypesArr.length; j++) {
                                        catagorizedData[entityType][riskTypesArr[j]]
                                            .forEach(populateEntityTypePoints);
                                    }
                                    data = entityTypePoints;
                                    color = symbols[i].color;
                                    name = entityType;
                                    symbol = symbols[i].shape;
                                    this.addOrUpdateSeries(data, color, name, symbol, i);
                                }
                            }
                            this.rescaleXaxis(chartData, xField);
                            $scope.chart.redraw(); //Redraw required because axis x' length changed and I need to
                        }
                    };
                    /**
                     * This method convert the data into two dimmensions array [entityName][riskLevel]
                     * name
                     * @param chartData - array of data objects
                     * @param xField - the name of field for Axis X
                     * @param yField - the name of field for Axis Y
                     * @param colorField - the name of field for the color
                     * @private
                     * @return {} two dimensions array [entityName][riskLevel]
                     */
                    this._getDataCatagorized = function (chartData, xField, yField, colorField) {
                        var catagorizedData = {};
                        //For each data in the original array, manipulate the data in "point" variable, and add the
                        // point to catagorizedData. entry - represents entry of original data from the original
                        // array
                        chartData.forEach(function (entry) {
                            //Get the x value, calculated from Date object.
                            var timeValue;
                            if (ctrl.xAxisIgnoreHours()) {
                                //Normalize the time to date only, in resolution of one day
                                timeValue = utils.date.getMoment(entry[xField]).startOf('day').toDate();
                            }
                            else {
                                timeValue = entry[xField];
                            }
                            var point = {
                                x: timeValue.valueOf(),
                                y: entry[yField] ? entry[yField] : 0,
                                entry: entry
                            };
                            var riskTypesArr = Object.keys(SCORE_COLOR_META_DATA);
                            //Add the point to the temporal array catagorizedData- split the data between the
                            // buckets [entity name][critical / high/  medium/low]
                            if (!catagorizedData[entry.type]) {
                                catagorizedData[entry.type] = {};
                                //Init catagorizedData[entry.type][riskTypesArr[i]] as empty array
                                for (var i = 0; i < riskTypesArr.length; i++) {
                                    catagorizedData[entry.type][riskTypesArr[i]] = [];
                                }
                            }
                            var riskKeys = ctrl.getRiskKeyByScore(entry[colorField]);
                            catagorizedData[entry.type][riskKeys].push(point);
                        });
                        return catagorizedData;
                    };
                },
                link: function postLink(scope, element, attrs, ctrl) {
                    //Set unique ID for the div, Highchart need it.
                    var chartId = Math.random().toString(36).slice(2);
                    //Set unique ID on the root element of the template
                    element.children('.highchart-chart-container').attr('id', chartId);
                    if (scope.graphSettings.height) {
                        element.css('height', scope.graphSettings.height + "px");
                    }
                    //Prepare configurations for chartConfig:
                    var calculatedMinHeight = scope.graphSettings.scales.y.domain ?
                        scope.graphSettings.scales.y.domain[0] : scope.graphSettings.scales.y.minValue;
                    var calculatedMaxHeight = scope.graphSettings.scales.y.domain ?
                        scope.graphSettings.scales.y.domain[1] : undefined;
                    var calculatedYAxistickInterval = scope.graphSettings.scales.y.ticks ?
                        scope.graphSettings.scales.y.ticks.interval : undefined;
                    var calculatedXAxistickInterval = ctrl.xAxisIgnoreHours() ? MILISECONDS_IN_DAY : undefined;
                    //Create the configuration chart for the scatterPlot;
                    var chartConfig = {
                        "chart": {
                            "renderTo": chartId,
                            "type": "scatter",
                            "zoomType": 'xy',
                            "height": scope.graphSettings.height,
                            events: {
                                load: function () {
                                    //The default behviour for highchart is so the tooltip displayed on hover.
                                    //I have to change it to be onclick only, therefore I have to override the
                                    // default tooltip after page rendered.
                                    this.myTooltip = new Highcharts.Tooltip(this, this.options.tooltip);
                                }
                            }
                        },
                        rangeSelector: {
                            selected: 1
                        },
                        legend: {
                            enabled: true,
                            layout: 'vertical',
                            align: 'right',
                            verticalAlign: 'top',
                            x: 10,
                            y: 40,
                            borderWidth: 0
                        },
                        "plotOptions": {
                            scatter: {
                                lineWidth: 0
                            },
                            area: {
                                marker: {
                                    enabled: false
                                },
                                cursor: 'Pointer',
                                stacking: 'normal'
                            },
                            series: {
                                stickyTracking: false,
                                cursor: 'pointer',
                                events: {
                                    //The default behvioud for highchart is so the tooltip displayed on hover.
                                    //I have to change it to be onclick only. I add to add events on all series
                                    // that catch click on item, and mouseout on item
                                    click: function (evt) {
                                        this.chart.myTooltip.refresh(evt.point, evt);
                                    },
                                    mouseOut: function () {
                                        this.chart.myTooltip.hide();
                                    }
                                }
                            }
                        },
                        yAxis: {
                            title: {
                                text: '<b>' + scope.graphSettings.axes.y.label + '</b>'
                            },
                            //The min value might come from y.domain[0] or y.minValue. Depend on configuratin
                            min: calculatedMinHeight,
                            //Max value not always given.
                            max: calculatedMaxHeight,
                            tickInterval: calculatedYAxistickInterval
                        },
                        xAxis: {
                            title: {
                                enabled: true,
                                text: '<b>' + scope.graphSettings.axes.x.label + '</b>'
                            },
                            type: 'datetime',
                            tickInterval: calculatedXAxistickInterval,
                            gridLineWidth: 0.5,
                            gridLineColor: "#E2E3E1"
                        },
                        tooltip: {
                            useHTML: true,
                            //Function which generate the tooltip as HTML
                            formatter: function () {
                                var entry = this.point.entry; //All the data of the point
                                var tooltipHtml = '<table>';
                                var toolTipFields = scope.graphSettings.onSelect.actionOptions.table.rows;
                                // Create a Set to prevent field duplications
                                var toolTipSet = _.indexBy(toolTipFields, 'label');
                                //For each field given in the tooltip descriptor, we add a line to tooltip with
                                // "label: value". We are using utils.strings.parseValue to evaluate the label and
                                // value from the given string.
                                _.each(toolTipSet, function (toolTipLine) {
                                    var label = utils.strings.parseValue(toolTipLine.label, entry);
                                    var value = '<b>' + utils.strings.parseValue(toolTipLine.value, entry) + '</b>';
                                    tooltipHtml =
                                        tooltipHtml + '<tr><td>' + label + ': </td><td>' + value + '</td></tr>';
                                });
                                tooltipHtml += "</table>";
                                return tooltipHtml;
                            }
                        }
                    };
                    $.extend(true, chartConfig, fsHighChartService.getBasicChartConfiguration());
                    //Create the chart object and save it on the scope
                    scope.$applyAsync(function () {
                        scope.chart = new Highcharts.Chart(chartConfig);
                    });
                    //The data of the chart mostly updated after the chart was rendered, and when clicking refresh.
                    //We are using watch to identify data changes.
                    scope.$watch('model', function (chartData) {
                        ctrl.refreshData(chartData);
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("ScatterPlotWidget").controller("ScatterPlotWidgetController", ["$scope", "colors", function ($scope, colors) {
        }]);
}());

(function () {
    'use strict';
    angular.module("SecurityFeed", ["Utils", "Transforms", "Styles", "Icons", "Widgets", "State"]).run(["$q", "utils",
        "transforms", "styles", "icons", "widgetViews",
        function ($q, utils, transforms, styles, icons, widgetViews) {
            function securityFeedDataParser(view, data, params) {
                var deferred = $q.defer(), viewData = [], promises = [];
                angular.forEach(data, function (item) {
                    //an addition for adding the investigate url to the username accordign to the investigate generator
                    item.investigateLink = typeLinks[item.generator_name] ?
                        utils.strings.parseValue(typeLinks[item.generator_name].url, item) :
                        utils.strings.parseValue("#/user/{{fsId}}/user_overview".url, item);
                    if (view.settings.dataField) {
                        angular.forEach(item[view.settings.dataField], addItem);
                    }
                    else {
                        addItem(item);
                    }
                });
                function addItem(item) {
                    var itemObj = {}, text = "";
                    //dynamicText deals with the case of nested {{ }}. example: {{expression with {{something}} inside
                    // }}
                    var dynamicText;
                    if (view.settings.link) {
                        var links = [];
                        if (item.aggregated) {
                            angular.forEach(item.aggregated, function (entity) {
                                if (!view.settings.linkIfExists || entity[view.settings.linkIfExists]) {
                                    if (view.settings.link.customUrl && view.settings.link.customUrl.map &&
                                        view.settings.link.customUrl.map[item.generator_name]) {
                                        links.push("<a href='" +
                                            utils.strings.parseValue(view.settings.link.customUrl
                                                .map[item.generator_name], entity, params) + "'>" +
                                            utils.strings.parseValue(view.settings.link.text, entity, params) + "</a>");
                                    }
                                    else {
                                        links.push("<a href='" +
                                            utils.strings.parseValue(view.settings.link.url, entity, params) + "'>" +
                                            utils.strings.parseValue(view.settings.link.text, entity, params) + "</a>");
                                    }
                                }
                                else {
                                    links.push(utils.strings.parseValue(view.settings.link.text, entity, params));
                                }
                            });
                            if (item.aggregated.length > 3) {
                                itemObj.linksHtml = utils.arrays.toSentence(links);
                                var multipleName = typeLinks[item.generator_name] &&
                                    typeLinks[item.generator_name].aggregatedObjectName || view.settings.link.name;
                                itemObj.collapsedLinksText = item.aggregated.length + " " + multipleName;
                            }
                            else {
                                text += utils.arrays.toSentence(links);
                            }
                        }
                        else {
                            if (!view.settings.linkIfExists || item[view.settings.linkIfExists]) {
                                if (view.settings.link.customUrl && view.settings.link.customUrl.map &&
                                    view.settings.link.customUrl.map[item.generator_name]) {
                                    links.push("<a href='" +
                                        utils.strings.parseValue(view.settings.link.customUrl.map[item.generator_name], item, params) + "'>" +
                                        utils.strings.parseValue(view.settings.link.text, item, params) + "</a>");
                                }
                                else {
                                    links.push("<a href='" +
                                        utils.strings.parseValue(view.settings.link.url, item, params) + "'>" +
                                        utils.strings.parseValue(view.settings.link.text, item, params) + "</a>");
                                }
                            }
                            else {
                                links.push(utils.strings.parseValue(view.settings.link.text, item, params));
                            }
                            text += utils.arrays.toSentence(links);
                        }
                    }
                    //remove the outer set of curly brackets, so parseValue could deal with the inner curly brackets
                    dynamicText =
                        view.settings.textWithVariables ? item[view.settings.textWithVariables] : view.settings.text;
                    text += utils.strings.parseValue(dynamicText, item, params);
                    //attributeMatches parse the parts with single curly brackets '{something}', which usually comes
                    // from 'cause' in mongo
                    var attributeMatches = text.match(/\{([^\}]+)\}/g);
                    if (attributeMatches) {
                        angular.forEach(attributeMatches, function (attributeMatch) {
                            var property = attributeMatch.match(/^\{([^\}]+)/)[1], propertyAttributes, html = [], 
                            //logical '&&' returns the first falsy var (or just the latest one is they all truthy)
                            itemAttributes = item.aggregated && item.aggAttributes || item.attributes;
                            if (itemAttributes) {
                                propertyAttributes = [];
                                angular.forEach(itemAttributes[property], function (attribute) {
                                    if (!~propertyAttributes.indexOf(attribute)) {
                                        propertyAttributes.push(attribute);
                                    }
                                });
                                var url;
                                if (view.settings.attributes && view.settings.attributes.url) {
                                    url = view.settings.attributes.url.map ?
                                        view.settings.attributes.url.map[item.generator_name] :
                                        view.settings.attributes.url;
                                }
                                if (url) {
                                    angular.forEach(propertyAttributes, function (attribute) {
                                        html.push("<a href='" +
                                            utils.strings.parseValue(url, { attribute: attribute }, params) + "'>" +
                                            attribute + "</a>");
                                    });
                                }
                                else {
                                    angular.forEach(propertyAttributes, function (attribute) {
                                        html.push("<span>" + attribute + "</span>");
                                    });
                                }
                            }
                            text = text.replace(attributeMatch, utils.arrays.toSentence(html));
                        });
                    }
                    itemObj.id = item.id;
                    itemObj.text = text.replace(/([^\.])$/, "$1.");
                    itemObj.dismissed = item.dismissed;
                    itemObj.flag = item.flag;
                    if (view.settings.note) {
                        itemObj.note = utils.strings.parseValue(view.settings.note, item, params);
                    }
                    if (view.settings.icon) {
                        promises.push(icons.getIcon(view.settings.icon, item).then(function (icon) {
                            itemObj.icon = icon;
                        }));
                    }
                    if (view.settings.allowComments) {
                        itemObj.commentsCount = item.commentsCount;
                        itemObj.comments = item.comments;
                        itemObj.loadedComments = false;
                    }
                    if (!item.aggregated || !typeLinks[item.generator_name] ||
                        typeLinks[item.generator_name].allowAggregated !== false) {
                        if (!!(itemObj.link = angular.copy(typeLinks[item.generator_name]))) {
                            var linkData = angular.copy(item);
                            if (item.aggregated) {
                                linkData.fsId = [];
                                linkData.displayName = [];
                                linkData.userCount = 0;
                                item.aggregated.forEach(function (user) {
                                    // Update array of fsIds
                                    if (linkData.fsId.indexOf(user.fsId) < 0) {
                                        linkData.fsId.push(user.fsId);
                                        // Increment number of users
                                        linkData.userCount++;
                                    }
                                    // Update array of displayNames
                                    if (linkData.displayName.indexOf(user.displayName) < 0) {
                                        linkData.displayName.push(user.displayName);
                                    }
                                });
                                // Concatenate fsIds
                                linkData.fsId = linkData.fsId.join(",");
                                // Concatenate displayNames
                                linkData.displayName = linkData.displayName.join(",");
                                // User count is not needed if there's only 1 user
                                if (linkData.userCount === 1) {
                                    delete linkData.userCount;
                                }
                            }
                            itemObj.link.href = utils.strings.parseValue(itemObj.link.url, linkData, params);
                            itemObj.link.text = utils.strings.parseValue(itemObj.link.text, linkData, params);
                        }
                    }
                    viewData.push(itemObj);
                }
                if (promises.length) {
                    $q.all(promises).then(function () {
                        deferred.resolve(viewData);
                    });
                    return deferred.promise;
                }
                return viewData;
            }
            var typeLinks = {
                VpnGeoHoppingNotificationGenerator: {
                    url: "#/packages/geo_hopping?user={{fsId}}&user_label={{displayName}}&start=" +
                        "{{:sinceNow:valueOf:-14d}}&end={{:sinceNow:valueOf}}&user_count={{userCount}}",
                    text: "Go to Geo-Hopping package"
                },
                VPNBruteForce: {
                    "text": "Investigate {{displayName}}'s VPN events"
                },
                UserCreatedEnabledDeletedGenerator: {
                    "url": "#/d/explore/users?filters=users.id%3D{{fsId}}",
                    "text": "Investigate user {{displayName}}",
                    "allowAggregated": false,
                    "notification_ts": "{{ts:date}}"
                },
                AboutToExpireGenerator: {
                    "url": "#/d/explore/users?filters=users.id%3D{{fsId}}",
                    "text": "Investigate user {{displayName}}",
                    "allowAggregated": false,
                    "notification_ts": "{{ts:date}}"
                },
                ScoreShotUpGenerator: {
                    "url": "#/d/explore/users?filters=users.id%3D{{fsId}}",
                    "text": "Investigate user {{displayName}}",
                    "allowAggregated": false,
                    "notification_ts": "{{ts:date}}"
                },
                UserHasNewAdminGroupGenerator: {
                    "url": "#/d/explore/users?filters=users.id%3D{{fsId}}",
                    "text": "Investigate user {{displayName}}",
                    "allowAggregated": false,
                    "notification_ts": "{{ts:date}}"
                },
                VpnOverlapNotification: {
                    "url": "#/d/explore/vpn_session?filters=vpn_session.username%3D{{attributes.username}}," +
                        "vpn_session.country%3DReserved%20Range&default_filters=vpn_session.session_time_utc%3D:" +
                        "{{attributes.start_date::date:unixtimestamp}}::{{attributes.end_date::date:unixtimestamp}}," +
                        "vpn_session.session_score%3D%3E%3D0&tableview_fields=username,source_ip,start_time,end_time," +
                        "country,city,read_bytes,write_bytes,duration,session_score",
                    "text": "Investigate user {{displayName}}",
                    "allowAggregated": false,
                    "notification_ts": "{{ts:date}}"
                }
            };
            widgetViews.registerView("securityFeed", { dataParser: securityFeedDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("SecurityFeed").controller("SecurityFeedController", ["$scope", "securityFeed", "eventBus", "state", "utils",
        function ($scope, securityFeed, eventBus, state, utils) {
            function onParamsChange(e, params) {
                var availableParams = ["start", "end", "userId", "userName", "showDismissed", "type"];
                setParams(params);
                for (var paramName in params) {
                    if (params.hasOwnProperty(paramName)) {
                        if (~availableParams.indexOf(paramName)) {
                            $scope.widget.refresh();
                            return;
                        }
                    }
                }
            }
            function setParams(params) {
                if (params.userId !== undefined && params.userName !== undefined) {
                    $scope.userFilter =
                        params.userId && params.userName ? { value: params.userId, label: params.userName } : null;
                }
                if (params.start !== undefined) {
                    $scope.startDate =
                        params.start ? utils.date.getMoment(params.start).format("YYYY-MM-DD") : null;
                }
                if (params.end !== undefined) {
                    $scope.endDate = params.end ? utils.date.getMoment(params.end).format("YYYY-MM-DD") : null;
                }
                if (params.showDismissed !== undefined) {
                    $scope.showDismissed = !!params.showDismissed;
                }
                if (params.type !== undefined) {
                    $scope.typeFilter = params.type;
                }
            }
            function init() {
                setParams(state.currentParams);
            }
            $scope.startDate = null;
            $scope.endDate = null;
            $scope.generatorTypes = securityFeed.generatorTypes;
            $scope.typeFilter = $scope.generatorTypes[0].id;
            $scope.showDismissed = false;
            // The optional names and their display names
            $scope.flagsName = { "FP": "Not Interesting", "TP": "Nailed it!" };
            // options for flags drop-down
            $scope.flagOptions = [
                {
                    "value": "FP",
                    "label": $scope.flagsName.FP
                },
                {
                    "value": "TP",
                    "label": $scope.flagsName.TP
                }
            ];
            // options for drop down, including remove-flag option
            $scope.flagOptionsWithRemove =
                [{
                        "value": "",
                        "label": "Remove Flag"
                    }].concat($scope.flagOptions);
            $scope.$on("$destroy", function () {
                eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
            });
            $scope.showComments = function (item) {
                if (!item.loadedComments) {
                    item.showComments = true;
                    securityFeed.setNotificationComments(item);
                }
                else {
                    item.showComments = !item.showComments;
                }
            };
            // Show/Hide the flags drop down
            $scope.showFlags = function (item) {
                item.showFlags = !item.showFlags;
            };
            $scope.saveNewComment = function (notification, replyTo) {
                if (notification.newComment) {
                    securityFeed.addComment(notification, replyTo, notification.newComment).then(function (comment) {
                        notification.newComment = null;
                        notification.comments.splice(0, 0, comment);
                        notification.commentsCount++;
                    });
                }
            };
            $scope.saveComment = function (notification, message, comment) {
                securityFeed.addComment(notification, comment.id, message).then(function (savedComment) {
                    if (!comment.children) {
                        comment.children = [];
                    }
                    comment.children.splice(0, 0, savedComment);
                    comment.reply = null;
                    comment.showReply = null;
                    notification.commentsCount++;
                });
            };
            // Send request (using the service) to save the flag in the server
            $scope.saveFlag = function (notification) {
                // send request to server
                securityFeed.saveFlag(notification, notification.flag)
                    .then(function () {
                    // hide drop down
                    notification.showFlags = false;
                });
            };
            $scope.dismiss = function (notification) {
                if (confirm("Are you sure you wish to dismiss this notification?")) {
                    securityFeed.dismiss(notification).then(function () {
                        $scope.view.data.splice($scope.view.data.indexOf(notification), 1);
                        $scope.widget.totalResults--;
                    });
                }
            };
            $scope.undismiss = function (notification) {
                securityFeed.undismiss(notification).then(function () {
                    notification.dismissed = false;
                });
            };
            $scope.onTypeSelect = function (type) {
                $scope.setParams({ type: type, page: null });
            };
            $scope.onStartDateChange = function (date) {
                $scope.setParams({ start: date ? Math.floor(date.valueOf() / 1000) : null, page: null });
            };
            $scope.clearStartDate = function () {
                $scope.setParams({ start: null });
                $scope.startDate = null;
            };
            $scope.onEndDateChange = function (date) {
                $scope.setParams({ end: date ? Math.floor(date / 1000) : null, page: null });
            };
            $scope.clearEndDate = function () {
                $scope.setParams({ end: null });
                $scope.endDate = null;
            };
            $scope.setUserFilter = function (userId, userDisplayName) {
                $scope.userFilter = { value: userId, label: userDisplayName };
                $scope.setParams({ userId: userId, userName: userDisplayName, page: null });
            };
            $scope.clearUser = function () {
                $scope.userFilter = null;
                $scope.setParams({ userId: null, userName: null });
            };
            $scope.changeShowDismissed = function () {
                $scope.setParams({ showDismissed: !$scope.showDismissed ? 1 : null, page: null });
            };
            $scope.userSearchSettings = securityFeed.userSearchSettings();
            eventBus.subscribe("dashboardParamsChange", onParamsChange);
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("SecurityFeed").factory("securityFeed", ["reports", "comments", "utils", function (reports, comments, utils) {
            return {
                addComment: function (notification, replyTo, message) {
                    return reports.runReport("notifications.addComment", {
                        notificationId: notification.id,
                        message: message,
                        replyTo: replyTo
                    }).then(function (results) {
                        return results.data[0].comments.pop();
                    });
                },
                saveFlag: function (notification, flag) {
                    return reports.runReport("notifications.flag_notification", {
                        notificationId: notification.id,
                        flag: flag
                    }).then(function (results) {
                        return results;
                    });
                },
                getNotifications: function (options) {
                    var reportParams = {};
                    if (options.after) {
                        reportParams.start = utils.date.toUnixTimestamp(options.after);
                    }
                    if (options.before) {
                        var beforeDate = utils.date.getMoment(options.before).toDate();
                        if (!beforeDate.getHours() && !beforeDate.getMinutes()) {
                            beforeDate.setDate(beforeDate.getDate() + 1);
                        }
                        reportParams.end = utils.date.toUnixTimestamp(beforeDate);
                    }
                    reportParams.notifications_events_dates =
                        (reportParams.start || "null") + "," + (reportParams.end || "null");
                    if (options.userIds) {
                        reportParams.userId =
                            angular.isArray(options.userIds) ? options.userIds.join(",") : options.userIds;
                    }
                    reportParams.showDismissed = options.showDismissed;
                    if (options.types) {
                        reportParams.type = angular.isArray(options.types) ? options.types.join(",") : options.types;
                    }
                    reportParams.size = options.maxResults ? options.maxResults : 9999;
                    if (options.page) {
                        reportParams.page = options.page;
                    }
                    return reports.runReportById("notifications", reportParams, true).then(function (results) {
                        return results.data;
                    });
                },
                dismiss: function (notification) {
                    return reports.runReport("notifications.dismiss_notification", {
                        notificationId: notification.id
                    });
                },
                undismiss: function (notification) {
                    return reports.runReport("notifications.undismiss_notification", {
                        notificationId: notification.id
                    });
                },
                get generatorTypes() {
                    return [
                        { name: "(Show all)", id: null },
                        { name: "Geo-hopping VPN sessions", "id": "VpnGeoHoppingNotificationGenerator" },
                        { name: "New VPN source country", "id": "NewCountryInVPNGenerator" },
                        { name: "User score shot up", "id": "ScoreShotUpGenerator" },
                        { name: "User status changed", "id": "UserCreatedEnabledDeletedGenerator" },
                        { name: "VPN brute force", "id": "VPNBruteForce" }
                    ];
                },
                userSearchSettings: function () {
                    return {
                        "reports": [
                            {
                                "dataSource": "api",
                                "endpoint": {
                                    "entity": "user",
                                    "method": "search"
                                },
                                "options": {
                                    "count": 10
                                },
                                "fields": {
                                    "name": { "type": "string" },
                                    "id": { "type": "string" }
                                },
                                "params": [
                                    {
                                        "field": "prefix",
                                        "type": "string",
                                        "dashboardParam": "term"
                                    }
                                ],
                                mock_data: "user_search"
                            }
                        ],
                        "search": {
                            "dataEntity": "users",
                            "dataEntityField": "id",
                            "labelField": "display_name"
                        },
                        "resultField": "name",
                        "value": "{{id}}",
                        "showValueOnSelect": true,
                        "placeholder": "Filter by user"
                    };
                },
                setNotificationComments: function (notification) {
                    return reports.runReport("notifications.notification", { notificationId: notification.id }).then(function (result) {
                        var notificationData = result.data[0];
                        notification.comments = comments.listToTree(notificationData.comments);
                        notification.loadedComments = true;
                        return notification;
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TagsWidget", ["Tags", "Widgets"]).run(["tags", "widgetViews", function (tags, widgetViews) {
            function tagsDataParser(view, data, params) {
                if (!data || !data.length) {
                    return null;
                }
                return tags.getTags(view.settings.tags, data[0]);
            }
            widgetViews.registerView("tags", { dataParser: tagsDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("TimelineWidget", ["Utils", "ChartWidgets", "Widgets", "Events"]).run(["widgetViews",
        function (widgetViews) {
            function timelineDataParser(view, data) {
                var viewData = data;
                if (view.settings.legend) {
                    viewData.legend = view.settings.legend;
                }
                return viewData;
            }
            widgetViews.registerView("timeline", { dataParser: timelineDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("TimelineWidget").directive("timeline", ["$rootScope", "$window", "utils", "$parse", "events", "config",
        function ($rootScope, $window, utils, $parse, events, config) {
            return {
                template: "<div class='timeline' style='width: 100%; height: 100%'></div>",
                restrict: 'E',
                scope: true,
                replace: true,
                link: function postLink(scope, element, attrs) {
                    var data, settings, options, defaultOptions = {
                        height: 300,
                        tooltipLineHeight: 20
                    }, isInit, axisHeight = 23, rectHeight = 18, seriesMargin = 4, seriesHeight = rectHeight + seriesMargin * 2, currentPage = 1, pageFunc = attrs.page ? $parse(attrs.page) : null, isPaging, timespanMaxWidth = 0.5, TIME_DISPLAY_HEIGHT = 15;
                    var svg, margin = { top: 0, right: 20, bottom: 0, left: 0 }, width, height, chartWidth, svgHeight, lastRefreshTime = new Date(), lastRefreshTimeLine, tooltip, tooltipRect, timeDisplay, timeDisplayText, timeDisplayVisible, hoveredDot, labelsWidth, labelsContainer, x, xAxis, xAxisElement, selectedTimespan, dataContainer, timeMinMax, seriesWidth, timeDiff, firstTimespanPosition, earliestTimespanDate, xField1, xField2, colorField, totalSeriesHeight, zoomBehavior, seriesBackground;
                    function drawChart() {
                        function onMouseLeave() {
                            element.off("mousemove.timeDisplay", onMouseMove);
                            element.off("mouseleave.timeDisplay", onMouseLeave);
                            timeDisplay[0][0].style.display = "none";
                            timeDisplayVisible = false;
                        }
                        function onMouseMove(e) {
                            if (e.offsetX < labelsWidth) {
                                if (timeDisplayVisible) {
                                    timeDisplayVisible = false;
                                    timeDisplay[0][0].style.display = "none";
                                }
                            }
                            else if (e.target.nodeName !== "text") {
                                if (!timeDisplayVisible) {
                                    timeDisplay[0][0].style.removeProperty("display");
                                    timeDisplayVisible = true;
                                }
                                timeDisplay.attr("transform", "translate(" + e.offsetX + ", 0)");
                                timeDisplayText.text(utils.date.getMoment(x.invert(e.offsetX -
                                    labelsWidth)).format("MMM DD, HH:mm:ss"));
                            }
                        }
                        function zoom() {
                            var translateX = d3.event.translate[0];
                            dataContainer.attr("transform", "translate(" + translateX + ", 0) scale(" + d3.event.scale + ", 1)");
                            var timeDiffScaled = timeDiff / d3.event.scale, timeStart = +timeMinMax[0] - timeDiff * (translateX / seriesWidth / d3.event.scale);
                            x.domain([
                                utils.date.getMoment(timeStart).toDate(),
                                utils.date.getMoment(timeStart + timeDiffScaled).toDate()
                            ]);
                            xAxisElement.call(xAxis);
                            lastRefreshTimeLine.attr("transform", "translate(" + x(lastRefreshTime) + ", 0)");
                            if (!isPaging && translateX / d3.event.scale * -1 < firstTimespanPosition) {
                                loadPage();
                            }
                        }
                        function setLastRefreshTime() {
                            lastRefreshTime = new Date();
                            lastRefreshTimeLine.attr("transform", "translate(" + x(lastRefreshTime) + ", 0)");
                        }
                        function loadPage() {
                            isPaging = true;
                            pageFunc(scope, { $firstTime: earliestTimespanDate });
                        }
                        function createSeries() {
                            dataContainer = svg.insert("g", ".axis")
                                .attr("class", "timespans-container")
                                .attr("transform", "translate(" + labelsWidth + ", 0)");
                            lastRefreshTimeLine = dataContainer.append("line")
                                .attr("transform", "translate(" + x(lastRefreshTime) + ", 0)")
                                .attr("x1", 0)
                                .attr("x2", 0)
                                .attr("y1", 0)
                                .attr("y2", totalSeriesHeight)
                                .attr("stroke", "#ddd")
                                .attr("stroke-width", 2);
                            var lines = svg.append("g");
                            seriesBackground = dataContainer.append("g")
                                .attr("clip-path", "url(#seriesClipPath)")
                                .call(zoomBehavior = d3.behavior.zoom().scaleExtent([0.1, 60])
                                .on("zoom", zoom));
                            seriesBackground.append("rect")
                                .attr("height", totalSeriesHeight)
                                .attr("width", "100%")
                                .attr("fill", "Transparent")
                                .attr("class", "zoom-area");
                            dataContainer = seriesBackground.append("g");
                            dataContainer.selectAll("g")
                                .data(data).enter()
                                .append("g")
                                .attr("class", function (d, i) {
                                return "series_" + i;
                            })
                                .attr("transform", function (d, i) {
                                return "translate(0, " + (i * seriesHeight) + ")";
                            });
                            lines.selectAll("line").data(data)
                                .enter().append("line")
                                .attr("transform", function (d, i) {
                                return "translate(0, " + (i * seriesHeight) + ")";
                            })
                                .attr("x1", 0)
                                .attr("x2", "100%")
                                .attr("y1", 0)
                                .attr("y2", 0)
                                .attr("stroke-width", "1")
                                .attr("stroke", "#ddd");
                            addTimespans(data);
                        }
                        function addTimespans(data) {
                            angular.forEach(data, function (series, i) {
                                var seriesContainer = dataContainer.selectAll(".series_" + i);
                                seriesContainer[0][0].innerHTML = "";
                                var timespansData;
                                if (settings.series.timeSpansSeries) {
                                    timespansData = [];
                                    angular.forEach(series[settings.series.timeSpansSeries], function (timeSpansArrayObject) {
                                        angular.forEach(timeSpansArrayObject[settings.series.timeSpans], function (timespan) {
                                            timespan._groupName =
                                                timeSpansArrayObject[settings.series
                                                    .timeSpansSeriesGroupName];
                                            timespansData.push(timespan);
                                        });
                                    });
                                }
                                else if (settings.series.timeSpans) {
                                    timespansData = series[settings.series.timeSpans];
                                }
                                else if (settings.series.isSingleSeries) {
                                    timespansData = series._timespans;
                                }
                                else {
                                    timespansData = [series];
                                }
                                seriesContainer.selectAll(".timespan")
                                    .data(timespansData)
                                    .enter().append("rect")
                                    .attr("class", "eventRect")
                                    .attr("height", rectHeight)
                                    .attr("width", function (d) {
                                    if (!d[xField2] || !d[xField1]) {
                                        return timespanMaxWidth;
                                    }
                                    return Math.max(timespanMaxWidth, x(utils.date.getMoment(d[xField2]).toDate()) -
                                        x(utils.date.getMoment(d[xField1]).toDate()));
                                })
                                    .attr("transform", function (d) {
                                    var position = x(utils.date.getMoment(d[xField1]).toDate());
                                    if (firstTimespanPosition === undefined ||
                                        position < firstTimespanPosition) {
                                        firstTimespanPosition = position;
                                    }
                                    return "translate(" + position + ", " + seriesMargin + ")";
                                })
                                    .attr("fill", function (d) {
                                    if (!d[xField2] && settings.colorMap._missingData) {
                                        return settings.colorMap._missingData;
                                    }
                                    return settings.colorMap && colorField &&
                                        settings.colorMap[d[colorField]] || settings.colorMap._default;
                                });
                            });
                            currentPage++;
                        }
                        // Get the relevant timeSpans
                        function getTimeSpanSeriesName(settings) {
                            if (settings.series.timeSpansSeries) {
                                return settings.series.timeSpansSeries;
                            }
                            return settings.series.timeSpans || "_timespans";
                        }
                        function getEarliestTimespanDate() {
                            if (settings.series.timeSpansSeries || settings.series.timeSpans ||
                                settings.series.isSingleSeries) {
                                var timeSpanSeriesName = getTimeSpanSeriesName(settings);
                                earliestTimespanDate = d3.min(data, function (d) {
                                    var timeSpansData = d[timeSpanSeriesName];
                                    return d3.min(timeSpansData, function (d2) {
                                        if (settings.series.timeSpansSeries) {
                                            return d3.min(d2[settings.series.timeSpans], function (d3) {
                                                return utils.date.getMoment(d3[xField1]).toDate();
                                            });
                                        }
                                        else {
                                            return utils.date.getMoment(d2[xField1]).toDate();
                                        }
                                    });
                                });
                            }
                            else {
                                earliestTimespanDate = d3.min(data, function (d) {
                                    return utils.date.getMoment(d[xField1]).toDate();
                                });
                            }
                            return earliestTimespanDate;
                        }
                        function createAxes() {
                            labelsContainer = svg.append("g");
                            labelsContainer.selectAll(".seriesLabel")
                                .data(data)
                                .enter().append("text")
                                .attr("class", "seriesLabel")
                                .text(function (d) {
                                return d[settings.series.name];
                            })
                                .attr("text-anchor", "end")
                                .attr("height", seriesHeight)
                                .attr("transform", function (d, i) {
                                return "translate(0, " + ((0.5 + i) * seriesHeight + 4) + ")";
                            });
                            labelsWidth = d3.max(labelsContainer.selectAll(".seriesLabel")[0], function (node) {
                                return node.clientWidth;
                            });
                            labelsContainer.attr("transform", "translate(" + labelsWidth + ", 0)");
                            labelsWidth += 10; // Padding for labels
                            var d3timeScale = config.alwaysUtc ? d3.time.scale.utc : d3.time.scale;
                            x = d3timeScale()
                                .range([0, seriesWidth = chartWidth - labelsWidth + margin.left + margin.right]);
                            xAxis = d3.svg.axis()
                                .scale(x)
                                .orient("bottom")
                                .tickSize(6, 0);
                            var xDomain1 = getEarliestTimespanDate(), xDomain2;
                            if (settings.series.timeSpansSeries || settings.series.timeSpans ||
                                settings.series.isSingleSeries) {
                                var timeSpanSeriesName = getTimeSpanSeriesName(settings);
                                if (settings.useLastRefreshTimeForX) {
                                    xDomain2 = utils.date.getMoment('1hours').toDate();
                                }
                                else {
                                    xDomain2 = d3.max(data, function (d) {
                                        return d3.max(d[timeSpanSeriesName], function (d2) {
                                            if (settings.series.timeSpansSeries) {
                                                return d3.max(d2[settings.series.timeSpans], function (d3) {
                                                    return utils.date.getMoment(d3[xField2] ||
                                                        d3[xField1]).toDate();
                                                });
                                            }
                                            else {
                                                return utils.date.getMoment(d2[xField2] || d2[xField1]).toDate();
                                            }
                                        });
                                    });
                                }
                            }
                            else {
                                xDomain2 = d3.max(data, function (d) {
                                    return utils.date.getMoment(d[xField2] || d[xField1]).toDate();
                                });
                            }
                            x.domain(timeMinMax = [xDomain1, xDomain2]);
                            timeDiff = xDomain2 - xDomain1;
                            xAxisElement = svg.append("g")
                                .attr("class", "x axis")
                                .attr("transform", "translate(" + labelsWidth + "," + (totalSeriesHeight + TIME_DISPLAY_HEIGHT - 15) +
                                ")")
                                .call(xAxis);
                            xAxisElement
                                .append("text")
                                .attr("class", "label")
                                .attr("x", chartWidth)
                                .attr("y", -6)
                                .style("text-anchor", "end");
                        }
                        function createTooltip() {
                            tooltip = svg.append("g")
                                .attr("style", "display: none");
                            tooltipRect = tooltip.append("rect")
                                .attr("width", 100)
                                .attr("height", 50)
                                .attr("fill", "#333333")
                                .attr("opacity", "0.8");
                            element.on("mouseover", ".eventRect", function (e) {
                                var dot = e.target;
                                if (dot !== hoveredDot) {
                                    if (hoveredDot) {
                                        hoveredDot.style.fill = hoveredDot.color;
                                    }
                                    hoveredDot = dot;
                                    hoveredDot.color = hoveredDot.style.fill;
                                    hoveredDot.style.fill = "#333333";
                                }
                                setTooltipText(getTooltipText(dot));
                                showTooltip();
                                window.addEventListener("mousemove", tooltipMoveHandler);
                            });
                            element.on("mouseout", ".eventRect", function (e) {
                                cancelSelection(e.target.__data__);
                            });
                        }
                        function createTimeDisplay() {
                            timeDisplay = svg.append("g").attr("style", "display: none");
                            timeDisplayText = timeDisplay.append("text")
                                .attr("fill", "#333")
                                .attr("text-anchor", "middle")
                                .attr("transform", "translate(0, -5)");
                            timeDisplay.append("line")
                                .attr("x1", "0")
                                .attr("x2", "0")
                                .attr("y1", "0")
                                .attr("y2", totalSeriesHeight)
                                .attr("stroke", "#ccc")
                                .attr("stroke-width", 1);
                        }
                        function cancelSelection() {
                            hideTooltip();
                        }
                        function getTooltipText(dot) {
                            var dotData = dot.__data__;
                            return utils.strings.parseValue(settings.tooltip, dotData);
                        }
                        function setTooltipText(text) {
                            var tspanTexts = text.split("|");
                            tooltip.selectAll("text").remove();
                            tooltip.selectAll("text")
                                .data(tspanTexts)
                                .enter()
                                .append("text")
                                .text(function (d) {
                                return d;
                            })
                                .attr("fill", "White")
                                .attr("font-size", "14px")
                                .attr("transform", function (d, i) {
                                return "translate(15, " + (20 + options.tooltipLineHeight * i) + ")";
                            });
                            tooltipRect.attr("width", d3.max(tooltip[0][0].childNodes, function (d) {
                                return d.clientWidth;
                            }) + 30);
                            tooltipRect.attr("height", options.tooltipLineHeight * tspanTexts.length + 15);
                        }
                        function hideTooltip() {
                            tooltip[0][0].style.display = "none";
                            hoveredDot.style.fill = hoveredDot.color;
                            hoveredDot = null;
                        }
                        function showTooltip() {
                            clearTimeout(mouseOutTimeout);
                            tooltip[0][0].style.removeProperty("display");
                        }
                        function tooltipMoveHandler(e) {
                            var boundingClientRect = element[0].getBoundingClientRect();
                            setTooltipPosition({
                                x: (e.x || e.clientX) - boundingClientRect.left,
                                y: (e.y || e.clientY) - boundingClientRect.top
                            });
                        }
                        function setTooltipPosition(position) {
                            var tooltipPositionX = position.x + 5, tooltipPositionY = position.y - TIME_DISPLAY_HEIGHT, tooltipWidth = parseInt(tooltipRect[0][0].getAttribute("width")), tooltipHeight = parseInt(tooltipRect[0][0].getAttribute("height"));
                            if (tooltipPositionX + tooltipWidth > element[0].clientWidth) {
                                tooltipPositionX = position.x - tooltipWidth - 5;
                                if (tooltipPositionX < 0) {
                                    tooltipPositionX = 0;
                                }
                            }
                            if (tooltipPositionY + tooltipHeight > element[0].clientHeight - 20) {
                                tooltipPositionY = position.y - tooltipHeight - 5;
                                if (tooltipPositionY < 0) {
                                    tooltipPositionY = 0;
                                }
                            }
                            tooltip.attr("transform", "translate(" + tooltipPositionX + "," + tooltipPositionY + ")");
                        }
                        var mouseOutTimeout;
                        if (!data || !settings) {
                            return;
                        }
                        if (settings.series.isSingleSeries) {
                            data = [{ _timespans: data }];
                        }
                        if (isInit) {
                            var previousEarliestTimespanDate = earliestTimespanDate;
                            x.domain(timeMinMax);
                            addTimespans(data);
                            getEarliestTimespanDate();
                            if (earliestTimespanDate.valueOf() !== previousEarliestTimespanDate.valueOf()) {
                                isPaging = false;
                            }
                            setLastRefreshTime();
                            zoomBehavior.event(seriesBackground);
                            return;
                        }
                        if (settings.data) {
                            if (angular.isArray(data)) {
                                data = data[0][settings.data];
                            }
                            else {
                                data = data[settings.data];
                            }
                        }
                        element.css({
                            width: "auto"
                        });
                        element.css({
                            width: element.width() - 20
                        });
                        totalSeriesHeight = seriesHeight * data.length;
                        if (!element.height()) {
                            element.css("height", totalSeriesHeight + axisHeight + TIME_DISPLAY_HEIGHT);
                        }
                        width = element.width();
                        height = element.height();
                        chartWidth = width - margin.left - margin.right;
                        svgHeight = height - margin.top - margin.bottom;
                        element.empty();
                        element.off();
                        svg = d3.select(element[0]).append("svg")
                            .attr("width", chartWidth + margin.left + margin.right)
                            .attr("height", svgHeight);
                        svg.append('svg:defs').append('svg:clipPath')
                            .attr("id", "seriesClipPath")
                            .append("rect")
                            .attr("width", width)
                            .attr("height", totalSeriesHeight);
                        svg = svg.append("g")
                            .attr("transform", "translate(" + margin.left + "," + TIME_DISPLAY_HEIGHT + ")");
                        xField1 = settings.series.timeStart;
                        xField2 = settings.series.timeEnd;
                        colorField = settings.color;
                        createTimeDisplay();
                        createAxes();
                        createSeries();
                        createTooltip();
                        svg[0][0].appendChild(labelsContainer[0][0]);
                        if (settings.onSelect) {
                            element.on("click", ".eventRect", function (e) {
                                events.triggerDashboardEvent(settings.onSelect, e.target.__data__);
                                if (selectedTimespan) {
                                    selectedTimespan.classList.remove("selected");
                                }
                                selectedTimespan = e.target;
                                selectedTimespan.classList.add("selected");
                            });
                        }
                        element.on("mouseenter.timeDisplay", function (e) {
                            if (e.offsetX < labelsWidth) {
                                timeDisplay[0][0].style.removeProperty("display");
                                timeDisplayVisible = true;
                            }
                            element.on("mouseleave.timeDisplay", onMouseLeave)
                                .on("mousemove.timeDisplay", onMouseMove);
                        });
                        if (!isInit) {
                            isInit = true;
                        }
                    }
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                    scope.$watch(attrs.ngModel, function (chartData) {
                        data = chartData;
                        drawChart();
                    });
                    scope.$watch(attrs.settings, function (value) {
                        settings = value;
                        options = angular.extend({}, defaultOptions, settings.options);
                        drawChart();
                    });
                    $window.addEventListener("resize", drawChart);
                    scope.$on("resize", drawChart);
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TimelineWidget").directive("timelinePoints", ["$rootScope", "$window", "utils", "$parse", "events", "config",
        function ($rootScope, $window, utils, $parse, events, config) {
            return {
                template: "<div class='timeline' style='width: 100%; height: 100%'></div>",
                restrict: 'E',
                scope: true,
                replace: true,
                link: function postLink(scope, element, attrs) {
                    var data, settings, options, defaultOptions = {
                        height: 300,
                        tooltipLineHeight: 20
                    }, isInit, axisHeight = 23, rectHeight = 18, seriesMargin = 4, seriesHeight = rectHeight + seriesMargin * 2, currentPage = 1, pageFunc = attrs.page ? $parse(attrs.page) : null, isPaging, TIME_DISPLAY_HEIGHT = 15, LEGEND_MARGIN = 10, LEGEND_HEIGHT = 20, LEGEND_ITEM_PADDING = 20;
                    var svg, mask, margin = { top: 0, right: 20, bottom: 30, left: 0 }, width, height, chartWidth, svgHeight, lastRefreshTime = new Date(), lastRefreshTimeLine, timeDisplay, timeDisplayText, timeDisplayVisible, labelsWidth, labelsContainer, x, xAxis, xAxisElement, lineElements, selectedTimespan, dataContainer, timeMinMax, seriesWidth, timeDiff, firstTimespanPosition, earliestTimespanDate, xField, colorField, totalSeriesHeight, points, color, typesCount = {};
                    function onResize() {
                        svg.attr("width", "100%");
                        //element.css("width", "100%");
                        width = element.width();
                        height =
                            totalSeriesHeight + axisHeight + TIME_DISPLAY_HEIGHT + margin.bottom + LEGEND_MARGIN +
                                LEGEND_HEIGHT;
                        chartWidth = width - margin.left - margin.right;
                        x.range([0, seriesWidth = chartWidth - labelsWidth + margin.left + margin.right]);
                        svg.attr("width", width);
                        mask.attr("width", width);
                        points.attr("transform", function (d) {
                            return "translate(" + x(utils.date.getMoment(d[xField]).toDate()) + ", " +
                                seriesHeight / 2 + ")";
                        });
                        xAxisElement.call(xAxis);
                        xAxisElement.attr("x", chartWidth);
                        lineElements.attr("x2", width);
                    }
                    function getColorScale(scaleName) {
                        if (scaleName && angular.isObject(scaleName) && scaleName.map) {
                            var defaultColor = scaleName.map._default || "#000000", field = scaleName.field, map = scaleName.map;
                            return function (d) {
                                var value = d[field], mapValue = map[value];
                                if (!value || !mapValue) {
                                    return defaultColor;
                                }
                                return mapValue;
                            };
                        }
                        if (scaleName) {
                            if (scaleName === "score") {
                                return d3.scale.linear().domain([0, 50, 51, 80, 90, 100]).range(['#80BFF0',
                                    '#80BFF0', '#F1CC37', '#F59925', '#D77576', '#D77576']);
                            }
                            var d3Scale = d3.scale[scaleName];
                            if (d3Scale) {
                                return d3Scale();
                            }
                        }
                        return d3.scale.category20c();
                    }
                    function drawChart() {
                        function onMouseLeave() {
                            element.off("mousemove.timeDisplay", onMouseMove);
                            element.off("mouseleave.timeDisplay", onMouseLeave);
                            timeDisplay[0][0].style.display = "none";
                            timeDisplayVisible = false;
                        }
                        function onMouseMove(e) {
                            if (e.offsetX < labelsWidth) {
                                if (timeDisplayVisible) {
                                    timeDisplayVisible = false;
                                    timeDisplay[0][0].style.display = "none";
                                }
                            }
                            else if (e.target.nodeName !== "text") {
                                if (!timeDisplayVisible) {
                                    timeDisplay[0][0].style.removeProperty("display");
                                    timeDisplayVisible = true;
                                }
                                timeDisplay.attr("transform", "translate(" + e.offsetX + ", 0)");
                                timeDisplayText.text(utils.date.getMoment(x.invert(e.offsetX -
                                    labelsWidth)).format("MMM DD, HH:mm:ss"));
                            }
                        }
                        function zoom() {
                            var translateX = d3.event.translate[0];
                            points.attr("transform", function (d) {
                                return "translate(" + x(utils.date.getMoment(d[xField]).toDate()) + ", " +
                                    seriesHeight / 2 + ")";
                            });
                            var timeDiffScaled = timeDiff / d3.event.scale, timeStart = +timeMinMax[0] - timeDiff * (translateX / seriesWidth / d3.event.scale);
                            x.domain([
                                utils.date.getMoment(timeStart).toDate(),
                                utils.date.getMoment(timeStart + timeDiffScaled).toDate()
                            ]);
                            xAxisElement.call(xAxis);
                            lastRefreshTimeLine.attr("transform", "translate(" + x(lastRefreshTime) + ", 0)");
                            if (!isPaging && translateX / d3.event.scale * -1 < firstTimespanPosition) {
                                loadPage();
                            }
                        }
                        function setLastRefreshTime() {
                            lastRefreshTime = new Date();
                            lastRefreshTimeLine.attr("transform", "translate(" + x(lastRefreshTime) + ", 0)");
                        }
                        function loadPage() {
                            isPaging = true;
                            pageFunc(scope, { $firstTime: earliestTimespanDate });
                        }
                        function createSeries() {
                            dataContainer = svg.append("g")
                                .attr("transform", "translate(" + labelsWidth + ", 0)");
                            var lines = svg.append("g");
                            var seriesBackground = dataContainer.append("g")
                                .attr("clip-path", "url(#seriesClipPath)")
                                .call(d3.behavior.zoom().x(x).scaleExtent([0.1, 60])
                                .on("zoom", zoom));
                            seriesBackground.append("rect")
                                .attr("height", totalSeriesHeight)
                                .attr("width", "100%")
                                .attr("fill", "Transparent")
                                .attr("class", "zoom-area");
                            dataContainer = seriesBackground.append("g");
                            dataContainer.selectAll("g")
                                .data(data).enter()
                                .append("g")
                                .attr("class", function (d, i) {
                                return "series_" + i;
                            })
                                .attr("transform", function (d, i) {
                                return "translate(0, " + (i * seriesHeight) + ")";
                            });
                            lineElements = lines.selectAll("line").data(data)
                                .enter().append("line")
                                .attr("transform", function (d, i) {
                                return "translate(0, " + (i * seriesHeight) + ")";
                            })
                                .attr("x1", 0)
                                .attr("x2", width)
                                .attr("y1", 0)
                                .attr("y2", 0)
                                .attr("stroke-width", "1")
                                .attr("stroke", "#ddd");
                            lastRefreshTimeLine = lines.append("line")
                                .attr("transform", "translate(" + x(lastRefreshTime) + ", 0)")
                                .attr("x1", 0)
                                .attr("x2", 0)
                                .attr("y1", 0)
                                .attr("y2", totalSeriesHeight)
                                .attr("stroke", "#ddd")
                                .attr("stroke-width", 2);
                            addTimespans(data);
                        }
                        function getTypeSymbol(type) {
                            var symbolType = settings.symbolMap[type] || "circle";
                            return d3.svg.symbol().type(symbolType).size(rectHeight * 5)();
                        }
                        function addTimespans(data) {
                            angular.forEach(data, function (series, i) {
                                var seriesContainer = dataContainer.selectAll(".series_" + i);
                                seriesContainer[0][0].innerHTML = "";
                                var timespansData;
                                if (settings.series.timeSpansSeries) {
                                    timespansData = [];
                                    angular.forEach(series[settings.series.timeSpansSeries], function (timeSpansArrayObject) {
                                        angular.forEach(timeSpansArrayObject[settings.series.timeSpans], function (timespan) {
                                            timespan._groupName =
                                                timeSpansArrayObject[settings.series
                                                    .timeSpansSeriesGroupName];
                                            timespansData.push(timespan);
                                        });
                                    });
                                }
                                else if (settings.series.timeSpans) {
                                    timespansData = series[settings.series.timeSpans];
                                }
                                else if (settings.series.isSingleSeries) {
                                    timespansData = series._timespans;
                                }
                                else {
                                    timespansData = [series];
                                }
                                points = seriesContainer.selectAll(".timespan")
                                    .data(timespansData)
                                    .enter().append("path")
                                    .attr("class", "timespan")
                                    .attr("d", function (d) {
                                    var typeCount = typesCount[d[typeField]];
                                    if (typeCount === undefined) {
                                        typesCount[d[typeField]] = 1;
                                    }
                                    else {
                                        typesCount[d[typeField]]++;
                                    }
                                    return getTypeSymbol(d[typeField]);
                                })
                                    .attr("transform", function (d) {
                                    var position = x(utils.date.getMoment(d[xField]).toDate());
                                    if (firstTimespanPosition === undefined ||
                                        position < firstTimespanPosition) {
                                        firstTimespanPosition = position;
                                    }
                                    return "translate(" + position + ", " + seriesHeight / 2 + ")";
                                })
                                    .attr("fill", "White")
                                    .attr("stroke-width", 1.5)
                                    .attr("stroke", function (d) {
                                    return color(d);
                                });
                            });
                            currentPage++;
                        }
                        // Get the relevant timeSpans
                        function getTimeSpanSeriesName(settings) {
                            if (settings.series.timeSpansSeries) {
                                return settings.series.timeSpansSeries;
                            }
                            return settings.series.timeSpans || "_timespans";
                        }
                        function getEarliestTimespanDate() {
                            if (settings.series.timeSpansSeries || settings.series.timeSpans ||
                                settings.series.isSingleSeries) {
                                var timeSpanSeriesName = getTimeSpanSeriesName(settings);
                                earliestTimespanDate = d3.min(data, function (d) {
                                    var timeSpansData = d[timeSpanSeriesName];
                                    return d3.min(timeSpansData, function (d2) {
                                        if (settings.series.timeSpansSeries) {
                                            return d3.min(d2[settings.series.timeSpans], function (d3) {
                                                return utils.date.getMoment(d3[xField]).toDate();
                                            });
                                        }
                                        else {
                                            return utils.date.getMoment(d2[xField]).toDate();
                                        }
                                    });
                                });
                            }
                            else {
                                earliestTimespanDate = d3.min(data, function (d) {
                                    return utils.date.getMoment(d[xField]).toDate();
                                });
                            }
                            return earliestTimespanDate;
                        }
                        function createAxes() {
                            labelsContainer = svg.append("g");
                            labelsContainer.selectAll(".seriesLabel")
                                .data(data)
                                .enter().append("text")
                                .attr("class", "seriesLabel")
                                .text(function (d) {
                                return d[settings.series.name];
                            })
                                .attr("text-anchor", "end")
                                .attr("height", seriesHeight)
                                .attr("transform", function (d, i) {
                                return "translate(0, " + ((0.5 + i) * seriesHeight + 4) + ")";
                            });
                            labelsWidth = d3.max(labelsContainer.selectAll(".seriesLabel")[0], function (node) {
                                return node.clientWidth;
                            });
                            labelsContainer.attr("transform", "translate(" + labelsWidth + ", 0)");
                            labelsWidth += 10; // Padding for labels
                            var d3timeScale = config.alwaysUtc ? d3.time.scale.utc : d3.time.scale;
                            x = d3timeScale()
                                .range([0, seriesWidth = chartWidth - labelsWidth + margin.left + margin.right]);
                            xAxis = d3.svg.axis()
                                .scale(x)
                                .orient("bottom")
                                .tickSize(6, 0);
                            var xDomain1 = getEarliestTimespanDate(), xDomain2;
                            if (settings.series.timeSpansSeries || settings.series.timeSpans ||
                                settings.series.isSingleSeries) {
                                var timeSpanSeriesName = getTimeSpanSeriesName(settings);
                                if (settings.useLastRefreshTimeForX) {
                                    xDomain2 = utils.date.getMoment('1hours').toDate();
                                }
                                else {
                                    xDomain2 = d3.max(data, function (d) {
                                        return d3.max(d[timeSpanSeriesName], function (d2) {
                                            if (settings.series.timeSpansSeries) {
                                                return d3.max(d2[settings.series.timeSpans], function (d3) {
                                                    return utils.date.getMoment(d3[xField]).toDate();
                                                });
                                            }
                                            else {
                                                return utils.date.getMoment(d2[xField]).toDate();
                                            }
                                        });
                                    });
                                }
                            }
                            else {
                                xDomain2 = d3.max(data, function (d) {
                                    return utils.date.getMoment(d[xField]).toDate();
                                });
                            }
                            x.domain(timeMinMax = [xDomain1, xDomain2]);
                            timeDiff = xDomain2 - xDomain1;
                            xAxisElement = svg.append("g")
                                .attr("class", "x axis")
                                .attr("transform", "translate(" + labelsWidth + "," + (totalSeriesHeight + TIME_DISPLAY_HEIGHT - 15) +
                                ")")
                                .call(xAxis);
                            xAxisElement
                                .append("text")
                                .attr("class", "label")
                                .attr("x", chartWidth)
                                .attr("y", -6)
                                .style("text-anchor", "end");
                        }
                        function createTimeDisplay() {
                            timeDisplay = svg.append("g").attr("style", "display: none");
                            timeDisplayText = timeDisplay.append("text")
                                .attr("fill", "#333")
                                .attr("text-anchor", "middle")
                                .attr("transform", "translate(0, -5)");
                            timeDisplay.append("line")
                                .attr("x1", "0")
                                .attr("x2", "0")
                                .attr("y1", "0")
                                .attr("y2", totalSeriesHeight)
                                .attr("stroke", "#ccc")
                                .attr("stroke-width", 1);
                        }
                        function createLegend() {
                            var legend = svg.append("g"), symbols = [], widths = [], totalWidth = 0;
                            for (var type in settings.symbolMap) {
                                if (settings.symbolMap.hasOwnProperty(type)) {
                                    if (typesCount[type]) {
                                        symbols.push({
                                            value: type,
                                            symbol: settings.symbolMap[type],
                                            color: color(type)
                                        });
                                    }
                                }
                            }
                            var items = legend.selectAll(".legendItem").data(symbols)
                                .enter().append("g")
                                .attr("class", "legendItem")
                                .attr("data-type", function (d) {
                                return d.symbol;
                            });
                            items.append("path").attr("d", function (d) {
                                return d3.svg.symbol().type(d.symbol).size(rectHeight * 5)();
                            })
                                .attr("fill", "White")
                                .attr("stroke-width", 1.5)
                                .attr("stroke", function (d) {
                                return d.color;
                            });
                            items.append("text")
                                .attr("transform", "translate(10, 4)")
                                .text(function (d) {
                                return d.value + " (" + (typesCount[d.value] || 0) + ")";
                            });
                            legend.selectAll(".legendItem")[0].forEach(function (item) {
                                var itemWidth = item.getBBox().width;
                                widths.push(itemWidth);
                                totalWidth += itemWidth;
                            });
                            items.attr("transform", function (d, i) {
                                var translateX = 0;
                                for (var widthIndex = 0; widthIndex < i; widthIndex++) {
                                    translateX += widths[widthIndex] + LEGEND_ITEM_PADDING;
                                }
                                return "translate(" + translateX + ", 0)";
                            });
                            legend.attr("transform", "translate(" + (width - totalWidth) / 2 + ", " +
                                (totalSeriesHeight + axisHeight + TIME_DISPLAY_HEIGHT + LEGEND_MARGIN) + ")");
                        }
                        if (!data || !settings) {
                            return;
                        }
                        var typeField = settings.series.type || "type";
                        if (settings.series.isSingleSeries) {
                            data = [{ _timespans: data }];
                        }
                        if (isInit) {
                            var previousEarliestTimespanDate = earliestTimespanDate;
                            x.domain(timeMinMax);
                            addTimespans(data);
                            getEarliestTimespanDate();
                            if (earliestTimespanDate.valueOf() !== previousEarliestTimespanDate.valueOf()) {
                                isPaging = false;
                            }
                            setLastRefreshTime();
                            return;
                        }
                        if (settings.data) {
                            if (angular.isArray(data)) {
                                data = data[0][settings.data];
                            }
                            else {
                                data = data[settings.data];
                            }
                        }
                        element.css({
                            width: "100%"
                        });
                        totalSeriesHeight = seriesHeight * data.length;
                        //if (!element.height())
                        //element.css("height", totalSeriesHeight + axisHeight + TIME_DISPLAY_HEIGHT);
                        width = element.width();
                        height =
                            totalSeriesHeight + axisHeight + TIME_DISPLAY_HEIGHT + margin.bottom + LEGEND_MARGIN +
                                LEGEND_HEIGHT;
                        chartWidth = width - margin.left - margin.right;
                        svgHeight = height;
                        element.empty();
                        element.off();
                        svg = d3.select(element[0]).append("svg")
                            .attr("width", chartWidth + margin.left + margin.right)
                            .attr("height", svgHeight);
                        mask = svg.append('svg:defs').append('svg:clipPath')
                            .attr("id", "seriesClipPath")
                            .append("rect")
                            .attr("width", width)
                            .attr("height", totalSeriesHeight);
                        svg = svg.append("g")
                            .attr("transform", "translate(" + margin.left + "," + TIME_DISPLAY_HEIGHT + ")");
                        xField = settings.series.time;
                        colorField = settings.color;
                        createTimeDisplay();
                        createAxes();
                        createSeries();
                        createLegend();
                        //createTooltip();
                        svg[0][0].appendChild(labelsContainer[0][0]);
                        if (settings.onSelect) {
                            element.on("click", ".timespan", function (e) {
                                scope.$apply(function () {
                                    var eventCopy = angular.copy(settings.onSelect);
                                    eventCopy.actionOptions.position = { top: e.clientY, left: e.clientX };
                                    events.triggerDashboardEvent(eventCopy, angular.extend({}, e.target.__data__.properties, e.target.__data__));
                                });
                                if (selectedTimespan) {
                                    selectedTimespan.classList.remove("selected");
                                }
                                selectedTimespan = e.target;
                                selectedTimespan.classList.add("selected");
                            });
                        }
                        element.on("mouseenter.timeDisplay", function (e) {
                            if (e.offsetX < labelsWidth) {
                                timeDisplay[0][0].style.removeProperty("display");
                                timeDisplayVisible = true;
                            }
                            element.on("mouseleave.timeDisplay", onMouseLeave)
                                .on("mousemove.timeDisplay", onMouseMove);
                        });
                        if (!isInit) {
                            isInit = true;
                        }
                    }
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                    scope.$watch(attrs.ngModel, function (chartData) {
                        data = chartData;
                        drawChart();
                    });
                    scope.$watch(attrs.settings, function (value) {
                        settings = value;
                        options = angular.extend({}, defaultOptions, settings.options);
                        color = getColorScale(settings.colorMap);
                        drawChart();
                    });
                    $window.addEventListener("resize", onResize);
                    //scope.$on("resize", drawChart);
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TimelineWidget").factory("timelineService", ["$q", "reports", function ($q, reports) {
            return {
                getEarlierData: function (settings, params, currentData) {
                    var deferred = $q.defer(), newData = angular.copy(currentData);
                    reports.runReport(settings.getPageReport, params, true).then(function (results) {
                        angular.forEach(results.data, function (series) {
                            var existingSeries = getSeriesByName(series[settings.series.name]);
                            if (!existingSeries) {
                                newData.push(series);
                            }
                            else {
                                var timeSpansArray = existingSeries[settings.series.timeSpansSeries];
                                angular.forEach(series[settings.series.timeSpansSeries], function (timeSpanSeriesGroup) {
                                    if (settings.series.timeSpansSeriesGroupName) {
                                        var existingGroup = getGroupByName(timeSpansArray, timeSpanSeriesGroup[settings.series.timeSpansSeriesGroupName]);
                                        if (!existingGroup) {
                                            timeSpansArray.push(timeSpanSeriesGroup);
                                        }
                                        else {
                                            existingGroup[settings.series.timeSpans] =
                                                timeSpanSeriesGroup[settings.series.timeSpans]
                                                    .concat(existingGroup[settings.series.timeSpans]);
                                        }
                                    }
                                });
                            }
                        });
                        deferred.resolve(newData);
                    }, deferred.reject);
                    function getSeriesByName(seriesName) {
                        for (var i = 0, series; !!(series = newData[i]); i++) {
                            if (series[settings.series.name] === seriesName) {
                                return series;
                            }
                        }
                        return null;
                    }
                    function getGroupByName(groupsArray, groupName) {
                        for (var i = 0, group; !!(group = groupsArray[i]); i++) {
                            if (group[settings.series.timeSpansSeriesGroupName] === groupName) {
                                return group;
                            }
                        }
                        return null;
                    }
                    return deferred.promise;
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TimelineWidget").controller("TimelineController", ["$scope", "timelineService", function ($scope, timelineService) {
            if ($scope.view.settings.getPageReport) {
                $scope.getPage = function (firstTime) {
                    timelineService.getEarlierData($scope.view.settings, { timestamp: firstTime.valueOf() }, $scope.view.data).then(function (data) {
                        data.legend = $scope.view.data.legend;
                        $scope.view.data = data;
                    });
                };
            }
        }]);
}());

(function () {
    'use strict';
    angular.module("MapWidget", ["Utils", "Chart", "Widgets", "Events"]).run(["widgetViews", function (widgetViews) {
            widgetViews.registerView("map");
        }]);
}());

(function () {
    'use strict';
    angular.module('MapWidget')
        .directive('map', ["fsHighChartService", "COLORS_RANGE_BLUE", function (fsHighChartService, COLORS_RANGE_BLUE) {
            return {
                template: '<div class="highchart-chart-container"></div>',
                restrict: 'E',
                scope: {
                    model: '=',
                    graphSettings: '='
                },
                controller: function ($scope) {
                    var ctrl = this;
                    /**
                     * This method triggered when data changed
                     * @param chartData
                     */
                    this.refreshData = function (chartData) {
                        if (chartData) {
                            //Get all countries from server in a map, which the key is the country code
                            var chartDataIndexedByCountriesCode = this._indexBy(chartData, "code");
                            //Get the original list of countries, into updated data
                            var countriesListForUpdate = ctrl.countriesList;
                            //maxCounter used to rescale the legend / color
                            var maxCounted = 0;
                            //For each country in the countries list (dataPoint) -
                            //check if this country arrived in the data from server, and if so - set the relevant count
                            // to the country
                            countriesListForUpdate.forEach(function (dataPoint) {
                                var countryCode = dataPoint.properties['iso-a2'];
                                var chartDataEntry = chartDataIndexedByCountriesCode[countryCode];
                                //Country has data from server:
                                if (chartDataEntry) {
                                    var counted = chartDataEntry.event_count;
                                    dataPoint.value = counted;
                                    maxCounted = Math.max(maxCounted, counted);
                                }
                                else {
                                    //Country doesn't has data. Init the countries value to zero, in case it's derty
                                    // from previous refresh
                                    dataPoint.value = 0;
                                }
                            });
                            //Destroy and recreate the chart.
                            //I would prefer to update the colorAxis instead, but because of bug
                            // "https://github.com/highslide-software/highcharts.com/issues/3207" Highchart is not
                            // updating the legend with the new colors.
                            $scope.chart.destroy();
                            $scope.chartConfig.colorAxis = this._getColorAxis(maxCounted);
                            $scope.chart = new Highcharts.Map($scope.chartConfig);
                            $scope.chart.addSeries(ctrl._getSeries(countriesListForUpdate));
                        }
                    };
                    /**
                     * Get an array and convert it to map object.
                     * Each key of the map, is property of the objects in the array, according to the 'property' param
                     * If we have 2 objects in the array with the same value in object.property, one of them will
                     * override the other.
                     *
                     * @param chartData - list objects
                     * @param property - the name of the property which will be used to as the new object key.
                     * @return {{}} - map object, each attribute contain an object from the original array.
                     * @private
                     */
                    this._indexBy = function (chartData, property) {
                        var indexedMap = {};
                        chartData.forEach(function (entry) {
                            indexedMap[entry[property]] = entry;
                        });
                        return indexedMap;
                    };
                    /**
                     * This function use to split the data into buccets, each bucket will have different color.
                     * For now, all buckets are in the same value (maxCount /5), but we consdiering to change the
                     * algorithm. See https://fortscale.atlassian.net/browse/FV-7103 also count = 0 has different
                     * color.
                     * @param maxCountValue - the maximum count for a country
                     * @return {} the color axis {dataClassColor: 'category', 	dataClasses: categoriesArray}
                     }
                     */
                    this._getColorAxis = function (maxCountValue) {
                        if (maxCountValue < 0) {
                            throw new RangeError('Score must be positive or zero');
                        }
                        var space; //= MaxValue - MinValue for each bucket
                        var categoriesArray = [{ to: 1 }]; //For all cases
                        var roundedMaximumValue;
                        var i;
                        if (maxCountValue <= 5) {
                            space = 1;
                        }
                        else {
                            //maxCount value greate then 5, and categories ranges should be calucated manually.
                            //Numbers will be rounded to : less then 15 --> 15. less then 25 --> 25. other will be
                            // rounded to the nears Multiplier of 10. The same with less then 150 to 150, less then 250
                            // --> 250, other will be rounded to the nears Multiplier of 10. and the same to 1000+
                            if (maxCountValue >= 10) {
                                var countNumberOfDigits = maxCountValue.toString().length;
                                var nearest10pow = Math.pow(10, countNumberOfDigits);
                                //Percntage- the given maximum as part of the next pow of ten.
                                var maxCountValueAsPercentage = maxCountValue / nearest10pow;
                                var STEPS_PERCENTAGE_ARRAY = [15, 25, 30, 40, 50, 60, 70, 80, 90];
                                for (i = 0; i < STEPS_PERCENTAGE_ARRAY.length && !roundedMaximumValue; i++) {
                                    if (maxCountValueAsPercentage < (STEPS_PERCENTAGE_ARRAY[i] / 100)) {
                                        roundedMaximumValue = STEPS_PERCENTAGE_ARRAY[i] / 100 * nearest10pow;
                                    }
                                }
                                if (!roundedMaximumValue) {
                                    roundedMaximumValue = nearest10pow;
                                }
                            }
                            else {
                                roundedMaximumValue = 10;
                            }
                            space = roundedMaximumValue / 5;
                            categoriesArray.push({
                                from: 1,
                                to: space
                            });
                        }
                        for (i = 1; i < 5; i++) {
                            categoriesArray.push({
                                from: space * i,
                                to: space * (i + 1)
                            });
                        }
                        return {
                            dataClassColor: 'category',
                            dataClasses: categoriesArray
                        };
                    };
                    /**
                     * Get high chart series of data.
                     * @param data  -data for series
                     * @return {{data: *, name: string, dataLabels: {enabled: boolean, format: string}, states: {hover:
                     *     {color: string}}}}
                     */
                    this._getSeries = function (data) {
                        return {
                            data: data,
                            name: 'World',
                            dataLabels: {
                                enabled: true,
                                format: '{point.properties.name}'
                            },
                            states: {
                                hover: {
                                    color: '#BADA55'
                                }
                            }
                        };
                    };
                },
                link: function postLink(scope, element, attrs, ctrl) {
                    //Set unique ID for the div, Highchart need it.
                    var chartId = Math.random().toString(36).slice(2);
                    //Set unique ID on the root element of the template
                    element.children('.highchart-chart-container').attr('id', chartId);
                    ctrl.countriesList = Highcharts.geojson(Highcharts.maps['custom/world']);
                    //Set default data - each point will have value of 0, and the flag will be the country code
                    ctrl.countriesList.forEach(function (dataPoint) {
                        dataPoint.value = 0;
                        dataPoint.flag = dataPoint.properties["hc-key"];
                    });
                    scope.chartConfig = {
                        chart: {
                            "renderTo": chartId
                        },
                        colors: COLORS_RANGE_BLUE,
                        //On small screen- use default legend, else set the legend location to right
                        legend: $('.highchart-chart-container').width() < 400 ? {} : {
                            layout: 'vertical',
                            align: 'right',
                            verticalAlign: 'middle',
                            valueDecimals: 0,
                            title: {
                                text: 'Events per Country'
                            }
                        },
                        //Tooltip will display country name, country value and flag.
                        //The tooltip always be on the left side
                        tooltip: {
                            backgroundColor: 'none',
                            borderWidth: 0,
                            shadow: false,
                            useHTML: true,
                            padding: 0,
                            enabled: true,
                            positioner: function () {
                                return { x: 0, y: 250 };
                            },
                            pointFormat: '<span class="f32"><span class="flag {point.flag}"></span></span>' +
                                ' {point.name}: <b>{point.value}</b>'
                        },
                        colorAxis: ctrl._getColorAxis(0),
                        mapNavigation: {
                            enabled: true,
                            buttonOptions: {
                                verticalAlign: 'bottom'
                            }
                        },
                        plotOptions: {
                            map: {
                                states: {
                                    hover: {
                                        color: '#EEDD66'
                                    }
                                }
                            }
                        },
                        series: [ctrl._getSeries(ctrl.countriesList)]
                    };
                    scope.chartConfig =
                        $.extend(true, fsHighChartService.getBasicChartConfiguration(), scope.chartConfig);
                    //Create the chart object and save it on the scope
                    scope.$applyAsync(function () {
                        scope.chart = new Highcharts.Map(scope.chartConfig);
                    });
                    scope.$watch('model', function (chartData) {
                        ctrl.refreshData(chartData);
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("PieWidget", ["Utils", "Chart", "Widgets"]).run(["widgetViews", function (widgetViews) {
            function pieDataParser(view, data) {
                var total = 0;
                data.forEach(function (item) {
                    var labelValue = item[view.settings.label];
                    if ((!labelValue || labelValue === "null") && labelValue !== 0 && view.settings.emptyLabelDisplay) {
                        item[view.settings.label] = view.settings.emptyLabelDisplay;
                    }
                    total += item[view.settings.value] || 0;
                });
                data.forEach(function (item) {
                    item._percent = 100 * item[view.settings.value] / total;
                });
                return data;
            }
            widgetViews.registerView("pie", { dataParser: pieDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('PieWidget')
        .directive('pie', ["Chart", "utils", function (Chart, utils) {
            return {
                template: '<div class="widget-pie"></div>',
                restrict: 'E',
                require: "?ngModel",
                replace: true,
                link: function postLink(scope, element, attrs, ngModel) {
                    function draw() {
                        /* jshint validthis: true */
                        var self = this, color = this.settings.color ? this.getColorScale(this.settings.color) :
                            d3.scale.ordinal().range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56",
                                "#d0743c", "#ff8c00"]), svg = this.dataSvg, r = this.options.radius, arc = d3.svg.arc().outerRadius(r).innerRadius(0), pie = d3.layout.pie()
                            .sort(function (a, b) {
                            var aVal = a[self.settings.value], bVal = b[self.settings.value];
                            if (aVal === bVal) {
                                return 0;
                            }
                            return aVal < bVal ? 1 : -1;
                        })
                            .value(function (d) {
                            return d[self.settings.value];
                        }), lines, pieData = pie(this.data), largeItemsData = pieData.filter(function (item) {
                            return item.data._percent > 4;
                        }); // Only items with value > 4%
                        var vis = svg.append("svg:g")
                            .attr("transform", "translate(" + this.width / 2 + ", " + this.height / 2 + ")");
                        //draw lines to connect label to pie triangle
                        lines = vis.selectAll("line").data(largeItemsData);
                        lines.enter().append("svg:line")
                            .attr("x1", 0)
                            .attr("x2", 0)
                            .attr("y1", -r - 1)
                            .attr("y2", -r - 8)
                            .attr("stroke", "gray")
                            .attr("transform", function (d) {
                            return "rotate(" + (d.startAngle + d.endAngle) / 2 * (180 / Math.PI) + ")";
                        });
                        lines.exit().remove();
                        //draw slices
                        var arcs = vis.selectAll("g.slice")
                            .data(pieData).enter()
                            .append("svg:g")
                            .attr("class", "slice")
                            .attr("data-tooltip", "");
                        //set the color for each slice
                        arcs.append("svg:path")
                            .attr("fill", function (d, i) {
                            return color(self.settings.color ? d.data : i);
                        })
                            .attr("d", arc);
                        var flipPoint = 1.9 * Math.PI;
                        //draw labels
                        var labels = arcs.append("svg:text")
                            .attr("class", function (d) {
                            return d.data._percent <= 4 ? "hidden" : "";
                        })
                            .attr("transform", function (d) {
                            var offset = self.options.labelsOffset;
                            return "translate(" +
                                Math.cos(((d.startAngle + d.endAngle - Math.PI) / 2)) * (r + offset) + "," +
                                Math.sin((d.startAngle + d.endAngle - Math.PI) / 2) * (r + offset) + ")";
                        })
                            .attr("dy", function (d) {
                            if ((d.startAngle + d.endAngle) / 2 > Math.PI / 2 &&
                                (d.startAngle + d.endAngle) / 2 < Math.PI * 1.5) {
                                return 5;
                            }
                            else {
                                return -7;
                            }
                        })
                            .attr("text-anchor", function (d) {
                            var middleAngle = (d.startAngle + d.endAngle) / 2;
                            if (middleAngle < Math.PI || (middleAngle > flipPoint && middleAngle < 2 * Math.PI)) {
                                return "beginning";
                            }
                            else {
                                return "end";
                            }
                        })
                            .text(function (d) {
                            return d.data[self.settings.label] + ": " + d.data[self.settings.value] + " (" +
                                Math.round(d.data._percent) + "%)";
                        });
                        var prevbb;
                        labels.each(function (d, i) {
                            var thisbb = this.getBoundingClientRect();
                            if (i > 0) {
                                // move if they overlap
                                if (!(thisbb.right < prevbb.left ||
                                    thisbb.left > prevbb.right ||
                                    thisbb.bottom < prevbb.top ||
                                    thisbb.top > prevbb.bottom)) {
                                    this.classList.add("hidden");
                                }
                            }
                            prevbb = thisbb;
                        });
                    }
                    var defaultOptions = {
                        radius: 100,
                        labelsOffset: 10
                    }, graph = new Chart(defaultOptions, draw);
                    element.css("height", "100%");
                    graph.getTooltipText = function (d) {
                        if (graph.settings.tooltipText) {
                            return utils.strings.parseValue(graph.settings.tooltipText, d.data);
                        }
                        return d.data[graph.settings.label] + ": " + d.data[graph.settings.value] + " (" +
                            Math.round(d.data._percent) + "%)";
                    };
                    graph.init(scope, element, attrs);
                    scope.$on("$destroy", function () {
                        element.off();
                        element.empty();
                    });
                    //this is called from Charts.js where the svg is appended to the HTML
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("BarsWidget", ["Utils", "Chart", "Widgets"]).run(["widgetViews", function (widgetViews) {
            function barsDataParser(view, data) {
                if (view.settings.calculatePercentage) {
                    var total = 0;
                    data.forEach(function (row) {
                        total += row[view.settings.value];
                    });
                    data.forEach(function (row) {
                        row.label = row.label ? row.label : "Unknown";
                        row._percent = (row[view.settings.value] / total) * 100;
                    });
                }
                return data;
            }
            widgetViews.registerView("bars", { dataParser: barsDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('BarsWidget').directive('bars', ["utils", "fsHighChartService", 'SCORE_COLOR_META_DATA',
        function (utils, fsHighChartService, SCORE_COLOR_META_DATA) {
            //The chart height will be FIXED_SERIES_HEIGHT_IN_PIXEL * number of users / computers
            var FIXED_SERIES_HEIGHT_IN_PIXEL = '45';
            return {
                template: '<div class="highchart-bar-chart-container-parent">' +
                    '<div class="highchart-bar-chart-container"></div></div>',
                restrict: 'E', scope: {
                    model: '=', graphSettings: '='
                }, controller: function ($scope) {
                    var ctrl = this;
                    this.refreshData = function (chartData) {
                        if (chartData && chartData.length > 0) {
                            //userOrComputerData - map which the key is name of user or computer,
                            // and for each user his count for each severity
                            var userOrComputerData = this._getPointByUserAndSeverity(chartData);
                            var dataForChart = this._prepareDataForChart(userOrComputerData);
                            //We need to re-calculate the hight depened on data.
                            //So we have to remove the chart, reset the container size, and re-create the cahrt
                            //Destroy current chart and handle contain height
                            var chartContainerDivId = $scope.chart.renderTo.id;
                            var chartContainer = $("#" + chartContainerDivId);
                            var chartAreaSizeStrWithPX = chartContainer.parent().css('height');
                            chartAreaSizeStrWithPX =
                                chartAreaSizeStrWithPX.slice(0, chartAreaSizeStrWithPX.length - 2);
                            var containerSize = Math.max(chartData.length * FIXED_SERIES_HEIGHT_IN_PIXEL, Number(chartAreaSizeStrWithPX));
                            chartContainer.css('height', containerSize);
                            //Save which sevirities to show, before destroy and rebuild chart
                            for (var i = 0; i < $scope.chartConfig.series.length; i++) {
                                $scope.chartConfig.series[i].visible = $scope.chart.series[i].visible;
                            }
                            $scope.chart.destroy();
                            //Re-Create the chart object and save it on the scope
                            $scope.chart = new Highcharts.Chart($scope.chartConfig);
                            $scope.chart.xAxis[0].setCategories(dataForChart.categories);
                            $scope.chart.series[0]
                                .update({ data: dataForChart.series[SCORE_COLOR_META_DATA.critical.name] });
                            $scope.chart.series[1]
                                .update({ data: dataForChart.series[SCORE_COLOR_META_DATA.high.name] });
                            $scope.chart.series[2]
                                .update({ data: dataForChart.series[SCORE_COLOR_META_DATA.medium.name] });
                            $scope.chart.series[3]
                                .update({ data: dataForChart.series[SCORE_COLOR_META_DATA.low.name] });
                        }
                    };
                    /*
                     This method prepare the categories and the data for each series in the chart.
                     @param userOrComputerData - object of the form - [user or coomputer name][seveiry] = counts

                     @return - {
                     categories - array of user or computer names
                     series - array of 4 series, one per serviriy (low, medium, high, critical).
                     each series contains array of counts
                     }
                     */
                    this._prepareDataForChart = function (userOrComputerData) {
                        var categories = [];
                        var dataForChartSeries = {};
                        dataForChartSeries[SCORE_COLOR_META_DATA.critical.name] = []; //Critical
                        dataForChartSeries[SCORE_COLOR_META_DATA.high.name] = []; //High
                        dataForChartSeries[SCORE_COLOR_META_DATA.medium.name] = []; //Medium
                        dataForChartSeries[SCORE_COLOR_META_DATA.low.name] = []; //Low
                        angular.forEach(userOrComputerData, function (sevirityAndCount, key) {
                            categories.push(key);
                            ctrl._pushPointForChartSeries(SCORE_COLOR_META_DATA.critical.name, sevirityAndCount, dataForChartSeries);
                            ctrl._pushPointForChartSeries(SCORE_COLOR_META_DATA.high.name, sevirityAndCount, dataForChartSeries);
                            ctrl._pushPointForChartSeries(SCORE_COLOR_META_DATA.medium.name, sevirityAndCount, dataForChartSeries);
                            ctrl._pushPointForChartSeries(SCORE_COLOR_META_DATA.low.name, sevirityAndCount, dataForChartSeries);
                        });
                        return {
                            categories: categories, series: dataForChartSeries
                        };
                    };
                    this._pushPointForChartSeries = function (seriesName, sourceArray, destArray) {
                        //Set the point data if exists, or zero if not exists
                        var point = sourceArray[seriesName] ? sourceArray[seriesName] : { y: 0, percentage: "0" };
                        destArray[seriesName].push(point);
                    };
                    /**
                     * @param chartData - array of data objects
                     * @return {} two dimensions array [user or coomputer name][seveiry] = counts
                     */
                    this._getPointByUserAndSeverity = function (chartData) {
                        var catagorizedData = {};
                        //For each user or computer - create and point with the value and percentage.
                        //entry - represents entry of original data from the original array
                        chartData.forEach(function (entry) {
                            //Add the point to the temporal array catagorizedData- split the data between the
                            // buckets [entity name][critical / high/  medium/low]
                            if (!catagorizedData[entry.label]) {
                                catagorizedData[entry.label] = {};
                            }
                            var percentage = (Math.round(entry._percent * 100) / 100).toFixed(2); //Truncate 2
                            // places after
                            // comma
                            catagorizedData[entry.label][entry.severity.toLowerCase()] =
                                { y: entry.event_count, percentage: percentage };
                        });
                        return catagorizedData;
                    };
                }, link: function postLink(scope, element, attrs, ctrl) {
                    //Set unique ID for the div, Highchart need it.
                    var chartId = Math.random().toString(36).slice(2);
                    //Set unique ID on the root element of the template
                    element.children().children('.highchart-bar-chart-container').attr('id', chartId);
                    scope.chartConfig = {
                        "chart": {
                            "renderTo": chartId, "type": "bar"
                        },
                        legend: {
                            enabled: true,
                            layout: 'vertical',
                            align: 'right',
                            verticalAlign: 'top',
                            x: 10,
                            y: 40,
                            borderWidth: 0
                        }, "plotOptions": {
                            bar: {
                                minPointLength: 5, dataLabels: {
                                    enabled: true, formatter: function () {
                                        if (!this.point.percentage) {
                                            this.point.percentage = "0.00";
                                        }
                                        return this.point.y + " (" + this.point.percentage + "%)";
                                    }, style: {
                                        fontWeight: 'bold'
                                    }, x: 0, y: 0, align: 'right'
                                }
                            }
                        }, scrollbar: {
                            enabled: true
                        }, yAxis: {
                            min: 0, maxPadding: 0, gridLineWidth: 0, title: {
                                text: '', align: 'high'
                            }, labels: {
                                overflow: 'justify', enabled: false
                            }, minTickInterval: 1, tickInterval: 1, endOnTick: true, minRange: 1
                        }, xAxis: {
                            categories: [], title: {
                                text: null
                            }
                        },
                        series: [{
                                name: utils.strings.capitalize(SCORE_COLOR_META_DATA.critical.name),
                                data: [],
                                color: SCORE_COLOR_META_DATA.critical.color
                            }, {
                                name: utils.strings.capitalize(SCORE_COLOR_META_DATA.high.name),
                                data: [],
                                color: SCORE_COLOR_META_DATA.high.color
                            }, {
                                name: utils.strings.capitalize(SCORE_COLOR_META_DATA.medium.name),
                                data: [],
                                color: SCORE_COLOR_META_DATA.medium.color,
                                visible: false
                            }, {
                                name: utils.strings.capitalize(SCORE_COLOR_META_DATA.low.name),
                                data: [],
                                color: SCORE_COLOR_META_DATA.low.color,
                                visible: false
                            }]
                    };
                    $.extend(true, scope.chartConfig, fsHighChartService.getBasicChartConfiguration());
                    //Create the chart object and save it on the scope
                    scope.$applyAsync(function () {
                        scope.chart = new Highcharts.Chart(scope.chartConfig);
                    });
                    scope.$watch('model', function (chartData) {
                        ctrl.refreshData(chartData);
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("StackedBarsWidget", ["Utils", "Chart", "Widgets"]).run(["utils", "widgetViews",
        function (utils, widgetViews) {
            function stackedBarsDataParser(view, data) {
                var seriesIndex = {}, series = [], labels = {}, labelTotals;
                if (view.settings.calculatePercentage) {
                    labelTotals = {};
                    data.forEach(function (row) {
                        var label = row[view.settings.label];
                        if (labelTotals[label] === undefined) {
                            labelTotals[label] = row[view.settings.value];
                        }
                        else {
                            labelTotals[label] += row[view.settings.value];
                        }
                    });
                    data.forEach(function (row) {
                        var label = row[view.settings.label];
                        row._percent = 100 * row[view.settings.value] / labelTotals[label];
                    });
                }
                data.forEach(function (row) {
                    var seriesName = row[view.settings.series], seriesValues = seriesIndex[seriesName], rowLabel = row[view.settings.label];
                    if (!seriesValues) {
                        seriesValues = seriesIndex[seriesName] = { dataIndex: {}, name: seriesName };
                    }
                    seriesValues.dataIndex[rowLabel] = {
                        label: rowLabel,
                        value: view.settings.calculatePercentage ? row._percent : row[view.settings.value],
                        rawData: row
                    };
                    labels[rowLabel] = true;
                });
                var seriesValues, label;
                var seriesName;
                // Add missing labels, with value=0:
                for (label in labels) {
                    if (labels.hasOwnProperty(label)) {
                        for (seriesName in seriesIndex) {
                            if (seriesIndex.hasOwnProperty(seriesName)) {
                                seriesValues = seriesIndex[seriesName];
                                if (!seriesValues.dataIndex[label]) {
                                    seriesValues.dataIndex[label] = { label: label, value: 0, rawData: null };
                                }
                            }
                        }
                    }
                }
                for (seriesName in seriesIndex) {
                    if (seriesIndex.hasOwnProperty(seriesName)) {
                        seriesValues = seriesIndex[seriesName];
                        seriesValues.data = utils.objects.toArray(seriesValues.dataIndex);
                        delete seriesValues.dataIndex;
                        seriesValues.data.sort(function (a, b) {
                            return a.label > b.label ? 1 : -1;
                        });
                    }
                }
                if (view.settings.seriesOrder) {
                    view.settings.seriesOrder.forEach(function (seriesName) {
                        var s = seriesIndex[seriesName];
                        if (s) {
                            s.name = seriesName;
                            series.push(s);
                        }
                    });
                }
                else {
                    series = utils.objects.toArray(seriesIndex, function (seriesName, d) {
                        d.name = seriesName;
                        return d;
                    });
                }
                return series;
            }
            widgetViews.registerView("stackedBars", { dataParser: stackedBarsDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('StackedBarsWidget')
        .directive('stackedBars', ["Chart", "utils", function (Chart, utils) {
            return {
                template: '<div class="chart widget-bars"></div>',
                restrict: 'E',
                replace: true,
                link: function postLink(scope, element, attrs) {
                    function draw() {
                        /* jshint validthis: true */
                        var self = this, labelsContainer, labels, labelsWidth, color = this.getColorScale(this.settings.color);
                        function createLabels() {
                            //var series = self.data.map(function (d) {
                            //        return d.name;
                            //    }),
                            var labelsData = labelsContainer.selectAll(".label").data(labels);
                            labelsData.enter().append("svg:text")
                                .text(function (d) {
                                var text = d;
                                if (text.length > 50) {
                                    text = text.substr(0, 50) + "...";
                                }
                                return text;
                            })
                                .attr("text-anchor", "end")
                                .attr("y", function (d, i) {
                                return yScale(d) + self.options.barHeight / 2;
                            })
                                .attr("dy", ".3em")
                                .attr("transform", isHorizontal ? "rotate(-90)" : null);
                            labelsData.exit().remove();
                            labelsWidth = labelsContainer[0][0].getBoundingClientRect().width;
                            labelsContainer.attr("transform", "translate(" + (isHorizontal ?
                                "0, " + (self.height - labelsWidth) : labelsWidth + ", 0") + ")");
                        }
                        function createScales() {
                            var xMax = d3.max(data, function (group) {
                                return d3.max(group, function (d) {
                                    return d.x + d.x0;
                                });
                            }), domain = [0, xMax];
                            xScale = d3.scale.linear()
                                .domain([0, xMax])
                                .rangeRound([0, self.width - labelsWidth - labelsBarsDistance]);
                            var seriesBarWidths = {};
                            graph.data.forEach(function (series) {
                                series.data.forEach(function (bar) {
                                    if (!bar.value) {
                                        return true;
                                    }
                                    var scaledValue = xScale(bar.value);
                                    if (graph.options.minBarWidth > scaledValue) {
                                        scaledValue -= graph.options.minBarWidth - scaledValue;
                                    }
                                    if (seriesBarWidths[bar.label] === undefined) {
                                        seriesBarWidths[bar.label] = scaledValue;
                                    }
                                    else {
                                        seriesBarWidths[bar.label] += scaledValue;
                                    }
                                });
                            });
                            for (var label in seriesBarWidths) {
                                if (seriesBarWidths.hasOwnProperty(label)) {
                                    xScales[label] = d3.scale.linear()
                                        .domain(domain)
                                        .rangeRound([0, seriesBarWidths[label]]);
                                }
                            }
                        }
                        function createBars() {
                            barsMargin = labelsWidth + labelsBarsDistance;
                            barsWidth = (isHorizontal ? self.height : self.width) - barsMargin;
                            barsContainer.attr("transform", "translate(" + barsMargin + ", 0)");
                            d3.scale.category10();
                            var groups = barsContainer.selectAll('g')
                                .data(data)
                                .enter()
                                .append('g');
                            createScales();
                            graph.elements.rects = groups.selectAll('rect')
                                .data(function (d) {
                                return d;
                            })
                                .enter()
                                .append('rect')
                                .attr("class", "stacked-bar")
                                .attr('x', function (d, i) {
                                return xScales[d.y](d.x0);
                            })
                                .attr("data-tooltip", graph.settings.tooltipText ? "" : null)
                                .attr('y', function (d, i) {
                                return yScale(d.y);
                            })
                                .style("fill", function (d) {
                                return color(d.series);
                            })
                                .attr('height', self.options.barHeight)
                                .attr('width', function (d) {
                                var value = d.x;
                                if (!value) {
                                    return 0;
                                }
                                var width = Math.max(xScales[d.y](value) - graph.options.rectMargin, graph.options.minBarWidth);
                                /*
                                 if (width < self.options.minBarWidth){
                                 var y = this.y.baseVal.valueAsString;
                                 if (overflowWidth[y] === undefined)
                                 overflowWidth[y] = 0;

                                 overflowWidth[y] += self.options.minBarWidth - width;
                                 width = self.options.minBarWidth;
                                 }
                                 */
                                return width;
                            });
                            /*
                             graph.elements.rects.each(function(){
                             var currentWidth = this.width.baseVal.value,
                             y = this.y.baseVal.valueAsString;

                             if (currentWidth > overflowWidth[y]){
                             this.setAttribute("width", (currentWidth - overflowWidth[y]) + "px");
                             }
                             });

                             graph.elements.rects.each(function(){
                             var currentX = this.x.baseVal.value,
                             y = this.y.baseVal.valueAsString;

                             if (currentWidth > overflowWidth[y]){
                             this.setAttribute("width", (currentWidth - overflowWidth[y]) + "px");
                             }
                             });
                             */
                        }
                        graph.barsAndLabelsContainer = this.dataSvg.append("svg:g");
                        labelsContainer = graph.barsAndLabelsContainer.append("g").attr("class", "labels");
                        barsContainer = graph.barsAndLabelsContainer.append("g").attr("class", "bars");
                        data = self.data.map(function (d) {
                            return d.data.map(function (o, i) {
                                // Structure it so that your numeric
                                // axis (the stacked amount) is y
                                return {
                                    y: o.value,
                                    x: o.label,
                                    series: d.name,
                                    rawData: o.rawData
                                };
                            });
                        });
                        stack(data);
                        data = data.map(function (group) {
                            return group.map(function (d) {
                                // Invert the x and y values, and y0 becomes x0
                                return {
                                    x: d.y,
                                    y: d.x,
                                    x0: d.y0,
                                    series: d.series,
                                    rawData: d.rawData
                                };
                            });
                        });
                        labels = data[0].map(function (d) {
                            return d.y;
                        });
                        yScale = function (d) {
                            return labels.indexOf(d) * (self.options.barHeight + self.options.barMargin);
                        };
                        createLabels();
                        createBars();
                        setSvgHeight();
                    }
                    function setSvgHeight() {
                        graph.svg.attr("height", (barsContainer[0][0].getBoundingClientRect().height + graph.options.margins.top +
                            graph.options.margins.bottom) + "px");
                    }
                    var defaultOptions = {
                        barHeight: 30,
                        barMargin: 10,
                        barsPadding: 20,
                        scrollBarWidth: 8,
                        rectMargin: 2,
                        minBarWidth: 3
                    }, labelsBarsDistance = 7, barsMargin, barsWidth, graph = new Chart(defaultOptions, draw), isHorizontal, yScale, barsContainer, stack = d3.layout.stack(), data, xScale, xScales = {};
                    graph.getTooltipText = function (d) {
                        if (this.settings.tooltipText) {
                            return utils.strings.parseValue(this.settings.tooltipText, d.rawData);
                        }
                        return d.rawData[this.settings.label] + " (" + d.rawData[this.settings.value] + ")";
                    };
                    graph.init(scope, element, attrs);
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("MultiLineWidget", ["Utils", "Chart", "Widgets"])
        .run(["utils", "widgetViews", "config",
        function (utils, widgetViews, config) {
            function multiLineDataParser(view, data) {
                function getParser(parser) {
                    if (parser.type === "date") {
                        if (parser.format) {
                            var d3timeFormat = config.alwaysUtc ? d3.time.format.utc : d3.time.format;
                            var parseDate = d3timeFormat(parser.format).parse;
                            if (parser.startOfDay) {
                                return function (str) {
                                    var date = parseDate(str);
                                    date.setSeconds(0);
                                    date.setMinutes(0);
                                    date.setHours(0);
                                };
                            }
                            else {
                                return function (str) {
                                    if (!str) {
                                        return null;
                                    }
                                    if (typeof str === "number") {
                                        return utils.date.getMoment(str).toDate();
                                    }
                                    return parseDate(str);
                                };
                            }
                        }
                        else {
                            return function (value) {
                                var m = utils.date.getMoment(value);
                                if (m.isValid()) {
                                    if (parser.startOfDay) {
                                        m.startOf("day");
                                    }
                                    return m.toDate();
                                }
                                return null;
                            };
                        }
                    }
                    return null;
                }
                var seriesIndex = {}, xField = view.settings.x;
                if (view.settings.xType) {
                    var xParser = getParser(view.settings.xType);
                }
                data.forEach(function (item) {
                    if (xParser) {
                        item["_" + xField] = item[xField];
                        item[xField] = xParser(item[xField]);
                    }
                    var seriesName = item[view.settings.series], series = seriesIndex[seriesName];
                    if (!series) {
                        series = seriesIndex[seriesName] = { name: seriesName, values: [] };
                    }
                    series.values.push(item);
                });
                function sortIndex(a, b) {
                    var aVal = a[xField], bVal = b[xField];
                    if (aVal === bVal) {
                        return 0;
                    }
                    return aVal > bVal ? 1 : -1;
                }
                for (var seriesName in seriesIndex) {
                    if (seriesIndex.hasOwnProperty(seriesName)) {
                        seriesIndex[seriesName].values.sort(sortIndex);
                    }
                }
                return utils.objects.toArray(seriesIndex);
            }
            widgetViews.registerView("multiLine", { dataParser: multiLineDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('MultiLineWidget')
        .directive('multiLine', ["Chart", "utils", function (Chart, utils) {
            return {
                template: '<div class="chart multiline"></div>',
                restrict: 'E',
                require: "?ngModel",
                replace: true,
                link: function postLink(scope, element, attrs, ngModel) {
                    function draw() {
                        /* jshint validthis: true */
                        var self = this, svg = this.dataSvg;
                        line = d3.svg.line()
                            .interpolate(graph.settings.interpolate || "linear")
                            .x(function (d) {
                            return graph.scale.x(d[graph.settings.x]);
                        })
                            .y(function (d) {
                            return graph.scale.y(d[graph.settings.y]);
                        });
                        var settingsMinXValue = graph.settings.minXValue || graph.settings.minDefaultXValue;
                        var settingsMaxXValue = graph.settings.maxXValue || graph.settings.maxDefaultXValue;
                        var minXValue = getXAxisValue(settingsMinXValue, graph.settings.xType.type);
                        var maxXValue = getXAxisValue(settingsMaxXValue, graph.settings.xType.type);
                        graph.scale.x.domain(getDomain("x", minXValue, maxXValue));
                        graph.scale.y.domain(getDomain("y", graph.settings.minYValue, graph.settings.maxYValue));
                        graph.elements.series = svg.selectAll(".series")
                            .data(self.data)
                            .enter().append("g")
                            .attr("class", "series pointsGroup")
                            .on("mouseover", function () {
                            var thisGroup = d3.select(this), parent = $(thisGroup[0]).parent();
                            putChildOnTopOfSvgItem(thisGroup, parent);
                            thisGroup.classed("onLine", true);
                        })
                            .on("mouseout", function () {
                            d3.select(this).classed("onLine", false);
                        });
                        graph.elements.series.append("path")
                            .attr("class", "line")
                            .attr("d", function (d) {
                            return line(d.values);
                        })
                            .style("stroke", function (d) {
                            return color(d.name);
                        });
                        graph.elements.series.each(function (series, i) {
                            d3.select(graph.elements.series[0][i]).selectAll(".point").data(series.values)
                                .enter().append("circle")
                                .attr("class", "point")
                                .attr("r", graph.options.circleRadius)
                                .attr("cx", function (d) {
                                return graph.options.circleRadius / 4 + graph.scale.x(d[graph.settings.x]);
                            })
                                .attr("cy", function (d) {
                                return graph.scale.y(d[graph.settings.y]);
                            })
                                .attr("data-tooltip", graph.settings.tooltipText ? "" : null)
                                .attr("data-selectable", graph.settings.onSelect ? "" : null)
                                .style("fill", function () {
                                return color(series.name);
                            });
                        });
                        //When the user will mouseover the legend item the path will be outlined and move to top
                        $(element).find(".legend").on("mouseover", ".legend-item", function () {
                            var pointsGroup = getThePointsGroupRelatedToTheLegend(this);
                            var thisClass = $(pointsGroup).attr("class");
                            (pointsGroup).attr("class", thisClass + " onLine");
                            putChildOnTopOfSvgItem(pointsGroup, pointsGroup.parent());
                        });
                        $(element).find(".legend").on("mouseout", ".legend-item", function () {
                            var pointsGroup = getThePointsGroupRelatedToTheLegend(this);
                            var thisClass = $(pointsGroup).attr("class");
                            $(pointsGroup).attr("class", thisClass.replace("onLine", ""));
                        });
                    }
                    var defaultOptions = {
                        circleRadius: 4
                    }, graph = new Chart(defaultOptions, draw), line, color;
                    element.css("height", "100%");
                    graph.getTooltipText = function (d) {
                        return utils.strings.parseValue(graph.settings.tooltipText, d);
                    };
                    graph.preRender = function () {
                        color = graph.getColorScale(graph.settings.color ||
                            (graph.data.length <= 10 ? "category10" : "category20"));
                        graph.legendData = graph.data.map(function (d) {
                            return { text: d.name, color: color(d.name) };
                        });
                    };
                    graph.init(scope, element, attrs);
                    scope.$on("$destroy", function () {
                        element.off();
                        element.empty();
                    });
                    function getXAxisValue(val, type) {
                        var returnVal;
                        var params;
                        if (val && angular.isString(val)) {
                            params = scope.widget.getState ? scope.widget.getState() : scope.getWidgetParams();
                            returnVal = Number(utils.strings.parseValue(val, {}, params));
                            if (type === "date") {
                                return utils.date.getMoment(returnVal).startOf('day');
                            }
                            return returnVal;
                        }
                        return val;
                    }
                    function putChildOnTopOfSvgItem(child, parent) {
                        child.remove();
                        $(parent).append(child[0]);
                    }
                    function getThePointsGroupRelatedToTheLegend(legendItem) {
                        var fillStyleColor = $(legendItem).find(".legend-item-bullet").attr("style");
                        fillStyleColor =
                            fillStyleColor.substring(fillStyleColor.indexOf(":") + 1, fillStyleColor.length - 1);
                        fillStyleColor = $.trim(fillStyleColor);
                        return $(element).find("g.pointsGroup>path[style*='" + fillStyleColor + "']").parent();
                    }
                    function getDomain(axis, minValue, maxValue) {
                        var min, max, property = graph.settings[axis];
                        graph.data.forEach(function (series) {
                            series.values.forEach(function (item) {
                                var value = item[property];
                                if (minValue === undefined) {
                                    if (min === undefined || value < min) {
                                        min = value;
                                    }
                                }
                                if (maxValue === undefined) {
                                    if (max === undefined || value > max) {
                                        max = value;
                                    }
                                }
                            });
                        });
                        return [min || minValue, max || maxValue];
                    }
                }
            };
        }]);
}());

angular.module("SpanBarsWidget", ["Utils", "Chart"]);

(function () {
    'use strict';
    angular.module('SpanBarsWidget')
        .directive('spanBars', ["Chart", function (Chart) {
            return {
                template: '<div class="chart widget-span-bars"></div>',
                restrict: 'E',
                replace: true,
                link: function postLink(scope, element, attrs) {
                    function draw() {
                        /* jshint validthis: true */
                        var self = this, svg = this.dataSvg;
                        if (this.settings.setDomainByData) {
                            this.setScaleDomains({
                                x: self.settings.setDomainByData.x ? [
                                    d3.min(self.data, function (d) {
                                        return d.start;
                                    }),
                                    d3.max(self.data, function (d) {
                                        return d.end;
                                    })
                                ] : null,
                                y: self.settings.setDomainByData.y ? [0, d3.max(self.data, function (d) {
                                        return d.value;
                                    })] : null
                            });
                        }
                        function createBars() {
                            var bars = svg.selectAll(".span").data(self.data, function (d) {
                                return [+d.start, +d.end].join(":");
                            });
                            graph.elements.bars = bars.enter().append("rect")
                                .attr("class", "span")
                                .attr("width", function (d) {
                                return Math.max(0, self.scale.x(d.end) - self.scale.x(d.start));
                            })
                                .attr("height", function (d) {
                                return Math.max(0, self.scale.y.reverseScale(d.value));
                            })
                                .attr("x", function (d) {
                                return self.scale.x(d.start);
                            })
                                .attr("y", function (d) {
                                return self.scale.y(d.value);
                            })
                                .attr("fill", "steelblue")
                                .attr("data-tooltip", graph.settings.tooltip ? "" : null);
                            bars.exit().remove();
                        }
                        createBars();
                    }
                    var defaultOptions = {
                        padding: 20
                    }, graph = new Chart(defaultOptions, draw);
                    element.css("height", "100%");
                    graph.init(scope, element, attrs);
                    graph.onResize = function () {
                        var self = this;
                        graph.elements.bars.attr("width", function (d) {
                            return Math.max(0, self.scale.x(d.end) - self.scale.x(d.start));
                        })
                            .attr("height", function (d) {
                            return Math.max(0, self.scale.y.reverseScale(d.value));
                        })
                            .attr("x", function (d) {
                            return self.scale.x(d.start);
                        })
                            .attr("y", function (d) {
                            return self.scale.y(d.value);
                        });
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("LinksWidget", ["Utils", "Chart", "Widgets"]).run(["utils", "widgetViews",
        function (utils, widgetViews) {
            function linksDataParser(view, data, params) {
                var settings = view.settings;
                var newData = {
                    nodes: [],
                    links: []
                }, nodeIndexes = {}, rowLinkKeys = {}, linksData = view.settings.getLinksData ? {} : null;
                function getRowNodes(row) {
                    var nodeName, nodeLabel, existingNode, nodeUnique, rowNodeIndexes = [], node;
                    for (var i = 0, nodeSettings; !!(nodeSettings = settings.nodes[i]); i++) {
                        nodeName = row[nodeSettings.name];
                        nodeLabel =
                            nodeSettings.label ? utils.strings.parseValue(nodeSettings.label, row, params) : nodeName;
                        nodeUnique = [nodeSettings.group, nodeLabel].join(":");
                        existingNode = nodeIndexes[nodeUnique];
                        if (existingNode === undefined) {
                            node = {
                                name: nodeName,
                                group: nodeSettings.group,
                                weight: 0,
                                index: newData.nodes.length,
                                label: nodeLabel,
                                unique: nodeUnique,
                                isCurrentlyFocused: false,
                                field: nodeSettings.name,
                                custom: nodeSettings.custom
                            };
                            if (settings.centerNodeName && settings.centerNodeName === nodeName) {
                                node.centered = true;
                                node.fixed = true;
                                node.group = settings.centerMachineGroup || "Center";
                            }
                            newData.nodes.push(node);
                            existingNode = nodeIndexes[nodeUnique] = node;
                        }
                        rowNodeIndexes.push(existingNode.index);
                    }
                    var currentLinkIndex, currentSubLinkIndex, linkKey, link, sourceNodeIndex, targetNodeIndex, currentSourceNode, currentTargetNode;
                    for (currentLinkIndex = 0; currentLinkIndex < rowNodeIndexes.length - 1; currentLinkIndex++) {
                        for (currentSubLinkIndex = currentLinkIndex + 1; currentSubLinkIndex < rowNodeIndexes.length; currentSubLinkIndex++) {
                            linkKey = [rowNodeIndexes[currentLinkIndex], rowNodeIndexes[currentSubLinkIndex]].join("_");
                            if (!rowLinkKeys[linkKey]) {
                                sourceNodeIndex = rowNodeIndexes[currentLinkIndex];
                                targetNodeIndex = rowNodeIndexes[currentSubLinkIndex];
                                currentSourceNode = newData.nodes[rowNodeIndexes[currentLinkIndex]];
                                currentTargetNode = newData.nodes[rowNodeIndexes[currentSubLinkIndex]];
                                if (view.settings.connectSameGroup !== false ||
                                    currentSourceNode.group !== currentTargetNode.group) {
                                    link = {
                                        depth: 1,
                                        unique: [currentSourceNode.unique, currentTargetNode.unique].join("_"),
                                        source: currentSourceNode,
                                        target: currentTargetNode
                                    };
                                    if (linksData) {
                                        linksData[linkKey] = link.data = [row];
                                    }
                                    newData.links.push(link);
                                    rowLinkKeys[linkKey] = true;
                                    currentSourceNode.weight++;
                                    currentTargetNode.weight++;
                                }
                            }
                            else if (linksData) {
                                linksData[linkKey].push(row);
                            }
                        }
                    }
                }
                data.forEach(getRowNodes);
                return newData;
            }
            widgetViews.registerView("links", { dataParser: linksDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('LinksWidget')
        .directive('links', ["Chart", "$parse", "utils", function (Chart, $parse, utils) {
            return {
                template: '<div class="chart widget-links"></div>',
                restrict: 'E',
                replace: true,
                link: function postLink(scope, element, attrs) {
                    function draw() {
                        /* jshint validthis:true */
                        var data = this.getData();
                        if (!data.nodes || !data.links) {
                            return false;
                        }
                        graphDataWidth = this.width;
                        graph.params = {
                            colors: colorbrewer.Set2[Math.max(3, graph.settings.legend ? graph.settings.legend.length : graph.settings.nodes.length)],
                            categories: {}
                        };
                        if (graph.settings.legend) {
                            graph.settings.legend.forEach(function (d) {
                                graph.params.categories[d] = { group: d };
                            });
                        }
                        else {
                            data.nodes.forEach(function (d) {
                                graph.params.categories[d.group] = d;
                            });
                        }
                        graph.params.categoryKeys = d3.keys(graph.params.categories);
                        angular.extend(graph.params, {
                            strokeColor: getColorScale(0.7),
                            fillColor: getColorScale(-0.1)
                        });
                        addDefsAndFilters();
                        createLegend();
                        graph.force = d3.layout.force()
                            .nodes(data.nodes)
                            .links(data.links)
                            .linkStrength(1)
                            .size([graphDataWidth, graph.height])
                            .linkDistance(this.options.linkDistance)
                            .charge(this.options.charge)
                            .gravity(this.options.gravity)
                            .on('tick', tick);
                        graphDataWidth -= legendWidth + 10;
                        this.dataSvg.attr("transform", "translate(" + (legendWidth + 10) + ", " + this.options.margins.top + ")");
                        setBoundaries();
                        setDrag();
                        createLinks();
                        createNodes();
                        initForce();
                        if (graph.settings.linkTooltip) {
                            graph.getTooltipText = function (d) {
                                return utils.strings.parseValue(graph.settings.linkTooltip, d);
                            };
                        }
                        drawed = true;
                    }
                    var defaultOptions = {
                        "linkDistance": 130,
                        "charge": -400,
                        "gravity": 0.01,
                        "height": 800,
                        "numColors": 12,
                        "labelPadding": {
                            "left": 3,
                            "right": 3,
                            "top": 2,
                            "bottom": 2
                        },
                        "labelMargin": { "left": 3, "right": 3, "top": 2, "bottom": 2 },
                        "ticksWithoutCollisions": 150,
                        "renderArrows": false,
                        "legendMargin": 20,
                        "keepNodePositionsOnUpdate": false,
                        // remain fixed in their current position,
                        "fixNodesOnDrag": false
                    }, graph = new Chart(defaultOptions, draw), mouseoutTimeout, highlighted, legendWidth = 0, graphDataWidth, boundaries, drawed, onSelect = attrs.onSelect ? $parse(attrs.onSelect) : null, onSelectLink = attrs.onSelectLink ? $parse(attrs.onSelectLink) : null, getHighlights = attrs.getHighlights ? $parse(attrs.getHighlights) : null, maxLineChars = 26, wrapChars = ' /_-.'.split('');
                    element.css("height", "100%");
                    graph.init(scope, element, attrs);
                    graph.update = function (newData, oldData) {
                        if (!newData.nodes) {
                            drawed = false;
                            return;
                        }
                        if (!drawed) {
                            draw.call(this);
                        }
                        else {
                            if (this.options.keepNodePositionsOnUpdate) {
                                graph.force.stop();
                                if (newData.nodes && oldData && oldData.nodes) {
                                    newData.nodes.forEach(function (newNode) {
                                        var isNew = true;
                                        for (var i = 0, oldNode; !!(oldNode = oldData.nodes[i]); i++) {
                                            if (oldNode.unique === newNode.unique) {
                                                newNode.x = oldNode.x;
                                                newNode.y = oldNode.y;
                                                newNode.fixed = true;
                                                isNew = false;
                                                break;
                                            }
                                        }
                                        newNode.isNewNode = isNew;
                                    });
                                }
                            }
                            graph
                                .force.nodes(newData.nodes || [])
                                .links(newData.links || []);
                            createNodes();
                            createLinks();
                            graph.force.on("end", unFixNodes);
                            initForce();
                        }
                    };
                    graph.onResize = function () {
                        graphDataWidth = this.width;
                        graph.force.size([graphDataWidth, graph.height]);
                        graphDataWidth -= legendWidth + 10;
                        this.dataSvg.attr("transform", "translate(" + (legendWidth + 10) + ", " + this.options.margins.top + ")");
                        setBoundaries();
                        this.force.resume();
                    };
                    graph.highlightNodes = function (selectedNode) {
                        if (highlighted !== selectedNode) {
                            var highlightedNodes = getHighlights ?
                                getHighlights(scope, { links: graph.getData().links, selectedNode: selectedNode }) :
                                getConnections(selectedNode);
                            highlightSelectedNodes(highlightedNodes);
                            highlighted = selectedNode;
                        }
                    };
                    function unFixNodes() {
                        graph.getData().nodes.forEach(function (d) {
                            if (!d.centered) {
                                d.fixed = false;
                            }
                        });
                        graph.force.on("end", null);
                    }
                    function initForce() {
                        if (!graph.force.nodes().length) {
                            return;
                        }
                        setTimeout(function () {
                            graph.elements.nodes.each(function (d) {
                                var node = d3.select(this), text = node.selectAll('text'), bounds = {}, first = true;
                                text.each(function () {
                                    var box = this.getBBox();
                                    if (first || box.x < bounds.x1) {
                                        bounds.x1 = box.x;
                                    }
                                    if (first || box.y < bounds.y1) {
                                        bounds.y1 = box.y;
                                    }
                                    if (first || box.x + box.width > bounds.x2) {
                                        bounds.x2 = box.x + box.width;
                                    }
                                    if (first || box.y + box.height > bounds.y2) {
                                        bounds.y2 = box.y + box.height;
                                    }
                                    first = false;
                                }).attr('text-anchor', 'middle');
                                var padding = graph.options.labelPadding, margin = graph.options.labelMargin, oldWidth = bounds.x2 - bounds.x1;
                                if (d.isNewNode === undefined || d.isNewNode) {
                                    bounds.x1 -= oldWidth / 2;
                                    bounds.x2 -= oldWidth / 2;
                                }
                                bounds.x1 -= padding.left;
                                bounds.y1 -= padding.top;
                                bounds.x2 += padding.left + padding.right;
                                bounds.y2 += padding.top + padding.bottom;
                                node.select('rect')
                                    .attr('x', bounds.x1)
                                    .attr('y', bounds.y1)
                                    .attr('width', bounds.x2 - bounds.x1)
                                    .attr('height', bounds.y2 - bounds.y1);
                                d.extent = {
                                    left: bounds.x1 - margin.left,
                                    right: bounds.x2 + margin.left + margin.right,
                                    top: bounds.y1 - margin.top,
                                    bottom: bounds.y2 + margin.top + margin.bottom
                                };
                                d.edge = {
                                    left: new geo.LineSegment(bounds.x1, bounds.y1, bounds.x1, bounds.y2),
                                    right: new geo.LineSegment(bounds.x2, bounds.y1, bounds.x2, bounds.y2),
                                    top: new geo.LineSegment(bounds.x1, bounds.y1, bounds.x2, bounds.y1),
                                    bottom: new geo.LineSegment(bounds.x1, bounds.y2, bounds.x2, bounds.y2)
                                };
                            });
                            graph.params.numTicks = 0;
                            graph.params.preventCollisions = true;
                            graph.force.start();
                            for (var i = 0; i < graph.options.ticksWithoutCollisions; i++) {
                                graph.force.tick();
                            }
                            graph.dataSvg.style("visibility", "visible");
                        }, 1);
                    }
                    function createNodes() {
                        function getNodeFillColor(d) {
                            return graph.params.fillColor(d.group);
                        }
                        function getNodeStrokeColor(d) {
                            return graph.params.strokeColor(d.group);
                        }
                        var nodesData = graph.dataSvg.selectAll('.node')
                            .data(graph.force.nodes(), function (d) {
                            return d.unique;
                        });
                        graph.elements.nodes = nodesData.enter().append('g')
                            .attr('class', "node")
                            .call(graph.drag)
                            .on('mouseover', function (d) {
                            if (mouseoutTimeout) {
                                clearTimeout(mouseoutTimeout);
                                mouseoutTimeout = null;
                            }
                            graph.highlightNodes(d);
                        })
                            .on('mouseout', function () {
                            if (mouseoutTimeout) {
                                clearTimeout(mouseoutTimeout);
                                mouseoutTimeout = null;
                            }
                            mouseoutTimeout = setTimeout(clearHighlight, 300);
                        });
                        if (onSelect) {
                            graph.elements.nodes.on("click", function (d) {
                                if (d3.event.defaultPrevented) {
                                    return;
                                } // ignore drag
                                var nodeElement = d3.event.currentTarget;
                                onSelect(scope, { node: d, element: d3.event.currentTarget }).then(function (response) {
                                    if (angular.isObject(response)) {
                                        angular.extend(d, response);
                                        if (response.group) {
                                            d3.select(nodeElement).selectAll("rect")
                                                .attr('stroke', getNodeStrokeColor)
                                                .attr('fill', getNodeFillColor);
                                        }
                                    }
                                });
                            });
                        }
                        graph.elements.nodeRect = graph.elements.nodes.append('rect')
                            .attr('rx', 5)
                            .attr('ry', 5)
                            .attr('stroke', getNodeStrokeColor)
                            .attr('fill', getNodeFillColor)
                            .attr('width', 120)
                            .attr('height', 30);
                        graph.elements.nodes.each(function (d) {
                            var node = d3.select(this), lines = wrap(d.label), ddy = 1.1, dy = -ddy * lines.length / 2 + 0.5;
                            lines.forEach(function (line) {
                                node.append('text')
                                    .text(line)
                                    .attr('dy', dy + 'em');
                                dy += ddy;
                            });
                        });
                        nodesData.exit().remove();
                        graph.elements.nodes = graph.dataSvg.selectAll('.node');
                    }
                    function createLinks() {
                        var linksData = graph.dataSvg.selectAll('.link')
                            .data(graph.force.links(), function (d) {
                            return d.unique;
                        });
                        graph.elements.links = linksData
                            .enter().insert('line', ".node")
                            .attr('class', 'link' + (graph.options.renderArrows ? " arrow" : "") +
                            (onSelectLink ? " selectable" : ""));
                        if (onSelectLink) {
                            graph.elements.links.on("click", function (d) {
                                if (d3.event.defaultPrevented) {
                                    return;
                                } // ignore drag
                                onSelectLink(scope, { $event: d3.event, link: d });
                            });
                        }
                        if (graph.settings.linkTooltip) {
                            graph.elements.links.attr("data-tooltip", "");
                        }
                        linksData.exit().remove();
                        graph.elements.links = graph.dataSvg.selectAll('.link');
                    }
                    function createLegend() {
                        if (!graph.elements.legend) {
                            graph.elements.legend = graph.svg.append('g')
                                .attr('class', 'legend')
                                .attr("transform", "translate(" + graph.options.margins.left + ", " + graph.options.margins.top + ")");
                            graph.params.legendConfig = {
                                rectWidth: 12,
                                rectHeight: 12,
                                xOffset: 0,
                                yOffset: 30,
                                xOffsetText: 20,
                                yOffsetText: 10,
                                lineHeight: 20
                            };
                            graph.params.legendConfig.xOffsetText += graph.params.legendConfig.xOffset;
                            graph.params.legendConfig.yOffsetText += graph.params.legendConfig.yOffset;
                        }
                        var legendCategories = graph.elements.legend.selectAll('.legend-category')
                            .data(d3.values(graph.params.categories))
                            .enter().append('g')
                            .attr('class', 'legend-category');
                        legendCategories.append('rect')
                            .attr('x', graph.params.legendConfig.xOffset)
                            .attr('y', function (d, i) {
                            return graph.params.legendConfig.yOffset + i * graph.params.legendConfig.lineHeight;
                        })
                            .attr('height', graph.params.legendConfig.rectHeight)
                            .attr('width', graph.params.legendConfig.rectWidth)
                            .attr('fill', function (d) {
                            return graph.params.fillColor(d.group);
                        })
                            .attr('stroke', function (d) {
                            return graph.params.strokeColor(d.group);
                        });
                        legendCategories.append('text')
                            .attr('x', graph.params.legendConfig.xOffsetText)
                            .attr('y', function (d, i) {
                            return graph.params.legendConfig.yOffsetText + i * graph.params.legendConfig.lineHeight;
                        })
                            .text(function (d) {
                            return d.group;
                        });
                        element.on('scroll', function () {
                            graph.elements.legend.attr('transform', 'translate(' + graph.options.margins.left + "," +
                                (graph.options.margins.top + $(this).scrollTop()) + ')');
                        });
                        legendWidth = graph.elements.legend[0][0].getBoundingClientRect().width;
                    }
                    function setBoundaries() {
                        var margin = 5;
                        boundaries = {
                            top: graph.options.labelPadding.top + margin,
                            bottom: graph.height - graph.options.labelMargin.bottom -
                                graph.options.labelPadding.bottom - margin,
                            left: graph.options.labelMargin.left + graph.options.labelPadding.left + margin,
                            right: graphDataWidth - graph.options.labelMargin.right - graph.options.labelPadding.right -
                                margin
                        };
                        boundaries.center = {
                            x: (boundaries.right - boundaries.left) / 2 + boundaries.left,
                            y: (boundaries.bottom - boundaries.top) / 2 + boundaries.top
                        };
                    }
                    function setDrag() {
                        graph.params.draggedThreshold = d3.scale.linear()
                            .domain([0, 0.1])
                            .range([5, 20])
                            .clamp(true);
                        function dragged(d) {
                            var threshold = graph.params.draggedThreshold(graph.force.alpha()), dx = d.oldX - d.px, dy = d.oldY - d.py;
                            if (Math.abs(dx) >= threshold || Math.abs(dy) >= threshold) {
                                d.dragged = true;
                            }
                            return d.dragged;
                        }
                        graph.drag = d3.behavior.drag()
                            .origin(function (d) {
                            return d;
                        })
                            .on('dragstart', function (d) {
                            d.oldX = d.x;
                            d.oldY = d.y;
                            d.dragged = false;
                            d.fixed = true;
                        })
                            .on('drag', function (d) {
                            d.px = d3.event.x;
                            d.py = d3.event.y;
                            if (dragged(d)) {
                                graph.params.numTicks = 0;
                                if (!graph.force.alpha()) {
                                    graph.force.alpha(0.025);
                                }
                            }
                        })
                            .on('dragend', function (d) {
                            d.fixed = graph.options.fixNodesOnDrag;
                        });
                    }
                    function addDefsAndFilters() {
                        graph.svg.insert('defs', ".graph-data").selectAll('marker')
                            .data(['end'])
                            .enter().append('marker')
                            .attr('id', String)
                            .attr('viewBox', '0 -5 10 10')
                            .attr('refX', 10)
                            .attr('refY', 0)
                            .attr('markerWidth', 6)
                            .attr('markerHeight', 6)
                            .attr('orient', 'auto')
                            .append('path')
                            .attr('d', 'M0,-5L10,0L0,5');
                        // adapted from http://stackoverflow.com/questions/9630008
                        // and http://stackoverflow.com/questions/17883655
                        var glow = graph.svg.insert('filter', ".graph-data")
                            .attr('x', '-50%')
                            .attr('y', '-50%')
                            .attr('width', '200%')
                            .attr('height', '200%')
                            .attr('id', 'blue-glow');
                        glow.append('feColorMatrix')
                            .attr('type', 'matrix')
                            .attr('values', '0 0 0 0  0 ' +
                            '0 0 0 0  0 ' +
                            '0 0 0 0  .7 ' +
                            '0 0 0 1  0 ');
                        glow.append('feGaussianBlur')
                            .attr('stdDeviation', 3)
                            .attr('result', 'coloredBlur');
                        glow.append('feMerge').selectAll('feMergeNode')
                            .data(['coloredBlur', 'SourceGraphic'])
                            .enter().append('feMergeNode')
                            .attr('in', String);
                    }
                    function getColorScale(darkness) {
                        return d3.scale.ordinal()
                            .domain(graph.params.categoryKeys)
                            .range(graph.params.colors.map(function (c) {
                            return d3.hsl(c).darker(darkness).toString();
                        }));
                    }
                    function tick(e) {
                        graph.params.numTicks++;
                        if (graph.params.preventCollisions) {
                            preventCollisions(e.alpha);
                        }
                        graph.elements.links
                            .attr('x1', function (d) {
                            return d.source.x;
                        })
                            .attr('y1', function (d) {
                            return d.source.y;
                        })
                            .each(function (d) {
                            var x = d.target.x, y = d.target.y;
                            if (d.source.x === x && d.source.y === y) {
                                return true;
                            }
                            var line = new geo.LineSegment(d.source.x, d.source.y, x, y);
                            for (var e in d.target.edge) {
                                if (d.target.edge.hasOwnProperty(e)) {
                                    var ix = line.intersect(d.target.edge[e].offset(x, y));
                                    if (ix.in1 && ix.in2) {
                                        x = ix.x;
                                        y = ix.y;
                                        break;
                                    }
                                }
                            }
                            d3.select(this)
                                .attr('x2', x)
                                .attr('y2', y);
                        });
                        graph.elements.nodes
                            .attr('transform', function (d) {
                            return 'translate(' + d.x + ',' + d.y + ')';
                        });
                    }
                    function preventCollisions() {
                        var data = graph.getData(), quadtree = d3.geom.quadtree(data.nodes);
                        data.nodes.forEach(function (obj) {
                            if (obj.centered) {
                                obj.y = boundaries.center.y;
                                obj.x = boundaries.center.x;
                                return true;
                            }
                            var ox1 = obj.x + obj.extent.left, ox2 = obj.x + obj.extent.right, oy1 = obj.y + obj.extent.top, oy2 = obj.y + obj.extent.bottom;
                            quadtree.visit(function (quad) {
                                if (quad.point && quad.point !== obj) {
                                    // Check if the rectangles intersect
                                    var p = quad.point, px1 = p.x + p.extent.left, px2 = p.x + p.extent.right, py1 = p.y + p.extent.top, py2 = p.y + p.extent.bottom, ix = (px1 <= ox2 && ox1 <= px2 && py1 <= oy2 && oy1 <= py2);
                                    if (ix) {
                                        var xa1 = ox2 - px1, // shift obj left , p right
                                        xa2 = px2 - ox1, // shift obj right, p left
                                        ya1 = oy2 - py1, // shift obj up   , p down
                                        ya2 = py2 - oy1, // shift obj down , p up
                                        adj = Math.min(xa1, xa2, ya1, ya2);
                                        if (adj === xa1) {
                                            obj.x -= adj / 2;
                                            p.x += adj / 2;
                                        }
                                        else if (adj === xa2) {
                                            obj.x += adj / 2;
                                            p.x -= adj / 2;
                                        }
                                        else if (adj === ya1) {
                                            obj.y -= adj / 2;
                                            p.y += adj / 2;
                                        }
                                        else if (adj === ya2) {
                                            obj.y += adj / 2;
                                            p.y -= adj / 2;
                                        }
                                    }
                                    return ix;
                                }
                            });
                            if (oy1 < boundaries.top) {
                                obj.y += 1;
                            }
                            else if (oy2 > boundaries.bottom - obj.extent.bottom + obj.extent.top) {
                                obj.y -= 1;
                            }
                            if (ox1 < boundaries.left) {
                                obj.x += 1;
                            }
                            else if (ox2 > boundaries.right - obj.extent.right + obj.extent.left) {
                                obj.x -= 1;
                            }
                        });
                    }
                    function wrap(text) {
                        if (text.length <= maxLineChars) {
                            return [text];
                        }
                        else {
                            for (var k = 0; k < wrapChars.length; k++) {
                                var c = wrapChars[k];
                                for (var i = maxLineChars; i >= 0; i--) {
                                    if (text.charAt(i) === c) {
                                        var line = text.substring(0, i + 1);
                                        return [line].concat(wrap(text.substring(i + 1)));
                                    }
                                }
                            }
                            return [text.substring(0, maxLineChars)]
                                .concat(wrap(text.substring(maxLineChars)));
                        }
                    }
                    function clearHighlight() {
                        graph.elements.nodes.classed('inactive', false);
                        graph.elements.links.classed('inactive', false);
                        highlighted = null;
                    }
                    function highlightSelectedNodes(selectedNodes) {
                        graph.elements.nodes.classed('inactive', function (d) {
                            return !selectedNodes[d.unique];
                        });
                        graph.elements.links.classed('inactive', function (d) {
                            return (!selectedNodes[d.source.unique] || !selectedNodes[d.target.unique]);
                        });
                    }
                    function getConnections(node) {
                        var connections = {};
                        connections[node.unique] = true;
                        graph.getData().links.forEach(function (link) {
                            if (link.source === node) {
                                connections[link.target.unique] = true;
                            }
                            else if (link.target === node) {
                                connections[link.source.unique] = true;
                            }
                        });
                        return connections;
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("MultiTimelineWidget", ["Utils", "Chart", "Widgets"]).run(["widgetViews", function (widgetViews) {
            widgetViews.registerView("multiTimeline");
        }]);
}());

(function () {
    'use strict';
    angular.module('MultiTimelineWidget')
        .directive('multiTimeline', ["Chart", "$parse", "utils", "$timeout",
        function (Chart, $parse, utils, $timeout) {
            return {
                template: '<div class="chart widget-multiTimeline"></div>',
                restrict: 'E',
                replace: true,
                link: function postLink(scope, element, attrs) {
                    function draw() {
                        /* jshint validthis: true */
                        var self = this, svg = this.dataSvg, seriesContainer = svg.append("g").attr("class", "series-container"), labelsContainer = svg.append("g").attr("class", "labels-container");
                        function createLabels() {
                            graph.elements.labels =
                                labelsContainer.selectAll(".label").data(self.data, function (d) {
                                    return d[graph.settings.unique];
                                });
                            graph.elements.labels.enter().append("svg:text")
                                .text(function (d) {
                                return d[self.settings.label];
                            })
                                .attr("text-anchor", "end")
                                .attr("y", function (d, i) {
                                return (i + 0.5) * graph.options.seriesHeight;
                            })
                                .attr("dy", ".3em");
                            graph.elements.labels.exit().remove();
                            labelsWidth = labelsContainer[0][0].getBoundingClientRect().width;
                            labelsContainer.attr("transform", "translate(" + labelsWidth + ", 0)");
                        }
                        function createSeries() {
                            graph.elements.series =
                                seriesContainer.selectAll(".series").data(self.data, function (d) {
                                    return d[graph.settings.unique];
                                });
                            var series = graph.elements.series.enter().append("svg:g")
                                .attr("class", "series" + (onSeriesClick ? " selectable" : ""))
                                .attr("transform", function (d, i) {
                                return "translate(0, " + i * graph.options.seriesHeight + ")";
                            });
                            series.append("svg:rect")
                                .attr("class", "series-background")
                                .attr("width", "100%")
                                .attr("height", graph.options.seriesHeight);
                            series.append("svg:line")
                                .attr("class", "series-divider")
                                .attr("x1", 0)
                                .attr("x2", "100%")
                                .attr("y1", 0)
                                .attr("y2", 0);
                            series.append("svg:rect")
                                .attr("class", "series-session")
                                .attr("x", function (series) {
                                return d3.min(series.events, function (d) {
                                    return graph.scale.x(d[graph.settings.value]);
                                });
                            })
                                .attr("y", (graph.options.seriesHeight - graph.options.sessionHeight) / 2)
                                .attr("width", function (series) {
                                return d3.max(series.events, function (d) {
                                    return graph.scale.x(d[graph.settings.value]);
                                }) - d3.min(series.events, function (d) {
                                    return graph.scale.x(d[graph.settings.value]);
                                });
                            })
                                .attr("height", graph.options.sessionHeight);
                            series.selectAll(".series-event")
                                .data(function (series) {
                                return series.events;
                            }, function (d) {
                                return d.id;
                            })
                                .enter().append("svg:circle")
                                .attr("class", "series-event")
                                .attr("r", graph.options.eventRadius)
                                .attr("cx", function (d) {
                                return graph.scale.x(d[graph.settings.value]);
                            })
                                .attr("cy", graph.options.seriesHeight / 2)
                                .attr("data-tooltip", graph.settings.eventTooltip ? "eventTooltip" : null);
                            graph.elements.series.exit().remove();
                        }
                        function addEvents() {
                            if (onSeriesHover) {
                                element.on("mouseenter", ".series", function (e) {
                                    $timeout.cancel(seriesMouseOutTimeout);
                                    scope.$apply(function () {
                                        onSeriesHover(scope, { series: e.currentTarget.__data__ });
                                    });
                                });
                            }
                            if (onSeriesMouseOut) {
                                element.on("mouseleave", ".series", function () {
                                    seriesMouseOutTimeout = $timeout(function () {
                                        scope.$apply(function () {
                                            onSeriesMouseOut(scope, { series: selectedSeries && selectedSeries.__data__ });
                                        });
                                    }, 40);
                                });
                            }
                            if (onSeriesClick) {
                                element.on("click", ".series", function (e) {
                                    if (selectedSeries) {
                                        selectedSeries.classList.remove("selected");
                                        if (selectedSeries === e.currentTarget) {
                                            scope.$apply(function () {
                                                onSeriesClick(scope, { series: selectedSeries = null });
                                            });
                                        }
                                        else {
                                            selectSeries(e.currentTarget);
                                        }
                                    }
                                    else {
                                        selectSeries(e.currentTarget);
                                    }
                                });
                            }
                            function selectSeries(seriesElement) {
                                scope.$apply(function () {
                                    selectedSeries = seriesElement;
                                    seriesElement.classList.add("selected");
                                    onSeriesClick(scope, { series: seriesElement.__data__ });
                                });
                            }
                        }
                        createLabels();
                        this.setScaleRanges({
                            x: [labelsWidth + this.options.seriesMargin + this.options.margins.left, this.width]
                        });
                        var domainExtent = {
                            x: [
                                d3.min(self.data, function (series) {
                                    return d3.min(series.events, function (d) {
                                        return d[graph.settings.value];
                                    });
                                }),
                                d3.max(self.data, function (series) {
                                    return d3.max(series.events, function (d) {
                                        return d[graph.settings.value];
                                    });
                                })
                            ]
                        };
                        if (domainExtent.x[0] === domainExtent.x[1]) {
                            var extentDate = domainExtent.x[0];
                            domainExtent.x[0] = utils.date.getMoment(extentDate).subtract(1, "days").toDate();
                            domainExtent.x[1] = utils.date.getMoment(extentDate).add(1, "days").toDate();
                        }
                        this.setScaleDomains(domainExtent);
                        this.color = this.getColorScale();
                        createSeries();
                        addEvents();
                    }
                    var defaultOptions = {
                        seriesHeight: 35,
                        sessionHeight: 3,
                        seriesMargin: 10,
                        eventRadius: 3
                    }, graph = new Chart(defaultOptions, draw), labelsWidth, onSeriesHover = attrs.onSeriesHover ? $parse(attrs.onSeriesHover) : null, onSeriesMouseOut = attrs.onSeriesMouseOut ? $parse(attrs.onSeriesMouseOut) : null, onSeriesClick = attrs.onSeriesClick ? $parse(attrs.onSeriesClick) : null, selectedSeries, seriesMouseOutTimeout;
                    graph.init(scope, element, attrs);
                    graph.onResize = function () {
                    };
                    graph.postRender = function () {
                        this.axes.x._element.attr("transform", "translate(" + this.options.margins.left + ", " +
                            (this.data.length * this.options.seriesHeight + this.options.margins.top) + ")");
                        this.axes.x._grid.attr("transform", "translate(" + this.options.margins.left + ", " +
                            (this.data.length * this.options.seriesHeight + this.options.margins.top) + ")");
                        this.axes.x._label.attr("transform", "translate(" + labelsWidth / 2 + ", 0)");
                    };
                    graph.preRender = function () {
                        element.css("height", this.data.length * this.options.seriesHeight + this.xAxisHeight +
                            this.options.margins.top + this.options.margins.bottom +
                            this.options.axisLabelsWidth.x);
                    };
                    graph.getTooltipText = function (d, type) {
                        return utils.strings.parseValue(graph.settings[type], d);
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TreeWidget", ["Utils", "Chart", "Widgets"]).run(["widgetViews", function (widgetViews) {
            function treeDataParser(view, data) {
                function createLinksIndex() {
                    data.forEach(function (row) {
                        var node = linksIndex[row[linkParam]];
                        if (!node) {
                            node = linksIndex[row[linkParam]] = {};
                        }
                        var child = node[row[nameParam]];
                        if (!child) {
                            child = node[row[nameParam]] = [];
                        }
                        child.push(row);
                    });
                }
                function getNodeChildren(node) {
                    var nodeLinks = linksIndex[node.name], newNode;
                    if (nodeLinks) {
                        node.children = [];
                        for (var childName in nodeLinks) {
                            if (nodeLinks.hasOwnProperty(childName)) {
                                newNode = createNode(node.unique, childName, nodeLinks[childName]);
                                node.children.push(newNode);
                                getNodeChildren(newNode);
                            }
                        }
                    }
                }
                function createNode(parentUnique, nodeName, nodeData) {
                    var node = { name: nodeName, data: nodeData, unique: [parentUnique, nodeName].join(":"), size: 1 };
                    if (view.settings.expandNode) {
                        node = angular.extend(node, view.settings.expandNode(node));
                    }
                    return node;
                }
                var root = view.settings.root, linksIndex = {}, linkParam = view.settings.link, nameParam = view.settings.nodeName;
                root.unique = root.unique || "__ROOT__";
                createLinksIndex();
                getNodeChildren(root);
                return root;
            }
            widgetViews.registerView("tree", { dataParser: treeDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module('TreeWidget')
        .directive('tree', ["Chart", "$parse", "utils", function (Chart, $parse, utils) {
            return {
                restrict: 'E',
                template: "<div class='chart widget-tree'></div>",
                replace: true,
                link: function postLink(scope, element, attrs) {
                    function draw() {
                        /* jshint validthis: true */
                        var data = this.getData();
                        if (!data) {
                            return false;
                        }
                        graph.tree = d3.layout.tree()
                            .size([this.dataHeight, this.dataWidth]);
                        root = data;
                        initNodes(data);
                        return true;
                    }
                    function initNodes() {
                        if (!root) {
                            return;
                        }
                        root.x0 = graph.dataHeight / 2;
                        root.y0 = graph.options.rtl ? graph.dataWidth : 0;
                        root[graph.settings.xPositionParam] = graph.scale.x.domain()[graph.options.rtl ? 1 : 0];
                        function toggleAll(d) {
                            if (d.children) {
                                d.children.forEach(toggleAll);
                                toggle(d);
                            }
                        }
                        if (root.children) {
                            root.children.forEach(toggleAll);
                        }
                        createGraph(root);
                    }
                    function selectNode(node) {
                        if (onSelect && !node.children) {
                            onSelect(scope, { node: node, element: d3.event.currentTarget, graph: graph }).then(function (response) {
                                if (angular.isObject(response)) {
                                    if (response.children) {
                                        var newnodes = graph.tree.nodes(response.children).reverse();
                                        node.children = newnodes[0];
                                        createGraph(node);
                                    }
                                    else {
                                        node.children = [];
                                    }
                                }
                                else {
                                    toggle(node);
                                    createGraph(node);
                                }
                            });
                        }
                        else {
                            toggle(node);
                            createGraph(node);
                        }
                    }
                    function setNodePosition(d) {
                        d.y = graph.scale.x(d[graph.settings.xPositionParam]);
                    }
                    function createGraph(source) {
                        function createNodes() {
                            if (graph.scale.x && graph.settings.xPositionParam) {
                                nodes.forEach(function (d) {
                                    if (d.unique === "__ROOT__") {
                                        d.y = d.y0;
                                    }
                                    else {
                                        d.y = graph.scale.x(d[graph.settings.xPositionParam]);
                                    }
                                });
                            }
                            var node = graph.dataSvg.selectAll("g.node")
                                .data(nodes, function (d) {
                                return d.unique;
                            });
                            // Enter any new nodes at the parent's previous position.
                            var nodeEnter = node.enter().append("svg:g")
                                .attr("class", "node")
                                .attr("data-tooltip", graph.settings.nodeTooltip ? function (d) {
                                return d.unique === "__ROOT__" ? null : "nodeTooltip";
                            } : null)
                                .attr("transform", function () {
                                return "translate(" + source.y0 + "," + source.x0 + ")";
                            })
                                .on("click", selectNode)
                                .on('mouseover', function (d) {
                                highlightPath(d);
                            })
                                .on('mouseout', function () {
                                clearHighlight();
                            });
                            graph.elements.nodes = nodeEnter;
                            nodeEnter.append("svg:circle")
                                .attr("r", 1e-6)
                                .style("fill", function (d) {
                                return d._children ? "lightsteelblue" : "#fff";
                            });
                            nodeEnter.append("svg:text")
                                .attr("y", "-.75em")
                                .attr("text-anchor", "middle")
                                .text(function (d) {
                                return d.name;
                            })
                                .style("fill-opacity", 1e-6);
                            // Transition nodes to their new position.
                            var nodeUpdate = node.transition()
                                .duration(duration)
                                .attr("transform", getNodeTransform);
                            nodeUpdate.select("circle")
                                .attr("r", 4.5)
                                .style("fill", function (d) {
                                return d._children ? "lightsteelblue" : "#fff";
                            });
                            nodeUpdate.select("text")
                                .style("fill-opacity", 1);
                            // Transition exiting nodes to the parent's new position.
                            var nodeExit = node.exit().transition()
                                .duration(duration)
                                .attr("transform", function () {
                                return "translate(" + source.y + "," + source.x + ")";
                            })
                                .remove();
                            nodeExit.select("circle")
                                .attr("r", 1e-6);
                            nodeExit.select("text")
                                .style("fill-opacity", 1e-6);
                            graph.elements.nodes = graph.dataSvg.selectAll('.node');
                        }
                        function createLinks() {
                            var link = graph.dataSvg.selectAll("path.link")
                                .data(tree.links(nodes), function (d) {
                                return d.target.unique;
                            });
                            // Enter any new links at the parent's previous position.
                            graph.elements.links = link.enter().insert("svg:path", ".node")
                                .attr("class", "link" + (onSelectLink ? " selectable" : ""))
                                .attr("d", function () {
                                var o = { x: source.x0, y: source.y0 };
                                return diagonal({ source: o, target: o });
                            });
                            if (onSelectLink) {
                                graph.elements.links.on("click", function (d) {
                                    onSelectLink(scope, { $event: d3.event, link: d });
                                });
                            }
                            graph.elements.links.transition()
                                .duration(duration)
                                .attr("d", diagonal);
                            // Transition links to their new position.
                            link.transition()
                                .duration(duration)
                                .attr("d", diagonal);
                            // Transition exiting nodes to the parent's new position.
                            link.exit().transition()
                                .duration(duration)
                                .attr("d", function () {
                                var o = { x: source.x, y: source.y };
                                return diagonal({ source: o, target: o });
                            })
                                .remove();
                            graph.elements.links = graph.dataSvg.selectAll('.link');
                        }
                        function createLinkTexts() {
                            var linksText = graph.dataSvg.selectAll(".linkText").data(tree.links(nodes), function (d) {
                                return d.target.unique;
                            }), params = scope.getWidgetParams();
                            graph.elements.linkTexts = linksText.enter().insert("svg:text", ".node")
                                .attr("class", "linkText" + (onSelectLink ? " selectable" : ""))
                                .text(function (d) {
                                return utils.strings.parseValue(graph.settings.linkText, d, params);
                            })
                                .attr("text-anchor", "middle")
                                .style("fill-opacity", 1e-6)
                                .attr("dy", "-.35em")
                                .attr("transform", function (d) {
                                return "translate(" + d.source.y + ", " + d.source.x + ")";
                            })
                                .attr("data-tooltip", graph.settings.linkTextTooltip ? "linkTextTooltip" : null);
                            if (onSelectLink) {
                                graph.elements.linkTexts.on("click", function (d) {
                                    onSelectLink(scope, { $event: d3.event, link: d });
                                });
                            }
                            graph.elements.linkTexts.transition()
                                .duration(duration)
                                .style("fill-opacity", 1)
                                .attr("transform", function (d) {
                                return "translate(" + (d.source.y + (d.target.y - d.source.y) / 2) + ", " +
                                    (d.source.x + (d.target.x - d.source.x) / 2) + ")";
                            });
                            linksText.exit().transition()
                                .duration(duration)
                                .attr("transform", function (d) {
                                return "translate(" + d.source.y + ", " + d.source.x + ")";
                            })
                                .style("fill-opacity", 1e-6)
                                .remove();
                            graph.elements.linkTexts = graph.dataSvg.selectAll('.linkText');
                        }
                        var tree = graph.tree, duration = graph.options.expandDuration;
                        nodes = tree.nodes(root).reverse();
                        createNodes();
                        createLinks();
                        if (graph.settings.linkText) {
                            createLinkTexts();
                        }
                        // Stash the old positions for transition.
                        nodes.forEach(function (d) {
                            d.x0 = d.x;
                            d.y0 = d.y;
                        });
                    }
                    function highlightPath(node) {
                        var highlighted = getHighlightedNodes(node);
                        graph.elements.nodes.classed('inactive', function (d) {
                            return !highlighted[d.unique];
                        });
                        graph.elements.links.classed('inactive', function (d) {
                            return (!highlighted[d.source.unique] || !highlighted[d.target.unique]);
                        });
                        element.addClass("highlighted");
                    }
                    function getHighlightedNodes(node) {
                        var highlighted = {}, currentNode = node;
                        while (currentNode) {
                            highlighted[currentNode.unique] = true;
                            currentNode = currentNode.parent;
                        }
                        return highlighted;
                    }
                    function toggle(d) {
                        if (d.children) {
                            d._children = d.children;
                            d.children = null;
                        }
                        else {
                            d.children = d._children;
                            d._children = null;
                        }
                    }
                    function clearHighlight() {
                        graph.elements.nodes.classed('inactive', false);
                        graph.elements.links.classed('inactive', false);
                        highlighted = null;
                        element.removeClass("highlighted");
                    }
                    function getNodeTransform(d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    }
                    function onUpdateDomain() {
                        nodes.forEach(setNodePosition);
                        graph.elements.nodes.attr("transform", getNodeTransform);
                        graph.elements.links.attr("d", function (d) {
                            return diagonal({ source: d.source, target: d.target });
                        });
                        graph.elements.linkTexts.attr("transform", function (d) {
                            return "translate(" + (d.source.y + (d.target.y - d.source.y) / 2) + ", " +
                                (d.source.x + (d.target.x - d.source.x) / 2) + ")";
                        });
                    }
                    var defaultOptions = {
                        expandDuration: 500,
                        rtl: false,
                        margins: {
                            top: 10,
                            bottom: 10,
                            left: 10,
                            right: 10
                        }
                    }, graph = new Chart(defaultOptions, draw), root, onSelect = attrs.onSelect ? $parse(attrs.onSelect) : null, onSelectLink = attrs.onSelectLink ? $parse(attrs.onSelectLink) : null, diagonal = d3.svg.diagonal().projection(function (d) {
                        return [d.y, d.x];
                    }), highlighted, nodes;
                    element.css("height", "100%");
                    graph.onUpdateDomain = onUpdateDomain;
                    graph.init(scope, element, attrs);
                    graph.getTooltipText = function (d, type) {
                        return utils.strings.parseValue(graph.settings[type], d);
                    };
                    graph.onResize = function () {
                        graph.tree.size([this.dataHeight, this.dataWidth]);
                        root.x0 = graph.dataHeight / 2;
                        root.y0 = graph.options.rtl ? graph.dataWidth : 0;
                        onUpdateDomain();
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("FiguresWidget", ["Utils", "Widgets"]).run(["utils", "widgetViews", function (utils, widgetViews) {
            function figuresDataParser(view, data, params) {
                var figuresData = [], noValueDisplay = view.settings.noValue || "(No value)";
                data.forEach(function (item, i) {
                    var value = view.settings.value ? utils.strings.parseValue(view.settings.value, item, params) :
                        item.value;
                    if (!value && value !== 0) {
                        value = noValueDisplay;
                    }
                    figuresData.push({
                        label: getLabel(item, i),
                        value: value
                    });
                });
                function getLabel(item, index) {
                    var label;
                    if (view.settings.label) {
                        label = item[view.settings.label];
                    }
                    if (!label && view.settings.labels) {
                        label = view.settings.labels[index];
                    }
                    return label;
                }
                return figuresData;
            }
            widgetViews.registerView("figures", { dataParser: figuresDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("FocusWhen", [])
        .directive("focusWhen", ["$parse", function ($parse) {
            return {
                restrict: 'A',
                link: function postLink(scope, element, attrs) {
                    scope.$watch(attrs.focusWhen, function (value) {
                        if (value) {
                            setTimeout(function () {
                                element[0].focus();
                                element[0].select();
                            }, 40);
                        }
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Tooltip", []).directive("tooltip", ["$timeout", function ($timeout) {
            return {
                restrict: 'E',
                transclude: true,
                template: '<div class="tooltip-directive" ng-show="isOpen" ng-transclude></div>',
                require: '?ngModel',
                link: function postLink(scope, element, attrs, ngModel) {
                    function open() {
                        scope.isOpen = true;
                        element.css("opacity", 0);
                        document.body.addEventListener("mousedown", onBackgroundClick);
                        $timeout(function () {
                            setPosition();
                            element.css("opacity", 1);
                        }, 50);
                    }
                    function close() {
                        document.body.removeEventListener("mousedown", onBackgroundClick);
                        scope.isOpen = false;
                        ngModel.$setViewValue(false);
                    }
                    function setPosition() {
                        var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, tooltipWidth = tooltip.outerWidth(), tooltipHeight = tooltip.outerHeight(), margin = 20;
                        if (currentPosition.left + tooltipWidth > width - margin) {
                            currentPosition.left = currentPosition.left - tooltipWidth;
                        }
                        if (currentPosition.top + tooltipHeight > height - margin) {
                            currentPosition.top = currentPosition.top - tooltipHeight;
                        }
                        tooltip.css(currentPosition);
                    }
                    function onBackgroundClick(e) {
                        var tooltipElement = $(e.target).closest(".tooltip-directive");
                        if (!tooltipElement.length || tooltipElement[0] !== tooltip[0]) {
                            scope.$apply(close);
                        }
                        return true;
                    }
                    var tooltip = element.find(".tooltip-directive"), currentPosition;
                    scope.isOpen = false;
                    ngModel.$render = function () {
                        if (ngModel.$viewValue) {
                            open();
                        }
                        else {
                            close();
                        }
                    };
                    scope.$watch(attrs.position, function (value) {
                        if (value) {
                            currentPosition = value;
                        }
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale", [
        "Version",
        'ngRoute',
        'ngMessages',
        'ui.router',
        'ngAnimate',
        "Config",
        "DAL",
        "Page",
        "Reports",
        "Widgets",
        "Controls",
        "Menus",
        "Search",
        "EventBus",
        "Events",
        "Popup",
        "Cache",
        "Chart",
        "Utils",
        "FSHighChart",
        "Format",
        "Conditions",
        "DataEntities",
        "FilterValidatorsModule",
        "DataQueries",
        "Explore",
        "Explore.Filters",
        "Explore.DataViews",
        "State",
        "Styles",
        "Transforms",
        "Icons",
        "Tags",
        "Yoxigen",
        "DatePicker",
        "Dropdown",
        "ui.layout",
        "ngResource",
        "FocusWhen",
        "Tooltip",
        "Colors",
        "FortscaleAuth",
        "NumberRangeModule",
        "StringInModule",
        "multi-select",
        "rt.debounce",
        "paging",
        "simplePagination",
        "NumbersOnlyModule",
        "DurationOnlyModule",
        "PopupConditions",
        'restangular',
        // Widgets:
        "TableWidget",
        "SecurityFeed",
        "BubblesWidget",
        "HeatMapWidget",
        "TagsWidget",
        "BarsChartWidget",
        "PercentChartWidget",
        "PropertiesWidget",
        "TabsWidget",
        "ForceChartWidget",
        "ScatterPlotWidget",
        "TimelineWidget",
        "ExploreWidget",
        "MapWidget",
        "PieWidget",
        "BarsWidget",
        "StackedBarsWidget",
        "LinksWidget",
        "SpanBarsWidget",
        "TreeWidget",
        "MultiTimelineWidget",
        "FiguresWidget",
        "RepeaterWidget",
        "MultiLineWidget",
        "pascalprecht.translate",
        // New design
        'fsTemplates',
        'Fortscale.shared',
        'Fortscale.layouts',
        'Fortscale.appConfig',
        'Fortscale.remoteAppConfig',
        'Fortscale.analytics'
    ])
        .config(['$rootScopeProvider', function ($rootScopeProvider) {
            // This was done to support Explore. It turns out that Explore needs more then 10 digest cycles
            // to work when switching data sources. I hope Explore will die soon, but most likely I'll die first...
            $rootScopeProvider.digestTtl(20);
        }])
        .run(['$rootScope', '$timeout', function ($rootScope, $timeout) {
            if (!$rootScope.safeApply) {
                // Prevent executing $apply if already in a digest cycle
                $rootScope.safeApply = function (fn) {
                    var phase = $rootScope.$$phase;
                    if (phase === '$apply' || phase === '$digest') {
                        if (typeof fn === 'function') {
                            fn();
                        }
                    }
                    else {
                        this.$apply(fn);
                    }
                };
            }
            $rootScope.hideLoader = true;
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .config(function ($routeProvider, $locationProvider) {
        /**
         * LEGACY
         * Setup Routes
         */
        $routeProvider
            .when('/d/:dashboardId', {
            templateUrl: 'views/pages/main_dashboard.html',
            controller: "MainDashboardController",
            reloadOnSearch: false
        })
            .when('/d/:dashboardId/:entityId', {
            templateUrl: 'views/pages/main_dashboard.html',
            controller: 'MainDashboardController',
            reloadOnSearch: false,
            resolve: {}
        })
            .when('/account', {
            templateUrl: 'views/pages/account.html',
            controller: "AccountSettingsController"
        })
            .when('/global_settings', {
            templateUrl: 'views/pages/global_settings.html',
            controller: "GlobalSettingsController"
        })
            .when('/alerts/:alertId', {})
            .when('/alerts/:alertId/:evidenceId', {})
            .when('/alerts/:alertId/evidence/:evidenceId', {})
            .when('/username/:username', {})
            .when('/user/:userId', {})
            .when('/user/:userId/baseline', {})
            .when('/reports/:reportId/:subReportId', {})
            .when('/configuration/:stateName', {})
            .when('/pxgrid-configuration/:certificateFlow/:generationFlow', {})
            .when('/users', {})
            .when('/:dashboardId/:entityId/:subDashboardId', {
            templateUrl: 'views/pages/main_dashboard.html',
            controller: "MainDashboardController",
            reloadOnSearch: false
        })
            .when('/:dashboardId/:subDashboardId', {
            templateUrl: 'views/pages/main_dashboard.html',
            controller: "MainDashboardController",
            reloadOnSearch: false
        });
        $locationProvider.html5Mode(false);
    })
        .config([
        '$sceProvider',
        '$stateProvider',
        '$urlRouterProvider',
        'alertsPageResolve',
        function ($sceProvider, $stateProvider, $urlRouterProvider, alertsPageResolve) {
            // LEGACY
            // Completely disable SCE.
            // For demonstration purposes only! Do not use in new projects.
            $sceProvider.enabled(false);
            //Configuration for UI-Router
            $urlRouterProvider.otherwise('/overview');
            $stateProvider
                .state('alerts', {
                url: '/alerts',
                templateUrl: 'app/layouts/alerts/alerts.view.html',
                controller: 'AlertsController',
                controllerAs: 'alerts',
                resolve: alertsPageResolve
            })
                .state('users', {
                url: '/users',
                templateUrl: 'app/layouts/users/users.view.html',
                controller: 'UsersController',
                controllerAs: 'usersCtrl'
            })
                .state('configuration', {
                url: '/configuration',
                templateUrl: 'app/layouts/configuration/configuration.view.html',
                controller: 'ConfigurationController',
                controllerAs: 'configuration'
            })
                .state('configuration.configForm', {
                url: '/:stateName',
                templateUrl: 'app/layouts/configuration/configuration-form.view.html',
                controller: 'ConfigurationFormController',
                controllerAs: 'configFormCtrl'
            })
                .state('ng-route-d-dashboardId', {
                url: '/d/:dashboardId'
            })
                .state('explore', {
                url: '/d/:dashboardId/:entityId'
            })
                .state('ng-route-d-dashboardId-entity-subDashboardId', {
                url: '/:dashboardId/:entityId/:subDashboardId'
            })
                .state('ng-route-d-dashboardId-subDashboardId', {
                url: '/:dashboardId/:subDashboardId'
            })
                .state('ng-route-count', {
                url: '/account'
            })
                .state('ng-route-global-settings', {
                url: '/global_settings'
            });
        }]);
}());

angular.module("Version", []).value("version", new Date().valueOf());

(function () {
    "use strict";
    angular.module("Fortscale").factory("eventBus", ["EventBus", function (EventBus) {
            return new EventBus();
        }]);
}());

(function () {
    'use strict';
    function widgets($q, DAL, format, reports, widgetViews, EventBus, Widget) {
        var cachedWidgets = {};
        function parseFieldValue(field, value, data, index, params, item) {
            return value.replace(/\{\{([^\}]+)\}\}/g, function (match, variable) {
                if (/^@/.test(variable)) {
                    var param = variable.replace("@", "");
                    if (param === "index") {
                        return index;
                    }
                    else if (param === "item") {
                        return item;
                    }
                    return params[param] || "";
                }
                else {
                    var dataValue = data[variable];
                    if (dataValue !== undefined && dataValue !== null) {
                        if (field.format) {
                            return format[field.format](dataValue, field.formatOptions);
                        }
                        return dataValue;
                    }
                    return "";
                }
            });
        }
        var methods = {
            getWidget: function (widgetId, uniqueWidgetId) {
                var cacheWidgetId = uniqueWidgetId || widgetId;
                if (cachedWidgets[cacheWidgetId]) {
                    return $q.when(angular.copy(cachedWidgets[cacheWidgetId]));
                }
                else {
                    return DAL.widgets.getWidget(widgetId).then(function (widgetConfig) {
                        var widget = Widget.loadWidget(widgetConfig);
                        if (widgetConfig.reportId) {
                            return reports.getReport(widgetConfig.reportId).then(function (report) {
                                widget.report = report;
                            });
                        }
                        cachedWidgets[cacheWidgetId] = widget;
                        return widget;
                    }, function () {
                        return $q.reject("Widget with ID '" + widgetId + "' not found.");
                    });
                }
            }, parseFieldValue: parseFieldValue, refreshAll: function () {
                widgetsEventBus.triggerEvent("refreshAll");
            }, setViewValues: function (view, data, params, rawData) {
                return $q.when(widgetViews.parseViewData(view, data, params, rawData));
            }
        };
        var widgetsEventBus = EventBus.setToObject(methods, ["refreshAll"]);
        return methods;
    }
    widgets.$inject = ["$q", "DAL", "format", "reports", "widgetViews", "EventBus", "Widget"];
    angular.module("Fortscale").factory("widgets", widgets);
})();

(function () {
    'use strict';
    angular.module("Fortscale").factory("widgetTypes", ["$q", "$http", "version", function ($q, $http, version) {
            var widgetTypes, cachedDefinitions = {};
            var methods = {
                getWidgetType: function (widgetTypeName) {
                    var deferred = $q.defer();
                    if (cachedDefinitions[widgetTypeName]) {
                        deferred.resolve(cachedDefinitions[widgetTypeName]);
                    }
                    else {
                        $http.get("widgets/" + widgetTypeName + "/" + widgetTypeName + ".definition.json?v=" +
                            version).success(function (definition) {
                            deferred.resolve(definition);
                            cachedDefinitions[widgetTypeName] = definition;
                        }).error(deferred.reject);
                    }
                    return deferred.promise;
                }, getWidgetTypes: function () {
                    var deferred = $q.defer();
                    if (widgetTypes) {
                        deferred.resolve(angular.copy(widgetTypes));
                    }
                    else {
                        $http.get("data/widget_types/widget_types.json?v=" + version).success(function (widgetTypesList) {
                            var typesData = {}, typesPromises = [];
                            angular.forEach(widgetTypesList, function (widgetTypeName) {
                                typesPromises.push(methods.getWidgetType(widgetTypeName));
                            });
                            $q.all(typesPromises).then(function (_widgetTypes) {
                                angular.forEach(_widgetTypes, function (widgetType, i) {
                                    widgetType.type = widgetTypesList[i];
                                    typesData[widgetTypesList[i]] = widgetType;
                                });
                                widgetTypes = typesData;
                                deferred.resolve(angular.copy(typesData));
                            }, deferred.reject);
                        }).error(deferred.reject);
                    }
                    return deferred.promise;
                }
            };
            return methods;
        }]);
}());

(function () {
    "use strict";
    angular.module("Fortscale").factory("packages", ["$q", "utils", function ($q, utils) {
            var cachedPackages = {};
            var methods = {
                getPackageById: function (packageId) {
                    if (cachedPackages[packageId]) {
                        return $q.when(angular.copy(cachedPackages[packageId]));
                    }
                    else {
                        return utils.http.wrappedHttpGet("packages/" + packageId + "/" + packageId +
                            ".package.json").then(function (packageConfig) {
                            try {
                                cachedPackages[packageId] = packageConfig;
                                return angular.copy(packageConfig);
                            }
                            catch (error) {
                                return $q.reject(error);
                            }
                        });
                    }
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("FortscaleAuth", ["Utils"]).factory("auth", ["$q", "$http", "utils", "configFlags",
        function ($q, $http, utils, configFlags) {
            var apiUrl = "/fortscale-webapp/api/analyst/", adminApiUrl = "/fortscale-webapp/api/admin/";
            var emailRegExp = /^(([a-zA-Z0-9_.-])+@([a-zA-Z0-9_.-])+\.([a-zA-Z])+([a-zA-Z])+)?$/;
            var methods = {
                changePassword: function (username, currentPassword, newPassword) {
                    var deferred = $q.defer();
                    $http({
                        method: "POST",
                        url: apiUrl + "changePassword",
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        data: $.param({
                            password: currentPassword,
                            newPassword: newPassword,
                            username: username
                        })
                    })
                        .success(function (response) {
                        deferred.resolve(response);
                    })
                        .error(function (error, httpCode) {
                        deferred.reject(getErrorMessage(error, httpCode));
                    });
                    return deferred.promise;
                },
                createUser: function (accountData) {
                    var deferred = $q.defer();
                    $http({
                        method: "POST",
                        url: adminApiUrl + "analyst/addAnalyst",
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        data: $.param(accountData)
                    })
                        .success(deferred.resolve)
                        .error(function (error, httpCode) {
                        deferred.reject(getErrorMessage(error, httpCode));
                    });
                    return deferred.promise;
                },
                deleteUser: function (username) {
                    var deferred = $q.defer();
                    $http({
                        method: "POST",
                        url: adminApiUrl + "analyst/disableAnalyst",
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        data: $.param({ username: username })
                    })
                        .success(deferred.resolve)
                        .error(function (error, httpCode) {
                        deferred.reject(getErrorMessage(error, httpCode));
                    });
                    return deferred.promise;
                },
                editUser: function (accountData) {
                    var deferred = $q.defer();
                    $http({
                        method: "POST",
                        url: apiUrl + "analyst/update",
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        data: $.param(accountData)
                    })
                        .success(deferred.resolve)
                        .error(function (error, httpCode) {
                        deferred.reject(getErrorMessage(error, httpCode));
                    });
                    return deferred.promise;
                },
                getAllUsers: function () {
                    if (configFlags.mockData) {
                        return utils.http.wrappedHttpGet("data/mock_data/admin_users.json").then(function (results) {
                            return results.data;
                        });
                    }
                    else {
                        return utils.http.wrappedHttpGet(adminApiUrl + "analyst/details").then(function (results) {
                            var users = [];
                            results.data.forEach(function (user) {
                                user.fullName = user.firstName + " " + user.lastName;
                                users.push(user);
                            });
                            return users;
                        }, function (error, httpCode) {
                            return $q.reject(getErrorMessage(error, httpCode));
                        });
                    }
                },
                getCurrentUser: function () {
                    if (configFlags.mockData) {
                        return utils.http.wrappedHttpGet("data/mock_data/currentUser.json").then(function (result) {
                            if (result && result.data) {
                                var userData = result.data[0];
                                userData.fullName = [userData.firstName, userData.lastName].join(" ");
                                return userData;
                            }
                            else {
                                return $q.reject("Current user unavailable.");
                            }
                        });
                    }
                    return utils.http.wrappedHttpGet(apiUrl + "me/details", { cache: true }).then(function (result) {
                        if (result && result.data) {
                            var userData = result.data[0];
                            userData.fullName = [userData.firstName, userData.lastName].join(" ");
                            return userData;
                        }
                        else {
                            return $q.reject("Can't get current user");
                        }
                    }, function (error, httpCode) {
                        return $q.reject(getErrorMessage(error, httpCode));
                    });
                },
                getLastLoggedInUser: function () {
                    return localStorage.getItem("lastUser");
                },
                login: function (username, password, remember) {
                    var deferred = $q.defer();
                    $http({
                        method: "POST",
                        url: apiUrl + "login",
                        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                        data: $.param({
                            j_username: username,
                            j_password: password,
                            _spring_security_remember_me: remember ? "yes" : "no"
                        })
                    })
                        .success(function (response) {
                        localStorage.setItem("lastUser", username);
                        deferred.resolve(response);
                    })
                        .error(function (error, httpCode) {
                        deferred.reject(getErrorMessage(error, httpCode));
                    });
                    return deferred.promise;
                },
                logout: function () {
                    $http.post(apiUrl + "logout").then(function () {
                        sessionStorage.removeItem('session-login');
                        localStorage.removeItem('last-login-time');
                        window.location.href = window.location.href.replace(/fortscale-webapp\/.*/, "fortscale-webapp/signin.html");
                    }, function (error) {
                        alert("Logout error: " + error.data.message);
                    });
                },
                renewPassword: function (user, adminPassword, newPassword) {
                    return utils.http.wrappedHttpPost(adminApiUrl + "analyst/renewPassword", {
                        password: adminPassword,
                        username: user,
                        newPassword: newPassword
                    });
                },
                validateUsername: function (username) {
                    return emailRegExp.test(username);
                }
            };
            function getErrorMessage(error, httpCode) {
                var errorMessage = { error: true };
                switch (httpCode) {
                    case 401:
                        errorMessage.message = "Wrong username or password.";
                        break;
                    case 403:
                        errorMessage.message = "Password has expired.";
                        errorMessage.expired = true;
                        break;
                    case 400:
                        errorMessage.message = error.message;
                        break;
                    default:
                        errorMessage.message = "Can't access server (error code " + httpCode + ").";
                }
                return errorMessage;
            }
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").factory("users", [function () {
            return {
                getSearchSettings: function () {
                    return {
                        "search": {
                            "dataEntity": "users",
                            "dataEntityField": ["id", "normalized_username"],
                            "labelField": "display_name"
                        },
                        "resultField": "displayname",
                        "value": "{{id}}",
                        "showValueOnSelect": false,
                        "placeholder": "All users",
                        "onSelect": function (e) {
                            if (e.$value) {
                                window.location.hash = "#/user/" + e.$value + "/user_overview";
                            }
                        }
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").factory("comments", ["$q", function ($q) {
            var methods = {
                listToTree: function (comments) {
                    var tree = [], index = {};
                    comments.forEach(function (comment) {
                        index[comment.id] = comment;
                    });
                    comments = comments.sort(function (a, b) {
                        return a.when < b.when ? 1 : -1;
                    });
                    comments.forEach(function (comment) {
                        if (comment.basedOn) {
                            var replyToComment = index[comment.basedOn];
                            if (!replyToComment) {
                                console.error("missing comment: ", replyToComment);
                            }
                            if (replyToComment.children) {
                                replyToComment.children.push(comment);
                            }
                            else {
                                replyToComment.children = [comment];
                            }
                        }
                        else {
                            tree.push(comment);
                        }
                        index[comment.id] = comment;
                    });
                    return tree;
                }
            };
            return methods;
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("MainController", ["$scope", "$routeParams", "dashboards", "auth", "users", "search", "reports", "configFlags", "utils", "$state",
        "userUtils",
        function ($scope, $routeParams, dashboards, auth, users, search, reports, configFlags, utils, $state, userUtils) {
            $scope.showBenchmarks = configFlags.qa;
            $scope.printPage = function () {
                window.print();
            };
            auth.getCurrentUser()
                .then(function (userData) {
                if (userData) {
                    $scope.loggedInUser = userData;
                }
                else {
                    window.location.href = "/fortscale-webapp/signin.html?redirect=" +
                        window.encodeURIComponent(window.location.hash);
                }
            });
            $scope.report = {
                /**
                 * An error callback function. It prints out an error to the console, unless error object has a
                 * redirectToState property, in which case it redirects to the required state.
                 *
                 * @param {{message:string, redirectToState:string=}|string} error
                 */
                error: function (error) {
                    var errorStr = typeof (error) === "string" ? error : typeof (error.message) === "string" ?
                        error.message : JSON.stringify(error);
                    if (error.redirectToState) {
                        console.warn(errorStr);
                        $state.go(error.redirectToState);
                    }
                    else {
                        console.error(errorStr);
                    }
                }
            };
            $scope.$on("$routeChangeSuccess", function () {
                $scope.currentNav = document.location.hash.split("?")[0];
                //setActiveNavItem();
                // Visible only when printing a page in the browser (top right)
                $scope.loadDate = utils.date.getMoment('now', false).format("MM/DD/YYYY HH:mm");
            });
            $scope.$on("$locationChangeSuccess", function (e, newUrl, oldUrl) {
                //reports.abortCurrentReports();
                $scope.$broadcast("locationChange", {
                    newUrl: newUrl,
                    oldUrl: oldUrl
                });
                //setActiveNavItem();
            });
            $scope.getCurrentNavRedirect = function () {
                return encodeURIComponent(document.location.hash);
            };
            $scope.$on("authError", function (e, data) {
                $scope.modal = {
                    show: true,
                    src: data.status === 403 ? "views/modals/password_expired.html" :
                        "views/modals/session_expired.html"
                };
            });
            $scope.setCurrentMainDashboard = function (dashboard) {
                $scope.currentMainDashboard = null;
                var dashboardIndex = 0;
                if ($scope.dashboards) {
                    for (var i = 0; i < $scope.dashboards.length && !$scope.currentMainDashboard; i++) {
                        if ($scope.dashboards[dashboardIndex].dashboardId === dashboard) {
                            $scope.currentMainDashboard = $scope.dashboards[dashboardIndex];
                        }
                    }
                }
            };
            $scope.logout = function () {
                auth.logout();
            };
            $scope.sortableOptions = {
                update: function (e, ui) {
                },
                connectWith: ".sortable-contents",
                tolerance: "pointer",
                handle: ".widget-header",
                forcePlaceholderSize: true,
                placeholder: "sortable-placeholder",
                cancel: ".widget-dashboard"
            };
            $scope.showPopup = function (popup) {
                if ($scope.popup) {
                    $scope.popup = null;
                }
                popup.show = true;
                $scope.popup = popup;
            };
            $scope.closePopup = function () {
                $scope.popupShow = false;
            };
            // Add user control settings
            $scope.userControlSettings = {
                "dataValueField": "id",
                "dataTextField": "fallBackDisplayName",
                /**
                 * Takes received users and creates fallBack display name for each, and prevents duplications.
                 * @param users
                 */
                "dataTextFn": function (users) {
                    userUtils.setFallBackDisplayNames(users);
                    userUtils.preventFallBackDisplayNameDuplications(users);
                },
                "placeholder": "Search User"
            };
            // Add user control resource settings
            $scope.userControlResource = {
                "entity": "user",
                "params": {
                    "page": 1,
                    "size": 10,
                    "sort_field": "displayName",
                    "sort_direction": "ASC",
                    "search_field_contains": "{{search}}"
                }
            };
            /**
             * Used as state update delegate for the user control. When user control state changes, this method is
             * invoked, and within, the input is cleaned, and state go is fired.
             *
             * @param {{id: string, immediate: boolean, type: string, value: *}}updateObj
             */
            $scope.goToUserProfile = function (updateObj) {
                // Clear user search control
                $('#main_user_search').find('input').val('');
                // Go to state
                $state.go('userOverviewPage.userOverview', { userId: updateObj.value });
            };
        }]);
}());

(function () {
    'use strict';
    function MainDashboardController($scope, $q, $routeParams, $location, $timeout, dashboards, utils, transforms, reportsProcess, reports, Report, Cache, Widget, widgets, tags, eventBus, conditions, state, events, DAL) {
        var locationChangeHandlerTimeout, nonUrlParams = {};
        $scope.$on("$destroy", function (e, data) {
            $timeout.cancel(locationChangeHandlerTimeout);
        });
        $scope.mainDashboardParams = { entityId: $routeParams.entityId, dashboardId: $routeParams.dashboardId };
        $scope.isMainDashboard = true;
        dashboards.getDashboardById($routeParams.dashboardId).then(function (dashboard) {
            if ($routeParams.subDashboardId) {
                dashboards.getDashboardById("nav_dashboard").then(function (navDashboard) {
                    $scope.dashboard = angular.extend(navDashboard, dashboard);
                    if ($scope.dashboard.params) {
                        angular.extend($scope.mainDashboardParams, $scope.dashboard.params);
                    }
                    $scope.$broadcast("onMainDashboard", { dashboard: dashboard });
                });
            }
            else {
                $scope.dashboard = dashboard;
                $scope.$broadcast("onMainDashboard", { dashboard: dashboard });
            }
        }, $scope.report.error);
        var disableLocationChangeListener;
        $scope.closePopup = function () {
            $scope.popupShow = false;
        };
        var dashboardEvents = {
            broadcast: function (options) {
                $scope.$broadcast(options.event, options.data);
            },
            clearCache: function (options) {
                Cache.clearAll();
            },
            closeAllPopups: function () {
                $scope.$broadcast("closePopups");
            },
            innerUrl: function (options, data, widgetParams) {
                var hash = "#" + utils.strings.parseValue(options.url, data, widgetParams || $scope.mainDashboardParams);
                if (options.params) {
                    var params = {};
                    for (var paramName in options.params) {
                        if (options.params.hasOwnProperty(paramName)) {
                            params[paramName] = utils.strings.parseValue(options.params[paramName], data, widgetParams);
                        }
                    }
                    params = transforms.transformParams(params, options.paramsTransform);
                    hash += (/\?/.test(hash) ? "&" : "?") + "params=" + encodeURIComponent(JSON.stringify(params));
                }
                hash = hash.replace(/%3A/g, ":");
                window.location.hash = hash;
            },
            openPopup: function (options, data, params) {
                var popupWidgetId = options.widgetId || (options.widget && options.widget.widgetId);
                var popup = {
                    width: options.width,
                    height: options.height,
                    title: utils.strings.parseValue(options.title, data, params),
                    src: popupWidgetId ? "views/widgets/standalone_widget.html" : "views/pages/dashboard.html",
                    show: true,
                    position: options.position,
                    data: data,
                    controls: options.controls
                };
                function showPopup() {
                    if ($scope.popup) {
                        $scope.popup = null;
                    }
                    popup.show = true;
                    $scope.popup = popup;
                }
                if (popupWidgetId) {
                    DAL.widgets.getWidget(popupWidgetId).then(function (widgetConfig) {
                        /*
                         parsing of dynamic report name (name that depends on data source type)
                         is executed before creation of Widget, since the creation of Report is done within Widget
                         constructor.
                         */
                        if (options.widget && options.widget.reportId) {
                            widgetConfig.reportId = utils.strings.parseValue(options.widget.reportId, data, params);
                        }
                        //returns new Widget
                        return Widget.loadWidget(widgetConfig);
                    }).then(function (widgetTemplate) {
                        var widget = angular.copy(widgetTemplate);
                        var parsedParams;
                        if (widget.exploreBased && state.__explore__ && widget.report &&
                            widget.report.endpoint && widget.report.endpoint.dataQuery) {
                            var exploreDataQuery = state.__explore__.getFiltersDataQuery();
                            if (exploreDataQuery.conditions) {
                                widget.report.endpoint.dataQuery.conditions =
                                    exploreDataQuery.conditions.terms
                                        .concat(widget.report.endpoint.dataQuery.conditions.terms);
                            }
                            widget.report.endpoint.dataQuery.entity = state.__explore__.dataEntity.id;
                            if (widget.report.endpoint.dataQuery.entitiesJoin) {
                                widget.report.endpoint.dataQuery.entitiesJoin.joinFields.left =
                                    widget.report.endpoint.dataQuery.entity + "." +
                                        widget.report.endpoint.dataQuery.entitiesJoin.joinFields.left;
                            }
                        }
                        if (options.widget) {
                            angular.extend(widget, options.widget);
                        }
                        if (options.params) {
                            parsedParams = {};
                            var paramValue;
                            for (var paramName in options.params) {
                                if (options.params.hasOwnProperty(paramName)) {
                                    paramValue = options.params[paramName];
                                    parsedParams[utils.strings.parseValue(paramName, data, params)] =
                                        typeof (paramValue) === "string" ?
                                            utils.strings.parseValue(paramValue, data, params) : paramValue;
                                }
                            }
                        }
                        if (!widget.className) {
                            widget.className = "no-shadow";
                        }
                        if (!widget.flags) {
                            widget.flags = { noBorder: true };
                        }
                        else {
                            widget.flags.noBorder = true;
                        }
                        popup.scope = {
                            widget: widget,
                            params: angular.extend({}, params, parsedParams)
                        };
                        var popupParent = angular.copy($scope.dashboard);
                        popupParent = angular.extend(popupParent, { params: parsedParams });
                        widget.setParent(popupParent);
                        widget.refresh();
                        showPopup();
                    });
                }
                else {
                    showPopup();
                }
            },
            refreshAll: function (options) {
                widgets.refreshAll();
            },
            refreshTags: function (options) {
                $scope.dashboard.runReports();
                if ($scope.dashboard.details.tags) {
                    tags.getTags($scope.dashboard.details.tags, state.currentParams[options.dashboardParam] || {})
                        .then(function (dashboardTags) {
                        $scope.dashboard.details.parsedTags = dashboardTags;
                    });
                }
            },
            runReport: function (options, data, widgetParams) {
                var report;
                if (!options.report && !options.reportId) {
                    return;
                }
                if (options.report) {
                    report = options.report;
                }
                else if (options.reportId) {
                    reports.getReport(options.reportId).then(function (_report) {
                        report = _report;
                        doRunReport();
                    }, function (error) {
                        console.error("Can't find report with ID %s: ", options.reportId, error);
                    });
                }
                function doRunReport() {
                    report = utils.objects.extend(report, options.reportParams);
                    reports.runReport(new Report(report), utils.objects.extend(widgetParams, data), true)
                        .then(function (results) {
                        if (options.onResults) {
                            $scope.dashboardEvent(utils.objects.extend(options.onResults, {
                                data: data,
                                params: widgetParams
                            }));
                        }
                    }, function (error) {
                        console.error(options.onError && options.onError.alert || "Error running report: ", error, ". Report: ", options.report);
                    });
                }
            },
            setParams: function (options, data) {
                var params = {}, paramValue, paramData, paramStrConfig, useParam, parsedParamName, urlParams = {}, existingParamValue;
                function getParamValue(paramConfig) {
                    var paramValue;
                    if (paramConfig) {
                        paramValue = angular.isString(paramConfig.value || paramConfig) ?
                            utils.strings.parseValue(paramConfig.value || paramConfig, paramData || {}, $scope.mainDashboardParams, undefined, true) :
                            paramConfig.value || paramConfig;
                    }
                    else if (paramConfig === null) {
                        paramValue = null;
                    }
                    else if (angular.isObject(options.params[paramName]) && options.params[paramName].dataValue) {
                        paramValue = paramData[options.params[paramName].dataValue];
                    }
                    else {
                        paramValue = paramConfig;
                    }
                    return paramValue;
                }
                function addUrlParams(paramName, paramConfig, paramValue) {
                    if (!urlParams[paramName]) {
                        urlParams[paramName] = [];
                    }
                    if (angular.isArray(paramConfig)) {
                        paramConfig.forEach(function (param) {
                            addUrlParams(paramName, param, getParamValue(param));
                        });
                    }
                    else {
                        urlParams[paramName].push(paramConfig && paramConfig.setToUrl === false ? null : paramValue);
                    }
                }
                for (var paramName in options.params) {
                    if (options.params.hasOwnProperty(paramName)) {
                        parsedParamName = utils.strings.parseValue(paramName, data, $scope.mainDashboardParams);
                        paramStrConfig = options.params[paramName];
                        useParam = true;
                        if (angular.isArray(data) && angular.isObject(paramStrConfig)) {
                            paramData = data[paramStrConfig.itemIndex || 0];
                            if (paramStrConfig.setIf) {
                                if (!paramData[paramStrConfig.setIf]) {
                                    useParam = false;
                                }
                            }
                            else {
                                paramStrConfig = paramStrConfig.value;
                            }
                        }
                        else {
                            paramData = data;
                        }
                        if (!useParam) {
                            continue;
                        }
                        if (options.updateUrl === false) {
                            nonUrlParams[paramName] = true;
                        }
                        else {
                            delete nonUrlParams[paramName];
                        }
                        paramValue = getParamValue(paramStrConfig);
                        if (parsedParamName === "filters") {
                            existingParamValue = state.currentParams.filters;
                        }
                        else {
                            existingParamValue = $scope.mainDashboardParams[parsedParamName];
                        }
                        if (options.addToParam && existingParamValue) {
                            // If the paramValue already exists in the param, there's no need to add it:
                            if (typeof (existingParamValue) === "string" &&
                                ~existingParamValue.split(",").indexOf(paramValue)) {
                                continue;
                            }
                            paramValue = existingParamValue + "," + paramValue;
                        }
                        params[parsedParamName] = paramValue;
                        addUrlParams(parsedParamName, paramStrConfig, paramValue);
                    }
                }
                params = transforms.transformParams(params, options.paramsTransform);
                angular.extend($scope.mainDashboardParams, params);
                state.setParams(params, false);
                if (options.updateUrl !== false) {
                    setParamsToUrl(urlParams);
                    state.setParams(urlParams);
                }
                if (params && Object.keys(params).length) {
                    eventBus.triggerEvent("dashboardParamsChange", params);
                }
            },
            showTooltip: function (options, data, params) {
                var tooltipContents = {}, tooltipOptions = options;
                if (options.switch) {
                    tooltipOptions = options.switchCases[data[options.switch]];
                }
                if (tooltipOptions.table && tooltipOptions.table.rows) {
                    tooltipContents.table = { rows: [] };
                    tooltipOptions.table.rows.forEach(function (row) {
                        tooltipContents.table.rows.push({
                            label: utils.strings.parseValue(row.label, data, params),
                            value: utils.strings.parseValue(row.value, data, params)
                        });
                    });
                }
                tooltipContents.text = tooltipOptions.text;
                $scope.tooltipContents = tooltipContents;
                $scope.tooltipOpen = true;
                $scope.tooltipPosition = options.position;
            }
        };
        $scope.$on("dashboardEvent", function (e, data) {
            $scope.dashboardEvent(data);
        });
        events.onDashboardEvent.subscribe(function (e, data) {
            $scope.dashboardEvent(data);
        });
        $scope.dashboardEvent = function (data) {
            if (data.event) {
                runEvent(data.event, data.data, data.params);
            }
            else if (data.events) {
                angular.forEach(data.events, function (event) {
                    runEvent(event, data.data, data.params);
                });
            }
        };
        // Shortcut for setParams dashboardEvent:
        $scope.setParams = function (params, updateUrl) {
            $scope.dashboardEvent({
                event: {
                    action: "setParams",
                    actionOptions: {
                        updateUrl: updateUrl,
                        params: params
                    }
                }
            });
        };
        $scope.innerUrl = function (url) {
            $scope.dashboardEvent({
                event: {
                    action: "innerUrl",
                    actionOptions: {
                        url: url
                    }
                }
            });
        };
        $scope.menuSelect = function ($event, item, data, menu, widgetParams) {
            var preSelectData;
            function doSelect() {
                var events = angular.copy(item.onSelect), eventData = menu.params ? {} : data, params = widgetParams;
                if (!angular.isArray(events)) {
                    events = [events];
                }
                if (menu.params) {
                    var param;
                    for (var paramName in menu.params) {
                        if (menu.params.hasOwnProperty(paramName)) {
                            param = menu.params[paramName];
                            if (typeof (param) === "string") {
                                eventData[paramName] = utils.strings.parseValue(menu.params[paramName], data, params);
                            }
                            else if (angular.isObject(param) && param.dashboardParam) {
                                eventData[paramName] = params[param.dashboardParam];
                            }
                        }
                    }
                }
                events.forEach(function (event) {
                    if (!event.actionOptions) {
                        event.actionOptions = {};
                    }
                    event.actionOptions.position = { top: $event.clientY, left: $event.clientX };
                });
                $scope.dashboardEvent({
                    events: events,
                    data: angular.extend(eventData, preSelectData),
                    params: widgetParams
                });
            }
            if (item.onSelect) {
                if (item.preSelectReport && (conditions.validateConditions(item.preSelectReport.conditions, data, menu.params) === true)) {
                    Report.loadReport({ reportId: item.preSelectReport.reportId }).then(function (preSelectReport) {
                        // resolve params
                        var itemParams = item.params ? {} : data;
                        if (item.params) {
                            var param;
                            for (var parameterName in item.params) {
                                if (item.params.hasOwnProperty(parameterName)) {
                                    param = item.params[parameterName];
                                    if (typeof (param) === "string") {
                                        itemParams[parameterName] =
                                            utils.strings.parseValue(item.params[parameterName], data);
                                    }
                                }
                            }
                        }
                        // send request for preSelectReport
                        reports.runReport(preSelectReport, angular.extend({}, widgetParams, itemParams, data))
                            .then(function (results) {
                            preSelectData = results.data.length && item.preSelectReport.singleResult ?
                                results.data[0] : results;
                            doSelect();
                        });
                    }, function (error) {
                        console.error("Can't get preSelectReport: ", error);
                    });
                }
                else {
                    doSelect();
                }
            }
        };
        function runEvent(event, data, params) {
            if (event && event.action) {
                var action = dashboardEvents[event.action];
                if (action) {
                    if (event.process) {
                        $q.when(reportsProcess.processData(event.process.processId, data, event.process.params))
                            .then(function (processedData) {
                            action(event.actionOptions, processedData.data.length && processedData.data[0], params);
                        }, function (error) {
                            console.error("Can't process data for event: ", error);
                        });
                    }
                    else {
                        action(event.actionOptions, data, params);
                    }
                }
                else {
                    console.error("Action not found: ", event.action);
                }
            }
        }
        $scope.onControlParamsChange = function (control) {
            if (control.updateDataOnChange) {
                setControlParamsToDashboard(control);
                setParamsToUrl();
            }
        };
        function setControlParamsToDashboard(control, useExistingParamsIfAvailable) {
            if (control.params) {
                var transformedParams = transforms.transformParams(control.params, control.paramsTransform);
                for (var paramName in transformedParams) {
                    if (!useExistingParamsIfAvailable || $scope.mainDashboardParams[paramName] === undefined) {
                        $scope.mainDashboardParams[paramName] = transformedParams[paramName];
                    }
                }
            }
        }
        function setParamsToUrl(urlParams) {
            var paramsObj = urlParams || angular.copy($scope.mainDashboardParams), currentUrlParams = $location.search(), paramValue;
            delete paramsObj.entityId;
            for (var paramName in paramsObj) {
                if (paramsObj.hasOwnProperty(paramName)) {
                    paramValue = paramsObj[paramName];
                    if (angular.isArray(paramValue) && (!paramValue.length || (paramValue.length === 1 &&
                        paramValue[0] === null))) {
                        paramValue = null;
                    }
                    if (paramValue === null || (paramValue && paramValue.length > 200)) {
                        delete paramsObj[paramName];
                    }
                    // If there's a query param of the same name as the param, remove it.
                    if (currentUrlParams[paramName]) {
                        $location.search(paramName, null);
                    }
                    //$location.search(paramName, angular.isObject(paramValue) ?
                    // JSON.stringify(paramValue) : paramValue);
                    $location.search(paramName, paramValue);
                }
            }
            disableLocationChangeListener = true;
            locationChangeHandlerTimeout = $timeout(function () {
                disableLocationChangeListener = false;
            }, 15);
        }
    }
    MainDashboardController.$inject = [
        "$scope", "$q", "$routeParams",
        "$location", "$timeout", "dashboards",
        "utils", "transforms", "reportsProcess",
        "reports", "Report", "Cache", "Widget", "widgets", "tags",
        "eventBus", "conditions", "state", "events", "DAL"];
    angular.module("Fortscale")
        .controller("MainDashboardController", MainDashboardController);
})();

(function () {
    'use strict';
    angular.module("Fortscale")
        .controller("DashboardController", ["$scope", "transforms", "utils", "eventBus", "reports", "tags", "menus", "page", "state", "events",
        function ($scope, transforms, utils, eventBus, reports, tags, menus, page, state, events) {
            var defaultMessages = {
                requiredParams: { text: "Missing parameters.", type: "error" }
            };
            function setDashboardFieldValues(dashboard) {
                if (dashboard) {
                    if (dashboard.title) {
                        page.setPageTitle(dashboard.title);
                    }
                    //if browserTitle attribute is found in dashboard json file it overrides the page title
                    // with its value
                    if (dashboard.browserTitle) {
                        page.setPageTitle(dashboard.browserTitle);
                    }
                    if (dashboard.navigation) {
                        parseNavigation(dashboard.navigation, state.currentParams);
                    }
                    if (dashboard.iconUrl) {
                        var dashboardIconUrl = utils.strings.parseValue(dashboard.iconUrl, {}, state.currentParams);
                        $scope.dashboardIconUrl = dashboardIconUrl || null;
                    }
                    if (dashboard.details) {
                        dashboard.currentDetails = {};
                        var detailValue, detailName;
                        for (detailName in dashboard.details) {
                            if (dashboard.details.hasOwnProperty(detailName)) {
                                detailValue = dashboard.details[detailName];
                                if (typeof (detailValue) === "string") {
                                    dashboard.currentDetails[detailName] = utils.strings.parseValue(detailValue, {}, state.currentParams);
                                }
                            }
                        }
                        setDashboardDetailsMenu(dashboard);
                        if (dashboard.details.tags) {
                            tags.getTags(dashboard.details.tags, state.currentParams || {})
                                .then(function (dashboardTags) {
                                $scope.dashboard.details.parsedTags = dashboardTags;
                            });
                        }
                    }
                    dashboard._renderHeader = dashboard.renderHeader !== false &&
                        (dashboard.controls && dashboard.controls.length ||
                            dashboard.title || dashboard.description);
                    if (!(dashboard.allRequiredParamsAvailable = checkRequiredParams())) {
                        dashboard._messages = [dashboard.messages && dashboard.messages.requiredParams ||
                                defaultMessages.requiredParams];
                    }
                    else {
                        dashboard._messages = null;
                    }
                }
            }
            function onParamsChange() {
                if ($scope.dashboard) {
                    $scope.dashboard.checkReady();
                    $scope.dashboard.update();
                    setDashboardFieldValues($scope.dashboard);
                }
            }
            function setDashboardDetailsMenu(dashboard) {
                if (dashboard.details.menu) {
                    menus.getMenu(dashboard.details.menu, {}, state.currentParams).then(function (menu) {
                        $scope.dashboard.details.parsedMenu = menu;
                    });
                }
            }
            function checkRequiredParams() {
                if (!$scope.dashboard.requiredParams) {
                    return true;
                }
                for (var i = 0, param; undefined !== (param = $scope.dashboard.requiredParams[i]); i++) {
                    if (!state.currentParams[param]) {
                        return false;
                    }
                }
                return true;
            }
            function parseNavigation(rootItem, params) {
                if (rootItem.url) {
                    rootItem.href = utils.strings.parseValue(rootItem.url, {}, params);
                }
                if (rootItem.children) {
                    rootItem.children.forEach(function (item) {
                        parseNavigation(item, params);
                    });
                }
            }
            function onDashboard(dashboard) {
                setDashboardFieldValues(dashboard);
                if (dashboard) {
                    dashboard.paramsReady = !dashboard.controls;
                }
            }
            setDashboardFieldValues($scope.dashboard);
            $scope.getDashboardParams = function () {
                return state.currentParams;
            };
            $scope.dashboardSubtitle = null;
            $scope.dashboardIconUrl = null;
            $scope.setParams = state.setParams;
            $scope.showDashboardNameDescription = function ($event) {
                events.triggerDashboardEvent({
                    action: "showTooltip",
                    actionOptions: {
                        text: $scope.dashboardNameDescription,
                        position: { top: $event.clientY, left: $event.clientX }
                    }
                });
            };
            $scope.$on("$destroy", function (e, data) {
                state.onStateChange.unsubscribe(onParamsChange);
            });
            $scope.$on("refresh", function () {
                if ($scope.dashboard) {
                    $scope.dashboard.runReports();
                }
            });
            state.onStateChange.subscribe(onParamsChange);
            $scope.$on("onMainDashboard", function (e, data) {
                onDashboard(data.dashboard);
            });
            $scope.$watch("dashboard", onDashboard);
            if ($scope.dashboard) {
                onDashboard($scope.dashboard);
            }
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .controller("WidgetControlController", ["$scope", "controls", "eventBus", "events",
        function ($scope, controls, eventBus, events) {
            function onParamsChange(e, changedParams) {
                for (var i = 0; i < $scope.control.refreshOn.length; i++) {
                    if (changedParams[$scope.control.refreshOn[i]] !== undefined) {
                        controls.initControl($scope.control, $scope.params, angular.extend($scope.getWidgetParams(), changedParams));
                        return;
                    }
                }
            }
            $scope.onEvent = function (e, eventConfig) {
                if (eventConfig) {
                    events.triggerDashboardEvent(eventConfig);
                }
            };
            function init() {
                var widgetParams = $scope.getWidgetParams ? $scope.getWidgetParams() : $scope.mainDashboardParams;
                controls.initControl($scope.control, $scope.params, widgetParams);
                if ($scope.control.refreshOn) {
                    eventBus.subscribe("dashboardParamsChange", onParamsChange);
                }
                $scope.$on("$destroy", function () {
                    eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
                });
            }
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("ButtonsBarWidgetController", ["$scope", "events", function ($scope, events) {
            $scope.btnClick = function (button) {
                if (button.toggleOnClick) {
                    button.on = !button.on;
                }
                angular.forEach($scope.view.settings.events, function (event) {
                    if (event.eventName === "click") {
                        events.triggerDashboardEvent(event);
                    }
                });
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .run(["widgetViews", function (widgetViews) {
            widgetViews.registerView("dashboardWidget", {});
        }])
        .controller("DashboardWidgetController", ["$scope", "dashboards", "utils", "$timeout", "eventBus", "state",
        function ($scope, dashboards, utils, $timeout, eventBus, state) {
            var setDashboardTimeout, currentDashboardId;
            $scope.dashboard = null;
            $scope.isDashboardWidget = true;
            $scope.$on("$destroy", function () {
                $timeout.cancel(setDashboardTimeout);
                state.onStateChange.unsubscribe(onParamsChange);
            });
            function allParamsAvailable(params) {
                var paramValue;
                for (var i = 0; i < $scope.view.settings.requiredParams.length; i++) {
                    paramValue = params[$scope.view.settings.requiredParams[i]];
                    if (!paramValue && paramValue !== 0) {
                        return false;
                    }
                }
                return true;
            }
            function setDashboard(dashboardId) {
                $scope.dashboard = null;
                setDashboardTimeout = $timeout(function () {
                    currentDashboardId = dashboardId;
                    dashboards.getDashboardById(dashboardId).then(function (dashboard) {
                        $scope.dashboard = angular.extend(dashboard, $scope.view.settings);
                        if ($scope.dashboard.params && $scope.mainDashboardParams) {
                            utils.objects.extend($scope.mainDashboardParams, $scope.dashboard.params);
                        }
                    }, function (error) {
                        console.error("Can't load dashboard: ", error);
                    });
                }, 40);
            }
            function init() {
                var widgetParams = state.currentParams;
                currentDashboardId = utils.strings.parseValue($scope.view.settings.defaultDashboardId ||
                    $scope.view.settings.dashboardId, {}, widgetParams);
                if (currentDashboardId &&
                    (!$scope.view.settings.requiredParams || allParamsAvailable(widgetParams))) {
                    setDashboard(currentDashboardId);
                }
                if ($scope.view.settings.dashboardId) {
                    state.onStateChange.subscribe(onParamsChange);
                }
            }
            function onParamsChange(e, params) {
                var dashboardId = utils.strings.parseValue($scope.view.settings.dashboardId, {}, state.currentParams);
                if (dashboardId && dashboardId !== currentDashboardId) {
                    currentDashboardId = dashboardId;
                    if (!$scope.view.settings.requiredParams || allParamsAvailable(params)) {
                        setDashboard(dashboardId);
                    }
                }
                if ($scope.dashboard) {
                    $scope.dashboard.update();
                }
            }
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .run(["widgetViews", function (widgetViews) {
            widgetViews.registerView("htmlWidget", {});
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("ItemsListController", ["$scope", function ($scope) {
            var defaultListItemDisplayCount = 5, graceLimitCount = 3;
            function setLimit() {
                $scope.limit = 999999999;
                $scope.disableLimit = false;
                $scope.showAllItems = false;
                if ($scope.view.settings.limit && $scope.items.length > $scope.view.settings.limit + graceLimitCount) {
                    $scope.limit = $scope.view.settings.limit;
                }
                else {
                    $scope.disableLimit = true;
                }
            }
            $scope.showAll = function (item) {
                item.enableShowLess = true;
                angular.forEach(item.list, function (listItem) {
                    listItem.enabled = true;
                });
            };
            $scope.showLess = function (item) {
                item.enableShowLess = false;
                angular.forEach(item.list, function (listItem, index) {
                    listItem.enabled = index < defaultListItemDisplayCount;
                });
            };
            $scope.setLimit = function (limit, showAll) {
                $scope.limit = limit;
                $scope.showAllItems = !!showAll;
            };
            $scope.$on("onWidgetData", setLimit);
            setLimit();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("MonitoringController", ["$scope", "reports", function ($scope, reports) {
            $scope.getJob = function (job) {
                if (!job.steps) {
                    reports.runReport(getJobDataReport(job.id), job, true).then(function (results) {
                        job.steps = results.steps;
                    });
                }
                job.isOpen = !job.isOpen;
            };
            function getJobDataReport(jobId) {
                return {
                    "mock_data": "monitor_" + jobId
                };
            }
        }]);
}());

(function () {
    'use strict';
    angular.module("RepeaterWidget", ["Utils", "Widgets"])
        .run(["widgetViews", function (widgetViews) {
            widgetViews.registerView("repeater", {});
        }])
        .controller("RepeaterWidgetController", ["$scope", "widgets", "$q", "utils", function ($scope, widgets, $q, utils) {
            $scope.widgetype = $scope.view.settings.widgetType;
            var promises = [];
            function addView(viewData) {
                var view = {
                    settings: $scope.view.settings.widgetSettings,
                    type: $scope.view.settings.widgetType,
                    rawData: viewData
                };
                $scope.repeaterViews.push(view);
                promises.push(widgets.setViewValues(view, viewData, $scope.getWidgetParams()));
            }
            function init() {
                $scope.repeaterViews = [];
                promises = [];
                if ($scope.view.settings.title && $scope.view.data && $scope.view.data.length) {
                    $scope.repeaterTitle = utils.strings.parseValue($scope.view.settings.title, $scope.view.data[0], $scope.getWidgetParams());
                }
                angular.forEach($scope.view.data, function (viewData) {
                    if ($scope.view.settings.repeatField) {
                        angular.forEach(viewData[$scope.view.settings.repeatField], addView);
                    }
                    else {
                        addView(viewData);
                    }
                });
                $q.all(promises).then(function (viewsData) {
                    angular.forEach(viewsData, function (viewData, i) {
                        $scope.repeaterViews[i].data = viewData;
                    });
                });
            }
            $scope.$on("onWidgetData", init);
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("PackageController", ["$scope", "packages", "utils", "conditions", "search", "eventBus",
        function ($scope, packages, utils, conditions, search, eventBus) {
            var packageId, requiredParams, controlParamNames = [];
            $scope.$on("$destroy", function () {
                eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
            });
            $scope.onControlChange = function (control, value, label) {
                $scope.paramChange = true;
                control.value = value;
                if (control.type === "search" && label) {
                    control.valueLabel = label;
                }
                setAllRequiredParamsAvailable(false);
                setDependantControls(control, value);
            };
            $scope.onControlBlur = function (control) {
                if (!control.value && control.default) {
                    control.value = control.default;
                }
            };
            $scope.updateParams = function () {
                if (!$scope.paramChange || !$scope.paramsReadyToRun) {
                    return;
                }
                var params = getParamsFromControls();
                setAllRequiredParamsAvailable(true);
                $scope.setParams(params.urlParams);
                $scope.setParams(params.innerParams, false);
                $scope.paramChange = false;
                setLinkToHref(params.innerParams);
            };
            $scope.setPackageError = function (error) {
                clearMessages();
                $scope.packageError = error;
            };
            $scope.setPackageLoading = function (isLoading) {
                clearMessages();
                $scope.packageLoading = isLoading;
            };
            $scope.setPackageNoData = function (noData) {
                clearMessages();
                $scope.packageNoData = !!noData;
            };
            function clearMessages() {
                $scope.packageError = $scope.packageLoading = $scope.packageNoData = null;
            }
            function setDependantControls(srcControl, value) {
                $scope.currentPackage.controls.forEach(function (control) {
                    if (srcControl !== control) {
                        var dependency = control.dependencies && control.dependencies[srcControl.param];
                        if (dependency) {
                            if (control.type === "date") {
                                if (dependency === "lesserThan") {
                                    control.maxValue =
                                        value !== undefined && value !== null ? value : control.settings.maxDate;
                                }
                                else if (dependency === "greaterThan") {
                                    control.minValue =
                                        value !== undefined && value !== null ? value : control.settings.minDate;
                                }
                            }
                        }
                    }
                });
            }
            function setLinkToHref(params) {
                var urlParams = [], paramValue, linkParams;
                function populateUrlParams(d) {
                    if (d) {
                        urlParams.push(paramName + "=" + encodeURIComponent(d));
                    }
                }
                for (var paramName in params) {
                    if (params.hasOwnProperty(paramName)) {
                        paramValue = params[paramName];
                        if (angular.isArray(paramValue)) {
                            paramValue.forEach(populateUrlParams);
                        }
                        else if (paramValue) {
                            urlParams.push(paramName + "=" + encodeURIComponent(paramValue));
                        }
                    }
                }
                linkParams = angular.extend(getParamsFromControls(), params);
                if ($scope.currentPackage.linkTo) {
                    $scope.currentPackage.links =
                        angular.isArray($scope.currentPackage.linkTo) ? $scope.currentPackage.linkTo :
                            [$scope.currentPackage.linkTo];
                    $scope.currentPackage.links.forEach(function (link) {
                        link.href = utils.strings.parseValue(link.url, { params: urlParams.join("&") }, linkParams);
                    });
                }
                if ($scope.currentPackage.multiLink) {
                    $scope.currentPackage.multiLink.links.forEach(function (link) {
                        link.href =
                            utils.url.escapeUrl(utils.strings.parseValue(link.url, { params: urlParams.join("&") }, linkParams));
                    });
                }
            }
            function getParamsFromControls() {
                if (!$scope.currentPackage.controls) {
                    return;
                }
                var params = { urlParams: {} }, widgetParams = $scope.getWidgetParams();
                $scope.currentPackage.controls.forEach(function (control) {
                    var innerParam, paramValue;
                    paramValue = params.urlParams[control.param] = !control.value ? null :
                        control.formatParam ?
                            utils.strings.parseValue(control.formatParam, { value: control.value }, widgetParams) :
                            control.value;
                    if (paramValue !== undefined && paramValue !== null) {
                        params[control.param] = paramValue;
                    }
                    if (control.value && control.valueLabel) {
                        params.urlParams[control.param + "_label"] = control.valueLabel;
                    }
                    if (control.innerParam) {
                        if (!params.innerParams) {
                            params.innerParams = {};
                        }
                        else {
                            innerParam = params.innerParams[control.innerParam.name];
                        }
                        var innerParamValue = getInnerParamValue(control, paramValue);
                        if (innerParam) {
                            params.innerParams[control.innerParam.name + "_conjuction"] = "AND";
                            if (!angular.isArray(innerParam)) {
                                params.innerParams[control.innerParam.name] = [innerParam];
                            }
                            params.innerParams[control.innerParam.name].push(innerParamValue);
                        }
                        else {
                            params.innerParams[control.innerParam.name] = innerParamValue;
                        }
                    }
                });
                return params;
            }
            function getInnerParamValue(control, paramValue) {
                return control.innerParam.type && control.innerParam.type !== "equals" && paramValue ?
                    conditions.getParamOperator(control.innerParam.type) + paramValue : paramValue;
            }
            function setControlParams() {
                var widgetParams = $scope.getWidgetParams(), innerParams;
                requiredParams = {};
                $scope.currentPackage.controls.forEach(function (control) {
                    var paramValue = widgetParams[control.param] || control.defaultValue;
                    if (paramValue) {
                        if (control.type === "date") {
                            control.value = utils.date.getMoment(paramValue) || null;
                            if (control.value) {
                                control.value = control.value.toDate();
                            }
                        }
                        else if (control.type === "number") {
                            control.value = parseInt(paramValue, 10);
                        }
                        else if (control.type === "boolean") {
                            control.value = paramValue !== "false";
                        }
                        else if (control.type === "search") {
                            control.value = widgetParams[control.param];
                            control.valueLabel = widgetParams[control.param + "_label"];
                        }
                        else {
                            control.value = paramValue;
                        }
                        if (control.innerParam) {
                            if (!innerParams) {
                                innerParams = {};
                            }
                            var innerParam = innerParams[control.innerParam.name];
                            if (!innerParam) {
                                innerParam = innerParams[control.innerParam.name] = [];
                            }
                            else {
                                innerParams[control.innerParam.name + "_conjuction"] = "AND";
                            }
                            innerParam.push(getInnerParamValue(control, paramValue));
                        }
                    }
                    if (control.isRequired) {
                        requiredParams[control.param] = control.label;
                    }
                });
                setAllRequiredParamsAvailable(true);
                if (innerParams) {
                    $scope.setParams(innerParams, false);
                }
                setLinkToHref(innerParams || {});
            }
            function setAllRequiredParamsAvailable(setParamsReady) {
                var allRequiredParamsAvailable = true, requiredParamNames = [];
                if ($scope.currentPackage.controls) {
                    for (var i = 0, control; !!(control = $scope.currentPackage.controls[i]); i++) {
                        if (control.isRequired && !control.value) {
                            allRequiredParamsAvailable = false;
                            requiredParamNames.push(control.label.toLowerCase());
                        }
                        if (control.disableConditions) {
                            control.disabled = conditions.validateConditions(control.disableConditions, getParamsFromControls().urlParams, {});
                        }
                    }
                }
                $scope.paramsReadyToRun = allRequiredParamsAvailable;
                if (setParamsReady) {
                    $scope.paramsReady = allRequiredParamsAvailable;
                }
                $scope.requiredParamNames = $scope.paramsReady ? null : utils.arrays.toSentence(requiredParamNames);
            }
            function setSearchSettings() {
                $scope.currentPackage.controls.forEach(function (control) {
                    if (control.type === "search" && control.settings.search) {
                        control.settings.search = control.settings.search.params ?
                            search[control.settings.search.entity].bind(this, control.settings.search.params) :
                            search[control.settings.search.entity];
                    }
                });
            }
            function init() {
                var params = $scope.getWidgetParams();
                packageId = params.entityId ||
                    $scope.dashboard.navigation.children[0].children[0].url.match(/package\/(.*)$/)[1];
                packages.getPackageById(packageId).then(function (packageConfig) {
                    $scope.setParams({
                        packageName: { value: packageConfig.name, setToUrl: false },
                        packageDescription: { value: packageConfig.description, setToUrl: false }
                    }, false);
                    $scope.currentPackage = packageConfig;
                    $scope.currentPackage.renderParams =
                        packageConfig.controls || packageConfig.linkTo || packageConfig.multiLink;
                    if ($scope.currentPackage.controls) {
                        setControlParams();
                        setSearchSettings();
                        $scope.currentPackage.controls.forEach(function (control) {
                            controlParamNames.push(control.param);
                        });
                        eventBus.subscribe("dashboardParamsChange", onParamsChange);
                    }
                    else {
                        $scope.paramsReady = true;
                        $scope.paramsReadyToRun = true;
                        setLinkToHref(params);
                    }
                }, function (error) {
                    console.error("Can't load package: ", error);
                });
            }
            function onParamsChange(e, changedParams) {
                if (utils.objects.containsAnyParam(changedParams, controlParamNames)) {
                    $scope.$broadcast("packageParamsChange", changedParams);
                }
            }
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .controller("PopupController", ["$scope", function ($scope) {
            $scope.isPopup = true;
        }]);
}());

(function () {
    'use strict';
    angular.module('simplePagination', []).directive('simplePagination', ["$parse", "$timeout", "utils", function ($parse, $timeout, utils) {
            return {
                templateUrl: "views/controls/simplePagination.html",
                restrict: 'E',
                scope: {
                    page: "=",
                    pageSize: "=",
                    onSelect: "&",
                    hideIfEmpty: "=",
                    total: "="
                },
                replace: true,
                link: function postLink(scope, element) {
                    function setPages() {
                        if (!isNaN(scope.total) && !isNaN(scope.pageSize)) {
                            scope.pageCount = Math.ceil(scope.total / scope.pageSize);
                        }
                        if (isNaN(scope.page)) {
                            scope.page = 1;
                        }
                        scope.pageInput = scope.page;
                        if (scope.pageCount) {
                            scope.pageInputWidth = (scope.pageCount.toString().length + 1) + "em";
                        }
                    }
                    function setWaitTime() {
                        $timeout.cancel(waitTimeout);
                        wait = true;
                        waitTimeout = $timeout(function () {
                            wait = false;
                        }, graceTime);
                    }
                    function fireOnChange() {
                        $timeout.cancel(onChangeTimeout);
                        setWaitTime();
                        if (scope.onSelect) {
                            onChangeTimeout = $timeout(function () {
                                scope.onSelect({ page: scope.page });
                            }, graceTime);
                        }
                    }
                    var onChangeTimeout, wait, waitTimeout, graceTime = 300;
                    scope.$on("$destroy", function () {
                        $timeout.cancel(waitTimeout);
                        $timeout.cancel(onChangeTimeout);
                        element.empty();
                        element.off();
                    });
                    //listen to url changes and update the pagination control accordingly
                    scope.$on("locationChange", function (event, args) {
                        var params = utils.url.parseUrlParams(args.newUrl);
                        if (params.page) {
                            scope.gotoPage(Number(params.page));
                        }
                    });
                    scope.gotoPage = function (page) {
                        if (page === scope.page) {
                            return;
                        }
                        if (page > scope.pageCount) {
                            scope.page = scope.pageCount;
                        }
                        else if (page < 1) {
                            scope.page = 1;
                        }
                        else {
                            scope.page = page;
                        }
                        setPages();
                        if (!wait) {
                            setWaitTime();
                            if (scope.onSelect) {
                                scope.onSelect({ page: scope.page });
                            }
                        }
                        else {
                            fireOnChange();
                        }
                    };
                    //enables the text box to insert the requested page number
                    scope.enablePageInput = function () {
                        scope.pageInputEnabled = true;
                    };
                    scope.prevPage = function () {
                        scope.gotoPage(scope.page - 1);
                    };
                    scope.nextPage = function () {
                        scope.gotoPage(scope.page + 1);
                    };
                    scope.onInputKeydown = function (e) {
                        if (e.keyCode === 27) {
                            scope.pageInput = scope.page;
                            scope.pageInputEnabled = false;
                        }
                    };
                    scope.$watchGroup(["page", "pageSize", "total"], setPages);
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("ButtonController", ["$scope", "utils", "eventBus", "events", "state", function ($scope, utils, eventBus, events, state) {
            var buttonState;
            $scope.$on("$destroy", function () {
                eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
            });
            $scope.buttonClick = function () {
                var events = angular.copy(angular.isArray($scope.control.onClick) ? $scope.control.onClick :
                    [$scope.control.onClick]);
                angular.forEach(events, function (event) {
                    if ($scope.button.actionOptions) {
                        event.actionOptions = jQuery.extend(true, event.actionOptions, $scope.button.actionOptions);
                    }
                });
                events.triggerDashboardEvent(events, null, state.currentParams);
                if ($scope.control.toggle) {
                    buttonState = buttonState === "on" ? "off" : "on";
                    $scope.button = $scope.control.toggle[buttonState];
                    $scope.button.state = buttonState;
                    setTexts();
                }
            };
            function setTexts() {
                if ($scope.button.text) {
                    $scope.button.text = utils.strings.parseValue($scope.button.text, {}, $scope.mainDashboardParams);
                }
                if ($scope.button.tooltip) {
                    $scope.button.tooltip =
                        utils.strings.parseValue($scope.button.tooltip, {}, $scope.mainDashboardParams);
                }
            }
            function init() {
                var buttonSettings;
                if ($scope.control.toggle) {
                    buttonState = $scope.mainDashboardParams[$scope.control.toggle.toggleParam] ? "on" :
                        $scope.control.toggle.defaultState || "off";
                    buttonSettings = $scope.control.toggle[buttonState];
                    buttonSettings.state = buttonState;
                }
                else {
                    buttonSettings = $scope.control;
                }
                $scope.button = angular.extend({}, $scope.control, buttonSettings);
                setTexts();
            }
            function needsRefresh(params) {
                if ($scope.control.toggle && params[$scope.control.toggle.toggleParam] !== undefined) {
                    var toggleParamState = params[$scope.control.toggle.toggleParam] ? "on" : "off";
                    return toggleParamState !== buttonState;
                }
                if ($scope.control.refreshOn) {
                    for (var i = 0; i < $scope.control.refreshOn.length; i++) {
                        if (params[$scope.control.refreshOn[i]] !== undefined) {
                            return true;
                        }
                    }
                }
                return false;
            }
            function onParamsChange(e, changedParams) {
                if (needsRefresh(changedParams)) {
                    init();
                }
            }
            if ($scope.control.toggle && $scope.control.refreshOn) {
                eventBus.subscribe("dashboardParamsChange", onParamsChange);
            }
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .controller("AccountSettingsController", ["$scope", "auth", "page", function ($scope, auth, page) {
            var originalData;
            $scope.modified = false;
            $scope.onChanged = function () {
                $scope.modified = true;
            };
            page.setPageTitle("Account Settings");
            auth.getCurrentUser().then(function (user) {
                originalData = angular.copy(user);
                $scope.account = user;
            });
            $scope.changePassword = function () {
                $scope.passwordError = null;
                $scope.success = null;
                if (!$scope.currentPassword) {
                    $scope.passwordError = { message: "Please enter your current password." };
                    return;
                }
                if (validatePasswordsMatch()) {
                    if ($scope.account) {
                        doChangePassword();
                    }
                }
            };
            $scope.saveUser = function () {
                $scope.success = null;
                $scope.error = null;
                if (!$scope.userPassword) {
                    $scope.passwordRequired = true;
                    return;
                }
                auth.editUser({
                    username: $scope.account.userName,
                    password: $scope.userPassword,
                    firstName: $scope.account.firstName,
                    lastName: $scope.account.lastName
                }).then(function () {
                    $scope.success = { message: "User saved successfully." };
                }, function (error) {
                    $scope.error = { message: "Error saving user." };
                    console.error("Error saving user: ", error);
                });
                $scope.passwordRequired = false;
            };
            $scope.reset = function () {
                $scope.account = angular.copy(originalData);
                $scope.modified = false;
                $scope.currentPassword = $scope.newPassword = $scope.newPasswordConfirm = $scope.userPassword = "";
                $scope.passwordRequired = false;
                $scope.error = null;
            };
            function doChangePassword() {
                auth.changePassword($scope.account.userName, $scope.currentPassword, $scope.newPassword)
                    .then(function () {
                    $scope.passwordSuccess = { message: "Password changed successfully." };
                    $scope.currentPassword = $scope.newPassword = $scope.newPasswordConfirm = "";
                }, function (error) {
                    $scope.passwordError = { message: error.message };
                });
            }
            function validatePasswordsMatch() {
                if (!$scope.newPasswordConfirm) {
                    $scope.passwordError = { message: "Please enter password confirmation." };
                    return;
                }
                if ($scope.newPassword !== $scope.newPasswordConfirm) {
                    $scope.passwordError = { message: "Passwords don't match." };
                    return;
                }
                if ($scope.currentPassword === $scope.newPassword) {
                    $scope.passwordError = { message: "The new password can't be identical to the current one." };
                    return;
                }
                return true;
            }
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("GlobalSettingsController", ["$scope", "utils", function ($scope, utils) {
            $scope.scores = [
                {
                    weight: 25,
                    name: "Active Directory"
                },
                {
                    weight: 25,
                    name: "Logins"
                },
                {
                    weight: 25,
                    name: "VPN"
                },
                {
                    weight: 25,
                    name: "Group Membership"
                }
            ];
            function getScoresWeightDisplay() {
                var totalWeights = 0;
                angular.forEach($scope.scores, function (score, index) {
                    totalWeights += score.weight;
                });
                angular.forEach($scope.scores, function (score, index) {
                    score.weightDisplay = Math.round((score.weight / totalWeights) * 100) + "%";
                });
            }
            getScoresWeightDisplay();
            $scope.distributeScoresEvenly = function () {
                var weight = Math.floor(100 / $scope.scores.length), firstWeight = weight + 100 - weight * $scope.scores.length;
                angular.forEach($scope.scores, function (score, index) {
                    var newWeight = index ? weight : firstWeight;
                    if (score.weight !== newWeight) {
                        score.weight = newWeight;
                        $scope.changed = true;
                    }
                });
                getScoresWeightDisplay();
            };
            $scope.scoreChange = function (score, scoreIndex) {
                getScoresWeightDisplay();
                $scope.changed = true;
            };
        }]);
}());

angular.module('Fortscale')
    .directive('daterange', ["$parse", "transforms", "utils",
    function ($parse, transforms, utils) {
        'use strict';
        return {
            template: "<input type='text'  readonly='readonly' class='daterange-input' />",
            restrict: 'E',
            require: "?ngModel",
            link: function postLink(scope, element, attrs, ngModel) {
                var params, init, input = element.children("input")[0], ngChangeFunc = attrs.ngChange ? $parse(attrs.ngChange) : null;
                var MOMENT_DATE_FORMAT = "MM/DD/YYYY";
                scope.$on("$destroy", function (e, data) {
                    $(input).empty().off();
                    element.empty();
                    element.off();
                });
                function onChange(dates) {
                    var timeStart = utils.date.getMoment(dates.start, null, MOMENT_DATE_FORMAT);
                    var timeEnd = utils.date.getMoment(dates.end, null, MOMENT_DATE_FORMAT);
                    params.timeStart = timeStart.startOf('day');
                    params.timeEnd = timeEnd.endOf('day');
                    ngModel.$setViewValue(params);
                    if (ngChangeFunc) {
                        ngChangeFunc(scope, params);
                    }
                }
                scope.$watch(attrs.ngModel, function (value) {
                    var timeStart, timeEnd;
                    if (value) {
                        if (angular.isObject(value)) {
                            if (value.timeStart && value.timeEnd) {
                                timeStart = utils.date.getMoment(value.timeStart).startOf('day');
                                timeEnd = utils.date.getMoment(value.timeEnd).endOf('day');
                            }
                        }
                        if (!timeStart || !timeEnd) {
                            timeStart = utils.date.getMoment(value).startOf('day');
                            if (timeStart.isValid()) {
                                timeEnd = timeStart = timeStart.toDate();
                            }
                        }
                    }
                    params = {
                        timeStart: transforms.date(timeStart || utils.date.getMoment('now'), {
                            format: MOMENT_DATE_FORMAT
                        }),
                        timeEnd: transforms.date(timeEnd || utils.date.getMoment('now'), {
                            format: MOMENT_DATE_FORMAT
                        })
                    };
                    if (params.timeStart === params.timeEnd) {
                        input.value = params.timeStart;
                    }
                    else {
                        input.value = [params.timeStart, params.timeEnd].join(" - ");
                    }
                    // Init DatePicker component
                    $(input).daterangepicker({
                        presets: {
                            dateRange: "Date Range"
                        },
                        presetRanges: [
                            { text: 'Last week', dateStart: 'today-7days', dateEnd: 'today', closeOnSelect: true },
                            { text: 'Last month', dateStart: 'today-1months', dateEnd: 'today', closeOnSelect: true }
                        ],
                        closeOnSelect: false,
                        doneButtonText: "Apply",
                        dateFormat: "mm/dd/yy",
                        onDone: onChange,
                        onChange: onChange,
                        latestDate: "today"
                    });
                    init = true;
                });
            }
        };
    }]);

(function () {
    'use strict';
    angular.module('Fortscale')
        .directive('searchbox', ["$timeout", "reports", "transforms", "widgets", "$parse", "$rootScope",
        "search", "utils", function ($timeout, reports, transforms, widgets, $parse, $rootScope, search, utils) {
            return {
                template: "<span class='searchbox' ng-class='{ loading: loading }'><input type='text'  " +
                    "placeholder='{{placeholder}}' class='search' ng-class='{ error: isRequired }' />" +
                    "<i class='icon-spinner icon-spin'></i></span>",
                restrict: 'AE',
                replace: true,
                require: "?ngModel",
                scope: {
                    onSelect: "&",
                    searchSettings: "=",
                    isRequired: "=",
                    display: "=",
                    charEntered: "="
                },
                link: function postLink(scope, element, attrs, ngModel) {
                    var isInit, MIN_SEARCH_SIZE = 1, // If the current term is smaller than this, search won't run.
                    onSelectTimeout, input = element.find("input"), onSelect;
                    if (!element[0].classList.contains("search")) {
                        element[0].classList.add("search");
                    }
                    scope.$watch("onSelect", function () {
                        if (Object(scope.onSelect) === scope.onSelect && scope.onSelect.url) {
                            onSelect = function (selected) {
                                if (selected.$item) {
                                    var path = utils.strings.parseValue(scope.onSelect.url, selected.$item);
                                    if (/^#/.test(scope.onSelect)) {
                                        window.location.hash = path;
                                    }
                                    else {
                                        window.location.href = path;
                                    }
                                }
                            };
                        }
                        else {
                            onSelect = scope.onSelect;
                        }
                    });
                    scope.$watch("searchSettings", function (value) {
                        if (value && !isInit) {
                            init();
                        }
                    });
                    if (ngModel) {
                        ngModel.$render = function () {
                            if (ngModel.$viewValue) {
                                input.val(scope.display || ngModel.$viewValue);
                            }
                        };
                    }
                    function split(val) {
                        return val.split(/,\s*/);
                    }
                    function extractLast(term) {
                        return split(term).pop();
                    }
                    function parseResults(results) {
                        var value, label;
                        if (scope.searchSettings.distinct) {
                            var checkDuplicates = [];
                            var toRemove = [];
                            results.forEach(function (item) {
                                var key = item[Object.keys(item)[0]];
                                if (checkDuplicates.indexOf(key) > -1) {
                                    toRemove.push(item);
                                }
                                else {
                                    checkDuplicates.push(key);
                                }
                            });
                            toRemove.forEach(function (item) {
                                results.splice(results.indexOf(item), 1);
                            });
                        }
                        if (results.data) {
                            results = results.data;
                        }
                        if (scope.searchSettings.valueField || scope.searchSettings.resultField) {
                            return results.map(function (result) {
                                if (result.label || result.display_name) {
                                    value = result.value || result.id;
                                    label = result.label || result.display_name;
                                }
                                else {
                                    value = result[scope.searchSettings.valueField ||
                                        scope.searchSettings.resultField];
                                    label = scope.searchSettings.labelField ?
                                        result[scope.searchSettings.labelField] : value;
                                }
                                return { label: label, value: value };
                            });
                        }
                        return results;
                    }
                    function init() {
                        if (scope.searchSettings.onSelect && !attrs.onSelect) {
                            scope.onSelect = scope.searchSettings.onSelect;
                        }
                        isInit = true;
                        input.on("keyup", function (event) {
                            if (event.keyCode === $.ui.keyCode.TAB &&
                                $(this).data("ui-autocomplete").menu.active) {
                                event.preventDefault();
                            }
                            else if (event.keyCode === $.ui.keyCode.ESCAPE) {
                                $(this)
                                    .val("")
                                    .autocomplete("close");
                            }
                            else if (event.keyCode === $.ui.keyCode.ENTER &&
                                scope.searchSettings.allowAllStrings) {
                                scope.onSelect(this.value);
                            }
                            else if (!input.val() || input.val() === "") {
                                onSelect({ $value: "", $label: "", $item: $.ui.item });
                                if (ngModel) {
                                    ngModel.$setViewValue("");
                                }
                            }
                            else {
                                if (scope.charEntered && scope.display !== input.val()) {
                                    scope.charEntered();
                                }
                            }
                        })
                            .attr("placeholder", scope.searchSettings.placeholder)
                            .data("autocomplete-enabled", true)
                            .autocomplete({
                            delay: 400,
                            autoFocus: true,
                            minLength: MIN_SEARCH_SIZE,
                            source: function (request, response) {
                                if (!request.term || request.term.length < MIN_SEARCH_SIZE) {
                                    return;
                                }
                                //var searchMethod = scope.searchSettings.search.constructor === Function ?
                                //    scope.searchSettings.search : search.searchDataEntityField.bind(search,
                                //    scope.searchSettings.dataEntity, scope.searchSettings.dataEntityField,
                                //    scope.searchSettings.labelField, scope.searchSettings.extraTerms);
                                scope.loading = true;
                                var searchTerm = extractLast(request.term);
                                if (scope.searchSettings.termTransform) {
                                    searchTerm = transforms.string(searchTerm, scope.searchSettings.termTransform);
                                }
                                $rootScope.safeApply(function () {
                                    if (scope.searchSettings.search) {
                                        scope.searchSettings.search(searchTerm).then(function (results) {
                                            results = results ? parseResults(results) : [];
                                            scope.loading = false;
                                            response(results);
                                        }, function (error) {
                                            scope.loading = false;
                                            response([]);
                                        });
                                    }
                                });
                            },
                            search: function () {
                                // custom minLength
                                var term = extractLast(this.value);
                                if (term.length < 1) {
                                    return false;
                                }
                            },
                            focus: function () {
                                // prevent value inserted on focus
                                return false;
                            },
                            select: function (event, ui) {
                                if (scope.searchSettings.showValueOnSelect) {
                                    input.val(ui.item.label || ui.item.value);
                                }
                                else {
                                    input.val("");
                                }
                                if (scope.onSelect) {
                                    $timeout.cancel(onSelectTimeout);
                                    onSelectTimeout = $timeout(function () {
                                        onSelect({
                                            $value: ui.item.value,
                                            $label: ui.item.label,
                                            $item: ui.item
                                        });
                                        scope.display = ui.item.label;
                                        if (ngModel) {
                                            ngModel.$setViewValue(ui.item.value);
                                        }
                                    }, 40);
                                }
                                return false;
                            }
                        });
                        scope.$on("$destroy", function (e, data) {
                            var $input = element.find("input");
                            $timeout.cancel(onSelectTimeout);
                            if ($input.data("autocomplete-enabled")) {
                                $input.autocomplete("destroy").off();
                            }
                            element.empty();
                            element.off();
                        });
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module('Fortscale')
        .directive('progressBar', function ($timeout, reports, transforms) {
        return {
            template: "<div class='progress-bar' ng-style='{width: width}' title='{{tooltip}}'><span " +
                "ng-style='{width: progressValue, background: progressColor}'><em ng-show='showArrow'></em></span>" +
                "</div>",
            restrict: 'E',
            replace: true,
            require: "?ngModel",
            link: function postLink(scope, element, attrs, ngModel) {
                var rawValue, settings, colors = ["#90CA77", "#E9B64D", "#E48743", "#E48743", "#9E3B33"];
                scope.progressValue = 0;
                scope.$watch(attrs.ngModel, function (value) {
                    rawValue = parseFloat(value, 10);
                    setValue();
                });
                scope.$watch(attrs.settings, function (value) {
                    settings = value;
                    scope.width = settings.width;
                    if (settings.tooltip) {
                        scope.tooltip = settings.tooltip;
                    }
                    setValue();
                });
                scope.$watch(attrs.tooltip, function (value) {
                    scope.tooltip = value;
                });
                function getColor(value) {
                    var color, colorStep = 1 / colors.length;
                    for (var i = 0; i < colors.length; i++) {
                        color = colors[i];
                        if (value < (i + 1) * colorStep) {
                            return color;
                        }
                    }
                    return color;
                }
                function setValue() {
                    if (rawValue === undefined || !settings) {
                        return;
                    }
                    rawValue = Math.max(settings.min, rawValue);
                    rawValue = Math.min(settings.max, rawValue);
                    var valueFracture = (rawValue - settings.min) / (settings.max - settings.min);
                    scope.progressValue = (100 * valueFracture) + "%";
                    scope.progressColor = getColor(valueFracture);
                    scope.showArrow = valueFracture > 0.05 && valueFracture < 0.95;
                }
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("Fortscale").directive("modal", function () {
        return {
            restrict: "E",
            template: ['<div class="modal" ng-show="settings.show" toggle-keys="{{ { escape: \'modalClose\' } }}" ' +
                    'toggle-keys-enabled="settings.show" ng-cloak>',
                '<div class="modal-background closes-modal"></div>',
                '<div class="modal-contents" ng-style="modalStyle" ng-transclude>',
                '</div></div>'].join(""),
            transclude: true,
            replace: true,
            require: '?ngModel',
            link: function ($scope, element, attrs, ngModel) {
                element.on("click", function (e) {
                    if (e.target.classList.contains("closes-modal")) {
                        $scope.$apply($scope.modalClose);
                    }
                });
                $scope.modalClose = function () {
                    $scope.settings.show = false;
                    //ngModel.$setViewValue(false);
                    $scope.$emit("modalClose");
                };
                ngModel.$render = function () {
                    $scope.settings = ngModel.$viewValue;
                    if ($scope.settings) {
                        $scope.modalStyle = {
                            width: $scope.settings.width,
                            height: $scope.settings.height,
                            'margin-top': $scope.settings.height / -2,
                            'margin-left': $scope.settings.width / -2
                        };
                    }
                };
                $scope.$on("$destroy", function (e, data) {
                    element.empty();
                    element.off();
                });
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .directive("hideOnError", [function () {
            return {
                restrict: 'A',
                link: function postLink(scope, element, attrs) {
                    scope.$on("$destroy", function (e, data) {
                        element.off();
                    });
                    element.on("error", function (event) {
                        element.css("display", "none");
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    function navigation(dynamicMenus, conditions, state) {
        return {
            template: "<div></div>",
            restrict: 'E',
            require: 'ngModel',
            scope: {
                onSelect: "&",
                navData: "="
            },
            link: function (scope, element, attrs, ngModel) {
                var selectedItem, selectedElement, navData;
                scope.$watch("navData", function (value) {
                    if (!!(navData = value)) {
                        setNav();
                    }
                });
                ngModel.$render = function () {
                    if (!navData || !ngModel.$viewValue) {
                        return;
                    }
                    if (selectedItem) {
                        selectedItem.selected = false;
                        selectedElement = element[0].querySelector(".nav-link.selected");
                        if (selectedElement) {
                            selectedElement.parentNode.classList.remove("selected");
                        }
                    }
                    selectedItem = getItem(navData, ngModel.$viewValue);
                    if (selectedItem) {
                        selectedItem.selected = true;
                        selectedElement = getElement(selectedItem);
                        selectedElement.parentNode.classList.add("selected");
                    }
                };
                function getItem(root, item) {
                    if ((root.id && root.id === item.id) || (root.url && root.url === item.url)) {
                        return root;
                    }
                    if (root.children) {
                        var found;
                        for (var i = 0, child; !!(child = root.children[i]); i++) {
                            found = getItem(child, item);
                            if (found) {
                                return found;
                            }
                        }
                    }
                    return null;
                }
                function getElement(item) {
                    var links = element[0].querySelectorAll(".nav-link");
                    for (var i = 0, link; !!(link = links[i]); i++) {
                        if (link.__data__ === item) {
                            return link;
                        }
                    }
                }
                function selectFirstItem() {
                    var firstElement = element.find(".nav-link").first();
                    if (firstElement.length) {
                        firstElement.parent().addClass("selected");
                        firstElement.parents(".nav").removeClass("closed").prev().removeClass("closed");
                        selectedElement = firstElement[0];
                        if (scope.onSelect) {
                            scope.onSelect({ $item: selectedElement.__data__ });
                        }
                    }
                }
                function addChildren(rootElement, navItem, isChild) {
                    var root = d3.select(rootElement);
                    if (navItem.name) {
                        var expand = root.append("a")
                            .attr("id", "menu-parent-item-" + navItem.name.toLowerCase().split(" ").join("_"))
                            .attr("class", "nav-expand" + (navItem.isOpen ? "" : " closed"));
                        expand.append("i").attr("class", "icon-");
                        expand.append("span").text(navItem.name);
                    }
                    var list = root.append("ul")
                        .attr("class", "unstyled nav " + (!isChild || navItem.isOpen ? "open" : "closed"));
                    if (navItem.children && navItem.children.length) {
                        rootElement.classList.add("with-children");
                    }
                    list.selectAll("li").data(navItem.children.filter(checkConditions))
                        .enter()
                        .append(function (d) {
                        var li = document.createElement("li");
                        if (d.children) {
                            addChildren(li, d, true);
                        }
                        else {
                            d3.select(li).append("a")
                                .attr("id", "nav-item-" + d.name.toLowerCase().split(" ").join("_"))
                                .attr("class", "nav-link" + (d.selected ? " selected" : ""))
                                .attr("href", d.href || d.url || null)
                                .attr("data-regexp", d.selectedRegExp)
                                .text(d.name)
                                .data([d]);
                            // This will change the href of the nav's a tags to reflect the changes to the state.
                            if (d.href) {
                                // Check if current hash is a match to d.href
                                var hrefRgx = new RegExp(d.href);
                                if (hrefRgx.test(window.location.href)) {
                                    // When a match, add a mouseover listener that updates href
                                    var aTag = li.querySelector('a');
                                    aTag.addEventListener('mouseover', function () {
                                        if (aTag.hash !== window.location.hash) {
                                            aTag.hash = window.location.hash;
                                        }
                                    });
                                }
                            }
                        }
                        return li;
                    });
                    return root[0][0];
                }
                function checkConditions(navItem) {
                    return !(navItem.conditions &&
                        !conditions.validateConditions(navItem.conditions, null, state.currentParams));
                }
                function setNav() {
                    element.empty();
                    dynamicMenus.setDynamicMenus(navData.children);
                    var newElement = angular.element(addChildren(document.createElement("div"), navData)), locationUrl = window.location.hash.split("?")[0];
                    element.append(newElement);
                    selectedElement = element.find(".nav-link.selected");
                    if (!selectedElement.length) {
                        selectedElement = element.find(".nav-link[href='" + locationUrl + "']");
                    }
                    if (!selectedElement.length) {
                        element.find(".nav-link[data-regexp]").each(function (i, link) {
                            var regexp = new RegExp(link.getAttribute("data-regexp"));
                            if (regexp && regexp.test(locationUrl)) {
                                selectedElement = jQuery(link);
                                return false;
                            }
                        });
                    }
                    if (selectedElement.length) {
                        selectedElement.parent().addClass("selected");
                        selectedElement.parents(".nav").removeClass("closed").prev().removeClass("closed");
                        selectedElement = selectedElement[0];
                    }
                    else {
                        selectFirstItem();
                    }
                }
                function init() {
                    if (scope.onSelect) {
                        element.on("click", ".nav-link", function (e) {
                            var navItem = e.target.__data__;
                            if (selectedElement) {
                                selectedElement.parentNode.classList.remove("selected");
                            }
                            selectedElement = e.target;
                            selectedElement.parentNode.classList.add("selected");
                            scope.$apply(function () {
                                scope.onSelect({ $item: navItem });
                            });
                        });
                    }
                    element.on("click", ".nav-expand", function (e) {
                        $(e.currentTarget).toggleClass("closed").next().toggleClass("closed");
                    });
                    scope.$on("$destroy", function () {
                        element.empty();
                        element.off();
                    });
                }
                init();
            }
        };
    }
    navigation.$inject = ["dynamicMenus", "conditions", "state"];
    angular.module("Fortscale")
        .directive('nav', navigation);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .directive('tabs', function () {
        return {
            template: "<div class='tabs'></div>",
            restrict: 'E',
            replace: true,
            scope: {
                onSelect: "&",
                _tabs: "=tabsData"
            },
            require: '?ngModel',
            link: function (scope, element, attrs, ngModel) {
                var dataWatcher, selectedElement, selectedTab;
                ngModel.$render = function () {
                    selectedTab = ngModel.$viewValue;
                    selectTabElement(selectedTab);
                };
                function selectTabElement(tab) {
                    if (!scope._tabs) {
                        return;
                    }
                    if (selectedElement) {
                        selectedElement.classList.remove("selected");
                        selectedElement = null;
                    }
                    for (var i = 0; i < scope._tabs.length; i++) {
                        if (scope._tabs[i] === tab) {
                            selectedElement = element[0].childNodes[i];
                            break;
                        }
                    }
                    if (selectedElement) {
                        selectedElement.classList.add("selected");
                    }
                }
                element.on("click", ".tab", function (e) {
                    e.stopPropagation();
                    selectTab(scope._tabs[e.currentTarget.tabIndex]);
                });
                function selectTab(tab) {
                    selectTabElement(tab);
                    scope.selectedTab = tab;
                    if (scope.onSelect) {
                        scope.onSelect({ tab: tab });
                    }
                }
                dataWatcher = scope.$watch("_tabs", function (tabsData) {
                    if (!tabsData) {
                        return;
                    }
                    tabsData.forEach(function (tabData, i) {
                        var tabElement = document.createElement("a");
                        tabElement.className = "tab";
                        if (selectedTab === tabData) {
                            tabElement.classList.add("selected");
                            selectedElement = tabElement;
                        }
                        tabElement.innerText = tabData.name;
                        element.append(tabElement);
                        tabElement.tabIndex = i;
                    });
                    dataWatcher();
                });
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("Fortscale").directive("dropdownMenu", ["$timeout", function ($timeout) {
            return {
                restrict: 'E',
                template: '<menu class="dropdown dropdown-directive"></menu>',
                replace: true,
                scope: {
                    items: "=",
                    params: "=",
                    onSelect: "&"
                },
                link: function postLink(scope, element) {
                    function selectMenuItem($event, item) {
                        if (!scope.onSelect) {
                            return true;
                        }
                        close();
                        scope.onSelect({ $event: $event, $item: item });
                    }
                    function renderMenu() {
                        if (!dropdownMenu) {
                            dropdownMenu = document.createElement("ul");
                            dropdownMenu.className = "dropdown-menu";
                            element.append(dropdownMenu);
                        }
                        if (!itemsRendered) {
                            scope.items.forEach(function (item, i) {
                                var listItem = document.createElement("li"), link = document.createElement("a");
                                if (item.href) {
                                    link.setAttribute("href", item.href);
                                }
                                else {
                                    link.setAttribute("data-select", i);
                                }
                                link.innerText = item.text || item.name;
                                listItem.appendChild(link);
                                dropdownMenu.appendChild(listItem);
                            });
                            itemsRendered = true;
                        }
                    }
                    function destroyMenu() {
                        dropdownMenu.parentElement.removeChild(dropdownMenu);
                        dropdownMenu = null;
                        itemsRendered = false;
                    }
                    function open(event) {
                        renderMenu();
                        dropdownMenu.style.opacity = "0";
                        buttonBoundingRect = event.currentTarget.getBoundingClientRect();
                        dropdownMenu.style.top = (buttonBoundingRect.bottom - 3) + "px";
                        dropdownMenu.style.left = buttonBoundingRect.left + "px";
                        dropdownMenu.classList.remove("rightDropdown");
                        dropdownMenu.classList.remove("topDropdown");
                        isOpen = true;
                        element.addClass("open");
                        element.removeClass("dropdown-top");
                        $timeout(function () {
                            setPosition();
                            dropdownMenu.style.opacity = "1";
                            document.body.addEventListener("mousedown", onBackgroundClick);
                            window.addEventListener("scroll", onBackgroundClick);
                        }, 50);
                    }
                    function setPosition() {
                        var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, dropdownMenuBoundingRect = dropdownMenu.getBoundingClientRect(), dropdownRight = dropdownMenuBoundingRect.right, dropdownBottom = dropdownMenuBoundingRect.bottom, marginRight = 20, marginBottom = 60;
                        if (dropdownRight > width - marginRight) {
                            dropdownMenu.style.removeProperty("left");
                            dropdownMenu.style.left = (buttonBoundingRect.right - dropdownMenuBoundingRect.width) + "px";
                            dropdownMenu.classList.add("rightDropdown");
                        }
                        if (dropdownBottom > height - marginBottom) {
                            dropdownMenu.style.removeProperty("top");
                            dropdownMenu.style.top = (buttonBoundingRect.top - dropdownMenuBoundingRect.height) + "px";
                            dropdownMenu.classList.add("topDropdown");
                            element.addClass("dropdown-top");
                            scope.isTopMenu = true;
                        }
                        else {
                            element.removeClass("dropdown-top");
                        }
                    }
                    function close() {
                        document.body.removeEventListener("mousedown", onBackgroundClick);
                        window.removeEventListener("scroll", onBackgroundClick);
                        isOpen = false;
                        element.removeClass("open");
                        element.removeClass("dropdown-top");
                        setTimeout(destroyMenu, 300);
                    }
                    function onBackgroundClick(e) {
                        if (!$(e.target).closest(".dropdown").length ||
                            $(e.target).closest(".dropdown")[0] !== element[0]) {
                            scope.$apply(close);
                        }
                        return true;
                    }
                    var dropdownMenu, buttonBoundingRect, isOpen = false, toggleButton = $('<a class="clickable dropdown-toggle hidden-phone"><b class="caret"></a>'), itemsRendered;
                    element.removeClass("open");
                    scope.$on("$destroy", function () {
                        element.off();
                        element.empty();
                    });
                    function toggle(event) {
                        if (isOpen) {
                            close();
                        }
                        else {
                            open(event);
                        }
                    }
                    element.append(toggleButton);
                    toggleButton.on("click", toggle);
                    scope.$watch("items", function (items) {
                        if (!items) {
                            return;
                        }
                        if (itemsRendered) {
                            destroyMenu();
                        }
                        renderMenu();
                    });
                    element.on("click", "[data-select]", function (e) {
                        var item = scope.items[parseInt(this.getAttribute("data-select"), 10)];
                        selectMenuItem(e, item);
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .directive("dropdownMenuDelegate", ["$timeout", "conditions", "state", function ($timeout, conditions, state) {
            return {
                restrict: 'A',
                scope: false,
                link: function postLink(scope, element, attrs) {
                    var dropdownMenu, dropdownMenuList, currentItems, itemsRendered, isOpen, isTopMenu;
                    function init() {
                        element.on("click", ".dropdown-delegate-toggle", function (e) {
                            if (dropdownMenu && this.parentNode !== dropdownMenu) {
                                closeMenu();
                            }
                            dropdownMenu = this.parentNode;
                            if (!dropdownMenu.menu) {
                                return true;
                            }
                            currentItems = dropdownMenu.menu.items;
                            toggle(e);
                        });
                        element.on("click", ".dropdown-directive .dropdown-menu-link", function (e) {
                            selectMenuItem(e, this.menuItem);
                        });
                    }
                    function renderMenu() {
                        if (!dropdownMenuList) {
                            dropdownMenuList = document.createElement("ul");
                            dropdownMenuList.className = "dropdown-menu";
                            dropdownMenu.appendChild(dropdownMenuList);
                        }
                        if (!itemsRendered) {
                            currentItems.forEach(function (item, i) {
                                var listItem = document.createElement("li"), link = document.createElement("a");
                                link.className = "dropdown-menu-link";
                                link.menuItem = item;
                                if (item.href) {
                                    link.setAttribute("href", item.href);
                                }
                                else {
                                    link.setAttribute("data-select", i);
                                }
                                link.innerText = item.text || item.name;
                                listItem.appendChild(link);
                                dropdownMenuList.appendChild(listItem);
                            });
                            itemsRendered = true;
                        }
                    }
                    function destroyMenu() {
                        dropdownMenu.removeChild(dropdownMenuList);
                        dropdownMenuList = null;
                        itemsRendered = false;
                        dropdownMenu = null;
                    }
                    function openMenu(event) {
                        renderMenu();
                        dropdownMenuList.style.opacity = "0";
                        var buttonBoundingRect = event.currentTarget.getBoundingClientRect();
                        dropdownMenuList.style.top = (buttonBoundingRect.bottom - 3) + "px";
                        dropdownMenuList.style.left = buttonBoundingRect.left + "px";
                        dropdownMenuList.classList.remove("rightDropdown");
                        dropdownMenuList.classList.remove("topDropdown");
                        isOpen = true;
                        dropdownMenu.classList.add("open");
                        dropdownMenu.classList.remove("dropdown-top");
                        document.body.addEventListener("mousedown", onBackgroundClick);
                        window.addEventListener("scroll", onBackgroundClick);
                        $timeout(function () {
                            setPosition(buttonBoundingRect);
                            dropdownMenuList.style.opacity = "1";
                        }, 1);
                    }
                    function setPosition(buttonBoundingRect) {
                        var width = document.documentElement.clientWidth, height = document.documentElement.clientHeight, dropdownMenuBoundingRect = dropdownMenuList.getBoundingClientRect(), dropdownRight = dropdownMenuBoundingRect.right, dropdownBottom = dropdownMenuBoundingRect.bottom, marginRight = 20, marginBottom = 60;
                        if (dropdownRight > width - marginRight) {
                            dropdownMenuList.style.removeProperty("left");
                            dropdownMenuList.style.left = (buttonBoundingRect.right - dropdownMenuBoundingRect.width) +
                                "px";
                            dropdownMenuList.classList.add("rightDropdown");
                        }
                        if (dropdownBottom > height - marginBottom) {
                            dropdownMenuList.style.removeProperty("top");
                            dropdownMenuList.style.top = (buttonBoundingRect.top - dropdownMenuBoundingRect.height) +
                                "px";
                            dropdownMenuList.classList.add("topDropdown");
                            dropdownMenu.classList.add("dropdown-top");
                            isTopMenu = true;
                        }
                        else {
                            dropdownMenu.classList.remove("dropdown-top");
                        }
                    }
                    function closeMenu(immediate) {
                        document.body.removeEventListener("mousedown", onBackgroundClick);
                        window.removeEventListener("scroll", onBackgroundClick);
                        isOpen = false;
                        if (dropdownMenu) {
                            dropdownMenu.classList.remove("open");
                            dropdownMenu.classList.remove("dropdown-top");
                            if (immediate) {
                                destroyMenu();
                            }
                            else {
                                setTimeout(destroyMenu, 300);
                            }
                        }
                    }
                    function toggle(event) {
                        if (isOpen) {
                            closeMenu();
                        }
                        else {
                            openMenu(event);
                        }
                    }
                    function selectMenuItem($event, item) {
                        if (!scope.menuSelect) {
                            return true;
                        }
                        closeMenu();
                        scope.menuSelect($event, item, dropdownMenu.data, dropdownMenu.menu, scope.mainDashboardParams);
                    }
                    function onBackgroundClick(e) {
                        if (!$(e.target).closest(".dropdown").length || $(e.target).closest(".dropdown")[0] !==
                            dropdownMenu) {
                            scope.$apply(closeMenu);
                        }
                        return true;
                    }
                    init();
                }
            };
        }]);
}());

(function () {
    'use strict';
    function paramControls(conditions, eventBus, utils, search, $timeout, controls, FilterValidators, popupConditions) {
        return {
            restrict: 'E',
            templateUrl: "scripts/directives/param_controls/param_controls.template.html",
            replace: true,
            scope: {
                controls: "=",
                buttons: "=",
                search: "=",
                getParams: "&",
                setParams: "&",
                ready: "=",
                classname: "@",
                widgetControlId: "@",
                widget: "=",
                controlsTitle: "@"
            },
            link: function postLink(scope) {
                var requiredParams, controlParamNames = [], changedParams = {};
                scope.renderUpdateButton = false;
                scope.$on("$destroy", function () {
                    eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
                });
                // in the cases controls selection have changed
                // load controls from control service and update the update button if needed.
                scope.$watch("controls", function (_controls) {
                    scope.controls = controls.loadControls(_controls);
                    setUpdateButton();
                    init();
                });
                scope.charEntered = function () {
                    scope.paramChange = true;
                };
                scope.onControlChange = function (control, value, label) {
                    scope.paramChange = true;
                    changedParams[control.param] = true;
                    control.value = value;
                    if (control.type === "search" && label) {
                        control.valueLabel = label;
                    }
                    setAllRequiredParamsAvailable(false);
                    setDependantControls(control, value);
                    if (control.warning) {
                        control.showWarning =
                            conditions.validateConditions(control.warning.conditions, { value: control.value });
                    }
                    if (control.autoUpdate) {
                        scope.updateParams();
                    }
                };
                scope.onControlBlur = function (control) {
                    if (!control.value && control.value !== 0 && control.default) {
                        control.value = control.default;
                    }
                };
                scope.updateParams = function () {
                    if (!scope.paramChange || !scope.paramsReadyToRun) {
                        return;
                    }
                    var params = getParamsFromControls(true);
                    var popupMessage = popupConditions.shouldNotifyPopup(params);
                    if (popupMessage !== "") {
                        bootbox.confirm({
                            message: popupMessage,
                            buttons: {
                                'cancel': {
                                    label: 'No'
                                },
                                'confirm': {
                                    label: 'Yes'
                                }
                            },
                            callback: function (result) {
                                if (result) {
                                    updateParamsAux(params);
                                }
                            }
                        });
                    }
                    else {
                        updateParamsAux(params);
                    }
                };
                function updateParamsAux(params) {
                    setAllRequiredParamsAvailable(true);
                    //if the new changed params doesn't contain a specific page but the current params does, reset the
                    // paging and go to the first page.
                    var scopeParams = scope.getParams();
                    if (scopeParams && scopeParams.page && params.urlParams && !params.urlParams.page) {
                        params.urlParams.page = 1;
                    }
                    // Timeout so the setParams runs AFTER the dashboard scope params are changed by
                    // setAllRequiredParamsAvailable. Otherwise, widgets in the dashboard that listen to changes in
                    // params/paramsReady are not updated.
                    $timeout(function () {
                        scope.setParams({ params: params.urlParams });
                        if (params.innerParams && Object.keys(params.innerParams).length) {
                            scope.setParams({ params: params.innerParams, setToUrl: false });
                        }
                    }, 1);
                    scope.paramChange = false;
                    updateButtons(angular.extend({}, params.innerParams, params.urlParams));
                    changedParams = {};
                }
                function setUpdateButton() {
                    if (scope.controls) {
                        for (var i = 0, control; !!(control = scope.controls[i]); i++) {
                            if (!control.autoUpdate && !control.hide) {
                                scope.renderUpdateButton = true;
                                return;
                            }
                        }
                    }
                    scope.renderUpdateButton = false;
                }
                function setDependantControls(srcControl, value) {
                    scope.controls.forEach(function (control) {
                        if (srcControl !== control) {
                            var dependency = control.dependencies && control.dependencies[srcControl.param];
                            if (dependency) {
                                if (control.type === "date") {
                                    if (dependency === "lesserThan") {
                                        control.maxValue =
                                            value !== undefined && value !== null ? value : control.settings.maxDate;
                                    }
                                    else if (dependency === "greaterThan") {
                                        control.minValue =
                                            value !== undefined && value !== null ? value : control.settings.minDate;
                                    }
                                }
                            }
                        }
                    });
                }
                scope.requiredValueEmpty = function (control) {
                    return (control && control.isRequired && (!control.value && control.value !== 0) && control.label);
                };
                //check if the control value is valid according to the control validator
                scope.isNotValidValue = function (control) {
                    if (control && control.filterValidator) {
                        try {
                            var validator = FilterValidators.getValidator(control.filterValidator, control.value);
                            validator.validate();
                        }
                        catch (errorMessage) {
                            return true;
                        }
                    }
                    return false;
                };
                function setAllRequiredParamsAvailable(setParamsReady) {
                    var allRequiredParamsAvailable = true, allValueParamsValid = true, requiredParamNames = [];
                    if (scope.controls) {
                        for (var i = 0, control; scope.controls[i]; i++) {
                            control = scope.controls[i];
                            //in the case the control is required check if it have value
                            if (scope.requiredValueEmpty(control)) {
                                allRequiredParamsAvailable = false;
                                requiredParamNames.push(control.label.toLowerCase());
                            }
                            //in the case the control have a validator check that the value is valid
                            if (scope.isNotValidValue(control)) {
                                allValueParamsValid = false;
                            }
                            if (control.disableConditions) {
                                control.disabled = conditions.validateConditions(control.disableConditions, getParamsFromControls().urlParams, {});
                            }
                        }
                    }
                    //uses for the ng-disable of the update button
                    scope.paramsReadyToRun = allRequiredParamsAvailable && allValueParamsValid;
                    if (setParamsReady) {
                        scope.paramsReady = allRequiredParamsAvailable && allValueParamsValid;
                    }
                    scope.requiredParamNames = scope.paramsReady ? null : utils.arrays.toSentence(requiredParamNames);
                }
                function getParamsFromControls() {
                    var params = { urlParams: {} }, widgetParams = scope.getParams();
                    if (scope.controls) {
                        scope.controls.forEach(function (control) {
                            if (control.defaultValueOnly && widgetParams[control.param]) {
                                return true;
                            }
                            var innerParam, paramValue = null;
                            if (control.settings && control.settings.useItemParams) {
                                control.settings.items.forEach(function (item) {
                                    params.urlParams[item.param] =
                                        control.value && ~control.value.indexOf(item.param) ? "true" : null;
                                });
                            }
                            else {
                                controls.getControlValue(control, widgetParams, params.urlParams);
                            }
                            if (control.value && control.valueLabel) {
                                params.urlParams[control.param + "_label"] = control.valueLabel;
                            }
                            if (control.innerParam) {
                                if (!params.innerParams) {
                                    params.innerParams = {};
                                }
                                else {
                                    innerParam = params.innerParams[control.innerParam.name];
                                }
                                var innerParamValue = getInnerParamValue(control, paramValue);
                                if (innerParam) {
                                    params.innerParams[control.innerParam.name + "_conjuction"] = "AND";
                                    if (!angular.isArray(innerParam)) {
                                        params.innerParams[control.innerParam.name] = [innerParam];
                                    }
                                    params.innerParams[control.innerParam.name].push(innerParamValue);
                                }
                                else {
                                    params.innerParams[control.innerParam.name] = innerParamValue;
                                }
                            }
                        });
                    }
                    return params;
                }
                function getInnerParamValue(control, paramValue, params) {
                    var value = control.innerParam.type && control.innerParam.type !== "equals" &&
                        (paramValue || paramValue === 0) ?
                        conditions.getParamOperator(control.innerParam.type) + paramValue : paramValue;
                    if (control.innerParam.formatParam) {
                        return utils.strings.parseValue(control.innerParam.formatParam, { value: value }, params);
                    }
                    return value;
                }
                /**
                 * Takes the current params and fills the controls values accordingly
                 */
                function setControlParams() {
                    var widgetParams = scope.getParams() || {}, innerParams = null;
                    requiredParams = {};
                    if (scope.controls) {
                        scope.controls.forEach(function (control) {
                            if (control.settings && control.settings.useItemParams) {
                                control.value = [];
                                control.settings.items.forEach(function (item) {
                                    if (widgetParams[item.param]) {
                                        control.value.push(item.param);
                                    }
                                });
                            }
                            else {
                                setParamsToControl(control, widgetParams, innerParams);
                            }
                            if (control.isRequired) {
                                requiredParams[control.param] = control.label;
                            }
                        });
                    }
                    setAllRequiredParamsAvailable(true);
                    if (innerParams) {
                        scope.setParams({ params: innerParams, setToUrl: false });
                    }
                    updateButtons(angular.extend({}, scope.getParams(), innerParams));
                }
                /**
                 * Sets the contents of a control according to the available params.
                 * @param control
                 * @param params
                 * @param innerParams
                 */
                function setParamsToControl(control, params, innerParams) {
                    var paramValue;
                    var dates;
                    if (params[control.param] || params[control.param] === 0) {
                        paramValue = params[control.param];
                    }
                    else {
                        paramValue = control.defaultValue;
                    }
                    if (paramValue || paramValue === 0) {
                        if (control.type === "date") {
                            control.value = utils.date.getMoment(paramValue) || null;
                            if (control.value) {
                                control.value = control.value.toDate();
                            }
                        }
                        else if (control.type === "dateRange") {
                            if (paramValue && typeof paramValue === "string") {
                                dates = paramValue.match(/^(\d+)\,(\d+)$/);
                            }
                            if (dates) {
                                control.value = {
                                    timeStart: utils.date.getMoment(dates[1]).toDate(),
                                    timeEnd: utils.date.getMoment(dates[2]).toDate()
                                };
                            }
                        }
                        else if (control.type === "number") {
                            control.value =
                                typeof (paramValue) === "string" ? parseInt(paramValue.match(/\d+/), 10) : paramValue;
                        }
                        else if (control.type === "boolean") {
                            control.value = paramValue !== "false";
                        }
                        else if (control.type === "search") {
                            control.value = params[control.param];
                            control.valueLabel = params[control.param + "_label"];
                        }
                        else {
                            control.value = paramValue;
                        }
                        if (control.innerParam) {
                            if (!innerParams) {
                                innerParams = {};
                            }
                            var innerParam = innerParams[control.innerParam.name];
                            if (!innerParam) {
                                innerParam = innerParams[control.innerParam.name] = [];
                            }
                            else {
                                innerParams[control.innerParam.name + "_conjuction"] = "AND";
                            }
                            innerParam.push(getInnerParamValue(control, paramValue, params));
                        }
                    }
                }
                function onParamsChange(e, changedParams) {
                    if (utils.objects.containsAnyParam(changedParams, controlParamNames)) {
                        scope.$broadcast("packageParamsChange", changedParams);
                    }
                    updateButtons(scope.getParams());
                    setControlParams();
                }
                var buttonsUpdateFunctions = {
                    link: function (button, data, params) {
                        button.settings.href = utils.strings.parseValue(button.settings.url, data, params);
                        button.settings.parsedText = utils.strings.parseValue(button.settings.text, data, params);
                    },
                    multiLink: function (button, data, params) {
                        button.settings.links.forEach(function (link) {
                            link.href = utils.url.escapeUrl(utils.strings.parseValue(link.url, data, params));
                            link.parsedText = utils.strings.parseValue(link.text, data, params);
                        });
                    }
                };
                function updateButtons(params) {
                    if (!scope.buttons || !scope.buttons.length) {
                        return;
                    }
                    var urlParams = [], paramValue, linkParams;
                    function populateUrlParam(d) {
                        if (d) {
                            urlParams.push(paramName + "=" + encodeURIComponent(d));
                        }
                    }
                    for (var paramName in params) {
                        if (params.hasOwnProperty(paramName)) {
                            paramValue = params[paramName];
                            if (angular.isArray(paramValue)) {
                                paramValue.forEach(populateUrlParam);
                            }
                            else if (paramValue) {
                                urlParams.push(paramName + "=" + encodeURIComponent(paramValue));
                            }
                        }
                    }
                    var controlParams = getParamsFromControls();
                    linkParams = angular.extend(controlParams.urlParams, controlParams.innerParams, params);
                    scope.buttons.forEach(function (button) {
                        button._show =
                            !button.requiredParams || utils.objects.containsAllParams(params, button.requiredParams);
                        var updater = buttonsUpdateFunctions[button.type];
                        if (updater) {
                            updater(button, { params: urlParams.join("&") }, linkParams);
                        }
                    });
                }
                function setSearchSettings(control) {
                    // if this is the second time for this control, we already binded the search function
                    if (typeof (control.settings.search) === "function") {
                        return;
                    }
                    if (!control.settings || !control.settings.search) {
                        throw new Error("Can't set search for control, missing the search object.");
                    }
                    if (Object(control.settings.search) !== control.settings.search) {
                        throw new TypeError("Invalid search settings for control, expected an object but got " +
                            control.settings.search + ".");
                    }
                    if (!control.settings.search.dataEntity || !control.settings.search.dataEntityField) {
                        throw new Error("Can't set search for control, both settings.search.dataEntity and " +
                            "settings.search.dataEntityField properties are required.");
                    }
                    /* jshint validthis: true */
                    if (control.settings.search) {
                        control.settings.search =
                            search.searchDataEntityField.bind(this, control.settings.search.dataEntity, control.settings.search.dataEntityField, control.settings.search.labelField, control.settings.search.extraTerms);
                    }
                }
                function init() {
                    if (scope.search) {
                        setSearchSettings(scope.search);
                    }
                    eventBus.subscribe("dashboardParamsChange", onParamsChange);
                    if (scope.controls) {
                        setControlParams();
                        scope.controls.forEach(function (control) {
                            if (control.type === "search") {
                                setSearchSettings(control);
                            }
                        });
                        scope.controls.forEach(function (control) {
                            controlParamNames.push(control.param);
                        });
                        setAllRequiredParamsAvailable();
                        getParamsFromControls();
                    }
                    else {
                        scope.paramsReady = true;
                        scope.paramsReadyToRun = true;
                        updateButtons(scope.getParams());
                    }
                }
            }
        };
    }
    paramControls.$inject =
        ["conditions", "eventBus", "utils", "search", "$timeout", "controls", "FilterValidators",
            "popupConditions"];
    angular.module("Fortscale").directive("paramControls", paramControls);
})();

(function () {
    'use strict';
    angular.module("Fortscale").directive("checklist", [function () {
            return {
                restrict: 'E',
                templateUrl: "scripts/directives/checklist/checklist.template.html",
                replace: true,
                require: '?ngModel',
                scope: {
                    items: "=",
                    _onChange: "&onChange",
                    defaultValue: "=",
                    allowNone: "=",
                    useItemParams: "="
                },
                link: function postLink(scope, element, attrs, ngModel) {
                    ngModel.$render = function () {
                        if (!ngModel.$viewValue) {
                            return;
                        }
                        var selectedItemsValues = ngModel.$viewValue || [];
                        if (typeof (selectedItemsValues) === "string") {
                            selectedItemsValues = selectedItemsValues.split(",");
                        }
                        scope.items.forEach(function (item) {
                            item.checked = !!~selectedItemsValues.indexOf(scope.useItemParams ? item.param : item.value);
                        });
                    };
                    scope.$watch("items", function (items) {
                        items.forEach(function (item) {
                            if (item.checked === undefined) {
                                item.checked = !!scope.defaultValue;
                            }
                        });
                    });
                    scope.selectAll = function () {
                        scope.items.forEach(function (item) {
                            item.checked = true;
                        });
                        scope.onChange();
                    };
                    scope.selectNone = function () {
                        scope.items.forEach(function (item) {
                            item.checked = false;
                        });
                        scope.onChange();
                    };
                    scope.onChange = function () {
                        var selectedItemsValues = [], allSelected = true;
                        scope.items.forEach(function (_item) {
                            if (_item.checked) {
                                selectedItemsValues.push(scope.useItemParams ? _item.param || _item.value : _item.value);
                            }
                            else {
                                allSelected = false;
                            }
                        });
                        if (!selectedItemsValues.length) {
                            selectedItemsValues = null;
                        }
                        ngModel.$setViewValue(selectedItemsValues, scope);
                        if (scope._onChange) {
                            scope._onChange(selectedItemsValues);
                        }
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .directive("dropdownNoclose", [function dropdownNoCloseDirective() {
            return {
                restrict: 'AC',
                link: function postLink(scope, element, attrs) {
                    element.on("click", function (e) {
                        e.stopPropagation();
                    });
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").directive("buttonSelect", [function () {
            return {
                restrict: 'E',
                templateUrl: "scripts/directives/button_select/button_select.template.html",
                replace: true,
                require: '?ngModel',
                scope: {
                    "buttons": "="
                },
                link: function postLink(scope, element, attrs, ngModel) {
                    function setSelectedButton() {
                        if (!scope.buttons) {
                            return;
                        }
                        scope.buttons.forEach(function (button) {
                            button.selected = String(ngModel.$viewValue) === String(button.value);
                            if (button.selected) {
                                selectedButton = button;
                            }
                        });
                    }
                    var selectedButton;
                    ngModel.$render = setSelectedButton;
                    scope.$watch("buttons", setSelectedButton);
                    scope.selectButton = function (button) {
                        if (button === selectedButton) {
                            return false;
                        }
                        if (selectedButton) {
                            selectedButton.selected = false;
                        }
                        selectedButton = button;
                        button.selected = true;
                        ngModel.$setViewValue(button.value, scope);
                    };
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("NumbersOnlyModule", []).directive("numbersOnly", function () {
        return {
            restrict: "A",
            require: 'ngModel',
            link: function ($scope, element, $attrs, ngModelCtrl) {
                ngModelCtrl.$parsers.push(function (inputValue) {
                    if (inputValue === undefined) {
                        return '';
                    }
                    var transformedInput = inputValue.replace(/[^\d.]/g, '');
                    if (transformedInput !== inputValue) {
                        ngModelCtrl.$setViewValue(transformedInput);
                        ngModelCtrl.$render();
                    }
                    return transformedInput;
                });
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("DurationOnlyModule", []).directive("durationOnly", function () {
        return {
            restrict: "A",
            require: 'ngModel',
            link: function ($scope, element, $attrs, ngModelCtrl) {
                //allows to enter the input field only digits and ':' - to support the format hh:mm:ss
                ngModelCtrl.$parsers.push(function (inputValue) {
                    if (inputValue === undefined) {
                        return '';
                    }
                    var transformedInput = inputValue.replace(/[^\d:]/g, '');
                    if (transformedInput !== inputValue) {
                        ngModelCtrl.$setViewValue(transformedInput);
                        ngModelCtrl.$render();
                    }
                    return transformedInput;
                });
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("NumberRangeModule", ["NumbersOnlyModule"]).directive("numberRange", function () {
        return {
            restrict: "E",
            templateUrl: "scripts/directives/number_range/number_range_template.html",
            replace: true,
            require: "?ngModel",
            scope: {
                minVal: '=',
                maxVal: '='
            },
            link: function ($scope, element, attrs, ngModelCtrl) {
                function initScopeVars() {
                    $scope.minPlaceholderValue = $scope.minVal ? "> " + $scope.minVal : "From";
                    $scope.maxPlaceholderValue = $scope.maxVal ? "< " + $scope.maxVal : "To";
                }
                ngModelCtrl.$render = function () {
                    $scope.value = angular.copy(ngModelCtrl.$viewValue);
                };
                initScopeVars();
                $scope.validateInput = function () {
                    ngModelCtrl.$setViewValue(angular.copy($scope.value));
                };
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("StringInModule", []).directive("stringIn", function () {
        return {
            restrict: "E",
            templateUrl: "scripts/directives/in_operator/string_in_template.html",
            replace: true,
            require: "?ngModel",
            scope: {
                inValues: '=ngModel',
                isSearchable: '=',
                searchSettings: '='
            },
            link: function ($scope) {
                function initValues() {
                    for (var i = 0; i < $scope.inValues.length; i++) {
                        var val = $scope.inValues[i];
                        $scope.vals.push({ enabled: true, val: val });
                    }
                }
                function isInValExist(val) {
                    for (var i = 0; i < $scope.vals.length; i++) {
                        if ($scope.vals[i].val === val) {
                            return true;
                        }
                    }
                    return false;
                }
                function getAllEnabledValues() {
                    var arr = [];
                    for (var i = 0; i < $scope.vals.length; i++) {
                        var stringInVal = $scope.vals[i];
                        if (stringInVal.enabled) {
                            arr.push(stringInVal.val);
                        }
                    }
                    return arr;
                }
                $scope.vals = [];
                if ($scope.inValues) {
                    initValues();
                }
                $scope.onStringInEnter = function (event) {
                    if (event.which === 13) {
                        var element = angular.element(event.target);
                        var val = element.val();
                        if (val && !isInValExist(val)) {
                            $scope.vals.push({ enabled: true, val: val });
                            $scope.inValues = getAllEnabledValues();
                        }
                        element.val("");
                        event.preventDefault();
                    }
                };
                $scope.onStringInSearchSelect = function ($value) {
                    if ($value && !isInValExist($value)) {
                        $scope.vals.push({ enabled: true, val: $value });
                        $scope.inValues = getAllEnabledValues();
                    }
                };
                $scope.removeStringInVal = function (val, index) {
                    $scope.vals.splice(index, 1);
                    $scope.inValues = getAllEnabledValues();
                };
                $scope.onCheckboxClick = function () {
                    $scope.inValues = getAllEnabledValues();
                };
            }
        };
    });
}());

(function () {
    'use strict';
    angular.module("Fortscale")
        .filter('dataFieldType', function () {
        return function (fields, dataFieldType) {
            if (!dataFieldType) {
                return fields;
            }
            var filteredFields = [];
            angular.forEach(fields, function (field) {
                if (field.type === dataFieldType) {
                    filteredFields.push(field);
                }
            });
            return filteredFields;
        };
    });
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("GeoHoppingPackageController", ["$scope", "$timeout", "geoHopping", "eventBus", "state", "utils",
        function ($scope, $timeout, geoHopping, eventBus, state, utils) {
            function destroy() {
                state.onStateChange.unsubscribe(setEvents);
            }
            function setEvents(e, data) {
                if (data && data.params && (data.params.subDashboardId || data.params.dashboardId)) {
                    destroy();
                    return;
                }
                $timeout.cancel(getDataTimeout);
                getDataTimeout = $timeout(function () {
                    if ($scope.widget.parent) {
                        var params = utils.objects.extend({}, state.currentParams, $scope.widget.parent.getState());
                        $scope.$parent.packageLoading = true;
                        $scope.widget.isLoading = true;
                        geoHopping.getUserEvents(params.notifications_events_dates &&
                            params.notifications_events_dates.split(",")[0], params.notifications_events_dates && params.notifications_events_dates.split(",")[1], params.user).then(function (userEvents) {
                            $scope.userEvents = userEvents;
                            $scope.usersTitle = "user";
                            $scope.isMultipleUsers = false;
                            if ($scope.userEvents && $scope.userEvents.length) {
                                var userCount = parseInt($scope.userEvents.length);
                                if (!isNaN(userCount) && userCount > 1) {
                                    $scope.usersTitle = userCount + " users";
                                    $scope.isMultipleUsers = true;
                                }
                            }
                            $scope.showAllUsers();
                            $scope.widget.isLoading = false;
                            $scope.widget.error = null;
                        }, function () {
                            $scope.widget.loading = false;
                            $scope.widget.error = "Error getting geo hopping data from server.";
                        });
                    }
                }, 200);
            }
            function init() {
                setEvents();
                state.onStateChange.subscribe(setEvents);
            }
            var getDataTimeout;
            $scope.graphSettings = geoHopping.graphSettings;
            $scope.view = {
                "type": "table",
                settings: geoHopping.tableSettings
            };
            $scope.$on("$destroy", destroy);
            $scope.$on("refresh", function () {
                setEvents();
            });
            $scope.showUser = function (user) {
                if (user) {
                    geoHopping.getTableData($scope.view, user.events, state.currentParams).then(function (tableData) {
                        $scope.view.data = tableData;
                    });
                    $scope.currentGeoHoppingUser = user;
                }
                else {
                    $scope.showAllUsers();
                }
            };
            $scope.showAllUsers = function () {
                var allEvents = [];
                $scope.userEvents.forEach(function (user) {
                    allEvents = allEvents.concat(user.events);
                });
                $scope.currentGeoHoppingUser =
                    { name: $scope.userEvents.length === 1 ? $scope.userEvents[0].name : "All Users" };
                geoHopping.getTableData($scope.view, allEvents, state.currentParams).then(function (tableData) {
                    $scope.view.data = tableData;
                });
            };
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").factory("geoHopping", ["securityFeed", "utils", "widgetViews", function (securityFeed, utils, widgetViews) {
            return {
                get graphSettings() {
                    return {
                        "value": "date_time",
                        "unique": "id",
                        "label": "name",
                        "eventLabelField": "country",
                        "scales": {
                            x: {
                                type: "time"
                            }
                        },
                        axes: {
                            x: {
                                type: "time",
                                label: "VPN Events Time"
                            }
                        },
                        options: {
                            margins: {
                                top: 0,
                                left: 0,
                                right: 5,
                                bottom: 0
                            }
                        },
                        eventTooltip: "{{city}}, {{country}} @ {{date_time:date}}"
                    };
                },
                get tableSettings() {
                    return {
                        fields: [
                            {
                                name: "Username",
                                value: "{{username}}",
                                link: "#/d/explore/vpn?filters=vpn.username%3D{{username}}",
                                externalLinks: [{
                                        url: "#/user/{{userId}}/user_overview",
                                        icon: "user",
                                        tooltip: "Go to {{username}}'s page"
                                    }]
                            },
                            {
                                name: "Source",
                                value: "{{source_ip}}",
                                link: "#/d/explore/vpn?filters=vpn.source_ip%3D{{source_ip}}"
                            },
                            {
                                name: "Country",
                                value: "{{country}}",
                                link: "#/d/explore/vpn?filters=vpn.country%3D{{country}}"
                            },
                            {
                                name: "City",
                                value: "{{city}}",
                                link: "#/d/explore/vpn?filters=vpn.city%3D{{city}}"
                            },
                            {
                                name: "Time",
                                value: "{{date_time:date}}"
                            }
                        ]
                    };
                },
                getUserEvents: function (start, end, userId) {
                    return securityFeed.getNotifications({
                        after: start,
                        before: end,
                        userIds: userId,
                        types: "VpnGeoHoppingNotificationGenerator"
                    }).then(function (notifications) {
                        var userEventsIndex = {}, userEvents = [];
                        notifications.forEach(function (notification) {
                            var user = userEventsIndex[notification.userid];
                            if (!user) {
                                user = userEventsIndex[notification.userid] =
                                    { name: notification.username, id: notification.userid, events: [] };
                            }
                            user.events.push({
                                date_time: utils.date.getMoment(notification.event_time_utc).toDate(),
                                country: utils.strings.capitalize(notification.country),
                                city: utils.strings.capitalize(notification.city),
                                source_ip: notification.source_ip,
                                username: notification.username,
                                local_ip: notification.local_ip,
                                id: notification.id,
                                userId: notification.userid
                            });
                        });
                        for (var userId in userEventsIndex) {
                            if (userEventsIndex.hasOwnProperty(userId)) {
                                userEvents.push(userEventsIndex[userId]);
                            }
                        }
                        return userEvents;
                    });
                },
                getTableData: function (_view, data, params, rawData) {
                    data = _.uniq(data, 'id');
                    return widgetViews.parseViewData(_view, data, params, rawData);
                }
            };
        }]);
}());

(function () {
    'use strict';
    angular.module("TabsWidget", ["Utils", "Styles", "Widgets"]).run(["utils", "styles", "widgetViews",
        function (utils, styles, widgetViews) {
            function tabsDataParser(view, data, params) {
                var viewData;
                if (view.settings.tab) {
                    viewData = [];
                    angular.forEach(data, function (item, itemIndex) {
                        var itemData = {};
                        itemData.display = utils.strings.parseValue(view.settings.tab.display, item, params, itemIndex);
                        itemData.id = utils.strings.parseValue(view.settings.tab.id, item, params, itemIndex);
                        if (view.settings.tab.style) {
                            styles.getStyle(view.settings.tab, item).then(function (style) {
                                itemData.style = style;
                            });
                        }
                        if (view.settings.label) {
                            itemData.label = {
                                value: utils.strings.parseValue(view.settings.label.value, item, params, itemIndex)
                            };
                            if (view.settings.label.style) {
                                styles.getStyle(view.settings.label, item).then(function (style) {
                                    itemData.label.style = style;
                                });
                            }
                        }
                        viewData.push(itemData);
                    });
                }
                else if (view.settings.tabs) {
                    viewData = view.settings.tabs;
                }
                return viewData;
            }
            widgetViews.registerView("tabs", { dataParser: tabsDataParser });
        }]);
}());

(function () {
    'use strict';
    angular.module("Fortscale").controller("TabsWidgetController", ["$scope", "eventBus", "dashboards", "events", "state", function ($scope, eventBus, dashboards, events, state) {
            var selectedDashboardParam;
            $scope.dashboard = null;
            $scope.$on("$destroy", function () {
                eventBus.unsubscribe("dashboardParamsChange", onParamsChange);
            });
            $scope.initDashboardForAtab = function (tab) {
                if (tab.dashboard) {
                    $scope.dashboard = dashboards.createDashboard(tab.dashboard);
                }
            };
            $scope.selectTab = function (tab, tabIndex, isDefaultTab) {
                if (!setCurrentTab(tabIndex)) {
                    return;
                }
                else if (tab.dashboardId) {
                    dashboards.getDashboardById(tab.dashboardId).then(function (dashboard) {
                        tab.dashboard = $scope.dashboard = dashboard;
                    });
                }
                if ($scope.view.settings.events) {
                    angular.forEach($scope.view.settings.events, function (eventSettings) {
                        if (eventSettings.eventName === "select") {
                            var eventSettingsCopy = angular.copy(eventSettings);
                            if (isDefaultTab && eventSettingsCopy.actionOptions) {
                                eventSettingsCopy.actionOptions.updateUrl = false;
                            }
                            events.triggerDashboardEvent(eventSettingsCopy, tab, state.currentParams);
                        }
                    });
                }
                if ($scope.view.settings.onSelect) {
                    $scope.view.settings.onSelect(tab);
                }
            };
            function setCurrentTabFromDashboardParam() {
                var currentlySelectedTab = $scope.getWidgetParams()[selectedDashboardParam];
                if (currentlySelectedTab) {
                    var tabToSelect = findTab(currentlySelectedTab);
                    if (tabToSelect) {
                        if (setCurrentTab(tabToSelect.tabIndex)) {
                            return true;
                        }
                        else {
                            return -1;
                        }
                    }
                }
                return false;
            }
            function onParamsChange(e, changedParams) {
                if (changedParams[selectedDashboardParam]) {
                    var tabToSelect = findTab(changedParams[selectedDashboardParam]);
                    if (tabToSelect) {
                        setCurrentTab(tabToSelect.tabIndex);
                    }
                    else {
                        $scope.currentTab = null;
                        $scope.currentTabIndex = null;
                    }
                }
            }
            function init() {
                var selectedMatch;
                if ($scope.view.settings.tab && $scope.view.settings.tab.selected) {
                    selectedMatch = $scope.view.settings.tab.selected.match(/^@(.*)$/);
                    if (selectedMatch) {
                        selectedDashboardParam = selectedMatch[1];
                        eventBus.subscribe("dashboardParamsChange", onParamsChange);
                    }
                    else {
                        console.error("Invalid selected property for tabs - " +
                            "must be a dashboard param and start with '@'.");
                    }
                }
                else if ($scope.view.settings.tabs && $scope.view.settings.selectedTabId) {
                    selectedMatch = $scope.view.settings.selectedTabId.match(/^@(.*)$/);
                    if (selectedMatch) {
                        selectedDashboardParam = selectedMatch[1];
                    }
                }
                $scope.$on("onWidgetData", function () {
                    if ($scope.view.data) {
                        setCurrentTabFromDashboardParam();
                    }
                });
                if (!setCurrentTabFromDashboardParam()) {
                    selectFirstTab();
                }
                if ($scope.view.settings.refreshOn) {
                    angular.forEach($scope.view.settings.refreshOn, function (refreshParam) {
                        $scope.$on("dashboardParamsChange", function (e, changedParams) {
                            if (changedParams[refreshParam]) {
                                setCurrentTabFromDashboardParam();
                            }
                        });
                    });
                }
            }
            function selectFirstTab() {
                if ($scope.view.settings.tabs && $scope.view.settings.tabs.length) {
                    $scope.selectTab($scope.view.settings.tabs[0], 0, true);
                }
                else if ($scope.view.settings.tab && $scope.view.data && $scope.view.data.length) {
                    $scope.selectTab($scope.view.data[0], 0, true);
                }
            }
            function setCurrentTab(tabIndex) {
                if (tabIndex !== $scope.currentTabIndex && $scope.view.data) {
                    $scope.currentTab = $scope.view.data[tabIndex];
                    $scope.initDashboardForAtab($scope.currentTab);
                    $scope.currentTabIndex = tabIndex;
                    return true;
                }
                return false;
            }
            function findTab(id) {
                if (!id || !$scope.view.data) {
                    return null;
                }
                for (var i = 0, tab; !!(tab = $scope.view.data[i]); i++) {
                    if (tab.id === id) {
                        return { tab: tab, tabIndex: i };
                    }
                }
                return null;
            }
            init();
        }]);
}());

(function () {
    'use strict';
    angular.module("Loader", ["DataEntities", "Controls", 'Fortscale.shared.services.assert', "Fortscale.remoteAppConfig"])
        .run(["dataEntities", "controls", "remoteAppConfig", "$q",
        function (dataEntities, controls, remoteAppConfig, $q) {
            // If last login was more then an hour ago
            var lastLoginTime = parseInt(localStorage.getItem('last-login-time'), 10);
            if (lastLoginTime && lastLoginTime + (1000 * 60 * 60) < Date.now().valueOf()) {
                // If there is session login then do nothing. http-request-interceptor will do
                // what needs to be done. If no session login, go to login.
                var sessionLogin = sessionStorage.getItem('session-login');
                if (!sessionLogin) {
                    window.location.href = 'signin.html?redirect=' +
                        encodeURIComponent(document.location.hash);
                    return;
                }
            }
            var initPromises = [dataEntities.initEntities(), controls.initControls(),
                remoteAppConfig.initRemoteAppConfig()];
            // After all pre loaded resources were loaded will start the Fortscale application
            $q.all(initPromises).then(function () {
                angular.element(document).ready(function () {
                    angular.bootstrap(document, ["Fortscale"]);
                });
            });
        }]);
}());

(function () {
    'use strict';
    angular.module('Config')
        .constant('BASE_URL', '/fortscale-webapp/api')
        .constant('BASE_WEBSOCKET_URL', '/fortscale-webapp');
}());

(function () {
    'use strict';
    /**
     *
     * @param {string} id
     * @param {string} displayName
     * @param {string} displayChar
     * @param {string} color
     * @param {Array<number>} scoreRange
     * @constructor
     */
    function Severity(id, displayName, displayChar, color, scoreRange) {
        this.id = id;
        this.displayName = displayName;
        this.displayChar = displayChar;
        this.color = color;
        this.scoreRange = scoreRange;
    }
    var SEVERITIES;
    /**
     *
     * @param {string} id
     * @returns {Severity || null}
     */
    function getById(id) {
        var severity = _.filter(SEVERITIES, { id: id });
        return severity ? severity[0] : null;
    }
    /**
     *
     * @param {number} score
     * @returns {Severity || null}
     */
    function getByScore(score) {
        var severity = _.filter(SEVERITIES, function (severity) {
            return score >= severity.scoreRange[0] && score <= severity.scoreRange[1];
        });
        return severity ? severity[0] : null;
    }
    function getList() {
        return _.map(SEVERITIES);
    }
    SEVERITIES = [
        new Severity('critical', 'Critical', 'C', '#F36F63', [90, 100]),
        new Severity('high', 'High', 'H', '#E99848', [75, 89]),
        new Severity('medium', 'Medium', 'M', '#F2C446', [50, 74]),
        new Severity('low', 'Low', 'L', '#B0C75E', [0, 49])
    ];
    SEVERITIES.getById = getById;
    SEVERITIES.getByScore = getByScore;
    SEVERITIES.getList = getList;
    angular.module('Config')
        .constant('SEVERITIES', SEVERITIES);
}());

(function () {
    'use strict';
    angular.module('Config')
        .constant('VERSION_NUMBER', '3.0.0')
        .constant('VERSION_YEAR', '2017')
        .constant('VERSION_COMPANY', 'Fortscale User Behavior Analytics');
}());

(function () {
    'use strict';
    /**
     * Factory restangular.adapters.dataQueryAdapter
     * returns a function that is an adapter for data returned from Fortscale's dataQuery api
     *
     * @returns {Function}
     * @constructor
     */
    function DataAdapters() {
        var provider = this;
        provider._errorMsg = 'restangular.dataAdapters: ';
        /**
         * Takes a data object (returned by Fortscale's dataQuery api) and converts it to a
         * generalized object schema where the main object holds the data,
         * and it has a _meta property holding all meta data
         *
         * @param {object} data
         * @returns {object}
         */
        provider.processDataQuery = function (data) {
            // Validations (not using assert because its a provider)
            if (!(data && angular.isDefined(data.data))) {
                throw new ReferenceError(provider._errorMsg +
                    'provided data argument must have a "data" property.');
            }
            if (!angular.isObject(data.data)) {
                throw new TypeError(provider._errorMsg +
                    'provided data argument\'s "data" property must be an object.');
            }
            // Set the 'actual' data as the primary object
            var transformedData = data.data;
            // Create a _meta object for holding meta data
            transformedData._meta = {};
            // Iterate through all keys on the data and attach them to _meta object (expect for
            // 'data' key which is already the primary object
            _.each(data, function (value, key, obj) {
                if (key !== 'data') {
                    transformedData._meta[key] = value;
                }
            });
            // Return the transformed data object
            return transformedData;
        };
        /**
         * Takes a data object (returned by Fortscale's rest api) and converts it to a
         * generalized object schema where the main object holds the data,
         * and it has a _meta property holding all meta data
         *
         * @param {object} data
         * @returns {object}
         */
        provider.processRest = function (data) {
            // Validations (not using assert because its a provider)
            if (!(data && angular.isDefined(data.data))) {
                throw new ReferenceError(provider._errorMsg +
                    'provided data argument must have an "data" property.');
            }
            if (!angular.isObject(data.data)) {
                throw new TypeError(provider._errorMsg +
                    'provided data._embedded argument\'s "data" property must be an object.');
            }
            // Set the 'actual' data as the primary object
            var transformedData = data.data;
            // Create a _meta object for holding meta data
            transformedData._meta = {};
            // Iterate through all keys on the data and attach them to _meta object (expect for
            // 'data' key which is already the primary object
            _.each(data, function (value, key, obj) {
                if (key !== 'data') {
                    transformedData._meta[key] = value;
                }
            });
            // Return the transformed data object
            return transformedData;
        };
        /*
        The $get is an angular convention, and is !required! when creating a provider.
         */
        provider.$get = [function () {
                throw new Error(provider._errorMsg +
                    'This provider is only supposed to be consumed in config phase.');
            }];
    }
    function restangularConfig(BASE_URL, RestangularProvider, dataAdaptersProvider) {
        // Set base url
        RestangularProvider.setBaseUrl(BASE_URL);
        // Add response interceptor
        // This is uses to 'iron-out' the response coming from different sources and having
        // different schemas
        RestangularProvider.addResponseInterceptor(function (data, operation, entity) {
            if (entity === 'dataQuery') {
                return dataAdaptersProvider.processDataQuery(data);
            }
            else {
                return dataAdaptersProvider.processRest(data);
            }
        });
    }
    restangularConfig.$inject = [
        'BASE_URL',
        'RestangularProvider',
        'restangular.dataAdaptersProvider'
    ];
    angular.module('Fortscale')
        .provider('restangular.dataAdapters', DataAdapters)
        .config(restangularConfig);
}());

(function () {
    'use strict';
    var defaultLang = 'en_US';
    angular.module('Fortscale')
        .config(['$translateProvider', function ($translateProvider) {
            $translateProvider.useLoader('customAngularTranslateLoader');
            $translateProvider.preferredLanguage('en');
        }]);
    /**
     * Factory for $translateProvider to load the messages from rest API
     */
    function CustomAngularTranslateLoaderFactory($http, BASE_URL, $q) {
        /**
         * This method fetch the messages from the RestAPI and return manipulated messages object to translateProvider
         */
        function customAngularTranslateLoader(options) {
            return $http({
                method: 'GET',
                url: BASE_URL + '/messages/' + defaultLang //Use for real messages from server (/api/messages/lang)
            }).then(function (response) {
                return response.data.data;
            }, function () {
                return options.key;
            });
        }
        return customAngularTranslateLoader;
    }
    CustomAngularTranslateLoaderFactory.$inject = ['$http', 'BASE_URL', '$q'];
    angular.module('Fortscale')
        .factory('customAngularTranslateLoader', CustomAngularTranslateLoaderFactory);
}());

(function () {
    'use strict';
    var remoteConfigList = null;
    var restPath = 'application_configuration';
    function RemoteAppConfigProvider() {
        var provider = this;
        /**
         * Change the REST path in config phase.
         *
         * @param _restPath
         */
        provider.changeRestPath = function (_restPath) {
            restPath = _restPath;
        };
        function RemoteAppConfigFactory(assert, BASE_URL, $http) {
            var remoteConfigApi;
            /**
             * Returns the REST url
             *
             * @returns {string}
             * @private
             */
            function _getUrl() {
                return BASE_URL + '/' + restPath;
            }
            /**
             * This is used by the Loader module. It loads the remote configuration and stores in remoteConfigList
             *
             * @returns {Promise.<T>|*}
             */
            function initRemoteAppConfig() {
                return $http.get(remoteConfigApi._getUrl())
                    .then(function (res) {
                    remoteConfigList = res.data.data;
                })
                    .catch(function (err) {
                    console.error('Remote configuration could not be loaded due to an http error.');
                    console.error(err);
                    remoteConfigList = {};
                });
            }
            /**
             * Returns a duplicated list of remote config list.
             *
             * @returns {Array<{key: string, value: string}>}
             */
            function getRemoteConfigList() {
                return _.map(remoteConfigList, function (configurationItem) {
                    return _.merge({}, configurationItem);
                });
            }
            /**
             *
             * @param {Array<{key: string, value: string}>} configItemsList
             * @returns {HttpPromise}
             */
            function updateConfigItems(configItemsList) {
                return $http.post(remoteConfigApi._getUrl(), {
                    items: configItemsList
                });
            }
            remoteConfigApi = {
                _getUrl: _getUrl,
                initRemoteAppConfig: initRemoteAppConfig,
                getRemoteConfigList: getRemoteConfigList,
                updateConfigItems: updateConfigItems
            };
            return remoteConfigApi;
        }
        provider.$get = [
            'assert', 'BASE_URL', '$http',
            RemoteAppConfigFactory
        ];
    }
    RemoteAppConfigProvider.$inject = [];
    angular.module('Fortscale.remoteAppConfig', [])
        .provider('remoteAppConfig', RemoteAppConfigProvider);
}());

var Fortscale;
(function (Fortscale) {
    var appConfigProvider;
    (function (appConfigProvider) {
        var configContainerProvider;
        (function (configContainerProvider) {
            var ConfigContainer = (function () {
                function ConfigContainer(id, displayName, description, parent, configurable, allowUpsert) {
                    this.id = id;
                    this.displayName = displayName;
                    this.description = description;
                    this.parent = parent;
                    this.configurable = configurable;
                    this.allowUpsert = allowUpsert;
                }
                return ConfigContainer;
            }());
            configContainerProvider.ConfigContainer = ConfigContainer;
            var ConfigContainerProvider = (function () {
                function ConfigContainerProvider(assert) {
                    this.assert = assert;
                    this.$get = [function () {
                            throw new Error('ConfigContainerProvider works only as a provider and not as a service');
                        }];
                }
                /**
                 * factory method for ConfigContainer
                 * @param configContainerData
                 * @returns {Fortscale.appConfig.ConfigContainer.ConfigContainer}
                 */
                ConfigContainerProvider.prototype.createContainer = function (configContainerData) {
                    // Validations
                    this.assert.isString(configContainerData.id, 'id', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configContainerData.displayName, 'displayName', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configContainerData.description, 'description', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configContainerData.parent, 'parent', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    var id = configContainerData.id;
                    var displayName = configContainerData.displayName;
                    var description = configContainerData.description;
                    var parent = ConfigContainerProvider._getParent(configContainerData.parent, id);
                    var configurable = typeof configContainerData.configurable === 'undefined' ? true :
                        !!configContainerData.configurable;
                    var allowUpsert = !!configContainerData.allowUpsert;
                    return new ConfigContainer(id, displayName, description, parent, configurable, allowUpsert);
                };
                ConfigContainerProvider._getParent = function (parent, id) {
                    if (!parent) {
                        parent = null;
                        var nameSpaceNodes = id.split(appConfigProvider.NAMESPACE_DELIMITER);
                        nameSpaceNodes.pop();
                        if (nameSpaceNodes.length) {
                            parent = nameSpaceNodes.join(appConfigProvider.NAMESPACE_DELIMITER);
                        }
                    }
                    return parent;
                };
                ConfigContainerProvider.$inject = ['assertConstant'];
                return ConfigContainerProvider;
            }());
            configContainerProvider.ConfigContainerProvider = ConfigContainerProvider;
            angular.module('Fortscale.appConfig.ConfigContainer', ['Fortscale.shared.services.assert'])
                .provider('Fortscale.appConfig.ConfigContainer', ConfigContainerProvider);
        })(configContainerProvider = appConfigProvider.configContainerProvider || (appConfigProvider.configContainerProvider = {}));
    })(appConfigProvider = Fortscale.appConfigProvider || (Fortscale.appConfigProvider = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var appConfigProvider;
    (function (appConfigProvider) {
        var configItemProvider;
        (function (configItemProvider) {
            var ConfigItem = (function () {
                function ConfigItem(id, containerId, description, displayName, type, validators, formatter, value, _originalValue, meta) {
                    this.id = id;
                    this.containerId = containerId;
                    this.description = description;
                    this.displayName = displayName;
                    this.type = type;
                    this.validators = validators;
                    this.formatter = formatter;
                    this.value = value;
                    this._originalValue = _originalValue;
                    this.meta = meta;
                }
                return ConfigItem;
            }());
            configItemProvider.ConfigItem = ConfigItem;
            var ConfigItemProvider = (function () {
                function ConfigItemProvider(assert) {
                    this.assert = assert;
                    this.$get = [function () {
                            throw new Error('ConfigItemProvider works only as a provider and not as a service');
                        }];
                }
                ConfigItemProvider.prototype._getContainerId = function (containerId, id) {
                    if (!containerId) {
                        var nameSpaceNodes = id.split(appConfigProvider.NAMESPACE_DELIMITER);
                        // Make sure there are at least two nodes
                        this.assert((nameSpaceNodes.length >= 2), 'appConfig: new ConfigItem: configObj: id must be a namespace with at least one dot. example: ' +
                            'someConfig.configId. id: ' + id, RangeError);
                        nameSpaceNodes.pop();
                        containerId = nameSpaceNodes.join(appConfigProvider.NAMESPACE_DELIMITER);
                    }
                    return containerId;
                };
                ;
                ConfigItemProvider.prototype.createItem = function (configItemData) {
                    // Validations
                    this.assert.isString(configItemData.id, 'id', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configItemData.containerId, 'containerId', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configItemData.displayName, 'displayName', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    this.assert.isString(configItemData.description, 'description', 'appConfig: new ConfigItem: configObj: ', appConfigProvider.IS_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    // Assignments
                    var id = configItemData.id;
                    var containerId = this._getContainerId(configItemData.containerId, id);
                    var description = configItemData.description;
                    var displayName = configItemData.displayName;
                    var type = configItemData.type || null;
                    var validators = configItemData.validators ? configItemData.validators :
                        [configItemData.type];
                    var formatter = configItemData.formatter || configItemData.type || null;
                    var value = configItemData.value === undefined ? null : configItemData.value;
                    var _originalValue = configItemData.value;
                    var meta = configItemData.meta || null;
                    return new ConfigItem(id, containerId, description, displayName, type, validators, formatter, value, _originalValue, meta);
                };
                ConfigItemProvider.$inject = ['assertConstant'];
                return ConfigItemProvider;
            }());
            configItemProvider.ConfigItemProvider = ConfigItemProvider;
            angular.module('Fortscale.appConfig.ConfigItem', ['Fortscale.shared.services.assert'])
                .provider('Fortscale.appConfig.ConfigItem', ConfigItemProvider);
        })(configItemProvider = appConfigProvider.configItemProvider || (appConfigProvider.configItemProvider = {}));
    })(appConfigProvider = Fortscale.appConfigProvider || (Fortscale.appConfigProvider = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var appConfigProvider;
    (function (appConfigProvider) {
        var ConfigItem = Fortscale.appConfigProvider.configItemProvider.ConfigItem;
        'use strict';
        appConfigProvider.IS_OPTIONAL = true;
        appConfigProvider.IS_NOT_OPTIONAL = false;
        appConfigProvider.CAN_NOT_BE_EMPTY = false;
        appConfigProvider.DO_NOT_VALIDATE = true;
        var DEFAULT_CONFIG_NAME = 'default';
        appConfigProvider.NAMESPACE_DELIMITER = '.';
        var assert;
        var AppConfigService = (function () {
            function AppConfigService(provider, $q, assert, remoteAppConfig) {
                this.provider = provider;
                this.$q = $q;
                this.assert = assert;
                this.remoteAppConfig = remoteAppConfig;
            }
            /**
             * Validates configId param
             *
             * @param {string} configId
             * @param {string} methodName
             *
             * @private
             */
            AppConfigService.prototype._validateConfigId = function (configId, methodName) {
                this.assert.isString(configId, 'configId', 'appConfig: ' + methodName + ': ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                this.assert(configId.split(appConfigProvider.NAMESPACE_DELIMITER).length >= 2, 'appConfig: ' + methodName + ': configId should be a namespace with at least two nodes; ' +
                    'configId: ' + configId, RangeError);
            };
            /**
             * Takes a key and traverses up (recursively) to see if any of the parent config containers exist,
             * and if so if any of them specify allowUpsert
             * @param {string} key
             * @returns {boolean}
             * @private
             */
            AppConfigService.prototype._shouldUpsert = function (key) {
                var namespace = key.split(appConfigProvider.NAMESPACE_DELIMITER);
                if (namespace.length > 1) {
                    namespace.pop();
                    var configContainer = this.getConfigContainer(namespace.join(appConfigProvider.NAMESPACE_DELIMITER));
                    if (configContainer) {
                        return !!configContainer.allowUpsert;
                    }
                    else {
                        return this._shouldUpsert(namespace.join(appConfigProvider.NAMESPACE_DELIMITER));
                    }
                }
                else {
                    return false;
                }
            };
            /**
             * Builds recursively the missing configContainers al the way to the existing configContainer.
             * If build fails, false is returned. If success the true is returned.
             *
             * @param {string} key
             * @returns {boolean}
             * @private
             */
            AppConfigService.prototype._buildContainerPath = function (key) {
                var namespace = key.split(appConfigProvider.NAMESPACE_DELIMITER);
                if (namespace.length > 1) {
                    // try and get container
                    namespace.pop();
                    var configContainer = this.getConfigContainer(namespace.join(appConfigProvider.NAMESPACE_DELIMITER));
                    if (configContainer) {
                        return true;
                    }
                    else {
                        //build the parent
                        if (this._buildContainerPath(namespace.join(appConfigProvider.NAMESPACE_DELIMITER))) {
                            //get the parent
                            var parentId = namespace.slice(0, namespace.length - 1).join(appConfigProvider.NAMESPACE_DELIMITER);
                            var parent_1 = this.getConfigContainer(parentId);
                            // build the current
                            this.provider.addConfigContainer({
                                id: namespace.join(appConfigProvider.NAMESPACE_DELIMITER),
                                displayName: namespace.pop(),
                                allowUpsert: true,
                                configurable: parent_1.configurable
                            });
                            return true;
                        }
                        else {
                            // if could not build the parent
                            return false;
                        }
                    }
                }
                else {
                    return false;
                }
            };
            /**
             * Takes a remote config item and inserts it into the config items.
             *
             * @param {{key: string, value: string, type: string=}} remoteConfigItem
             * @private
             */
            AppConfigService.prototype._upsertRemoteConfigItem = function (remoteConfigItem) {
                var messageName = remoteConfigItem.key.split(appConfigProvider.NAMESPACE_DELIMITER).pop();
                var newConfigItem = this.provider.ConfigItemProvider.createItem({
                    id: remoteConfigItem.key,
                    displayName: messageName,
                    value: remoteConfigItem.value,
                    type: remoteConfigItem.type || "string",
                    validators: ['required']
                });
                this.provider.addConfigItem(newConfigItem);
            };
            /**
             * Returns configItem by id
             *
             * @param {string} configId
             * @param {boolean=} _doNotValidate
             * @returns {*|null}
             */
            AppConfigService.prototype.getConfigItem = function (configId, _doNotValidate) {
                // Validations
                if (!_doNotValidate) {
                    this._validateConfigId(configId, 'getDerivedConfigItem');
                }
                // Get the configItem
                return this.provider.getConfigItem(configId);
            };
            ;
            /**
             * Traverses the config node tree to find the closest node item.
             *
             * @param {string} configId
             * @param {boolean=} _doNotValidate
             * @returns {ConfigItem|null}
             */
            AppConfigService.prototype.getDerivedConfigItem = function (configId, _doNotValidate) {
                // Validations
                if (!_doNotValidate) {
                    this._validateConfigId(configId, 'getDerivedConfigItem');
                }
                // Get the configItem
                var configItem = this.provider.getConfigItem(configId);
                // If the value is not undefined and it's value property is not null or undefined return it's value.
                if (configItem !== undefined && configItem !== null && configItem.value !== undefined &&
                    configItem.value !== null) {
                    return configItem;
                }
                var propName = configId.split(appConfigProvider.NAMESPACE_DELIMITER).pop();
                if (configItem !== undefined && configItem !== null) {
                    var container = this.provider.getConfigContainer(configItem.containerId);
                    // If there's a parent, return parent's value recursively
                    if (container.parent) {
                        return this.getDerivedConfigItem(container.parent + appConfigProvider.NAMESPACE_DELIMITER + propName, appConfigProvider.DO_NOT_VALIDATE);
                    }
                }
                // If stateName is not 'default' and: [configItem item is undefined or value is undefined or value is
                // null] then try and get the default value.
                if (configId.indexOf(DEFAULT_CONFIG_NAME + appConfigProvider.NAMESPACE_DELIMITER) !== 0 &&
                    (configItem === undefined || configItem === null || configItem.value === undefined ||
                        configItem.value === null)) {
                    return this.getDerivedConfigItem(DEFAULT_CONFIG_NAME + appConfigProvider.NAMESPACE_DELIMITER + propName, appConfigProvider.DO_NOT_VALIDATE);
                }
                return null;
            };
            ;
            /**
             * Returns a config item's value. If configItem is not found, or its value is undefined or null, the parent
             * is accessed for the same property key. If no parent is found, the "default" config state is accessed for
             * the same property key. If no value is found on the parent, null is returned.
             *
             * @param {string} stateName
             * @param {string} propName
             * @returns {*}
             */
            AppConfigService.prototype.getConfigValue = function (stateName, propName) {
                // Validations
                this.assert.isString(stateName, 'stateName', 'appConfig: getConfigValue: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                this.assert.isString(propName, 'propName', 'appConfig: getConfigValue: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                // Get the config item
                var configValue = this.getDerivedConfigItem(stateName + appConfigProvider.NAMESPACE_DELIMITER + propName, appConfigProvider.DO_NOT_VALIDATE);
                // If configItem has a value that is different than null, return the value. If not return null.
                if (configValue !== null && configValue.value !== null && configValue.value !== undefined) {
                    return configValue.value;
                }
                return null;
            };
            ;
            /**
             * Returns a list of configItems of a specific container.
             *
             * @param {string} containerId
             * @returns {Array}
             */
            AppConfigService.prototype.getConfigItemsByContainer = function (containerId) {
                // Validations
                this.assert.isString(containerId, 'stateName', 'appConfig: getConfigItemsByContainer: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                // Iterate through config keys, and find all configItems where the parent equals the stateName and are
                // not nodes
                return _.filter(this.provider.getConfigItems(), function (configItem) { return configItem.containerId === containerId; });
            };
            ;
            /**
             * Returns an object that represents all config nodes as a tree. each node has a 'nodes' object that holds
             * all child nodes
             *
             * @returns {object}
             */
            AppConfigService.prototype.getConfigNodesTree = function () {
                var configNodeTree = { nodes: {} };
                _.each(this.provider.getConfigContainers(), function (configContainer) {
                    // place on nodeTree by breaking to namespace
                    var nameSpaceNodes = configContainer.id.split(appConfigProvider.NAMESPACE_DELIMITER);
                    var traversed = configNodeTree.nodes;
                    // Create entire namespace if it doesn't exist
                    _.each(nameSpaceNodes, function (nameSpaceNode, index) {
                        // build or traverse nodes as long as its not the last node
                        if (index < nameSpaceNodes.length - 1) {
                            traversed[nameSpaceNode] = traversed[nameSpaceNode] || { nodes: {} };
                            traversed = traversed[nameSpaceNode].nodes;
                        }
                        else {
                            // On the last node place the config container on the last created 'nodes'
                            traversed[nameSpaceNode] = _.merge({ nodes: {} }, configContainer);
                        }
                    });
                });
                return configNodeTree;
            };
            ;
            /**
             * Returns a ConfigContainer by a configContainerId
             *
             * @param {string} configContainerId
             * @returns {ConfigContainer|null}
             */
            AppConfigService.prototype.getConfigContainer = function (configContainerId) {
                // Validations
                this.assert.isString(configContainerId, 'configContainerId', 'appConfig: getConfigContainer: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                return this.provider.getConfigContainer(configContainerId);
            };
            /**
             * Checks if current container (by id) is a maternal relative of target container (by id)
             *
             * @param {string} currentContainerId
             * @param {string} targetContainerId
             * @returns {boolean}
             */
            AppConfigService.prototype.isParentOfConfigContainer = function (currentContainerId, targetContainerId) {
                // Validations
                this.assert.isString(currentContainerId, 'currentContainerId', 'appConfig: isParentOfConfigContainer: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                // Validations
                this.assert.isString(targetContainerId, 'targetContainerId', 'appConfig: isParentOfConfigContainer: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                // Get config container
                var targetConfigContainer = this.getConfigContainer(targetContainerId);
                // If no config container was found, return false
                if (targetConfigContainer === null) {
                    return false;
                }
                // If configContainer has a parent, and the parent points to currentContainerId return true
                if (targetConfigContainer.parent && targetConfigContainer.parent === currentContainerId) {
                    return true;
                }
                // If configContainer has a parent, and the parent does not point to currentContainerId then run the
                // function recursively with the parent
                if (targetConfigContainer.parent) {
                    return this.isParentOfConfigContainer(currentContainerId, targetConfigContainer.parent);
                }
                // If configContainer has no parent then return false
                return false;
            };
            /**
             * Takes a config id and returns a list of all possible affected config items
             *
             * @param {string} configId
             * @returns {Array<ConfigItem>}
             */
            AppConfigService.prototype.getAffectedConfigItems = function (configId) {
                var _this = this;
                // Validations
                this._validateConfigId(configId, 'getAffectedConfigItems');
                // get config item
                var configItem = this.getConfigItem(configId, appConfigProvider.DO_NOT_VALIDATE);
                // get a list of possible affected items (use last node of configId)
                var propName = configId.split(appConfigProvider.NAMESPACE_DELIMITER).pop();
                var propNameRegExp = new RegExp(propName + '$');
                var possibleAffectedConfigItems = _.filter(this.provider.getConfigItems(), function (configItem) { return propNameRegExp.test(configItem.id); });
                // filter list for configItem's container is a parent of list config item's container. return list.
                return _.filter(possibleAffectedConfigItems, function (paConfigItem) {
                    // DEFAULT_CONFIG_NAME is excepted because all items are affected by default
                    return (configItem.containerId === DEFAULT_CONFIG_NAME &&
                        paConfigItem.containerId !== DEFAULT_CONFIG_NAME) ||
                        _this.isParentOfConfigContainer(configItem.containerId, paConfigItem.containerId);
                });
            };
            /**
             * Verifies an object is an instance of ConfigItem
             *
             * @param obj
             * @returns {boolean}
             */
            AppConfigService.prototype.isConfigItem = function (obj) {
                return (obj instanceof ConfigItem);
            };
            /**
             * Duplicates a ConfigItem. This is done so original config items will not be affected.
             *
             * @param {ConfigItem} configItem
             * @returns {ConfigItem}
             */
            AppConfigService.prototype.duplicateConfigItem = function (configItem) {
                this.assert(this.isConfigItem(configItem), 'appConfig: duplicateConfigItem: provided configItem must be an instance of ConfigItem', TypeError);
                return this.provider.ConfigItemProvider.createItem(_.merge({}, configItem));
            };
            /**
             * This method checks if a target config item can inherit from a specific config container.
             *
             * @param {string} targetConfigId
             * @param {string} containerId
             * @returns {boolean}
             */
            AppConfigService.prototype.canTargetDeriveFromContainer = function (targetConfigId, containerId) {
                // Get the config item
                var configItem = this.provider.getConfigItem(targetConfigId);
                if (!configItem) {
                    return false;
                }
                // Get the prop
                var prop = targetConfigId.split(appConfigProvider.NAMESPACE_DELIMITER).pop();
                // Check if target's container is a child of containerId and target's container is not default return
                // false
                if (!this.isParentOfConfigContainer(containerId, configItem.containerId) &&
                    containerId !== DEFAULT_CONFIG_NAME) {
                    return false;
                }
                // Travers up to targetConfigId (not including) and check if it has value
                // If value exists before the parent, then return false
                var cursorConfigContainer, cursorValue;
                cursorValue = null;
                cursorConfigContainer = this.getConfigContainer(configItem.containerId);
                while (cursorValue === null) {
                    cursorValue = (this.provider.getConfigItem(cursorConfigContainer.id + appConfigProvider.NAMESPACE_DELIMITER + prop) ||
                        { value: null }).value;
                    if (cursorValue !== null) {
                        return false;
                    }
                    if (!cursorConfigContainer.parent || cursorConfigContainer.parent === containerId) {
                        return true;
                    }
                    cursorConfigContainer = this.getConfigContainer(cursorConfigContainer.parent);
                }
                return true;
            };
            /**
             * Returns a formatter if on exists. If it does not, it returns null
             *
             * @param formatterId
             * @returns {function|null}
             */
            AppConfigService.prototype.getFormatter = function (formatterId) {
                return this.provider.getFormatter(formatterId) || null;
            };
            /**
             * Returns a validator if on exists. If it does not, it returns null
             *
             * @param validatorId
             * @returns {function|null}
             */
            AppConfigService.prototype.getValidator = function (validatorId) {
                return this.provider.getValidator(validatorId) || null;
            };
            /**
             * Takes a list of objects, and updates the local config. Remote config must relate to a local config. If
             * it does not, than remote config is ignored. If validator exists for the type, and validation fails. The
             * remote config will be ignored.
             *
             * @param {Array<{key: string, value: string}>} remoteConfigList
             */
            AppConfigService.prototype.digestRemoteConfig = function (remoteConfigList) {
                var _this = this;
                _.each(remoteConfigList, function (remoteConfigItem) {
                    var configItem = _this.getConfigItem(remoteConfigItem.key);
                    var finalValue;
                    if (configItem) {
                        finalValue = _this.formatConfigItem(remoteConfigItem);
                        // Validate value based on type. If valid or no validator, than set value to configItem.
                        if (_this.validateConfigItem({ key: remoteConfigItem.key, value: finalValue })) {
                            configItem.value = finalValue;
                        }
                    }
                    else {
                        // Check if any parent container allows upsert
                        if (_this._shouldUpsert(remoteConfigItem.key)) {
                            // build the path up to the parent container
                            if (_this._buildContainerPath(remoteConfigItem.key)) {
                                // insert the remote config item
                                _this._upsertRemoteConfigItem(remoteConfigItem);
                            }
                            else {
                                console.warn('Could not upsert remote config item.' + remoteConfigItem.key + ': ' +
                                    remoteConfigItem.value);
                            }
                        }
                    }
                });
            };
            /**
             * Validates a config item based on its validators
             *
             * @param {IKeyValueConfig} keyValueConfig
             * @returns {boolean}
             */
            AppConfigService.prototype.validateConfigItem = function (keyValueConfig) {
                var _this = this;
                var configItem = this.getConfigItem(keyValueConfig.key);
                this.assert.isObject(configItem, 'configItem', 'validateConfigItem: ');
                var validators = _.map(configItem.validators, function (validatorName) { return _this.getValidator(validatorName); });
                return _.every(validators, function (validatorFn) {
                    if (validatorFn === null) {
                        return true;
                    }
                    return validatorFn(keyValueConfig.value);
                });
            };
            /**
             * Takes a formatter and converts it to its proper format.
             *
             * @param {IKeyValueConfig} keyValueConfig
             * @returns {any}
             */
            AppConfigService.prototype.formatConfigItem = function (keyValueConfig) {
                var configItem = this.getConfigItem(keyValueConfig.key);
                this.assert.isObject(configItem, 'configItem', 'formatConfigItem: ');
                var formatterFn = this.getFormatter(configItem.formatter);
                if (formatterFn) {
                    return formatterFn(keyValueConfig.value);
                }
                return keyValueConfig.value;
            };
            /**
             * Accepts a list of objects, validates, updates the config items in the db, then locally.
             *
             * @param {Array<{key: string, value: string}>} configItemsList
             * @returns {*}
             */
            AppConfigService.prototype.updateConfigItems = function (configItemsList) {
                var _this = this;
                // Validate list
                this.assert.isArray(configItemsList, 'configItemsList', 'appConfig: updateConfigItems: ', appConfigProvider.IS_NOT_OPTIONAL);
                _.each(configItemsList, function (configItem, index) {
                    _this.assert.isString(configItem.key, 'key', 'appConfig: updateConfigItems: configItemsList: item ' + index + ': ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                    _this.assert(_this.getConfigItem(configItem.key) !== undefined, 'appConfig: updateConfigItems: configItemsList: item ' + index +
                        ': Item\'s key does not point to a valid config item.', ReferenceError);
                });
                var clonedList = _.cloneDeep(configItemsList);
                return this.$q(function (resolve, reject) {
                    _.each(clonedList, function (configItem) {
                        // format output
                        configItem.value = _this.formatConfigItem(configItem);
                        // validate
                        if (!_this.validateConfigItem(configItem)) {
                            return reject(new RangeError("Trying to update a config value with an invalid value. key: " + configItem.key + "  -  value: " + configItem.value));
                        }
                        resolve();
                    });
                })
                    .then(function () {
                    return _this.remoteAppConfig.updateConfigItems(clonedList);
                })
                    .then(function () { return _this.digestRemoteConfig(clonedList); });
            };
            /**
             * Init function. Digests remote config.
             *
             * @private
             */
            AppConfigService.prototype._init = function () {
                this.digestRemoteConfig(this.remoteAppConfig.getRemoteConfigList());
            };
            return AppConfigService;
        }());
        var AppConfigProvider = (function () {
            function AppConfigProvider(assert, ConfigContainerProvider, ConfigItemProvider) {
                this.assert = assert;
                this.ConfigContainerProvider = ConfigContainerProvider;
                this.ConfigItemProvider = ConfigItemProvider;
                this.$get = ['$q', 'assert', 'remoteAppConfig', this.appConfigFactory.bind(this)];
                // Initialize privates
                this._configContainers = {};
                this._configItems = {};
                this._formatters = {};
                this._validators = {};
            }
            AppConfigProvider.prototype.appConfigFactory = function ($q, assert, remoteAppConfig) {
                var service = new AppConfigService(this, $q, assert, remoteAppConfig);
                service._init();
                return service;
            };
            AppConfigProvider.prototype.getConfigItem = function (configId) {
                return this._configItems[configId] || null;
            };
            AppConfigProvider.prototype.getConfigItems = function () {
                return _.values(this._configItems);
            };
            AppConfigProvider.prototype.getConfigContainer = function (containerId) {
                return this._configContainers[containerId] || null;
            };
            AppConfigProvider.prototype.getConfigContainers = function () {
                return _.values(this._configContainers);
            };
            /**
             * Adds a config container
             *
             * @param {IConfigContainerData} configContainerData
             * @param {boolean} isUnique
             * @returns {AppConfigProvider}
             */
            AppConfigProvider.prototype.addConfigContainer = function (configContainerData, isUnique) {
                if (isUnique === void 0) { isUnique = true; }
                // Validations
                this.assert.isObject(configContainerData, 'configContainerData', 'AppConfigProvider: addConfigContainer: ', appConfigProvider.IS_NOT_OPTIONAL);
                // Create new ConfigItem instance
                var configContainer = this.ConfigContainerProvider.createContainer(configContainerData);
                //Validations: make sure that if isUnique is true, the config item does not override an existing one.
                this.assert((isUnique && this._configContainers[configContainerData.id] === undefined), 'appConfig: addConfigContainer: When isUnique is true, config container id must be unique and it is ' +
                    'not; id: ' + configContainerData.id, RangeError);
                // Place config item on the config items object
                this._configContainers[configContainerData.id] = configContainer;
                // Return the config item instance from configItems
                return this;
            };
            /**
             * Adds a config item
             * @param {IConfigItemData} configItemData
             * @param isUnique
             * @returns {AppConfigProvider}
             */
            AppConfigProvider.prototype.addConfigItem = function (configItemData, isUnique) {
                if (isUnique === void 0) { isUnique = true; }
                // Validations
                this.assert.isObject(configItemData, 'configItemData', 'AppConfigProvider: addConfigItem: ', appConfigProvider.IS_NOT_OPTIONAL);
                // Create new ConfigItem instance
                var configItem = this.ConfigItemProvider.createItem(configItemData);
                // If isUnique make sure its not pointing to an existing object
                this.assert((isUnique && this._configItems[configItem.id] === undefined), 'AppConfigProvider: addConfigItem: When isUnique is true, config item id must be unique and it is ' +
                    'not; id: ' + configItemData.id, RangeError);
                // Make sure the config item is pointing to an existing container
                this.assert(!!this._configContainers[configItem.containerId], 'AppConfigProvider: addConfigItem: config item containerId must point to an existing container; id: ' +
                    configItemData.id, ReferenceError);
                // Place config item on the config items object
                this._configItems[configItem.id] = configItem;
                // Return the config item instance from configItems
                return this;
            };
            /**
             * Changes the name of the default container in the config phase.
             *
             * @param {string} newName
             */
            AppConfigProvider.prototype.changeDefaultName = function (newName) {
                // Validations
                this.assert.isString(newName, 'newName', 'appConfigProvider: changeDefaultName: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                DEFAULT_CONFIG_NAME = newName;
            };
            ;
            /**
             * Adds a formatter. Formatter will be consumed when config item type equals formatter id.
             *
             * @param {string} formatterId
             * @param {function} formatterFn
             * @param {boolean=} isUnique
             * @returns {AppConfigProvider}
             */
            AppConfigProvider.prototype.addFormatter = function (formatterId, formatterFn, isUnique) {
                if (isUnique === void 0) { isUnique = true; }
                // Validations
                this.assert.isString(formatterId, 'formatterId', 'appConfigProvider: addFormatter: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                this.assert.isFunction(formatterFn, 'formatterFn', 'appConfigProvider: addFormatter: ', appConfigProvider.IS_NOT_OPTIONAL);
                // If isUnique make sure its not pointing to an existing object
                this.assert((isUnique && this._formatters[formatterId] === undefined), 'appConfigProvider: addFormatter: When isUnique is true, formatter must be unique and it is ' +
                    'not; formatterId: ' + formatterId, RangeError);
                this._formatters[formatterId] = formatterFn;
                return this;
            };
            ;
            /**
             * Returns a formatter by id
             *
             * @param formatterId
             * @returns {*}
             */
            AppConfigProvider.prototype.getFormatter = function (formatterId) {
                return this._formatters[formatterId];
            };
            /**
             * Adds a validator. Validator will be consumed when config item type equals validator id.
             *
             * @param {string} validatorId
             * @param {function} validatorFn
             * @param {boolean=} isUnique
             * @returns {AppConfigProvider}
             */
            AppConfigProvider.prototype.addValidator = function (validatorId, validatorFn, isUnique) {
                if (isUnique === void 0) { isUnique = true; }
                // Validations
                this.assert.isString(validatorId, 'validatorId', 'appConfigProvider: addValidator: ', appConfigProvider.IS_NOT_OPTIONAL, appConfigProvider.CAN_NOT_BE_EMPTY);
                this.assert.isFunction(validatorFn, 'validatorFn', 'appConfigProvider: addValidator: ', appConfigProvider.IS_NOT_OPTIONAL);
                // If isUnique make sure its not pointing to an existing object
                this.assert((isUnique && this._validators[validatorId] === undefined), 'appConfigProvider: addValidator: When isUnique is true, validator must be unique and it is ' +
                    'not; validatorId: ' + validatorId, RangeError);
                this._validators[validatorId] = validatorFn;
                return this;
            };
            ;
            /**
             * Returns a validator by id
             *
             * @param validatorId
             * @returns {*}
             */
            AppConfigProvider.prototype.getValidator = function (validatorId) {
                return this._validators[validatorId];
            };
            AppConfigProvider.$inject = ['assertConstant', 'Fortscale.appConfig.ConfigContainerProvider',
                'Fortscale.appConfig.ConfigItemProvider'];
            return AppConfigProvider;
        }());
        function containerIdToDisplayNameFilter(appConfig) {
            return function (containerId) {
                return (appConfig.getConfigContainer(containerId) || { displayName: 'N/A' }).displayName;
            };
        }
        function containerIdToDisplayCrumb(appConfig) {
            return function fn(containerId) {
                if (containerId) {
                    var configContainer = appConfig.getConfigContainer(containerId);
                    return (configContainer.parent ? fn(configContainer.parent) + ': ' : '') + configContainer.displayName;
                }
                return '';
            };
        }
        angular.module('Fortscale.appConfig', ['Fortscale.shared.services.assert', 'Fortscale.remoteAppConfig', 'Fortscale.appConfig.ConfigContainer',
            'Fortscale.appConfig.ConfigItem'])
            .provider('appConfig', AppConfigProvider)
            .filter('containerIdToDisplayName', ['appConfig', containerIdToDisplayNameFilter])
            .filter('containerIdToDisplayCrumb', ['appConfig', containerIdToDisplayCrumb]);
    })(appConfigProvider = Fortscale.appConfigProvider || (Fortscale.appConfigProvider = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var appConfigProvider;
    (function (appConfigProvider_1) {
        var formatters;
        (function (formatters) {
            'use strict';
            function numberFormatter(val) {
                var parsedVal = parseFloat(val);
                if (!isNaN(parsedVal)) {
                    return parsedVal;
                }
                if (val === '' || val === undefined) {
                    return null;
                }
                return val;
            }
            function booleanFormatter(val) {
                if (typeof val === 'string') {
                    return val.trim().toLowerCase() !== 'false';
                }
                return !!val;
            }
            function stringFormatter(val) {
                if (val === null || val === undefined) {
                    return null;
                }
                return val.toString();
            }
            angular.module('Fortscale.appConfig')
                .config([
                'appConfigProvider',
                function (appConfigProvider) {
                    appConfigProvider.addFormatter('integer', numberFormatter);
                    appConfigProvider.addFormatter('number', numberFormatter);
                    appConfigProvider.addFormatter('boolean', booleanFormatter);
                    appConfigProvider.addFormatter('string', stringFormatter);
                    appConfigProvider.addFormatter('password', stringFormatter);
                    appConfigProvider.addFormatter('isEnabled', booleanFormatter);
                }
            ]);
        })(formatters = appConfigProvider_1.formatters || (appConfigProvider_1.formatters = {}));
    })(appConfigProvider = Fortscale.appConfigProvider || (Fortscale.appConfigProvider = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var appConfigProvider;
    (function (appConfigProvider_1) {
        var validators;
        (function (validators) {
            'use strict';
            function requiredValidator(val) {
                return val !== null && val !== undefined && val !== '';
            }
            /**
             * Validates integer
             *
             * @param {string} val
             * @returns {boolean}
             */
            function integerValidator(val) {
                if (val === null) {
                    return true;
                }
                return (!isNaN(val) && _.isNumber(val) && Math.floor(val) === val);
            }
            function numberValidator(val) {
                if (val === null) {
                    return true;
                }
                return (!isNaN(val) && _.isNumber(val));
            }
            function portValidator(val) {
                if (val === null) {
                    return true;
                }
                return (!isNaN(val) && _.isNumber(val) && val > 0 && val <= 65535);
            }
            function ipValidator(val) {
                if (val === null) {
                    return true;
                }
                if (!_.isString(val)) {
                    return false;
                }
                var ipRgx = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
                return ipRgx.test(val);
            }
            function stringValidator(val) {
                if (val === null) {
                    return true;
                }
                return _.isString(val);
            }
            function booleanValidator(val) {
                if (val === null || val === true || val === false) {
                    return true;
                }
            }
            angular.module('Fortscale.appConfig')
                .config(['appConfigProvider', function (appConfigProvider) {
                    appConfigProvider
                        .addValidator('integer', integerValidator)
                        .addValidator('number', numberValidator)
                        .addValidator('string', stringValidator)
                        .addValidator('password', stringValidator)
                        .addValidator('boolean', booleanValidator)
                        .addValidator('required', requiredValidator)
                        .addValidator('port', portValidator)
                        .addValidator('ip', ipValidator);
                }]);
        })(validators = appConfigProvider_1.validators || (appConfigProvider_1.validators = {}));
    })(appConfigProvider = Fortscale.appConfigProvider || (Fortscale.appConfigProvider = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function fsConfigTypeDirective() {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // Link function logic
            scope.ctrl.ngModelController = ctrl[0];
            scope.ctrl._linkInit();
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsConfigurationAffectedItemsController($element, $scope, appConfig, assert) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            ctrl.appConfig = appConfig;
            ctrl.assert = assert;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsConfigurationAffectedItemsController.prototype, {
            _errMsg: 'Fortscale.appConfig: fsConfigType.directive: ',
            _linkInit: function () {
                var ctrl = this;
                // Get formatter
                var formatter = this.appConfig.getFormatter(this.configItem.type);
                // Inject formatter into ngModel
                if (formatter) {
                    this.ngModelController.$formatters.push(formatter);
                }
                // Get validator
                var validator = this.appConfig.getValidator(this.configItem.type);
                // Inject validator into ngModel
                if (validator) {
                    this.ngModelController.$validators[this.configItem.type] = function (modelValue, viewValue) {
                        // Value should be modelValue or viewValue or configItem.value
                        var value = modelValue !== undefined ? modelValue : viewValue;
                        value = value !== undefined ? value : ctrl.configItem.value;
                        // run formatter
                        if (formatter) {
                            value = formatter(value);
                        }
                        // Run validator
                        return validator(value);
                    };
                }
            },
            /**
             * Init
             */
            init: function init() {
            }
        });
        FsConfigurationAffectedItemsController.$inject = ['$element', '$scope', 'appConfig', 'assert'];
        return {
            restrict: 'A',
            link: linkFn,
            controller: FsConfigurationAffectedItemsController,
            controllerAs: 'ctrl',
            bindToController: {
                configItem: '<'
            },
            require: ['ngModel'],
            priority: -1000
        };
    }
    fsConfigTypeDirective.$inject = [];
    angular.module('Fortscale.appConfig')
        .directive('fsConfigType', fsConfigTypeDirective);
}());

(function () {
    'use strict';
    function appConfig(appConfigProvider) {
        appConfigProvider
            .addConfigContainer({
            id: 'default',
            displayName: 'Default',
            description: 'All Default configuration'
        })
            .addConfigItem({
            id: 'default.daysRange',
            displayName: 'Date Range in Days',
            description: 'Default value for all Date Range in Days in the application, in days, from now.',
            type: 'integer',
            value: 7
        })
            .addConfigItem({
            id: 'default.daysAgo',
            displayName: 'Days Ago',
            description: 'Default date value for all Days Ago in the application, in days, from now.',
            type: 'integer',
            value: 30
        })
            .addConfigItem({
            id: 'default.shortDaysRange',
            displayName: 'Short Days Range in Days',
            description: 'Default short date range value, in days, from now.',
            type: 'integer',
            value: 1
        })
            .addConfigItem({
            id: 'default.longDaysRange',
            displayName: 'Long Days Range in Days',
            description: 'Default long date range value, in days, from now.',
            type: 'integer',
            value: 7
        })
            .addConfigItem({
            id: 'default.topRelatedDaysRange',
            displayName: 'Top Related Days Range',
            description: 'Default value for User-Overview Top-Related date range, in days, from now.',
            type: 'integer',
            value: 90
        })
            .addConfigItem({
            id: 'default.topRelatedListLimit',
            displayName: 'Top Related List Limit',
            description: 'Default value for Top-Related items limit.',
            type: 'integer',
            value: 5
        })
            .addConfigItem({
            id: 'default.userNameFallbackOrder',
            displayName: 'User Name Fallback Order',
            description: 'Default user name order. A CSV string value describing the priority order of property' +
                ' names on the user that might have a user name value.',
            type: 'string',
            value: 'adDisplayName,name,displayName,noDomainUsername,username'
        })
            .addConfigContainer({
            id: 'ui',
            displayName: 'User Interface',
            description: 'User interface configuration'
        })
            .addConfigContainer({
            id: 'ui.overview',
            displayName: 'Overview',
            description: 'Overview page configuration'
        })
            .addConfigItem({
            id: 'ui.overview.shortDaysRange',
            displayName: 'Short Date Range in Days',
            description: 'Overview\'s short date range value, in days, from now. ' +
                'Used in "Alerts Status"s left chart.',
            type: 'integer',
            value: null
        })
            .addConfigItem({
            id: 'ui.overview.longDaysRange',
            displayName: 'Long Date Range in Days',
            description: 'Overview\'s long date range value, in days, from now. ' +
                'Used in "Alerts Status"s right chart, and in "Alerts Severity"s chart.',
            type: 'integer',
            value: null
        })
            .addConfigItem({
            id: 'ui.overview.numberOfRiskUsers',
            displayName: 'Number Of Risk Users',
            description: 'Overview\'s number of requested risk users',
            type: 'integer',
            value: 5
        })
            .addConfigContainer({
            id: 'ui.alerts',
            displayName: 'Alerts',
            description: 'Alerts page configuration'
        })
            .addConfigItem({
            id: 'ui.alerts.daysRange',
            displayName: 'Date Range in Days',
            description: 'Alerts\'s "Alert Start" filter\'s date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.explore',
            displayName: 'Explore',
            description: 'Explore page configuration'
        })
            .addConfigItem({
            id: 'ui.explore.daysRange',
            displayName: 'Date Range in Days',
            description: 'Explore\'s "Result Between" control\'s date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports',
            displayName: 'Reports',
            description: 'All Reports default configuration'
        })
            .addConfigItem({
            id: 'ui.reports.daysRange',
            displayName: 'Date Range in Days',
            description: 'Reports default value for all Date Range in Days , in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigItem({
            id: 'ui.reports.daysAgo',
            displayName: 'Days Ago',
            description: 'Reports default date value for all Days Ago, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.highPrivilegedUsersMonitoring',
            displayName: 'High Privileged Users',
            description: 'High Privileged Users reports configuration'
        })
            .addConfigItem({
            id: 'ui.reports.highPrivilegedUsersMonitoring.daysRange',
            displayName: 'Date Range in Days',
            description: 'High Privileged Users Reports default Date Range in Days value, ' +
                'in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.highPrivilegedUsersMonitoring.admins',
            displayName: 'Admin Accounts',
            description: 'Admin Accounts report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.highPrivilegedUsersMonitoring.admins.daysRange',
            displayName: 'Date Range in Days',
            description: 'Admin Accounts report\'s "Events Time" control\'s date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.highPrivilegedUsersMonitoring.executives',
            displayName: 'Executive Accounts',
            description: 'Executive Accounts report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.highPrivilegedUsersMonitoring.executives.daysRange',
            displayName: 'Date Range in Days',
            description: 'Executive Accounts report\'s "Events Time" control\'s date range value, ' +
                'in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.highPrivilegedUsersMonitoring.serviceAccounts',
            displayName: 'Service Accounts',
            description: 'Service Accounts report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.highPrivilegedUsersMonitoring.serviceAccounts.daysRange',
            displayName: 'Date Range in Days',
            description: 'Service Accounts report\'s "Events Time" control\'s date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.externalAccessToNetwork',
            displayName: 'External Access to the Network',
            description: 'External Access to the Network reports configuration'
        })
            .addConfigItem({
            id: 'ui.reports.externalAccessToNetwork.daysRange',
            displayName: 'Date Range in Days',
            description: 'Service Accounts report\'s "Events Time" control\'s date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.externalAccessToNetwork.suspiciousVPNDataAmount',
            displayName: 'VPN Anomalous Data Usage',
            description: 'VPN Anomalous Data Usage report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.externalAccessToNetwork.suspiciousVPNDataAmount.daysRange',
            displayName: 'Date Range in Days',
            description: 'VPN Anomalous Data Usage report\'s "Events Time" control\'s date range ' +
                'value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.externalAccessToNetwork.VPNGeoHopping',
            displayName: 'VPN Anomalous Geolocation Sequences',
            description: 'VPN Anomalous Geolocation Sequences report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.externalAccessToNetwork.VPNGeoHopping.daysRange',
            displayName: 'Date Range in Days',
            description: 'VPN Anomalous Geolocation Sequences report\'s "Events Time" control\'s ' +
                'date range value, in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.deviceMonitoring',
            displayName: 'Device Investigation',
            description: 'Device Investigation reports configuration'
        })
            .addConfigItem({
            id: 'ui.reports.deviceMonitoring.daysRange',
            displayName: 'Date Range in Days',
            description: 'Device Investigation report\'s "Events Time" control\'s date range value, in days,' +
                ' from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.deviceMonitoring.IPInvestigation',
            displayName: 'IP Investigation',
            description: 'IP Investigation report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.deviceMonitoring.IPInvestigation.daysRange',
            displayName: 'Date Range in Days',
            description: 'IP Investigation report\'s "Events Time" control\'s date range value, in days,' +
                ' from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.deviceMonitoring.suspiciousEndpointAccess',
            displayName: 'Suspicious Device Access',
            description: 'Suspicious Device Access report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.deviceMonitoring.suspiciousEndpointAccess.daysRange',
            displayName: 'Date Range in Days',
            description: 'Suspicious Device Access report\'s "Events Time" control\'s date range value, ' +
                'in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.deviceMonitoring.sensitiveResourcesMonitoring',
            displayName: 'Sensitive Resources Monitoring',
            description: 'Sensitive Resources Monitoring report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.deviceMonitoring.sensitiveResourcesMonitoring.daysRange',
            displayName: 'Date Range in Days',
            description: 'Sensitive Resources Monitoring report\'s "Events Time" control\'s date range value, ' +
                'in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.staleAccountsMonitoring',
            displayName: 'Stale Accounts',
            description: 'Stale Accounts reports configuration'
        })
            .addConfigItem({
            id: 'ui.reports.staleAccountsMonitoring.daysAgo',
            displayName: 'Days Ago',
            description: 'Stale Accounts reports default date value for all Days Ago, ' +
                'in days, from now.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.staleAccountsMonitoring.disabledUserAccounts',
            displayName: 'Disabled Accounts',
            description: 'Disabled Accounts report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.staleAccountsMonitoring.disabledUserAccounts.daysAgo',
            displayName: 'Days Ago',
            description: 'Disabled Accounts report\'s "Disabled Since" control\'s date value, ' +
                'in days, from now, will be set to start of day.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'ui.reports.staleAccountsMonitoring.inactiveUserAccounts',
            displayName: 'Inactive Accounts',
            description: 'Inactive Accounts report configuration'
        })
            .addConfigItem({
            id: 'ui.reports.staleAccountsMonitoring.inactiveUserAccounts.daysAgo',
            displayName: 'Days Ago',
            description: 'Inactive Accounts report\'s "No Activity Since" control\'s date value, ' +
                'in days, from now, will be set to start of day.',
            type: 'integer',
            value: null
        })
            .addConfigContainer({
            id: 'system',
            displayName: 'System',
            description: 'Holds system configuration'
        })
            .addConfigContainer({
            id: 'system.email',
            displayName: 'Email',
            description: 'Holds all generic email configuration'
        })
            .addConfigItem({
            id: 'system.email.from',
            displayName: 'From',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigItem({
            id: 'system.email.username',
            displayName: 'User',
            type: 'string',
            value: null
        })
            .addConfigItem({
            id: 'system.email.password',
            displayName: 'Password',
            type: 'password',
            value: null,
            meta: {
                encrypt: true
            }
        })
            .addConfigItem({
            id: 'system.email.port',
            displayName: 'Port',
            type: 'integer',
            validators: ['required', 'integer', 'port'],
            value: null
        })
            .addConfigItem({
            id: 'system.email.host',
            displayName: 'Host',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigItem({
            id: 'system.email.auth',
            displayName: 'Authentication',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigContainer({
            id: 'system.alertsEmail',
            displayName: 'Alerts Email',
            description: 'Holds configuration for Alerts email'
        })
            .addConfigItem({
            id: 'system.alertsEmail.settings',
            displayName: 'Alerts Mail Settings',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigContainer({
            id: 'system.logEmail',
            displayName: 'Log Email',
            description: 'Holds configuration for Log email'
        })
            .addConfigItem({
            id: 'system.logEmail.subscribers',
            displayName: 'Log Mail Settings',
            type: 'string',
            value: null
        })
            .addConfigContainer({
            id: 'system.pxgrid',
            displayName: 'pxGrid',
            description: 'Holds configuration for pxGrid',
            configurable: false
        })
            .addConfigItem({
            id: 'system.pxgrid.cer',
            displayName: 'Certificate',
            type: 'simpleRequiredString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.csr',
            displayName: 'CSR',
            type: 'simpleRequiredString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.hosts',
            displayName: 'Hosts',
            type: 'pxgridString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.username',
            displayName: 'Username',
            type: 'pxgridString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.group',
            displayName: 'Group',
            type: 'pxgridString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.keystorepath',
            displayName: 'Keystore Path',
            type: 'pxgridFile',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.keystorepasspharse',
            displayName: 'Key Store Pass Phrase',
            type: 'pxgridString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.truststore',
            displayName: 'Trust Store',
            type: 'pxgridFile',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.truststorepasspharse',
            displayName: 'Trust Store Pass Phrase',
            type: 'pxgridString',
            value: null
        })
            .addConfigItem({
            id: 'system.pxgrid.connectionretrymillisecond',
            displayName: 'Connection Retry in Milliseconds',
            type: 'pxgridString',
            value: null
        })
            .addConfigContainer({
            id: 'system.syslogforwarding',
            displayName: 'Alert Forwarding via Syslog',
            description: 'Set up properties for forwarding alerts'
        })
            .addConfigItem({
            id: 'system.syslogforwarding.enabled',
            displayName: 'Enable Forwarding?',
            type: 'boolean',
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.forwardingtype',
            displayName: 'Forwarding Type',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.ip',
            displayName: 'IP',
            type: 'string',
            validators: ['required', 'ip'],
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.port',
            displayName: 'Port',
            type: 'integer',
            validators: ['required', 'port'],
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.messageformat',
            displayName: 'Message Format',
            type: 'string',
            validators: ['required'],
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.alertseverity',
            displayName: 'Selective Forwarding: Alert Severity',
            type: 'string',
            value: null
        })
            .addConfigItem({
            id: 'system.syslogforwarding.usertypes',
            displayName: 'Selective Forwarding: User Tags',
            type: 'string',
            value: null
        })
            .addConfigContainer({
            id: 'system.locale',
            displayName: 'Locale',
            configurable: false
        })
            .addConfigItem({
            id: 'system.locale.settings',
            displayName: 'Locale',
            type: 'string',
            value: 'en'
        });
        /**
         * END OF Locale configuration
         */
        /**
         * END OF System Configuration
         */
    }
    appConfig.$inject = ['appConfigProvider'];
    angular.module('Fortscale.appConfig')
        .config(appConfig);
}());

(function () {
    'use strict';
    function appConfig(appConfigProvider) {
        appConfigProvider
            .addConfigContainer({
            id: 'messages',
            displayName: 'Locale Messages',
            configurable: false,
            allowUpsert: true
        });
    }
    appConfig.$inject = ['appConfigProvider'];
    angular.module('Fortscale.appConfig')
        .config(appConfig);
}());

(function () {
    'use strict';
    function analyticsConfig(appConfigProvider) {
        appConfigProvider
            .addConfigContainer({
            id: 'system.analytics',
            displayName: 'Analytics'
        })
            .addConfigItem({
            id: 'system.analytics.allowAnalytics',
            displayName: 'Allow Analytics',
            type: 'boolean',
            value: false
        })
            .addConfigItem({
            id: 'system.analytics.updateEventsNum',
            displayName: 'Update on Number Of Events',
            description: 'When local db accumulates this number of events, it will try to upload the events ' +
                'to the remote db.',
            type: 'integer',
            value: 200
        });
    }
    analyticsConfig.$inject = ['appConfigProvider'];
    angular.module('Fortscale.appConfig')
        .config(analyticsConfig);
}());

(function () {
    'use strict';
    var countryCodes = {
        "afghanistan": { "name": "Afghanistan", "alpha-2": "AF", "country-code": "004" },
        "land islands": { "name": "land Islands", "alpha-2": "AX", "country-code": "248" },
        "albania": { "name": "Albania", "alpha-2": "AL", "country-code": "008" },
        "algeria": { "name": "Algeria", "alpha-2": "DZ", "country-code": "012" },
        "american samoa": { "name": "American Samoa", "alpha-2": "AS", "country-code": "016" },
        "andorra": { "name": "Andorra", "alpha-2": "AD", "country-code": "020" },
        "angola": { "name": "Angola", "alpha-2": "AO", "country-code": "024" },
        "anguilla": { "name": "Anguilla", "alpha-2": "AI", "country-code": "660" },
        "antarctica": { "name": "Antarctica", "alpha-2": "AQ", "country-code": "010" },
        "antigua and barbuda": { "name": "Antigua and Barbuda", "alpha-2": "AG", "country-code": "028" },
        "argentina": { "name": "Argentina", "alpha-2": "AR", "country-code": "032" },
        "armenia": { "name": "Armenia", "alpha-2": "AM", "country-code": "051" },
        "aruba": { "name": "Aruba", "alpha-2": "AW", "country-code": "533" },
        "australia": { "name": "Australia", "alpha-2": "AU", "country-code": "036" },
        "austria": { "name": "Austria", "alpha-2": "AT", "country-code": "040" },
        "azerbaijan": { "name": "Azerbaijan", "alpha-2": "AZ", "country-code": "031" },
        "bahamas": { "name": "Bahamas", "alpha-2": "BS", "country-code": "044" },
        "bahrain": { "name": "Bahrain", "alpha-2": "BH", "country-code": "048" },
        "bangladesh": { "name": "Bangladesh", "alpha-2": "BD", "country-code": "050" },
        "barbados": { "name": "Barbados", "alpha-2": "BB", "country-code": "052" },
        "belarus": { "name": "Belarus", "alpha-2": "BY", "country-code": "112" },
        "belgium": { "name": "Belgium", "alpha-2": "BE", "country-code": "056" },
        "belize": { "name": "Belize", "alpha-2": "BZ", "country-code": "084" },
        "benin": { "name": "Benin", "alpha-2": "BJ", "country-code": "204" },
        "bermuda": { "name": "Bermuda", "alpha-2": "BM", "country-code": "060" },
        "bhutan": { "name": "Bhutan", "alpha-2": "BT", "country-code": "064" },
        "bolivia (plurinational state of)": {
            "name": "Bolivia (Plurinational State of)",
            "alpha-2": "BO",
            "country-code": "068"
        },
        "bolivia": { "name": "Bolivia", "alpha-2": "BO", "country-code": "068" },
        "bonaire, sint eustatius and saba": {
            "name": "Bonaire, Sint Eustatius and Saba",
            "alpha-2": "BQ",
            "country-code": "535"
        },
        "bosnia and herzegovina": { "name": "Bosnia and Herzegovina", "alpha-2": "BA", "country-code": "070" },
        "botswana": { "name": "Botswana", "alpha-2": "BW", "country-code": "072" },
        "bouvet island": { "name": "Bouvet Island", "alpha-2": "BV", "country-code": "074" },
        "brazil": { "name": "Brazil", "alpha-2": "BR", "country-code": "076" },
        "british indian ocean territory": {
            "name": "British Indian Ocean Territory",
            "alpha-2": "IO",
            "country-code": "086"
        },
        "brunei darussalam": { "name": "Brunei Darussalam", "alpha-2": "BN", "country-code": "096" },
        "bulgaria": { "name": "Bulgaria", "alpha-2": "BG", "country-code": "100" },
        "burkina faso": { "name": "Burkina Faso", "alpha-2": "BF", "country-code": "854" },
        "burundi": { "name": "Burundi", "alpha-2": "BI", "country-code": "108" },
        "cambodia": { "name": "Cambodia", "alpha-2": "KH", "country-code": "116" },
        "cameroon": { "name": "Cameroon", "alpha-2": "CM", "country-code": "120" },
        "canada": { "name": "Canada", "alpha-2": "CA", "country-code": "124" },
        "cabo verde": { "name": "Cabo Verde", "alpha-2": "CV", "country-code": "132" },
        "cape verde": { "name": "Cape Verde", "alpha-2": "CV", "country-code": "132" },
        "cayman islands": { "name": "Cayman Islands", "alpha-2": "KY", "country-code": "136" },
        "central african republic": { "name": "Central African Republic", "alpha-2": "CF", "country-code": "140" },
        "chad": { "name": "Chad", "alpha-2": "TD", "country-code": "148" },
        "chile": { "name": "Chile", "alpha-2": "CL", "country-code": "152" },
        "china": { "name": "China", "alpha-2": "CN", "country-code": "156" },
        "christmas island": { "name": "Christmas Island", "alpha-2": "CX", "country-code": "162" },
        "cocos (keeling) islands": { "name": "Cocos (Keeling) Islands", "alpha-2": "CC", "country-code": "166" },
        "colombia": { "name": "Colombia", "alpha-2": "CO", "country-code": "170" },
        "comoros": { "name": "Comoros", "alpha-2": "KM", "country-code": "174" },
        "congo": { "name": "Congo", "alpha-2": "CG", "country-code": "178" },
        "congo (democratic republic of the)": {
            "name": "Congo (Democratic Republic of the)",
            "alpha-2": "CD",
            "country-code": "180"
        },
        "congo the democratic republic of the": {
            "name": "Congo The Democratic Republic Of The",
            "alpha-2": "CD",
            "country-code": "180"
        },
        "cook islands": { "name": "Cook Islands", "alpha-2": "CK", "country-code": "184" },
        "costa rica": { "name": "Costa Rica", "alpha-2": "CR", "country-code": "188" },
        "cte d'ivoire": { "name": "Cte d'Ivoire", "alpha-2": "CI", "country-code": "384" },
        "cote d'ivoire": { "name": "Cote d'Ivoire", "alpha-2": "CI", "country-code": "384" },
        "croatia": { "name": "Croatia", "alpha-2": "HR", "country-code": "191" },
        "cuba": { "name": "Cuba", "alpha-2": "CU", "country-code": "192" },
        "curaao": { "name": "Curaao", "alpha-2": "CW", "country-code": "531" },
        "cyprus": { "name": "Cyprus", "alpha-2": "CY", "country-code": "196" },
        "czech republic": { "name": "Czech Republic", "alpha-2": "CZ", "country-code": "203" },
        "denmark": { "name": "Denmark", "alpha-2": "DK", "country-code": "208" },
        "djibouti": { "name": "Djibouti", "alpha-2": "DJ", "country-code": "262" },
        "dominica": { "name": "Dominica", "alpha-2": "DM", "country-code": "212" },
        "dominican republic": { "name": "Dominican Republic", "alpha-2": "DO", "country-code": "214" },
        "ecuador": { "name": "Ecuador", "alpha-2": "EC", "country-code": "218" },
        "egypt": { "name": "Egypt", "alpha-2": "EG", "country-code": "818" },
        "el salvador": { "name": "El Salvador", "alpha-2": "SV", "country-code": "222" },
        "equatorial guinea": { "name": "Equatorial Guinea", "alpha-2": "GQ", "country-code": "226" },
        "eritrea": { "name": "Eritrea", "alpha-2": "ER", "country-code": "232" },
        "estonia": { "name": "Estonia", "alpha-2": "EE", "country-code": "233" },
        "ethiopia": { "name": "Ethiopia", "alpha-2": "ET", "country-code": "231" },
        "falkland islands (malvinas)": { "name": "Falkland Islands (Malvinas)", "alpha-2": "FK", "country-code": "238" },
        "faroe islands": { "name": "Faroe Islands", "alpha-2": "FO", "country-code": "234" },
        "fiji": { "name": "Fiji", "alpha-2": "FJ", "country-code": "242" },
        "finland": { "name": "Finland", "alpha-2": "FI", "country-code": "246" },
        "france": { "name": "France", "alpha-2": "FR", "country-code": "250" },
        "french guiana": { "name": "French Guiana", "alpha-2": "GF", "country-code": "254" },
        "french polynesia": { "name": "French Polynesia", "alpha-2": "PF", "country-code": "258" },
        "french southern territories": { "name": "French Southern Territories", "alpha-2": "TF", "country-code": "260" },
        "gabon": { "name": "Gabon", "alpha-2": "GA", "country-code": "266" },
        "gambia": { "name": "Gambia", "alpha-2": "GM", "country-code": "270" },
        "georgia": { "name": "Georgia", "alpha-2": "GE", "country-code": "268" },
        "germany": { "name": "Germany", "alpha-2": "DE", "country-code": "276" },
        "ghana": { "name": "Ghana", "alpha-2": "GH", "country-code": "288" },
        "gibraltar": { "name": "Gibraltar", "alpha-2": "GI", "country-code": "292" },
        "greece": { "name": "Greece", "alpha-2": "GR", "country-code": "300" },
        "greenland": { "name": "Greenland", "alpha-2": "GL", "country-code": "304" },
        "grenada": { "name": "Grenada", "alpha-2": "GD", "country-code": "308" },
        "guadeloupe": { "name": "Guadeloupe", "alpha-2": "GP", "country-code": "312" },
        "guam": { "name": "Guam", "alpha-2": "GU", "country-code": "316" },
        "guatemala": { "name": "Guatemala", "alpha-2": "GT", "country-code": "320" },
        "guernsey": { "name": "Guernsey", "alpha-2": "GG", "country-code": "831" },
        "guinea": { "name": "Guinea", "alpha-2": "GN", "country-code": "324" },
        "guinea-bissau": { "name": "Guinea-Bissau", "alpha-2": "GW", "country-code": "624" },
        "guyana": { "name": "Guyana", "alpha-2": "GY", "country-code": "328" },
        "haiti": { "name": "Haiti", "alpha-2": "HT", "country-code": "332" },
        "heard island and mcdonald islands": {
            "name": "Heard Island and McDonald Islands",
            "alpha-2": "HM",
            "country-code": "334"
        },
        "holy see": { "name": "Holy See", "alpha-2": "VA", "country-code": "336" },
        "honduras": { "name": "Honduras", "alpha-2": "HN", "country-code": "340" },
        "hong kong": { "name": "Hong Kong", "alpha-2": "HK", "country-code": "344" },
        "hungary": { "name": "Hungary", "alpha-2": "HU", "country-code": "348" },
        "iceland": { "name": "Iceland", "alpha-2": "IS", "country-code": "352" },
        "india": { "name": "India", "alpha-2": "IN", "country-code": "356" },
        "indonesia": { "name": "Indonesia", "alpha-2": "ID", "country-code": "360" },
        "iran (islamic republic of)": { "name": "Iran (Islamic Republic of)", "alpha-2": "IR", "country-code": "364" },
        "iran islamic republic of": { "name": "Iran Islamic Republic Of", "alpha-2": "IR", "country-code": "364" },
        "iraq": { "name": "Iraq", "alpha-2": "IQ", "country-code": "368" },
        "ireland": { "name": "Ireland", "alpha-2": "IE", "country-code": "372" },
        "isle of man": { "name": "Isle of Man", "alpha-2": "IM", "country-code": "833" },
        "israel": { "name": "Israel", "alpha-2": "IL", "country-code": "376" },
        "italy": { "name": "Italy", "alpha-2": "IT", "country-code": "380" },
        "jamaica": { "name": "Jamaica", "alpha-2": "JM", "country-code": "388" },
        "japan": { "name": "Japan", "alpha-2": "JP", "country-code": "392" },
        "jersey": { "name": "Jersey", "alpha-2": "JE", "country-code": "832" },
        "jordan": { "name": "Jordan", "alpha-2": "JO", "country-code": "400" },
        "kazakhstan": { "name": "Kazakhstan", "alpha-2": "KZ", "country-code": "398" },
        "kenya": { "name": "Kenya", "alpha-2": "KE", "country-code": "404" },
        "kiribati": { "name": "Kiribati", "alpha-2": "KI", "country-code": "296" },
        "korea (democratic people's republic of)": {
            "name": "Korea (Democratic People's Republic of)",
            "alpha-2": "KP",
            "country-code": "408"
        },
        "korea (republic of)": { "name": "Korea (Republic of)", "alpha-2": "KR", "country-code": "410" },
        "korea republic of": { "name": "Korea Republic Of", "alpha-2": "KR", "country-code": "410" },
        "kuwait": { "name": "Kuwait", "alpha-2": "KW", "country-code": "414" },
        "kyrgyzstan": { "name": "Kyrgyzstan", "alpha-2": "KG", "country-code": "417" },
        "lao people's democratic republic": {
            "name": "Lao People's Democratic Republic",
            "alpha-2": "LA",
            "country-code": "418"
        },
        "latvia": { "name": "Latvia", "alpha-2": "LV", "country-code": "428" },
        "lebanon": { "name": "Lebanon", "alpha-2": "LB", "country-code": "422" },
        "lesotho": { "name": "Lesotho", "alpha-2": "LS", "country-code": "426" },
        "liberia": { "name": "Liberia", "alpha-2": "LR", "country-code": "430" },
        "libya": { "name": "Libya", "alpha-2": "LY", "country-code": "434" },
        "liechtenstein": { "name": "Liechtenstein", "alpha-2": "LI", "country-code": "438" },
        "lithuania": { "name": "Lithuania", "alpha-2": "LT", "country-code": "440" },
        "luxembourg": { "name": "Luxembourg", "alpha-2": "LU", "country-code": "442" },
        "macao": { "name": "Macao", "alpha-2": "MO", "country-code": "446" },
        "macedonia (the former yugoslav republic of)": {
            "name": "Macedonia (the former Yugoslav Republic of)",
            "alpha-2": "MK",
            "country-code": "807"
        },
        "macedonia the former yugoslav republic of": {
            "name": "Macedonia The Former Yugoslav Republic Of",
            "alpha-2": "MK",
            "country-code": "807"
        },
        "madagascar": { "name": "Madagascar", "alpha-2": "MG", "country-code": "450" },
        "malawi": { "name": "Malawi", "alpha-2": "MW", "country-code": "454" },
        "malaysia": { "name": "Malaysia", "alpha-2": "MY", "country-code": "458" },
        "maldives": { "name": "Maldives", "alpha-2": "MV", "country-code": "462" },
        "mali": { "name": "Mali", "alpha-2": "ML", "country-code": "466" },
        "malta": { "name": "Malta", "alpha-2": "MT", "country-code": "470" },
        "marshall islands": { "name": "Marshall Islands", "alpha-2": "MH", "country-code": "584" },
        "martinique": { "name": "Martinique", "alpha-2": "MQ", "country-code": "474" },
        "mauritania": { "name": "Mauritania", "alpha-2": "MR", "country-code": "478" },
        "mauritius": { "name": "Mauritius", "alpha-2": "MU", "country-code": "480" },
        "mayotte": { "name": "Mayotte", "alpha-2": "YT", "country-code": "175" },
        "mexico": { "name": "Mexico", "alpha-2": "MX", "country-code": "484" },
        "micronesia (federated states of)": {
            "name": "Micronesia (Federated States of)",
            "alpha-2": "FM",
            "country-code": "583"
        },
        "micronesia federated states of": {
            "name": "Micronesia Federated States Of",
            "alpha-2": "FM",
            "country-code": "583"
        },
        "moldova (republic of)": { "name": "Moldova (Republic of)", "alpha-2": "MD", "country-code": "498" },
        "moldova republic of": { "name": "Moldova Republic Of", "alpha-2": "MD", "country-code": "498" },
        "monaco": { "name": "Monaco", "alpha-2": "MC", "country-code": "492" },
        "mongolia": { "name": "Mongolia", "alpha-2": "MN", "country-code": "496" },
        "montenegro": { "name": "Montenegro", "alpha-2": "ME", "country-code": "499" },
        "montserrat": { "name": "Montserrat", "alpha-2": "MS", "country-code": "500" },
        "morocco": { "name": "Morocco", "alpha-2": "MA", "country-code": "504" },
        "mozambique": { "name": "Mozambique", "alpha-2": "MZ", "country-code": "508" },
        "myanmar": { "name": "Myanmar", "alpha-2": "MM", "country-code": "104" },
        "namibia": { "name": "Namibia", "alpha-2": "NA", "country-code": "516" },
        "nauru": { "name": "Nauru", "alpha-2": "NR", "country-code": "520" },
        "nepal": { "name": "Nepal", "alpha-2": "NP", "country-code": "524" },
        "netherlands": { "name": "Netherlands", "alpha-2": "NL", "country-code": "528" },
        "new caledonia": { "name": "New Caledonia", "alpha-2": "NC", "country-code": "540" },
        "new zealand": { "name": "New Zealand", "alpha-2": "NZ", "country-code": "554" },
        "nicaragua": { "name": "Nicaragua", "alpha-2": "NI", "country-code": "558" },
        "niger": { "name": "Niger", "alpha-2": "NE", "country-code": "562" },
        "nigeria": { "name": "Nigeria", "alpha-2": "NG", "country-code": "566" },
        "niue": { "name": "Niue", "alpha-2": "NU", "country-code": "570" },
        "norfolk island": { "name": "Norfolk Island", "alpha-2": "NF", "country-code": "574" },
        "northern mariana islands": { "name": "Northern Mariana Islands", "alpha-2": "MP", "country-code": "580" },
        "norway": { "name": "Norway", "alpha-2": "NO", "country-code": "578" },
        "oman": { "name": "Oman", "alpha-2": "OM", "country-code": "512" },
        "pakistan": { "name": "Pakistan", "alpha-2": "PK", "country-code": "586" },
        "palau": { "name": "Palau", "alpha-2": "PW", "country-code": "585" },
        "palestine, state of": { "name": "Palestine, State of", "alpha-2": "PS", "country-code": "275" },
        "panama": { "name": "Panama", "alpha-2": "PA", "country-code": "591" },
        "papua new guinea": { "name": "Papua New Guinea", "alpha-2": "PG", "country-code": "598" },
        "paraguay": { "name": "Paraguay", "alpha-2": "PY", "country-code": "600" },
        "peru": { "name": "Peru", "alpha-2": "PE", "country-code": "604" },
        "philippines": { "name": "Philippines", "alpha-2": "PH", "country-code": "608" },
        "pitcairn": { "name": "Pitcairn", "alpha-2": "PN", "country-code": "612" },
        "poland": { "name": "Poland", "alpha-2": "PL", "country-code": "616" },
        "portugal": { "name": "Portugal", "alpha-2": "PT", "country-code": "620" },
        "puerto rico": { "name": "Puerto Rico", "alpha-2": "PR", "country-code": "630" },
        "qatar": { "name": "Qatar", "alpha-2": "QA", "country-code": "634" },
        "runion": { "name": "Runion", "alpha-2": "RE", "country-code": "638" },
        "reunion": { "name": "Reunion", "alpha-2": "RE", "country-code": "638" },
        "romania": { "name": "Romania", "alpha-2": "RO", "country-code": "642" },
        "russian federation": { "name": "Russian Federation", "alpha-2": "RU", "country-code": "643" },
        "rwanda": { "name": "Rwanda", "alpha-2": "RW", "country-code": "646" },
        "saint barthlemy": { "name": "Saint Barthlemy", "alpha-2": "BL", "country-code": "652" },
        "saint helena, ascension and tristan da cunha": {
            "name": "Saint Helena, Ascension and Tristan da Cunha",
            "alpha-2": "SH",
            "country-code": "654"
        },
        "saint kitts and nevis": { "name": "Saint Kitts and Nevis", "alpha-2": "KN", "country-code": "659" },
        "saint lucia": { "name": "Saint Lucia", "alpha-2": "LC", "country-code": "662" },
        "saint martin (french part)": { "name": "Saint Martin (French part)", "alpha-2": "MF", "country-code": "663" },
        "saint pierre and miquelon": { "name": "Saint Pierre and Miquelon", "alpha-2": "PM", "country-code": "666" },
        "saint vincent and the grenadines": {
            "name": "Saint Vincent and the Grenadines",
            "alpha-2": "VC",
            "country-code": "670"
        },
        "samoa": { "name": "Samoa", "alpha-2": "WS", "country-code": "882" },
        "san marino": { "name": "San Marino", "alpha-2": "SM", "country-code": "674" },
        "sao tome and principe": { "name": "Sao Tome and Principe", "alpha-2": "ST", "country-code": "678" },
        "saudi arabia": { "name": "Saudi Arabia", "alpha-2": "SA", "country-code": "682" },
        "senegal": { "name": "Senegal", "alpha-2": "SN", "country-code": "686" },
        "serbia": { "name": "Serbia", "alpha-2": "RS", "country-code": "688" },
        "serbia and montenegro": { "name": "Serbia and Montenegro", "alpha-2": "RS", "country-code": "688" },
        "seychelles": { "name": "Seychelles", "alpha-2": "SC", "country-code": "690" },
        "sierra leone": { "name": "Sierra Leone", "alpha-2": "SL", "country-code": "694" },
        "singapore": { "name": "Singapore", "alpha-2": "SG", "country-code": "702" },
        "sint maarten (dutch part)": { "name": "Sint Maarten (Dutch part)", "alpha-2": "SX", "country-code": "534" },
        "slovakia": { "name": "Slovakia", "alpha-2": "SK", "country-code": "703" },
        "slovenia": { "name": "Slovenia", "alpha-2": "SI", "country-code": "705" },
        "solomon islands": { "name": "Solomon Islands", "alpha-2": "SB", "country-code": "090" },
        "somalia": { "name": "Somalia", "alpha-2": "SO", "country-code": "706" },
        "south africa": { "name": "South Africa", "alpha-2": "ZA", "country-code": "710" },
        "south georgia and the south sandwich islands": {
            "name": "South Georgia and the South Sandwich Islands",
            "alpha-2": "GS",
            "country-code": "239"
        },
        "south sudan": { "name": "South Sudan", "alpha-2": "SS", "country-code": "728" },
        "spain": { "name": "Spain", "alpha-2": "ES", "country-code": "724" },
        "sri lanka": { "name": "Sri Lanka", "alpha-2": "LK", "country-code": "144" },
        "sudan": { "name": "Sudan", "alpha-2": "SD", "country-code": "729" },
        "suriname": { "name": "Suriname", "alpha-2": "SR", "country-code": "740" },
        "svalbard and jan mayen": { "name": "Svalbard and Jan Mayen", "alpha-2": "SJ", "country-code": "744" },
        "swaziland": { "name": "Swaziland", "alpha-2": "SZ", "country-code": "748" },
        "sweden": { "name": "Sweden", "alpha-2": "SE", "country-code": "752" },
        "switzerland": { "name": "Switzerland", "alpha-2": "CH", "country-code": "756" },
        "syrian arab republic": { "name": "Syrian Arab Republic", "alpha-2": "SY", "country-code": "760" },
        "taiwan, province of china": { "name": "Taiwan, Province of China", "alpha-2": "TW", "country-code": "158" },
        "taiwan province of china": { "name": "Taiwan Province Of China", "alpha-2": "TW", "country-code": "158" },
        "taiwan": { "name": "Taiwan", "alpha-2": "TW", "country-code": "158" },
        "tajikistan": { "name": "Tajikistan", "alpha-2": "TJ", "country-code": "762" },
        "tanzania, united republic of": {
            "name": "Tanzania, United Republic of",
            "alpha-2": "TZ",
            "country-code": "834"
        },
        "thailand": { "name": "Thailand", "alpha-2": "TH", "country-code": "764" },
        "timor-leste": { "name": "Timor-Leste", "alpha-2": "TL", "country-code": "626" },
        "togo": { "name": "Togo", "alpha-2": "TG", "country-code": "768" },
        "tokelau": { "name": "Tokelau", "alpha-2": "TK", "country-code": "772" },
        "tonga": { "name": "Tonga", "alpha-2": "TO", "country-code": "776" },
        "trinidad and tobago": { "name": "Trinidad and Tobago", "alpha-2": "TT", "country-code": "780" },
        "tunisia": { "name": "Tunisia", "alpha-2": "TN", "country-code": "788" },
        "turkey": { "name": "Turkey", "alpha-2": "TR", "country-code": "792" },
        "turkmenistan": { "name": "Turkmenistan", "alpha-2": "TM", "country-code": "795" },
        "turks and caicos islands": { "name": "Turks and Caicos Islands", "alpha-2": "TC", "country-code": "796" },
        "tuvalu": { "name": "Tuvalu", "alpha-2": "TV", "country-code": "798" },
        "uganda": { "name": "Uganda", "alpha-2": "UG", "country-code": "800" },
        "ukraine": { "name": "Ukraine", "alpha-2": "UA", "country-code": "804" },
        "united arab emirates": { "name": "United Arab Emirates", "alpha-2": "AE", "country-code": "784" },
        "united kingdom of great britain and northern ireland": {
            "name": "United Kingdom of Great Britain and Northern Ireland",
            "alpha-2": "GB",
            "country-code": "826"
        },
        "united kingdom": {
            "name": "United Kingdom",
            "alpha-2": "GB",
            "country-code": "826"
        },
        "united states of america": { "name": "United States of America", "alpha-2": "US", "country-code": "840" },
        "usa": { "name": "USA", "alpha-2": "US", "country-code": "840" },
        "united states": { "name": "United States", "alpha-2": "US", "country-code": "840" },
        "united states minor outlying islands": {
            "name": "United States Minor Outlying Islands",
            "alpha-2": "UM",
            "country-code": "581"
        },
        "uruguay": { "name": "Uruguay", "alpha-2": "UY", "country-code": "858" },
        "uzbekistan": { "name": "Uzbekistan", "alpha-2": "UZ", "country-code": "860" },
        "vanuatu": { "name": "Vanuatu", "alpha-2": "VU", "country-code": "548" },
        "venezuela (bolivarian republic of)": {
            "name": "Venezuela (Bolivarian Republic of)",
            "alpha-2": "VE",
            "country-code": "862"
        },
        "venezuela": { "name": "Venezuela", "alpha-2": "VE", "country-code": "862" },
        "viet nam": { "name": "Viet Nam", "alpha-2": "VN", "country-code": "704" },
        "virgin islands (british)": { "name": "Virgin Islands (British)", "alpha-2": "VG", "country-code": "092" },
        "virgin islands (u.s.)": { "name": "Virgin Islands (U.S.)", "alpha-2": "VI", "country-code": "850" },
        "wallis and futuna": { "name": "Wallis and Futuna", "alpha-2": "WF", "country-code": "876" },
        "western sahara": { "name": "Western Sahara", "alpha-2": "EH", "country-code": "732" },
        "yemen": { "name": "Yemen", "alpha-2": "YE", "country-code": "887" },
        "zambia": { "name": "Zambia", "alpha-2": "ZM", "country-code": "894" },
        "zimbabwe": { "name": "Zimbabwe", "alpha-2": "ZW", "country-code": "716" }
    };
    angular.module('Config')
        .constant('countryCodes', countryCodes);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared', [
        'Fortscale.shared.services',
        'Fortscale.shared.directives',
        'Fortscale.shared.components',
        'Fortscale.shared.filters',
        'Fortscale.shared.service.fsDownloadFile'
    ]);
}());







(function () {
    'use strict';
    angular.module('Fortscale.shared.services', [
        'Fortscale.shared.services.assert',
        'Fortscale.shared.services.dependencyMounter',
        'Fortscale.shared.services.objectUtils',
        'Fortscale.shared.services.interpolation',
        'Fortscale.shared.services.CSVConverter',
        'Fortscale.shared.services.URLUtils',
        'Fortscale.shared.services.tableSettingsUtil',
        'Fortscale.shared.services.jsonLoader',
        'Fortscale.shared.services.indicatorTypeMapper',
        'Fortscale.shared.services.modelUtils',
        'Fortscale.shared.services.fsModals',
        'Fortscale.shared.services.dateRanges',
        'Fortscale.shared.services.tagsUtils',
        'Fortscale.shared.services.countryCodesUtil',
        'Fortscale.shared.services.fsIndicatorTypes',
        'Fortscale.shared.services.fsIndicatorGraphsHandler',
        'Fortscale.shared.services.fsIndexedDBService',
        'Fortscale.shared.services.stringUtils',
        'Fortscale.shared.services.fsIndicatorErrorCodes',
        'Fortscale.shared.services.fsNanobarAutomation',
        'Fortscale.shared.services.entityActivityUtils',
        'Fortscale.shared.services.toastrService'
    ]);
}());

(function () {
    'use strict';
    function assertFactory() {
        /**
         *
         * @param {boolean | *} condition
         * @param {string=} message
         * @param {function=} ErrorType The object should be
         */
        function assert(condition, message, ErrorType) {
            // Create an early return when condition is fulfilled to prevent execution of futile code.
            if (condition) {
                return;
            }
            // Set defaults
            message = message || '';
            var error;
            // Verify error type is valid. If it's not, then Error type should be error
            if (typeof ErrorType === 'function') {
                // Create new error from Error type
                error = new ErrorType(message);
            }
            // If ErrorType is not a function or (newly populated) error is not an instance of Error
            // Then error should be new Error
            if (!(error instanceof Error)) {
                error = new Error(message);
            }
            throw error;
        }
        /**
         * Validates that a variable is string and not an empty string
         *
         * @param {string} str
         * @param {string} strName
         * @param {string=} errMsg Defaults to empty string
         * @param {boolean=} isOptional Defaults to false
         * @param {boolean=} canBeEmpty Defaults to false
         */
        assert.isString = function (str, strName, errMsg, isOptional, canBeEmpty) {
            errMsg = errMsg || '';
            isOptional = !!isOptional;
            canBeEmpty = !!canBeEmpty;
            if (!(str === undefined && isOptional)) {
                assert(!_.isUndefined(str), errMsg + strName + ' must be provided.', ReferenceError);
                assert(_.isString(str), errMsg + strName + ' must be a string.', TypeError);
                assert(str !== '' || canBeEmpty, errMsg + strName + ' must not be an empty string.', RangeError);
            }
        };
        /**
         * Validates that a variable is string and not an empty string
         *
         * @param {number} num
         * @param {string} numName
         * @param {string=} errMsg Defaults to empty string
         * @param {boolean=} isOptional Defaults to false
         */
        assert.isNumber = function (num, numName, errMsg, isOptional) {
            errMsg = errMsg || '';
            isOptional = !!isOptional;
            if (!(num === undefined && isOptional)) {
                assert(!_.isUndefined(num), errMsg + numName + ' must be provided.', ReferenceError);
                assert(_.isNumber(num), errMsg + numName + ' must be a number.', TypeError);
            }
        };
        /**
         * Validates that a variable is an array
         *
         * @param {string} arr
         * @param {string} arrName
         * @param {string=} errMsg Defaults to empty string
         * @param {boolean=} isOptional Defaults to false
         */
        assert.isArray = function (arr, arrName, errMsg, isOptional) {
            errMsg = errMsg || '';
            isOptional = !!isOptional;
            if (!(arr === undefined && isOptional)) {
                assert(!_.isUndefined(arr), errMsg + arrName + ' must be provided.', ReferenceError);
                assert(_.isArray(arr), errMsg + arrName + ' must be an array.', TypeError);
            }
        };
        /**
         * Validates that a variable is a function
         *
         * @param {string} fn
         * @param {string} fnName
         * @param {string=} errMsg Defaults to empty string
         * @param {boolean=} isOptional Defaults to false
         */
        assert.isFunction = function (fn, fnName, errMsg, isOptional) {
            errMsg = errMsg || '';
            isOptional = !!isOptional;
            if (!(fn === undefined && isOptional)) {
                assert(!_.isUndefined(fn), errMsg + fnName + ' must be provided.', ReferenceError);
                assert(_.isFunction(fn), errMsg + fnName + ' must be a function.', TypeError);
            }
        };
        /**
         * Validates that a variable is a function
         *
         * @param {string} obj
         * @param {string} objName
         * @param {string=} errMsg Defaults to empty string
         * @param {boolean=} isOptional Defaults to false
         */
        assert.isObject = function (obj, objName, errMsg, isOptional) {
            errMsg = errMsg || '';
            isOptional = !!isOptional;
            if (!(obj === undefined && isOptional)) {
                assert(!_.isUndefined(obj), errMsg + objName + ' must be provided.', ReferenceError);
                assert(_.isObject(obj), errMsg + objName + ' must be an object.', TypeError);
            }
        };
        return assert;
    }
    angular.module('Fortscale.shared.services.assert', [])
        .factory('assert', assertFactory)
        .constant('assertConstant', assertFactory());
}());

(function () {
    'use strict';
    /**
     * The purpose of this service is to provide an alternative way for injecting dependencies.
     *
     *
     * @param {object} $injector Angular service for injecting dependencies.
     * @constructor
     */
    function DependencyMounter($injector) {
        /**
         * PRIVATE PROPERTIES
         */
        /**
         * Holds the error message start.
         *
         * @type {string}
         * @private
         */
        this._errorMsgStart = 'Fortscale.shared.services.dependencyMounter: ';
        /**
         * PRIVATE VALIDATIONS
         */
        /**
         * Validates a Constructor function
         *
         * @param {string} methodName The name of the method requesting validation
         * @param {function} Constructor The constructor function being validated
         * @private
         */
        this._validateConstructor = function _validateConstructor(methodName, Constructor) {
            // error msg start
            var errMsgStart = this._errorMsgStart + methodName + ': ';
            // Validate Constructor is received.
            // If it's not received, throw ReferenceError
            if (!angular.isDefined(Constructor)) {
                throw new ReferenceError(errMsgStart + 'Constructor argument must be provided.');
            }
            // Validate Constructor is a function
            // If not throw Type error.
            if (!angular.isFunction(Constructor)) {
                throw new TypeError(errMsgStart + 'Constructor argument must be a function.');
            }
        };
        /**
         * Validates a Constructor
         *
         * @param {string} methodName The name of the method requesting validation
         * @param {object} instance The instance object being validated
         * @private
         */
        this._validateInstance = function _validateInstance(methodName, instance) {
            // error msg start
            var errMsgStart = this._errorMsgStart + methodName + ': ';
            // Validate instance is received.
            // If it's not received, throw ReferenceError
            if (!angular.isDefined(instance)) {
                throw new ReferenceError(errMsgStart + 'instance argument must be provided.');
            }
            // Validate instance is an object. If it isn't throw TypeError.
            if (!angular.isObject(instance)) {
                throw new TypeError(errMsgStart + 'instance argument must be an object.');
            }
        };
        /**
         * Validates an array of strings
         *
         * @param {string} methodName The name of the method requesting validation
         * @param {Array<string>} arrDependencies The instance object being validated
         * @private
         */
        this._validateArrDependencies = function _validateArrDependencies(methodName, arrDependencies) {
            // error msg start
            var errMsgStart = this._errorMsgStart + methodName + ': ';
            // Validate arrDependencies is received.
            // If not throw ReferenceError
            if (!angular.isDefined(arrDependencies)) {
                throw new ReferenceError(errMsgStart + 'arrDependencies argument must be provided.');
            }
            // validate arrDependencies is an array.
            // If not, throw TypeError
            if (!angular.isArray(arrDependencies)) {
                throw new TypeError(errMsgStart + 'arrDependencies argument must be an array.');
            }
            // Validate all members are strings.
            // If not throw TypeError
            angular.forEach(arrDependencies, function (dependecy, index) {
                if (!angular.isString(dependecy)) {
                    throw new TypeError(errMsgStart + 'arrDependencies array member ' + index + ' is not a string.' +
                        ' All members must be strings.');
                }
            });
        };
        /**
         * PRIVATE METHODS
         */
        /**
         * Iterate through arrDependencies and get the dependency for each, then mount
         * that dependency on the object if that key is undefined.
         *
         * @param {object} obj The object that the dependencies are to be mounter on
         * @param {Array<string>} arrDependencies The list of dependency names
         * @private
         */
        this._mountOnObject = function _mountOnObject(obj, arrDependencies) {
            // Iterate through dependencies and mount each dependency on prototype (if not already there)
            angular.forEach(arrDependencies, function (dependency) {
                if (!angular.isDefined(obj[dependency])) {
                    obj[dependency] = $injector.get(dependency);
                }
            });
        };
        /**
         * Iterate through arrDependencies, and for each dependency name, it gets the dependency,
         * and uses angular.extend to extend the object.
         *
         * @param {object} obj The object that the dependencies are to be mounter on
         * @param {Array<string>} arrDependencies The list of dependency names
         * @private
         */
        this._extendObject = function _extendObject(obj, arrDependencies) {
            // Iterate through dependencies and mount each dependency on prototype (if not already there)
            angular.forEach(arrDependencies, function (dependency) {
                angular.extend(obj, $injector.get(dependency));
            });
        };
        /**
         * PUBLIC METHODS
         */
        /**
         * Takes a constructor function and a list of dependency names, gets the dependencies and mounts them on the
         * constructor's prototype
         *
         * @param {function} Constructor
         * @param {Array<string>} arrDependencies An array of string where each string is a name of a dependency
         */
        this.mountOnConstructor = function mountOnConstructor(Constructor, arrDependencies) {
            // Validations
            this._validateConstructor('mountOnConstructor', Constructor);
            this._validateArrDependencies('mountOnConstructor', arrDependencies);
            // Start mounting process
            this._mountOnObject(Constructor.prototype, arrDependencies);
        };
        /**
         * Takes an instance object and a list of dependency names, gets the dependencies and mounts them on the
         * constructor's prototype
         *
         * @param {object} instance A controller's instance
         * @param {Array<string>} arrDependencies An array of string where each string is a name of a dependency
         */
        this.mountOnInstance = function mountOnInstance(instance, arrDependencies) {
            // Validations
            this._validateInstance('mountOnInstance', instance);
            this._validateArrDependencies('mountOnInstance', arrDependencies);
            // Start mounting process
            this._mountOnObject(instance, arrDependencies);
        };
        this.extendConstructor = function extendConstructor(Constructor, arrDependencies) {
            // Validations
            this._validateConstructor('mountOnConstructor', Constructor);
            this._validateArrDependencies('mountOnConstructor', arrDependencies);
            // Start mounting process
            this._extendObject(Constructor.prototype, arrDependencies);
        };
        this.extendInstance = function extendInstance(instance, arrDependencies) {
            // Validations
            this._validateInstance('mountOnInstance', instance);
            this._validateArrDependencies('mountOnInstance', arrDependencies);
            // Start mounting process
            this._extendObject(instance, arrDependencies);
        };
    }
    DependencyMounter.$inject = ['$injector'];
    angular.module('Fortscale.shared.services.dependencyMounter', [])
        .service('dependencyMounter', DependencyMounter);
}());

(function () {
    'use strict';
    /**
     * This service is used to open an iframe and download a file.
     *
     * @constructor
     */
    function FsDownloadFile(assert) {
        /**
         * Opens an iframe, downloads a file, then (if shouldRemoveOnDone) removes the iframe.
         *
         * @param {string} src
         * @param {boolean=} shouldRemoveOnDone
         * @returns {Element}
         */
        this.openIFrame = function (src, shouldRemoveOnDone) {
            // Validate src
            assert.isString(src, 'src', 'FsDownloadFile: openIFrame: ', false, false);
            if (shouldRemoveOnDone === undefined) {
                shouldRemoveOnDone = true;
            }
            // Open new Iframe to download
            var iframe = document.createElement('iframe');
            iframe.style.display = "none";
            var html = document.getElementsByTagName('html')[0];
            html.appendChild(iframe);
            // If shouldRemoveOnDone then on file load remove the iframe
            if (shouldRemoveOnDone) {
                $(iframe).load(function () {
                    html.removeChild(iframe);
                });
            }
            iframe.src = src;
            return iframe;
        };
    }
    FsDownloadFile.$inject = ['assert'];
    angular.module('Fortscale.shared.service.fsDownloadFile', [])
        .service('fsDownloadFile', FsDownloadFile);
}());

(function () {
    'use strict';
    var IS_NOT_OPTIONAL = false;
    var CAN_NOT_BE_EMPTY = false;
    var IS_OPTIONAL = true;
    function FsIndicatorGraphsHandlerProvider(assert) {
        var provider = this;
        provider._errMsg = "FsIndicatorGraphsHandlerProvider: ";
        provider._indicatorQueries = new Map();
        /**
         * Add an indicator query. This will add a query to match the indicator and a handler function to fire
         * when indicator is matched
         *
         * @param {object} queryObj Will be used as the query object to determine which handler function to use
         * @param handlerFn The function to invoke when indicator has matched the query
         */
        provider.addIndicatorQuery = function (queryObj, handlerFn) {
            var errMsg = provider._errMsg + "addIndicatorQuery: ";
            // Validations
            assert.isObject(queryObj, 'queryObj', errMsg, IS_NOT_OPTIONAL);
            assert.isFunction(handlerFn, 'handlerFn', errMsg, IS_NOT_OPTIONAL);
            var queryObjectKey;
            try {
                queryObjectKey = JSON.stringify(queryObj);
            }
            catch (e) {
                throw new RangeError(errMsg + "queryObj must be a parseble to string.", e);
            }
            assert(typeof provider._indicatorQueries.get(queryObjectKey) === 'undefined', errMsg + "queryObj must be a unique query.", RangeError);
            // Add query object and handler function
            provider._indicatorQueries.set(queryObjectKey, { query: queryObj, handlerFn: handlerFn });
        };
        /**
         * PROVIDER'S FACTORY
         */
        function fsIndicatorGraphsHandlerFactory($location, $rootScope) {
            var errMsg = "fsIndicatorGraphsHandlerFactory: ";
            /**
             * Takes a selector and returns the indicator from the element's controller.
             *
             * @param {string} selector
             * @returns {object|null} Returns an indicator or null
             */
            function getIndicatorBySelector(selector) {
                assert.isString(selector, 'selector', errMsg + "getIndicatorBySelector: ", IS_NOT_OPTIONAL);
                var element = $(selector);
                if (!element.length) {
                    return null;
                }
                var controller = angular.element(element[0]).controller();
                if (!controller) {
                    return null;
                }
                return controller.indicator || null;
            }
            /**
             * Takes an indicator and iterates through queries. When a query matches, the handlerFn is returned.
             * If no match is made, null is returned.
             *
             * @param {object} indicator The indicator to be matched
             * @returns {function|null} Returns a handlerFn or null;
             */
            function getHandlerFnByIndicator(indicator) {
                assert.isObject(indicator, 'indicator', errMsg + "getHandlerFnByIndicator: ", IS_NOT_OPTIONAL);
                var queriesHandlers = Array.from(provider._indicatorQueries.values());
                var selectedQueryHandler = null;
                for (var _i = 0, queriesHandlers_1 = queriesHandlers; _i < queriesHandlers_1.length; _i++) {
                    var queryHandler = queriesHandlers_1[_i];
                    if (_.find([indicator], queryHandler.query)) {
                        selectedQueryHandler = queryHandler;
                        break;
                    }
                }
                if (selectedQueryHandler) {
                    return selectedQueryHandler.handlerFn;
                }
                return null;
            }
            /**
             * Matches a handlerFn to an indicator, and if match is made, the handlerFn is invoked.
             *
             * @param {object} indicator
             * @param {*} value
             * @param {string=} identifier
             * @returns {null|*}
             */
            function invokeHandlerByIndicator(indicator, value, identifier) {
                assert.isObject(indicator, 'indicator', errMsg + "getHandlerFnByIndicator: ", IS_NOT_OPTIONAL);
                assert.isString(identifier, 'identifier', errMsg + "getHandlerFnByIndicator: ", IS_OPTIONAL);
                var handlerFn = api.getHandlerFnByIndicator(indicator);
                if (handlerFn) {
                    return handlerFn(indicator, value, identifier);
                }
                return null;
            }
            /**
             * Takes a data source id and a search object, and uses $location.path to transition to Explore page.
             *
             * @param {string} dataSourceId
             * @param {object=} search
             */
            function goToExplore(dataSourceId, search) {
                // Validations
                assert.isString(dataSourceId, 'dataSourceId', errMsg + "goToExplore: ", IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
                assert.isObject(search, 'search', errMsg + "goToExplore: ", IS_OPTIONAL);
                // We use applyAsync because there is no guaranty that angular is not in a digest phase when the
                // function is called.
                $rootScope.$applyAsync(function () {
                    $location.path('/d/explore/' + dataSourceId).search(search);
                });
            }
            var api = {
                getIndicatorBySelector: getIndicatorBySelector,
                getHandlerFnByIndicator: getHandlerFnByIndicator,
                invokeHandlerByIndicator: invokeHandlerByIndicator,
                goToExplore: goToExplore
            };
            return api;
        }
        this.$get = ['$location', '$rootScope', fsIndicatorGraphsHandlerFactory];
    }
    FsIndicatorGraphsHandlerProvider.$inject = ['assertConstant'];
    angular.module('Fortscale.shared.services.fsIndicatorGraphsHandler', [])
        .provider('fsIndicatorGraphsHandler', FsIndicatorGraphsHandlerProvider);
}());

(function () {
    'use strict';
    var fsIndicatorGraphsHandler;
    angular.module('Fortscale.shared.services.fsIndicatorGraphsHandler')
        .run(['$location', '$rootScope', 'fsIndicatorGraphsHandler',
        function (_$location_, _$rootScope_, _fsIndicatorGraphsHandler_) {
            // Get the service so it will be available on angular's event_loop phase
            fsIndicatorGraphsHandler = _fsIndicatorGraphsHandler_;
        }])
        .config(['fsIndicatorGraphsHandlerProvider', function (fsIndicatorGraphsHandlerProvider) {
            // Source Machine Click Handler
            fsIndicatorGraphsHandlerProvider.addIndicatorQuery({
                anomalyTypeFieldName: 'source_machine'
            }, 
            /**
             *
             * @param {{entityName: string, anomalyValue: string, dataEntitiesIds: array<string>,
             * startDate: number}} indicator
             * @param {{name: string}} point
             * @param identifier
             */
            function sourceMachineIndicatorGraphHandler(indicator, point, identifier) {
                if (point.name.toLocaleLowerCase() === "others") {
                    return;
                }
                var user, dataSourceId, sourceDevice, startTime, endDate, minScore;
                // populate user and sourceDevice based on chart identifier
                if (identifier === "left-column") {
                    user = indicator.entityName;
                    sourceDevice = point.name;
                }
                else if (identifier === "right-column") {
                    user = point.name;
                    sourceDevice = indicator.anomalyValue;
                }
                else {
                    return;
                }
                // Populate dataSourceId, startTime, endDate, minScore
                dataSourceId = indicator.dataEntitiesIds[0];
                startTime = moment.utc(indicator.startDate).subtract(90, 'days').valueOf();
                endDate = moment.utc(indicator.startDate).valueOf();
                minScore = 0;
                // Populate filters and defaultFilters
                var filters = "users.normalized_username=" + user + ',' +
                    dataSourceId + ".source_machine=" + sourceDevice;
                var defaultFilters = dataSourceId + ".event_time_utc=:" + startTime + '::' + endDate + ',' +
                    dataSourceId + ".event_score=>=" + minScore;
                // Go to Explore
                fsIndicatorGraphsHandler
                    .goToExplore(dataSourceId, { filters: filters, default_filters: defaultFilters });
            });
            // Source Machine Click Handler
            fsIndicatorGraphsHandlerProvider.addIndicatorQuery({
                anomalyTypeFieldName: "destination_machine"
            }, function destinationMachineIndicatorGraphHandler(indicator, point, identifier) {
                if (point.name.toLocaleLowerCase() === "others") {
                    return;
                }
                var user, dataSourceId, targetDevice, startTime, endDate, minScore;
                // populate user and targetDevice based on chart identifier
                if (identifier === "left-column") {
                    user = indicator.entityName;
                    targetDevice = point.name;
                }
                else if (identifier === "right-column") {
                    user = point.name;
                    targetDevice = indicator.anomalyValue;
                }
                else {
                    return;
                }
                // Populate dataSourceId, startTime, endDate, minScore
                dataSourceId = indicator.dataEntitiesIds[0];
                startTime = moment.utc(indicator.startDate).subtract(90, 'days').valueOf();
                endDate = moment.utc(indicator.startDate).valueOf();
                minScore = 0;
                // Populate filters and defaultFilters
                var filters = "users.normalized_username=" + user + ',' +
                    dataSourceId + ".destination_machine=" + targetDevice;
                var defaultFilters = dataSourceId + ".event_time_utc=:" + startTime + '::' + endDate + ',' +
                    dataSourceId + ".event_score=>=" + minScore;
                // Go to Explore
                fsIndicatorGraphsHandler
                    .goToExplore(dataSourceId, { filters: filters, default_filters: defaultFilters });
            });
            // Country Click Handler
            fsIndicatorGraphsHandlerProvider.addIndicatorQuery({
                anomalyTypeFieldName: "country"
            }, function countryIndicatorGraphHandler(indicator, point, identifier) {
                if (point.name.toLocaleLowerCase() === "others") {
                    return;
                }
                var user, dataSourceId, sourceCountry, startTime, endDate, minScore;
                // populate user and targetDevice based on chart identifier
                if (identifier === "left-column") {
                    user = indicator.entityName;
                    sourceCountry = point.name;
                }
                else if (identifier === "right-column") {
                    user = point.name;
                    sourceCountry = indicator.anomalyValue;
                }
                else {
                    return;
                }
                // Populate dataSourceId, startTime, endDate, minScore
                dataSourceId = indicator.dataEntitiesIds[0];
                startTime = moment.utc(indicator.startDate).subtract(90, 'days').valueOf();
                endDate = moment.utc(indicator.startDate).valueOf();
                minScore = 0;
                // Populate filters and defaultFilters
                var filters = "users.normalized_username=" + user + ',' +
                    dataSourceId + ".country=" + sourceCountry;
                var defaultFilters = dataSourceId + ".event_time_utc=:" + startTime + '::' + endDate + ',' +
                    dataSourceId + ".event_score=>=" + minScore;
                // Go to Explore
                fsIndicatorGraphsHandler
                    .goToExplore(dataSourceId, { filters: filters, default_filters: defaultFilters });
            });
        }]);
}());

(function () {
    'use strict';
    /**
     * Service used by fs-state-container directive to manage the queries and data fetching
     *
     * @param $interpolate
     * @constructor
     */
    function Interpolation($interpolate) {
        /**
         * PRIVATE PROPERTIES
         */
        this._errMessageStart = 'interpolation: ';
        /**
         * PRIVATE METHODS
         */
        /**
         * Takes a template, string or object. Returns a stringified string,
         * or throws SyntaxError if object can not be stringified.
         *
         * @param {string | object} template
         * @returns {string}
         * @private
         */
        this._convertTemplateToString = function _convertTemplateToString(template) {
            var self = this;
            if (angular.isString(template)) {
                return template;
            }
            try {
                return JSON.stringify(template);
            }
            catch (e) {
                var errMsg = self._errMessageStart +
                    '_convertTemplateToString: template provided is not a string, ' +
                    'and can not be stringified wite JSON.stringify.\n' + e.message;
                throw new SyntaxError(errMsg);
            }
        };
        /**
         * Takes a template string and tries to JSON.parse it into an object.
         * If JSON.parse fails, it throws a SyntaxError
         *
         * @param {string} templateString
         * @private
         */
        this._convertStringToObject = function _convertStringToObject(templateString) {
            var self = this;
            try {
                return JSON.parse(templateString);
            }
            catch (e) {
                var errMsg = self._errMessageStart +
                    '_convertStringToObject: templateString provided ' +
                    'could not be parsed to object.\nThe string:\n' + templateString + '\n' +
                    e.message;
                throw new SyntaxError(errMsg);
            }
        };
        /**
         * Takes a query value, a changeTo value (or function) and an object. It iterates through
         * all object values (also nested) and if a certain value matches the queryValue, the state
         * property will change to -or by if changeTo is a function - changeTo value.
         * If changeTo is a function, the new value will be the result of changeTo(value,key,obj)
         *
         *
         * @param {*} queryValue
         * @param {string|function} changeTo
         * @param {object|Array} obj
         * @returns {*}
         * @private
         */
        this._digestAdapterItem = function (queryValue, changeTo, obj) {
            // Duplicate object/array
            if (_.isArray(obj)) {
                obj = obj.slice(0);
            }
            else {
                obj = _.merge({}, obj);
            }
            // Iterate through object's keys and invoke _digestAdapterItem recursively or
            // apply changeTo
            _.each(obj, _.bind(function (value, key) {
                // If the value of the property is an object, invoke _digestAdapterItem recursively
                if (_.isObject(value)) {
                    obj[key] = this._digestAdapterItem(queryValue, changeTo, value);
                    return;
                }
                // the property value equals to the query value, this means that the adapter should
                // be used. When the changeTo value is a function, it is invoked with value,key,obj
                // otherwise if its not a function, then the value of the property should be
                // changeTo value
                if (value === queryValue) {
                    if (_.isFunction(changeTo)) {
                        obj[key] = changeTo(value, key, obj);
                    }
                    else {
                        obj[key] = changeTo;
                    }
                }
            }, this));
            return obj;
        };
        /**
         * Takes a state adapter, and state, iterates through all values in the adapter, and for
         * each adapterItem, it invokes _digestAdapterItem which in turn will return a new state
         * object, that is potentially modified.
         *
         * @param {Array<{queryValue: *, changeTo: string|function}>=} stateAdapter
         * @param {object} state
         * @returns {Result|*}
         * @private
         */
        this._digestStateAdapter = function (stateAdapter, state) {
            _.each(stateAdapter, _.bind(function (adapterItem) {
                var queryValue = adapterItem.queryValue;
                var changeTo = adapterItem.changeTo;
                state = this._digestAdapterItem(queryValue, changeTo, state);
            }, this));
            return state;
        };
        /**
         *
         * @param {string} templateString
         * @param {object} state
         * @returns {object} The interpolated and objectified templateString
         * @private
         */
        this._interpolateTemplate = function _interpolateTemplate(templateString, state) {
            return this._convertStringToObject($interpolate(templateString)(state));
        };
        /**
         * Takes a template (string or object) and a state object, and interpolates the template
         * based on state. It returns an (post-interpolated) object.
         * If stateAdapter is provided, the state will be digested with the stateAdapter.
         *
         * @param {string|object} template
         * @param {object} state
         * @param {Array<{queryValue: *, changeTo: string|function}>=} stateAdapter
         * @returns {Object}
         */
        this.interpolate = function interpolate(template, state, stateAdapter) {
            if (stateAdapter) {
                state = this._digestStateAdapter(stateAdapter, state);
            }
            var templateString = this._convertTemplateToString(template);
            var interpolated = this._interpolateTemplate(templateString, state);
            // In the case of a string template, there is no need to do the elaborate merge,
            // because no data is dropped by converting to a string.
            if (_.isString(template)) {
                return interpolated;
            }
            // The reason a merge is returned and not the interpolated object, is that some data is
            // dumped on the convertion to string of the original object (_convertTemplateToString)
            // Functions for example are dumped in the stringfication process (this is the native
            // functionality of JSON.stringify). So in order to insert them back, the pre
            // interpolated template (if not a string) is merged with the interpolated one, so all
            // new values override old values, but missing data like functions remain.
            return _.merge({}, template, interpolated);
        };
    }
    Interpolation.$inject = ['$interpolate'];
    angular.module('Fortscale.shared.services.interpolation', [])
        .service('interpolation', Interpolation);
}());

(function () {
    'use strict';
    function ObjectUtils(assert) {
        this._errMsg = 'Fortscale.shared.services.objectUtils: ';
        /**
         *
         * @param caller
         * @param obj
         * @private
         */
        this._validateObject = function (caller, obj) {
            var errMsg = this._errMsg + caller + ': ';
            assert(angular.isDefined(obj), errMsg + 'obj argument must be provided.', ReferenceError);
            assert(angular.isObject(obj), errMsg + 'obj argument must be an object.', TypeError);
        };
        this._validateHashObject = function (caller, obj) {
            var errMsg = this._errMsg + caller + ': ';
            assert(angular.isDefined(obj), errMsg + 'hashMap argument must be provided.', ReferenceError);
            assert(angular.isObject(obj), errMsg + 'hashMap argument must be an object.', TypeError);
        };
        this._validateObjectName = function (caller, objName) {
            var errMsg = this._errMsg + caller + ': ';
            assert(angular.isDefined(objName), errMsg + 'objName argument must be provided.', ReferenceError);
            assert(angular.isString(objName), errMsg + 'objName argument must be a string.', TypeError);
            assert(objName !== '', errMsg + 'objName argument must not be an empty string.', RangeError);
        };
        /**
         * Takes an object and returns a deep flattened array of key-value pairs,
         * where the odd member is the namespace of the property and the even member is the value.
         * This function runs recursively so there is a danger of stack overflowing.
         *
         * @param {object} obj
         * @param {string} objName
         */
        this._flattenObject = function (obj, objName) {
            var self = this;
            // iterate through keys of object to flatten. If the value is not an object
            // then a key-value array is returned. If value is an object, the function is invoked
            // recursively with the object value and the key name.
            // The array is flattened for each recursion resulting in a single array of key-value
            // pairs where the odd is key and the even is value
            return _.flattenDeep(_.map(_.keys(obj), function (key) {
                var nameSpace = objName + '.' + key;
                if (_.isObject(obj[key])) {
                    return self._flattenObject(obj[key], nameSpace);
                }
                else {
                    return [nameSpace, obj[key]];
                }
            }));
        };
        /**
         * Takes an array of key-value pairs where the odd is the key and the even is the value
         * Returns a hash-map object
         *
         * @param {Array} flattenedArray An array of key value pairs
         * @returns {object} Hash map object
         * @private
         */
        this._createPairsObject = function (flattenedArray) {
            var length = flattenedArray.length;
            var pairsObject = {};
            for (var i = 0; i < length; i += 2) {
                pairsObject[flattenedArray[i]] = flattenedArray[i + 1];
            }
            return pairsObject;
        };
        /**
         * Takes an object and a dot delimited namespace.
         * Recursively build (or use if exists) an object for each namespace but the last.
         * The value will be set to the last namespace which is the property's name.
         *
         * @param {object} obj
         * @param {string} nameSpace
         * @param {*} value
         * @returns {object}
         * @private
         */
        this._inflateNameSpace = function (obj, nameSpace, value) {
            var nsList = nameSpace.split('.');
            if (nsList.length === 1) {
                obj[nsList] = value;
                return obj;
            }
            var nsCurrentPos = nsList.shift();
            obj[nsCurrentPos] = obj[nsCurrentPos] || {};
            this._inflateNameSpace(obj[nsCurrentPos], nsList.join('.'), value);
        };
        /**
         * Takes an object (possibly with nesting) and returns a flattened object
         * where each property is the namespace of the original property from the original object
         * and each value is the original value
         *
         * @param {object} obj
         * @param {string} objName
         * @returns {Object}
         */
        this.flattenToNamespace = function (obj, objName) {
            // Validations
            this._validateObject('flattenToNamespace', obj);
            this._validateObjectName('flattenToNamespace', objName);
            // Create a flattened object
            return this._createPairsObject(this._flattenObject(obj, objName));
        };
        /**
         * Takes a Key-value object where each key represents a namespace.
         * The namespace should be inflated into the provided object
         * (or new object if no object was provided) and the value set to the namespace.
         *
         * @param {object} hashMap
         * @param {object=} obj
         * @returns {object}
         */
        this.createFromFlattened = function (hashMap, obj) {
            var self = this;
            // Validate hashMap
            self._validateHashObject('createFromFlattened', hashMap);
            // Validate object
            self._validateObject('createFromFlattened', obj);
            // Default the object
            obj = obj || {};
            // Iterate through keys and inflate each namespace into the object
            _.each(hashMap, function (value, key) {
                self._inflateNameSpace(obj, key, value);
            });
            return obj;
        };
        /**
         * Removes all properties that have null values.
         * This is useful for example to pass query params and remove all that have null values.
         * It is possible to remove other values if alternativeValue is provided.
         *
         * @param {object} obj
         * @param {*=} alternativeValue
         */
        this.removeNulls = function (obj, alternativeValue) {
            // Validate object
            this._validateObject('removeNulls', obj);
            alternativeValue = alternativeValue === undefined ? null : alternativeValue;
            _.each(obj, function (value, propertyName) {
                if (value === alternativeValue) {
                    delete obj[propertyName];
                }
            });
        };
    }
    ObjectUtils.$inject = ['assert'];
    angular.module('Fortscale.shared.services.objectUtils', [
        'Fortscale.shared.services.assert'
    ])
        .service('objectUtils', ObjectUtils);
}());

(function () {
    'use strict';
    function CSVConverter(assert) {
        this.assert = assert;
    }
    angular.merge(CSVConverter.prototype, {
        /**
         * The start of the error message
         * @private
         */
        _errMsg: 'CSVConverter.service: ',
        /**
         * An array holding allowed values for CSVSchemaValue.type
         * @private
         */
        _validSchemaTypes: ['boolean', 'integer', 'number'],
        /**
         * Validate a single CSVSchema member
         * @methodOf CSVConverter
         *
         * @param {{type: string, name: string} | string} CSVSchemaValue
         * @param {string} errMsg
         * @private
         */
        _validateCSVSchemaValue: function (CSVSchemaValue, errMsg) {
            var self = this;
            errMsg = errMsg || '';
            // Validation in case the CSVSchemaValue is a string
            if (_.isString(CSVSchemaValue)) {
                self.assert(CSVSchemaValue !== '', errMsg + 'All CSVSchema members that are strings ' +
                    'must not be empty strings.', RangeError);
            }
            else if (_.isObject(CSVSchemaValue)) {
                // Validate CSVSchemaValue.name
                self.assert(!_.isUndefined(CSVSchemaValue.name), errMsg + 'All CSVSchema members that are objects ' +
                    'must have a "name" property.', ReferenceError);
                self.assert(_.isString(CSVSchemaValue.name), errMsg + 'All CSVSchema members that are objects ' +
                    'must have a "name" property that is a string.', TypeError);
                self.assert(CSVSchemaValue.name !== '', errMsg + 'All CSVSchema members that are objects ' +
                    'must have a "name" property this is not an empty string.', RangeError);
                // Validate CSVSchemaValue.type
                self.assert(!_.isUndefined(CSVSchemaValue.type), errMsg + 'All CSVSchema members that are objects ' +
                    'must have a "type" property.', ReferenceError);
                self.assert(_.isString(CSVSchemaValue.type), errMsg + 'All CSVSchema members that are objects ' +
                    'must have a "type" property that is a string.', TypeError);
                self.assert(self._validSchemaTypes
                    .indexOf(CSVSchemaValue.type.toLowerCase()) !== -1, 'All CSVSchema members that are objects ' +
                    'must have a "type" property that is one of these values: ' +
                    self._validSchemaTypes.join(', ') + ' .', RangeError);
            }
            else {
                // Default assertion that always fires if this branch is executed.
                // This branch executing means that CSVSchemaValue was not a string or an object
                self.assert(false, errMsg + 'All CSVSchema members must be either a string ' +
                    'or an object.', TypeError);
            }
        },
        /**
         * Validate a CSVSchema array
         *
         * @param {Array<{type: string, name: string} | string>} CSVSchema
         * @param {string} errMsg
         * @private
         */
        _validateCSVSchema: function (CSVSchema, errMsg) {
            var self = this;
            errMsg = errMsg || '';
            self.assert(!_.isUndefined(CSVSchema), errMsg + 'CSVSchema argument must be provided.', ReferenceError);
            self.assert(_.isArray(CSVSchema), errMsg + 'CSVSchema argument must be an array.', TypeError);
            _.each(CSVSchema, function (CSVSchemaValue) {
                self._validateCSVSchemaValue(CSVSchemaValue, errMsg);
            });
        },
        /**
         * Validates CSVString
         *
         * @param {string} CSVString
         * @param {string} errMsg
         * @private
         */
        _validateCSVString: function (CSVString, errMsg) {
            var self = this;
            errMsg = errMsg || '';
            // Validate CSVSchemaValue.name
            self.assert(!_.isUndefined(CSVString), errMsg + 'CSVString argument must be provided.', ReferenceError);
            self.assert(_.isString(CSVString), errMsg + 'CSVString argument must be a string.', TypeError);
        },
        /**
         * Validates CSVString
         *
         * @param {string} CSVString
         * @param {string} errMsg
         * @private
         */
        _validateModel: function (model, errMsg) {
            var self = this;
            errMsg = errMsg || '';
            // Validate CSVSchemaValue.name
            self.assert(!_.isUndefined(model), errMsg + 'model argument must be provided.', ReferenceError);
            self.assert(_.isObject(model), errMsg + 'model argument must be an object.', TypeError);
        },
        /**
         * Holds parser methods -to- and -from-
         * @private
         */
        _parsers: {
            /**
             * Holds -to- parsers. converts from string to a specific type.
             */
            to: {
                /**
                 * returns false if value is undefined, null, '0', 0, or 'false',
                 * otherwise it returns true.
                 *
                 * @param {*} value
                 * @returns {boolean}
                 */
                boolean: function (value) {
                    return (value !== undefined &&
                        value !== null &&
                        value !== '0' &&
                        value !== 0 &&
                        value !== 'false');
                },
                /**
                 * Parses from string to integer
                 *
                 * @param {string} value
                 * @returns {Number}
                 */
                integer: function (value) {
                    return parseInt(value);
                },
                /**
                 * Parses from string to number
                 *
                 * @param {string} value
                 * @returns {Number}
                 */
                number: function (value) {
                    return parseFloat(value);
                }
            },
            /**
             * Holds -from- parsers. converts from primitives to string.
             */
            from: {
                /**
                 * Returns '1' if true and '0' if false
                 *
                 * @param {boolean} value
                 * @returns {string}
                 */
                boolean: function (value) {
                    return value ? '1' : '0';
                },
                /**
                 * Returns a string from a number.
                 *
                 * @param {number} value
                 * @returns {string}
                 */
                integer: function (value) {
                    return value.toString();
                },
                /**
                 * Returns a string from a number.
                 *
                 * @param {number} value
                 * @returns {string}
                 */
                number: function (value) {
                    return value.toString();
                }
            }
        },
        /**
         * Takes a CSVString and a SCVSchema and returns an array of objects based on the schema
         *
         * @param {String} CSVString
         * @param {Array<{type: string, name: string} | string>} CSVSchema
         * @returns {Array<{}>}
         */
        toModel: function (CSVString, CSVSchema) {
            var self = this;
            // Validate CSVSchema
            self._validateCSVSchema(CSVSchema, this._errMsg + 'toModel: ');
            // Validate CSVString
            self._validateCSVString(CSVString, this._errMsg + 'toModel: ');
            // Extract values array from the string
            var values = CSVString.split(',');
            // Create a model array
            var model = [];
            // Ascertain the length
            var schemaLength = CSVSchema.length;
            // Iterate through values, and place each value in the correct position and type
            // on the model array
            _.each(values, function (value, index) {
                // Position in the model array
                var pos = Math.floor(index / schemaLength);
                // CSVSchema array position is determined by
                // modding the index of values by schemaLength
                var CSVSchemaValue = CSVSchema[index % schemaLength];
                // Create a new object member on the model array if on does not exist.
                if (!model[pos]) {
                    model[pos] = {};
                }
                // When CSVSchemaValue is an object, parsing is required,
                // otherwise the value is set directly.
                if (_.isObject(CSVSchemaValue)) {
                    // Set the value to model after parsing it.
                    model[pos][CSVSchemaValue.name] = self._parsers.to[CSVSchemaValue.type](value);
                }
                else {
                    model[pos][CSVSchemaValue] = value;
                }
            });
            // return the model array
            return model;
        },
        /**
         * Takes an array of object and a CSVSchema, and converts the model into a SCV string.
         *
         * @param {Array<{}>} model An array model that correlates to the schema
         * @param {Array<{type: string, name: string} | string>} CSVSchema
         * @returns {string}
         */
        toCSVString: function (model, CSVSchema) {
            var self = this;
            // Validate CSVSchema
            self._validateCSVSchema(CSVSchema, this._errMsg + 'toCSVString: ');
            // Validate model
            self._validateModel(model, this._errMsg + 'toCSVString: ');
            // Iterate through model members and return a string from joining array by map
            return _.map(model, function (tabObj) {
                // Iterate through CSVSchema members and return string from joining array by map
                return _.map(CSVSchema, function (CSVSchemaValue) {
                    // If CSVSchemaValue is an object, then parsing is required
                    // otherwise return the direct value.
                    if (_.isObject(CSVSchemaValue)) {
                        // parse from primitive type to string and return the value
                        return self._parsers.from[CSVSchemaValue.type](tabObj[CSVSchemaValue.name]);
                    }
                    // return a direct value (if CSVSchemaValue is not an object)
                    return tabObj[CSVSchemaValue];
                }).join(',');
            }).join(',');
        }
    });
    CSVConverter.$inject = ['assert'];
    angular.module('Fortscale.shared.services.CSVConverter', [
        'Fortscale.shared.services.assert'
    ])
        .service('CSVConverter', CSVConverter);
}());

(function () {
    'use strict';
    function URLUtils($location) {
        this.$location = $location;
    }
    angular.extend(URLUtils.prototype, {
        /**
         * Gets the (angular) url, and uses regex to get the query string.
         * if withoutQuestionMark is set to true, the returned value will be without it;
         *
         * @param {boolean=} withoutQuestionMark
         * @returns {string}
         */
        getSearchQueryString: function (withoutQuestionMark) {
            // Get the (angular) url
            var url = this.$location.url();
            // Match the search query
            var match = url.match(/(\?)([^#]+)/);
            // If match was made
            if (match) {
                // if withoutQuestionMark return the match without the question mark
                if (withoutQuestionMark) {
                    return match[2];
                }
                // return the match string
                return match[0];
            }
            // If no match then return an empty string
            return '';
        },
        /**
         * Takes an (angular) url and sets it to transition to a new state.
         * If shouldPassQuery is set to true, the search query will be added to the url.
         *
         * @param {string} url
         * @param {boolean=} shouldPassQuery
         */
        setUrl: function (url, shouldPassQuery) {
            var transitionTo = url + (shouldPassQuery ? this.getSearchQueryString() : '');
            this.$location.url(transitionTo);
        }
    });
    URLUtils.$inject = ['$location'];
    angular.module('Fortscale.shared.services.URLUtils', [])
        .service('URLUtils', URLUtils);
}());

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var tagsUtilsService;
            (function (tagsUtilsService) {
                'use strict';
                var TagsUtils = (function () {
                    function TagsUtils($http, BASE_URL, assert) {
                        this.$http = $http;
                        this.BASE_URL = BASE_URL;
                        this.assert = assert;
                        this.USER_URL = this.BASE_URL + '/user';
                        this.TAGS_URL = this.BASE_URL + '/tags';
                        this.USER_TAGS_URL = this.TAGS_URL + '/user_tags';
                        this.ERR_MSG = 'tagsUtils.service: ';
                    }
                    TagsUtils.prototype._getPostUrl = function (userId) {
                        return this.USER_URL + '/' + userId;
                    };
                    /**
                     * Returns promise that resolves on the response of the http request. Adds tag.
                     *
                     * @param {string} userId
                     * @param {string} tagName
                     * @returns {HttpPromise|Promise}
                     */
                    TagsUtils.prototype.addTag = function (userId, tagName) {
                        return this.$http.post(this._getPostUrl(userId), { add: tagName });
                    };
                    /**
                     * Returns promise that resolves on the response of the http request. Removes tag.
                     *
                     * @param {string} userId
                     * @param {string} tagName
                     * @returns {HttpPromise|Promise}
                     */
                    TagsUtils.prototype.removeTag = function (userId, tagName) {
                        return this.$http.post(this._getPostUrl(userId), { remove: tagName });
                    };
                    /**
                     * Returns promise that resolves on a list of tags in the application.
                     *
                     * @returns {IPromise<{data: ITagDefinition[]}>}
                     */
                    TagsUtils.prototype.getTags = function () {
                        var ctrl = this;
                        ctrl.allTagsCache = this.$http.get(this.USER_TAGS_URL)
                            .then(function (res) {
                            var data = res && res.data || null;
                            return data;
                        });
                        return ctrl.allTagsCache;
                    };
                    /**
                     * Retrun tags from cache, if there is any data in the cache.
                     * If no data in cache - return empty
                     */
                    TagsUtils.prototype.getTagsFromCacheOnly = function () {
                        return this.allTagsCache ? this.allTagsCache : this.getTags();
                    };
                    /**
                     * Creates a new tag in the system.
                     * Flow: get tags, then validate new tag, then create new tag in system, then return new tags list
                     * @param {string} name
                     * @param {string=} displayName
                     * @param {string=} createsIndicator
                     * @returns {IPromise<IHttpPromiseCallbackArg<any>>}
                     */
                    TagsUtils.prototype.createNewTag = function (name, displayName, createsIndicator) {
                        var _this = this;
                        var err_msg = this.ERR_MSG + 'createNewTag: ';
                        var _tags;
                        var _tag;
                        // Async validation
                        return this.getTags()
                            .then(function (res) {
                            _tags = res.data;
                            // Validate tag name does not already exist
                            var valid = _.every(_tags, function (tag) {
                                return tag.name !== name;
                            });
                            return valid;
                        })
                            .then(function (valid) {
                            // Validation
                            if (!valid) {
                                var err = new RangeError(err_msg + 'Trying to add a tag with a name that already exists.');
                                err.name = 'identical-tag-name';
                                throw err;
                            }
                            _this.assert.isString(name, 'name', err_msg);
                            _this.assert.isString(displayName, 'displayName', err_msg, true);
                        })
                            .then(function () {
                            // Set defaults
                            if (!displayName) {
                                displayName = name;
                            }
                            createsIndicator = !!createsIndicator;
                            _tag = {
                                name: name,
                                displayName: displayName,
                                active: true,
                                createsIndicator: createsIndicator,
                                rules: [],
                                isAssignable: true
                            };
                            return _this.$http.post("" + _this.USER_TAGS_URL, [_tag]);
                        })
                            .then(function (res) {
                            // if POST was successful return updated tags
                            if (res.status !== 202) {
                                throw new Error(err_msg + "Server should have responded with 202, but instead got " + res.status + ".");
                            }
                            return _this.getTags()
                                .then(function (res) {
                                return res.data;
                            });
                        });
                    };
                    TagsUtils.$inject = ['$http', 'BASE_URL', 'assert'];
                    return TagsUtils;
                }());
                angular.module('Fortscale.shared.services.tagsUtils', [])
                    .service('tagsUtils', TagsUtils);
            })(tagsUtilsService = services.tagsUtilsService || (services.tagsUtilsService = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function TableSettingsUtil() { }
    angular.extend(TableSettingsUtil.prototype, {
        /**
         * The default adapter object that holds general definitions.
         *
         * @private
         */
        _adapter: {
            types: {
                DATE_TIME: {
                    template: '{{ dataItem.date_time | date:\"MM/dd/yyyy HH\\:mm\\:ss\":\"UTC\"}}'
                }
            },
            ids: {
                status: {
                    'template': "{{dataItem.status }}",
                    'attributes': {
                        'class': 'capitalizeText'
                    }
                },
                write_bytes: {
                    template: '{{dataItem.write_bytes|prettyBytes}}'
                },
                read_bytes: {
                    template: '{{dataItem.read_bytes|prettyBytes}}'
                },
                session_score: {
                    template: '<fs-score-icon score="dataItem.session_score"></fs-score-icon>' +
                        '{{dataItem.session_score}}'
                },
                event_score: {
                    template: '<fs-score-icon score="dataItem.event_score"></fs-score-icon>' +
                        '{{dataItem.event_score}}'
                },
                country: {
                    template: '{{ dataItem.country|orNA}}'
                },
                city: {
                    template: '{{ dataItem.city|orNA}}'
                },
                source_machine: {
                    template: '{{ dataItem.source_machine|orNA}}'
                }
            }
        },
        /**
         * Takes (optionally) an adapter and returns an adapter that is the default adapter
         * merged with the provided adapter.
         *
         * @param {object=} adapter
         * @returns {object}
         * @private
         */
        _getAdapterObject: function (adapter) {
            return adapter ? _.merge({ types: {}, ids: {} }, adapter, this._adapter) :
                this._adapter;
        },
        /**
         * Returns a specific adapter property based on the adapterType, the property and the
         * adapterObject
         *
         * @param {string} adapterType Should generally be 'types' or 'ids'
         * @param {string} prop The property name correlating to the desired adapter
         * @param {object} adapter The adapter object
         * @returns {object|null} Returns null if the property does not exists on the adapterType,
         * or the adapterType does not exist on the adapter.
         * @private
         */
        _getAdapter: function (adapterType, prop, adapter) {
            return (adapter[adapterType] && adapter[adapterType][prop]) || null;
        },
        /**
         * Takes a title and makes sure that every two words there's a line break.
         * @param title
         * @returns {*}
         * @private
         */
        _processTitle: function (title) {
            if (!_.isString(title) || title === '') {
                return title;
            }
            // if title is string and not empty
            // split by space
            var titleNodes = title.split(' ');
            // remove empty strings
            titleNodes = _.filter(titleNodes, function (titleNode) { return titleNode !== ''; });
            // iterate through strings and for each even concat with space, for each odd concat with <br>
            var processedTitle = '';
            _.each(titleNodes, function (titleNode, index) {
                if (index === titleNodes.length - 1) {
                    processedTitle += titleNode;
                }
                else if (index % 2 === 0) {
                    processedTitle += titleNode + ' ';
                }
                else {
                    processedTitle += titleNode + '<br>';
                }
            });
            // return string
            return processedTitle;
        },
        /**
         * Takes an entity field and an adapter and returns a single column definition
         *
         * @param {{name: string, id: string, type: {id: string}}} entityField
         * @param {object} adapter An adapter object
         * @returns {object} returns a column definition object
         * @private
         */
        _getColumnByEntityField: function (entityField, adapter) {
            // Define title and field
            var title = entityField.name;
            var field = entityField.id;
            // Create a basic column def object
            var columnDef = {
                title: title,
                field: field
            };
            // Get adapters (this is contingent on the existence of adapters on the type or id)
            var adapterByType = this.getAdapterByType(entityField.type.id, adapter);
            var adapterById = this.getAdapterById(entityField.id, adapter);
            // Merge type adapter if exists into the columnDef
            if (adapterByType) {
                _.merge(columnDef, adapterByType);
            }
            // Merge id adapter if exists into the columnDef
            if (adapterById) {
                _.merge(columnDef, adapterById);
            }
            // Add score icon
            if (entityField.scoreField) {
                var template = '<fs-score-icon score="::dataItem.' +
                    entityField.scoreField.id + '"></fs-score-icon>';
                if (columnDef.template) {
                    columnDef.template = template + columnDef.template;
                }
                else {
                    columnDef.template = template + '{{::dataItem.' + columnDef.field + '}}';
                }
            }
            columnDef.title = this._processTitle(columnDef.title);
            return columnDef;
        },
        /**
         * Takes a type value and returns adapter.types[type] or null
         *
         * @param {string} type The property name on adapter.types
         * @param {object} adapter The adapter object
         * @returns {Object|null}
         */
        getAdapterByType: function (type, adapter) {
            // All types should be upper cased.
            type = type && type.toUpperCase();
            return this._getAdapter('types', type, adapter);
        },
        /**
         *
         * @param {string} id the property name on adapter.ids or null
         * @param {object} adapter
         * @returns {Object|null}
         */
        getAdapterById: function (id, adapter) {
            return this._getAdapter('ids', id, adapter);
        },
        /**
         * Returns a columns definition object. It takes an entityFields array,
         * and uses it to build the columns definition.
         *
         * @param {Array<{name: string, id: string, type: {id: string}}>} entityFields
         * @param {object=} adapter An optional adapter object that is different from the default
         * service adapter.
         * If adapter object is provided, it will be merged (override) into the default adapter.
         */
        getColumnsByEntityFields: function (entityFields, adapter) {
            var self = this;
            // Get adapter object (merge if provided with default adapter)
            adapter = self._getAdapterObject(adapter);
            // Return a columns settings map
            return _.map(entityFields, function (entityField) {
                return self._getColumnByEntityField(entityField, adapter);
            });
        }
    });
    TableSettingsUtil.$inject = [];
    angular.module('Fortscale.shared.services.tableSettingsUtil', [])
        .service('tableSettingsUtil', TableSettingsUtil);
}());

(function () {
    'use strict';
    function JsonLoader(assert, $http) {
        this._errMsg = 'Fortscale.shared.services.jsonLoader: ';
        this.$http = $http;
        this.assert = assert;
    }
    angular.merge(JsonLoader.prototype, {
        _validateUrl: function (url, errMsg) {
            this.assert(_.isString(url), errMsg + 'url must be a string.', TypeError);
            this.assert(url !== '', errMsg + 'url must not be an empty string.', RangeError);
            this.assert(/\.json$/.test(url) || /\.jsonx$/.test(url), errMsg + 'url must request a json or jsonx type file.', RangeError);
        },
        /**
         * Takes a json url.
         * Returns a promise that is resolved on an object that a json file represents.
         * If preventCache is true, the file will not be cached.
         *
         * @param {string} url
         * @param {boolean=} preventCache
         * @returns {Promise}
         */
        load: function (url, preventCache) {
            this._validateUrl(url, this._errMsg + 'load: ');
            var shouldCache = !preventCache;
            return this.$http
                .get(url, {
                cache: shouldCache
            })
                .then(function (res) {
                return res.data;
            });
        },
        /**
         * Takes a jsonx url.
         * Returns a promise that is resolved on a string that a jsonx file represents.
         * This type of file is used when a json needs to be interpolated, and before interpolation is not a valid
         * JSON file.
         * If preventCache is true, the file will not be cached.
         *
         * @param {string} url
         * @param {boolean=} preventCache
         * @returns {Promise}
         */
        loadJsonx: function (url, preventCache) {
            this._validateUrl(url, this._errMsg + 'load: ');
            var shouldCache = !preventCache;
            return this.$http({
                method: 'get',
                url: url,
                transformResponse: function (data) {
                    return data;
                },
                cache: shouldCache
            })
                .then(function (res) {
                return res.data;
            });
        }
    });
    JsonLoader.$inject = ['assert', '$http'];
    angular.module('Fortscale.shared.services.jsonLoader', [
        'Fortscale.shared.services.assert'
    ])
        .service('jsonLoader', JsonLoader);
}());

(function () {
    'use strict';
    function DateRanges(utils) {
        this.utils = utils;
    }
    /**
     * Returns a number that is divided by 1000 and floored.
     *
     * @param {number} value
     * @returns {number}
     * @private
     */
    DateRanges.prototype._truncate = function (value) {
        return Math.floor(value / 1000);
    };
    /**
     * A dummy function that returns what it gets. Used as a 'through' alternative.
     *
     * @param {*} value
     * @returns {*}
     * @private
     */
    DateRanges.prototype._through = function (value) {
        return value;
    };
    /**
     * Returns the start of days 'days' days ago.
     *
     * @param {number} days
     * @returns {number}
     */
    DateRanges.prototype.getStartOfDayByDaysAgo = function (days) {
        return this.utils.date.getMoment()
            .endOf('day').subtract(days, 'days').startOf('day').valueOf();
    };
    /**
     * Returns the end of the current day
     *
     * @returns {*}
     */
    DateRanges.prototype.getEndOfCurrentDay = function () {
        return this.utils.date.getMoment()
            .endOf('day').valueOf();
    };
    /**
     * Returns a CSV string that represent a date range; from(now->days-end->minus-days->days-start),to(now->days-end).
     *
     * @param {number} days
     * @param {string=} type If set to 'short' will return a 10 digits timestamp.
     * @returns {string}
     */
    DateRanges.prototype.getByDaysRange = function (days, type) {
        var transformFn;
        switch (type) {
            case 'short':
                transformFn = this._truncate;
                break;
            default:
                transformFn = this._through;
        }
        return _.map([this.getStartOfDayByDaysAgo(days), this.getEndOfCurrentDay()], transformFn).join(',');
    };
    /**
     * Returns a range that's 8 days from today's end of day
     *
     * @param {string=} type
     * @returns {string} csv of startDate, endDate
     * @private
     */
    DateRanges.prototype.getLast7Days = function (type) {
        return this.getByDaysRange(7, type);
    };
    /**
     * Returns a range that's 8 days from today's end of day
     *
     * @param {string=} type
     * @returns {string} csv of startDate, endDate
     * @private
     */
    DateRanges.prototype.getLastDay = function (type) {
        return this.getByDaysRange(1, type);
    };
    DateRanges.$inject = ['utils'];
    angular.module('Fortscale.shared.services.dateRanges', [])
        .service('dateRanges', DateRanges);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.alertFeedback', []);
}());

(function () {
    'use strict';
    // ENUMS
    var enumAlertStatus = {
        OPEN: 'open',
        CLOSED: 'closed'
    };
    /**
     * Map the display name of the feedback to the value sent to the server
     * @type {{Approved: string, Rejected: string, Unresolved: string}}
     */
    var alertFeedbackMap = {
        Approved: 'approved',
        Rejected: 'rejected',
        Unresolved: 'none'
    };
    /**
     * Constants
     */
    var CLOSE_ALERT_POPUP_CONSTANTS = {
        TEMPLATE_URL: 'app/shared/components/alert-feedback/alert-feedback-close-modal/alert-feedback-close-modal.html',
        CONTROLLER_NAME: 'CloseAlertModalInstanceCtrl'
    };
    var OPEN_ALERT_POPUP_CONSTANTS = {
        TEMPLATE_URL: 'app/shared/components/alert-feedback/alert-feedback-open-modal/alert-feedback-open-modal.html',
        CONTROLLER_NAME: 'OpenAlertModalInstanceCtrl'
    };
    var FEEDBACK_RESPONSE_POPUP_CONSTANTS = {
        TEMPLATE_URL: 'app/shared/components/alert-feedback/alert-feedback-results-modal' +
            '/alert-feedback-result-modal.html',
        CONTROLLER_NAME: 'FeedbackResultModalInstanceCtrl'
    };
    var FEEDBACK_FAILURE_POPUP_CONSTANTS = {
        TEMPLATE_URL: 'app/shared/components/alert-feedback/alert-feedback-failure-modal' +
            '/alert-feedback-failure-modal.html',
        CONTROLLER_NAME: 'FeedbackFailureModalInstanceCtrl'
    };
    function AlertFeedback(assert, BASE_URL, $http, $modal) {
        this._errMsg = 'alertFeedback.service: ';
        this.enumAlertStatus = enumAlertStatus;
        this.alertFeedbackMap = alertFeedbackMap;
        this.$modal = $modal;
        /**
         * Checks if a value is allowed in a certain enum
         *
         * @param {object} enm
         * @param {*} value
         * @returns {boolean}
         * @private
         */
        this._isValueAllowed = function (enm, value) {
            return _.some(enm, function (enumValue) {
                return enumValue === value;
            });
        };
        this._verifyAlert = function (alert) {
            assert.isObject(alert, 'alert', 'Alert should be an object');
            assert.isString(alert.id, 'alert id', 'Alert must has an ID');
            assert.isString(alert.name, 'alert name', 'Alert must has a name');
        };
        /**
         * Make a patch request to set an alert status and/or feedback.
         * @example alertFeedback.setAlertStatus({alertId: someAlertId, alertStatus:
         *     alertFeedback.enumAlertStatus.OPEN, alertFeedback: alertFeedback.alertFeedbackMap.APPROVED})
         * @example alertFeedback.setAlertStatus({alertId: someAlertId, alertStatus:
         *     alertFeedback.enumAlertStatus.CLOSED})
         * @example alertFeedback.setAlertStatus({alertId: someAlertId, alertFeedback:
         *     alertFeedback.alertFeedbackMap.REJECTED})
         *
         * @param {{alertId: string, alertStatus: string=, alertFeedback: string=}} config
         * @param {string=} errMsg This argument is mainly for internal use.
         */
        this.setAlertStatus = function (config, errMsg) {
            errMsg = errMsg || this._errMsg + 'setAlertStatus: ';
            // Validate config object
            assert.isObject(config, 'config', errMsg);
            assert.isString(config.alertId, 'config.alertId', errMsg);
            if (!_.isUndefined(config.alertStatus)) {
                assert(this._isValueAllowed(this.enumAlertStatus, config.alertStatus), errMsg + 'The value "' + config.alertStatus +
                    '" is not an allowed alert status value', RangeError);
            }
            if (!_.isUndefined(config.alertFeedback)) {
                assert(this._isValueAllowed(this.alertFeedbackMap, config.alertFeedback), errMsg + 'The value "' + config.alertFeedback +
                    '" is not an allowed alert feedback value', RangeError);
            }
            // Create the patch request body
            var body = {
                status: config.alertStatus,
                feedback: config.alertFeedback
            };
            // Create the patch request url
            var url = BASE_URL + '/alerts/' + config.alertId;
            return $http.patch(url, body);
        };
        /**
         * Makes a patch request to set an alert as open with conditional feedback.
         * @example alertFeedback.openAlert(someAlertId, alertFeedback.alertFeedbackMap.APPROVED)
         * @example alertFeedback.openAlert(someAlertId)
         *
         * @param {string} alertId
         * @param {string=} alertFeedback
         */
        this.openAlert = function (alertId, alertFeedback) {
            return this.setAlertStatus({
                alertId: alertId,
                alertStatus: this.enumAlertStatus.OPEN,
                alertFeedback: alertFeedback
            }, this._errMsg + 'openAlert: ');
        };
        /**
         * Makes a patch request to set an alert as open with conditional feedback.
         * @example alertFeedback.closeAlert(someAlertId, alertFeedback.alertFeedbackMap.REJECTED)
         * @example alertFeedback.closeAlert(someAlertId)
         *
         * @param {string} alertId
         * @param {string=} alertFeedback
         */
        this.closeAlert = function (alertId, alertFeedback) {
            return this.setAlertStatus({
                alertId: alertId,
                alertStatus: this.enumAlertStatus.CLOSED,
                alertFeedback: alertFeedback
            }, this._errMsg + 'closeAlert: ');
        };
        /**
         * This method opens a modal with specific template and controller
         * @param templateUrl - URL for the template HTML
         * @param controller - The name of the controller
         * @param controllerAs - The name which parts in the html use to reffer to the controller
         * @param inputParamObejct - object which pass to the controller and contains data which the
         *                          controller consumes
         * @param windowClass - for case which we need to set a class for the top parent of the modal window
         *          (this is not part of the template but part of the infra.
         * @returns {*}The modal instance
         * @private
         */
        this._openPopup = function (templateUrl, controller, controllerAs, inputParamObejct, windowClass) {
            var ctrl = this;
            return ctrl.$modal.open({
                animation: true,
                templateUrl: templateUrl,
                controller: controller,
                controllerAs: controllerAs,
                size: 'lg',
                resolve: {
                    inputParams: function () {
                        return inputParamObejct;
                    }
                },
                windowClass: windowClass
            });
        };
        /**
         * Callback which executed if the user click on "OK" button
         * when he asked to approve reopen the alert
         * @param model
         * @returns {*}Promise of the "openAlert" method
         * @private
         */
        this._approveAlertReopenCallback = function (model) {
            var alertId = model.inputParams.alert.id;
            return this.openAlert(alertId, alertFeedbackMap.Unresolved);
        };
        /**
         * Callback which executed if the user click on "OK" button
         * when he asked to approve close the alert
         * @param model
         * @returns {*}Promise of the "closeAlert" method
         * @private
         */
        this._approveAlertCloseCallback = function (model) {
            var alertId = model.inputParams.alert.id;
            return this.closeAlert(alertId, model.closeAlertStatus);
        };
        /**
         * Trigger the "are you sure" popup for closing the alert.
         * If the user click "ok" it will execute the "closeAlert" method.
         * @param alert
         * @returns {*}Promise which resolved after closeAlert triggered
         */
        this.handleCloseAlertPopupFlow = function (alert) {
            var ctrl = this;
            ctrl._verifyAlert(alert);
            var templateUrl = CLOSE_ALERT_POPUP_CONSTANTS.TEMPLATE_URL;
            var controller = CLOSE_ALERT_POPUP_CONSTANTS.CONTROLLER_NAME;
            var controllerAs = 'closeModal';
            var inputParamObejct = {
                alert: alert,
                options: ctrl.alertFeedbackMap
            };
            return ctrl._openPopup(templateUrl, controller, controllerAs, inputParamObejct)
                .result
                .then(ctrl._approveAlertCloseCallback.bind(this));
        };
        /**
         * Trigger the "are you sure" popup for re-open of the alert.
         * If the user click "ok" it will execute the "openAlert" method.
         * @param alert
         * @returns {*}Promise which resolved after openAlert triggered
         */
        this.handleOpenAlertPopupFlow = function (alert) {
            var ctrl = this;
            ctrl._verifyAlert(alert);
            var templateUrl = OPEN_ALERT_POPUP_CONSTANTS.TEMPLATE_URL;
            var controller = OPEN_ALERT_POPUP_CONSTANTS.CONTROLLER_NAME;
            var controllerAs = 'openModal';
            var inputParamObejct = {
                alert: alert
            };
            return ctrl._openPopup(templateUrl, controller, controllerAs, inputParamObejct)
                .result
                .then(ctrl._approveAlertReopenCallback.bind(this));
        };
        /**
         * Trigger the "are you sure" popup for re-open of the alert.
         * If the user click "ok" it will execute the "openAlert" method.
         * @param newAlertStatus - the new status that we suspect if operation was finished sucessfuly
         *                         should be "open" or "closed"
         * @param {string=} specificBodyMessage - Extra message to display below the title.
         * @returns {*}The modal instance
         */
        this.showResponseSuccessPopup = function (newAlertStatus, specificBodyMessage) {
            var ctrl = this;
            //newAlertStatus is a mandatory string
            assert.isString(newAlertStatus, 'Alert status', 'must be a string', false, false);
            //Check the new status to be a valid status
            if (!_.isUndefined(newAlertStatus)) {
                assert(this._isValueAllowed(this.enumAlertStatus, newAlertStatus), 'showResponsePopup: The value "' + newAlertStatus +
                    '" is not an allowed alert status value', RangeError);
            }
            //Initiate the modal
            var templateUrl = FEEDBACK_RESPONSE_POPUP_CONSTANTS.TEMPLATE_URL;
            var controller = FEEDBACK_RESPONSE_POPUP_CONSTANTS.CONTROLLER_NAME;
            var controllerAs = 'responseModal';
            var inputParamObejct = {
                newAlertStatus: newAlertStatus,
                specificBodyMessage: specificBodyMessage
            };
            var cssClass = (specificBodyMessage ? 'fs-alert-success-wrapper-with-body' : 'fs-alert-success-wrapper');
            return ctrl._openPopup(templateUrl, controller, controllerAs, inputParamObejct, cssClass);
        };
        /**
         * Call this method display feedback update failure message
         * @param newAlertStatus
         * @returns {*}
         */
        this.showResponseFailurePopup = function (newAlertStatus) {
            var ctrl = this;
            //newAlertStatus is a mandatory string
            assert.isString(newAlertStatus, 'Alert status', 'must be a string', false, false);
            //Initiate the modal
            var templateUrl = FEEDBACK_FAILURE_POPUP_CONSTANTS.TEMPLATE_URL;
            var controller = FEEDBACK_FAILURE_POPUP_CONSTANTS.CONTROLLER_NAME;
            var controllerAs = 'responseModal';
            var inputParamObejct = {
                newAlertStatus: newAlertStatus
            };
            return ctrl._openPopup(templateUrl, controller, controllerAs, inputParamObejct);
        };
    }
    AlertFeedback.$inject = ['assert', 'BASE_URL', '$http', '$modal'];
    angular.module('Fortscale.shared.components.alertFeedback')
        .service('alertFeedback', AlertFeedback);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsMinScore', []);
}());

(function () {
    'use strict';
    var DEFAULT_VALUE = 50;
    var MAX_VALUE_DEFAULT = 100;
    var MIN_VALUE = 0;
    function fsMinScoreDirective(assert) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrls
         */
        function linkFn(scope, element, attrs, ctrls) {
            // Link function logic
            var ctrl = ctrls[0];
            ctrl.formCtrl = ctrls[1];
            ctrl.setMinScoreValue(DEFAULT_VALUE);
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsMinScoreController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsMinScoreController.prototype, {
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                if (this.fetchStateDelegate && !angular.isFunction(this.fetchStateDelegate)) {
                    throw new TypeError('fsMinScore.directive: FsMinScoreController: ' +
                        'If fetchStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                if (this.updateStateDelegate && !angular.isFunction(this.updateStateDelegate)) {
                    throw new TypeError('fsMinScore.directive: FsMinScoreController: ' +
                        'If updateStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Directive validation sequence
             *
             * @private
             */
            _validations: function () {
                this._validateGetStateFn();
                this._validateSetStateFn();
            },
            /**
             * Returns the value of the the state by the id
             * @returns {*}
             * @private
             */
            _stateWatchFn: function () {
                return this.fetchStateDelegate(this.minScoreId);
            },
            /**
             * Watch action function . Sets the value to the picker if state has changed.
             *
             * @param {string|number} value
             */
            _stateWatchActionFn: function (value) {
                if (_.isString(value)) {
                    value = parseInt(value, 10);
                }
                if (value !== undefined && value !== null && this.getMinScoreValue() !== value) {
                    this.setMinScoreValue(value);
                }
            },
            /**
             * Initiates state watch
             *
             * @returns {*|function()}
             * @private
             */
            _initStateWatch: function () {
                this.$scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
            },
            /**
             * input change handler. When the input element changes, will change the value of the picker and fire
             * 'change' event.
             *
             * @param {Event} evt
             * @private
             */
            _inputChangeHandler: function (evt) {
                this.setMinScoreValue(this.getMinScoreValue());
                this.updateStateDelegate({
                    id: this.minScoreId,
                    type: 'DATA',
                    value: this.getMinScoreValue(),
                    immediate: false
                });
                if (this.formCtrl) {
                    this.$scope.$apply(this.formCtrl.$setDirty.bind(this.formCtrl));
                }
            },
            /**
             * Sets an input change handler.
             *
             * @private
             */
            _initInputChangeWatch: function () {
                var ctrl = this;
                // Lock in context
                function listenerFn(evt) {
                    ctrl._inputChangeHandler(evt);
                }
                ctrl.minScoreElement.on('change', listenerFn);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    ctrl.minScoreElement.off('change', listenerFn);
                });
            },
            _initDisableSubmitOnEnter: function () {
                var ctrl = this;
                function disableEnterKey(evt) {
                    var code = evt.keyCode || evt.which;
                    if (code === 13) {
                        evt.preventDefault();
                        ctrl.minScoreElement.trigger('blur');
                        return false;
                    }
                }
                ctrl.minScoreElement.on('keyup keypress', disableEnterKey);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    ctrl.minScoreElement.off('keyup keypress', disableEnterKey);
                });
            },
            /**
             * Init watches sequence
             *
             * @private
             */
            _initWatches: function () {
                this._initStateWatch();
                this._initInputChangeWatch();
                this._initDisableSubmitOnEnter();
            },
            _checkMinMaxValues: function (value) {
                if (value < MIN_VALUE) {
                    return MIN_VALUE;
                }
                if (value > MAX_VALUE_DEFAULT) {
                    return MAX_VALUE_DEFAULT;
                }
                return value;
            },
            /**
             * Sets the picker value.
             *
             * @param {string|number} value
             * @returns {*}
             */
            setMinScoreValue: function (value) {
                assert((_.isString(value) || _.isNumber(value)), 'fsMinScore.directive: FsMinScoreController:' +
                    ' setMinScoreValue: value argument must be a number or a string representing a number.');
                if (_.isString(value)) {
                    value = parseInt(value, 10) || 0;
                }
                value = this._checkMinMaxValues(value);
                this.minScoreElement.val(value);
            },
            /**
             * Gets the picker value
             *
             * @returns {string}
             */
            getMinScoreValue: function () {
                return this.minScoreElement.val();
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                ctrl.minScoreElement = ctrl.$element.find('.min-score-input');
                ctrl._validations();
                ctrl._initWatches();
            }
        });
        FsMinScoreController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<input type="number" class="min-score-input">',
            scope: {},
            link: linkFn,
            controller: FsMinScoreController,
            controllerAs: 'ctrl',
            bindToController: {
                minScoreId: '@',
                maxScore: '<?',
                fetchStateDelegate: '=',
                updateStateDelegate: '='
            },
            require: ['fsMinScore', '?^^form']
        };
    }
    fsMinScoreDirective.$inject = ['assert'];
    angular.module('Fortscale.shared.components.fsMinScore')
        .directive('fsMinScore', fsMinScoreDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsSelect', []);
}());

(function () {
    'use strict';
    function fsSelectDirective(assert) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrls
         */
        function linkFn(scope, element, attrs, ctrls) {
            // Link function logic
            var ctrl = ctrls[0];
            ctrl.formCtrl = ctrls[1];
            ctrl._renderSelectElement();
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsSelectController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsSelectController.prototype, {
            _errMsg: 'fsSelect.directive: ',
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                assert.isFunction(this.fetchStateDelegate, 'fetchStateDelegate', this._errMsg + 'arguments: ', true);
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                assert.isFunction(this.updateStateDelegate, 'updateStateDelegate', this._errMsg + 'arguments: ', true);
            },
            /**
             * Validates selectMap
             *
             * @private
             */
            _validateSelectMap: function () {
                var errMsg = this._errMsg + 'arguments: ';
                assert.isObject(this.selectMap, 'selectMap', errMsg);
                if (this.selectMap) {
                    _.each(this.selectMap, function (selectValue, key) {
                        assert.isString(selectValue, 'selectMap[' + key + ']', errMsg, false, true);
                    });
                }
            },
            /**
             * Validates that provided selectedId is an actual id on selectMap
             *
             * @param {string=} errMsg
             * @param {string=} selectedId
             * @private
             */
            _validateSelectedId: function (errMsg, selectedId) {
                if (this.selectedId !== undefined && this.selectedId !== null) {
                    errMsg = errMsg || this._errMsg + '_validateSelectedId: id must be one of the id\'s provided in' +
                        ' selectMap';
                    selectedId = selectedId || this.selectedId;
                    var exists = Object.keys(this.selectMap).some(function (id) {
                        return id === selectedId;
                    }, this);
                    assert(exists, errMsg, RangeError);
                }
            },
            /**
             * Directive validation sequence
             *
             * @private
             */
            _validations: function () {
                this._validateGetStateFn();
                this._validateSetStateFn();
                this._validateSelectMap();
            },
            /**
             * Returns the value of the the state by the id
             * @returns {*}
             * @private
             */
            _stateWatchFn: function () {
                if (this.fetchStateDelegate) {
                    return this.fetchStateDelegate(this.selectId);
                }
            },
            /**
             * Watch action function . Sets the value to the picker if state has changed.
             *
             * @param {string|number} value
             */
            _stateWatchActionFn: function (value) {
                if (value !== null && value !== undefined) {
                    this.setSelectValue(value);
                }
            },
            /**
             * Initiates state watch
             *
             * @returns {*|function()}
             * @private
             */
            _initStateWatch: function () {
                this.$scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
            },
            /**
             * input change handler. When the input element changes, will change the value of the picker and fire
             * 'change' event.
             *
             * @private
             */
            _SelectChangeHandler: function () {
                this.updateStateDelegate({
                    id: this.selectId,
                    type: 'DATA',
                    value: this.getSelectValue(),
                    immediate: !this.isNotImmediate
                });
                if (this.formCtrl && !!this.isNotImmediate) {
                    this.$scope.$apply(this.formCtrl.$setDirty.bind(this.formCtrl));
                }
                this.selectElement.blur();
            },
            /**
             * Sets a Select change handler.
             *
             * @private
             */
            _initSelectChangeWatch: function () {
                var ctrl = this;
                // Lock in context
                function listenerFn(evt) {
                    ctrl._SelectChangeHandler(evt);
                }
                ctrl.selectElement.on('change', listenerFn);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    ctrl.selectElement.off('change', listenerFn);
                });
            },
            /**
             * Init watches sequence
             *
             * @private
             */
            _initWatches: function () {
                this._initStateWatch();
                this._initSelectChangeWatch();
            },
            /**
             * Adds a select option to select element
             *
             * @param {string} id
             * @param {string} value
             * @private
             */
            _addSelectOption: function (id, value) {
                var option = document.createElement("option");
                option.text = value;
                option.value = id;
                this.selectElement[0].add(option);
            },
            /**
             * Renders all options received on selectMap
             *
             * @private
             */
            _renderOptions: function () {
                _.each(this.selectMap, _.bind(function (value, key) {
                    this._addSelectOption(key, value);
                }, this));
            },
            /**
             * Sets the initial value of the select element. If selectedId is provided, it's assigned to the element
             * via setSelectValue. if selectedId is not provided, the first option is selected.
             * @private
             */
            _setInitialValue: function () {
                var selectedId = this.selectedId ||
                    (this.selectElement[0].options &&
                        this.selectElement[0].options[0] &&
                        this.selectElement[0].options[0].value);
                if (selectedId) {
                    this.setSelectValue(selectedId);
                }
            },
            /**
             * Renders the select element
             *
             * @private
             */
            _renderSelectElement: function () {
                this._renderOptions();
                this._setInitialValue();
            },
            /**
             * Sets the element value.
             *
             * @param {string|number} value
             * @returns {*}
             */
            setSelectValue: function (value) {
                this._validateSelectedId(this._errMsg + 'setSelectValue: ', value);
                this.selectElement[0].value = value;
            },
            /**
             * Gets the element value
             *
             * @returns {string}
             */
            getSelectValue: function () {
                return this.selectElement[0].value;
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                ctrl.selectElement = ctrl.$element.find('select');
                ctrl._validations();
                ctrl._initWatches();
            }
        });
        FsSelectController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<div class="fs-select"><select></select><svg class="dropdown-icon"><use xlink:href="#dropdown-icon"></use></svg></div>',
            scope: {},
            link: linkFn,
            controller: FsSelectController,
            controllerAs: 'ctrl',
            bindToController: {
                selectId: '@',
                selectMap: '=',
                selectedId: '@',
                isNotImmediate: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '='
            },
            require: ['fsSelect', '?^^form']
        };
    }
    fsSelectDirective.$inject = ['assert'];
    angular.module('Fortscale.shared.components.fsSelect')
        .directive('fsSelect', fsSelectDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsAutocomplete', []);
}());

/**
 * @name: fsAutocomplete.directive
 * @description: This directive will use kendo to render an autocomplete element. The element is based on received
 * configurations and settings.
 * @param {string} autocompleteId The (should be) unique id within a state chain.
 * @param {function=} fetchStateDelegate Function that's used to get an external state by providing autocompleteId
 * @param {function=} updateStateDelegate Function that's used to update an external state by providing an object:
 * {id: string, type: string, value: *, immediate: boolean}
 * @param {object} autocompleteSettings The required configuration. The received object will override any property
 * on _settings.
 * @param {object} resourceSettings A configuration object, that if received will be used for server filtering.
 */
(function () {
    'use strict';
    function fsAutocompleteDirective(assert, interpolation, BASE_URL) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrls
         */
        function linkFn(scope, element, attrs, ctrls) {
            // Link function logic
            var ctrl = ctrls[0];
            ctrl.formCtrl = ctrls[1];
            ctrl._renderAutocompleteElement();
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsAutocompleteController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsAutocompleteController.prototype, {
            _errMsg: 'fsAutocomplete.directive: ',
            /**
             * Validates received id is a non empty string.
             *
             * @private
             */
            _validateId: function () {
                assert.isString(this.autocompleteId, 'autocompleteId', this._errMsg + 'arguments: autocompleteId: ', false, false);
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                assert.isFunction(this.fetchStateDelegate, 'fetchStateDelegate', this._errMsg + 'arguments: ', true);
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                assert.isFunction(this.updateStateDelegate, 'updateStateDelegate', this._errMsg + 'arguments: ', true);
            },
            /**
             * Validate settings was received
             * @private
             */
            _validateSettingsReceived: function () {
                assert.isObject(this.autocompleteSettings, 'autocompleteSettings', this._errMsg + 'arguments: ', false);
            },
            /**
             * Validates settings has dataValueField or dataValueFn
             * Validates dataValueField is a non empty string if received.
             * Validates dataValueFn is a function if received.
             *
             * @private
             */
            _validateSettingsDataValue: function () {
                assert(this.autocompleteSettings.dataValueField || this.autocompleteSettings.dataValueFn, this._errMsg + 'arguments: autocompleteSettings: dataValueField or dataValueFn must be provided.', ReferenceError);
                assert.isString(this.autocompleteSettings.dataValueField, 'autocompleteSettings.dataValueField', this._errMsg + 'arguments: autocompleteSettings: ', true, false);
                assert.isFunction(this.autocompleteSettings.dataValueFn, 'autocompleteSettings.dataValueFn', this._errMsg + 'arguments: autocompleteSettings: ', true);
            },
            /**
             * Validates dataTextField is a non empty string.
             * Validates dataTextFn is a function if received.
             *
             * @private
             */
            _validateSettingsTextValue: function () {
                assert.isString(this.autocompleteSettings.dataTextField, 'autocompleteSettings.dataTextField', this._errMsg + 'arguments: autocompleteSettings: ', false, false);
                assert.isFunction(this.autocompleteSettings.dataTextFn, 'autocompleteSettings.dataTextFn', this._errMsg + 'arguments: autocompleteSettings: ', true);
            },
            /**
             * Validates resourceSettings is an object if received.
             *
             * @private
             */
            _validateResourceSettingsReceived: function () {
                assert.isObject(this.resourceSettings, 'resourceSettings', this._errMsg + 'arguments: ', true);
            },
            /**
             * Validates entity on resourceSettings is a non empty string
             *
             * @private
             */
            _validateResourceSettingsEntity: function () {
                assert.isString(this.resourceSettings.entity, 'resourceSettings.entity', this._errMsg + 'arguments: resourceSettings: ', false, false);
            },
            /**
             * Validates params on resourceSettings is an object if received.
             *
             * @private
             */
            _validateResourceSettingsParams: function () {
                assert.isObject(this.resourceSettings.params, 'resourceSettings.params', this._errMsg + 'arguments:' + ' resourceSettings: ', true);
            },
            /**
             * Directive validation sequence
             *
             * @private
             */
            _validations: function () {
                this._validateId();
                this._validateGetStateFn();
                this._validateSetStateFn();
            },
            /**
             * Directive's settings validation sequence
             *
             * @private
             */
            _validateSettings: function () {
                this._validateSettingsReceived();
                this._validateSettingsDataValue();
                this._validateSettingsTextValue();
            },
            /**
             * Directive's resource settings validation sequence
             *
             * @private
             */
            _validateResourceSettings: function () {
                this._validateResourceSettingsReceived();
                if (this.resourceSettings) {
                    this._validateResourceSettingsEntity();
                    this._validateResourceSettingsParams();
                }
            },
            /**
             * Fires a fsAutocomplete:itemSelected event.
             *
             * @private
             */
            _fireSelectEvent: function (dataItem) {
                this.$scope.$applyAsync(function () {
                    this.$scope.$root.$broadcast('fsAutocomplete:itemSelected', this.autocompleteId, dataItem);
                }.bind(this));
            },
            /**
             * Fires when element value has changed, ie selection was made or focus was lost after change. It's
             * fired via Kendo autocomplete controller
             *
             * @private
             */
            _changeHandler: function () {
                // Get value
                var dataValue = this.getAutocompleteValue();
                var stateValue = this.fetchStateDelegate && this.fetchStateDelegate(this.autocompleteId);
                if (dataValue === stateValue) {
                    return;
                }
                // Positive updateOnNull will cause the element to update state even if the value is null
                if ((this._settings.updateOnNull || dataValue !== null) && this.updateStateDelegate) {
                    // Update state
                    this.updateStateDelegate({
                        id: this.autocompleteId,
                        type: 'DATA',
                        value: dataValue,
                        immediate: !!this._settings.isImmediate
                    });
                    // Update form controller if it exists and isImmediate is false
                    if (this.formCtrl && !this._settings.isImmediate) {
                        this.$scope.$apply(this.formCtrl.$setDirty.bind(this.formCtrl));
                    }
                }
                // If flag resetOnNull is positive, then reset value of element. (set to null)
                if (this._settings.resetOnNull && !dataValue) {
                    this.setAutocompleteValue(null);
                }
                // Focus out of element
                this.inputElement.blur();
                var dataItem = this.autocompleteCtrl.dataItem();
                this._fireSelectEvent(dataItem);
            },
            /**
             * Initiates settings. Digest received settings and creates settings that kendo will accept.
             *
             * @private
             */
            _initSettings: function () {
                this._validateSettings();
                var ctrl = this;
                this._settings = _.merge({}, {
                    // Directive  default settings
                    dataValueField: null,
                    dataValueFn: null,
                    mustBeInData: false,
                    updateOnNull: false,
                    resetOnNull: false,
                    isImmediate: false,
                    dataTextFn: null,
                    // Kendo default settings
                    delay: 300,
                    minLength: 1,
                    placeholder: "Service Account Username",
                    dataSource: (ctrl.resourceSettings && new kendo.data.DataSource({
                        transport: {
                            read: {
                                url: BASE_URL + '/' + ctrl._resourceSettings.entity,
                                dataType: "json",
                                data: function () {
                                    var searchQuery = ctrl._getSearchQueryValue();
                                    var interpolatedSettings = interpolation.interpolate(ctrl._resourceSettings, {
                                        search: searchQuery || ctrl._initialValue
                                    });
                                    return interpolatedSettings.params;
                                }
                            },
                            /**
                             * Adapter function for query params
                             *
                             * @param data
                             * @returns {string}
                             */
                            parameterMap: function (data) {
                                return _.map(data, function (queryParamValue, queryParamName) {
                                    if (_.isObject(queryParamValue)) {
                                        var queryParamAsJsonString;
                                        try {
                                            queryParamAsJsonString = JSON.stringify(queryParamValue);
                                            queryParamValue = queryParamAsJsonString;
                                        }
                                        catch (e) {
                                            console.warn(ctrl._errMsg + 'kendo:transport:parameterMap:' +
                                                ' translation of object to string failed.', queryParamValue);
                                            return '';
                                        }
                                    }
                                    return queryParamName + '=' + queryParamValue;
                                }).join('&');
                            }
                        },
                        schema: {
                            data: "data"
                        },
                        serverFiltering: ctrl.resourceSettings && true,
                        change: function () {
                            if (ctrl.autocompleteSettings.dataTextFn) {
                                ctrl.autocompleteSettings.dataTextFn(this.data());
                            }
                        }
                    })) || null,
                    //Kendo default event handlers
                    change: this._changeHandler.bind(this)
                }, this.autocompleteSettings);
                // place the dataSource directly on the controller instance
                this._dataSource = this._settings.dataSource;
            },
            /**
             * Initiates resource settings.
             *
             * @private
             */
            _initResourceSettings: function () {
                this._validateResourceSettings();
                this._resourceSettings = _.merge({}, this.resourceSettings);
            },
            /**
             * Returns the value of the the state by the id
             * @returns {*}
             * @private
             */
            _stateWatchFn: function () {
                if (this.fetchStateDelegate) {
                    return this.fetchStateDelegate(this.autocompleteId);
                }
            },
            /**
             * Watch action function . Sets the value to the autocomplete if state has changed.
             *
             * @param {string|number} value
             */
            _stateWatchActionFn: function (value) {
                if (value !== null && value !== undefined && value !== this.getAutocompleteValue()) {
                    this._setAutocompleteInitialValue(value);
                }
            },
            /**
             * Initiates state watch
             *
             * @returns {*|function()}
             * @private
             */
            _initStateWatch: function () {
                this.$scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
            },
            _initWatches: function () {
                this._initStateWatch();
            },
            /**
             * Processes the value of the input. Remove all whitespace from the string.
             *
             * @returns {string|null}
             * @private
             */
            _getSearchQueryValue: function () {
                // Get value
                var value = this.autocompleteCtrl.value(value);
                if (!value) {
                    return null;
                }
                //// Remove all white spaces
                //value = value.replace(/\s/g, '');
                // return value
                return value;
            },
            /**
             * Renders the autocomplete element. Places the rendered element kendo controller on the controller
             * instance.
             *
             * @private
             */
            _renderAutocompleteElement: function () {
                var ctrl = this;
                ctrl.inputElement.kendoAutoComplete(ctrl._settings);
                ctrl.autocompleteCtrl = ctrl.inputElement.data("kendoAutoComplete");
                // Make sure that when input value is deleted, and updateOnNull is on, update happens
                function emptyOnBackspaceHandler(evt) {
                    if (evt.keyCode === 8 && ctrl.inputElement.val() === '' && ctrl._settings.updateOnNull) {
                        ctrl._fireSelectEvent(null);
                        ctrl.autocompleteCtrl.trigger('change');
                    }
                }
                ctrl.inputElement.on('keyup', emptyOnBackspaceHandler);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    ctrl.inputElement.off('keyup', emptyOnBackspaceHandler);
                });
            },
            /**
             * Processes received value from state, and selects the required choice.
             *
             * @param value
             * @private
             */
            _setAutocompleteInitialValue: function (value) {
                var ctrl = this;
                ctrl._initialValue = value;
                ctrl.autocompleteCtrl.enable(false);
                // fetch data if resourceSettings is provided
                if (ctrl.resourceSettings && ctrl._dataSource.fetch) {
                    // Fetch data and fire callback
                    ctrl._dataSource.fetch(function () {
                        // select the first one (should be only one)
                        if (ctrl.autocompleteCtrl.dataItems().length) {
                            ctrl.autocompleteCtrl.select(ctrl.autocompleteCtrl.ul.children().eq(0));
                            ctrl._fireSelectEvent(ctrl.autocompleteCtrl.dataItem());
                            ctrl.autocompleteCtrl.trigger('change');
                        }
                        // delete initial value
                        ctrl._initialValue = null;
                        // enable the element
                        ctrl.autocompleteCtrl.enable(true);
                    });
                }
                else {
                    assert(ctrl._settings.dataValueField !== null || ctrl._settings.dataValueField !== undefined, ctrl._errMsg + 'When using autocomplete without server filtering, ie providing dataSource ' +
                        'in settings, dataValueField must be provided. Using dataValueFn will not allow the ' +
                        'selection of initial state.', RangeError);
                    var query = {};
                    query[ctrl._settings.dataValueField] = value;
                    var selectedItem = _.filter(ctrl._dataSource, query).shift();
                    if (selectedItem) {
                        ctrl.setAutocompleteValue(selectedItem[ctrl._settings.dataTextField]);
                        ctrl._fireSelectEvent(selectedItem);
                    }
                    else {
                        ctrl.setAutocompleteValue(value);
                    }
                    ctrl.autocompleteCtrl.trigger('change');
                    // delete initial value
                    ctrl._initialValue = null;
                    // enable the element
                    ctrl.autocompleteCtrl.enable(true);
                }
            },
            /**
             * Sets the element value (without selection).
             *
             * @param {string|number} value
             * @returns {*}
             */
            setAutocompleteValue: function (value) {
                return this.autocompleteCtrl.value(value);
            },
            /**
             * Gets the element value. The extraction is based on the configuration.
             *
             * @returns {string|null}
             */
            getAutocompleteValue: function () {
                // Get data item from kendo controller
                var dataItem = this.autocompleteCtrl.dataItem();
                // If dataItem is not null:
                if (dataItem) {
                    // If settings has a dataValueField then dataItem should be dataItem[dataValueField] otherwise
                    // it should be the return value of dataValueFn(dataItem, dataItems)
                    if (this._settings.dataValueField) {
                        dataItem = dataItem[this._settings.dataValueField];
                    }
                    else if (this._settings.dataValueFn) {
                        dataItem = this._settings.dataValueFn(dataItem, this.autocompleteCtrl.dataItems());
                    }
                }
                else {
                    // if flag mustBeInData is negative, then data item should be
                    // autocompleteCtrl.value() otherwise it should be null
                    if (!this._settings.mustBeInData) {
                        dataItem = this.autocompleteCtrl.value();
                    }
                }
                return dataItem;
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                ctrl.inputElement = ctrl.$element.find('input');
                ctrl._validations();
                ctrl._initResourceSettings();
                ctrl._initSettings();
                ctrl._initWatches();
            }
        });
        FsAutocompleteController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<input class="autocomplete-input">',
            scope: {},
            link: linkFn,
            controller: FsAutocompleteController,
            controllerAs: 'ctrl',
            bindToController: {
                autocompleteId: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                autocompleteSettings: '=',
                resourceSettings: '='
            },
            require: ['fsAutocomplete', '?^^form']
        };
    }
    fsAutocompleteDirective.$inject = ['assert', 'interpolation', 'BASE_URL'];
    angular.module('Fortscale.shared.components.fsAutocomplete')
        .directive('fsAutocomplete', fsAutocompleteDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsGenInput', []);
}());

(function () {
    'use strict';
    var IS_OPTIONAL = true;
    var IS_NOT_OPTIONAL = false;
    var CAN_NOT_BE_EMPTY = false;
    function fsGenInputDirective(assert, $compile) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrls
         */
        function linkFn(scope, element, attrs, ctrls) {
            // Link function logic
            var ctrl = ctrls[0];
            ctrl.formCtrl = ctrls[1];
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsGenInputController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsGenInputController.prototype, {
            _errMsg: 'fsGenInput.directive: ',
            _validateGenInputId: function () {
                assert.isString(this.genInputId, 'genInputId', this._errMsg + 'arguments: ', IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                assert.isFunction(this.fetchStateDelegate, 'fetchStateDelegate', this._errMsg + 'arguments: ', IS_OPTIONAL);
            },
            /**
             * Validate updateStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                assert.isFunction(this.updateStateDelegate, 'updateStateDelegate', this._errMsg + 'arguments: ', IS_OPTIONAL);
            },
            _validateAttributes: function () {
                assert.isObject(this.attributes, 'attributes', this._errMsg + 'arguments: ', IS_OPTIONAL);
            },
            _validateState: function () {
                assert.isObject(this.state, 'state', this._errMsg + 'arguments: ', IS_OPTIONAL);
            },
            /**
             * Directive validation sequence
             *
             * @private
             */
            _validations: function () {
                this._validateGenInputId();
                this._validateGetStateFn();
                this._validateSetStateFn();
                this._validateAttributes();
                this._validateState();
            },
            /**
             * Returns the value of the the state by the id
             * @returns {*|undefined}
             * @private
             */
            _stateWatchFn: function () {
                if (this.fetchStateDelegate) {
                    return this.fetchStateDelegate(this.genInputId);
                }
            },
            /**
             * Watch action function . Sets the value to the picker if state has changed.
             *
             * @param {string|number} value
             */
            _stateWatchActionFn: function (value) {
                if (value !== undefined && value !== null && this.getInputValue() !== value) {
                    this.setInputValue(value);
                }
            },
            /**
             * Initiates state watch
             *
             * @returns {*|function()}
             * @private
             */
            _initStateWatch: function () {
                this.$scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
            },
            /**
             * input change handler. When the input element changes, the
             *
             * @private
             */
            _inputChangeHandler: function () {
                if (!this.ngModelCtrl.$valid) {
                    return;
                }
                if (this.updateStateDelegate) {
                    this.updateStateDelegate({
                        id: this.genInputId,
                        type: 'DATA',
                        value: this.getInputValue(),
                        immediate: !!this.isImmediate
                    });
                }
                if (this.formCtrl) {
                    this.formCtrl.$setDirty.call(this.formCtrl);
                }
            },
            /**
             * Sets an input change handler.
             *
             * @private
             */
            _initInputChangeWatch: function () {
                var ctrl = this;
                ctrl.ngModelCtrl.$viewChangeListeners = [
                    this._inputChangeHandler.bind(this)
                ];
            },
            /**
             * Makes sure that using the 'Enter' key will not fire submit action on the form.
             *
             * @private
             */
            _initDisableSubmitOnEnter: function () {
                var ctrl = this;
                function disableEnterKey(evt) {
                    var code = evt.keyCode || evt.which;
                    if (code === 13) {
                        evt.preventDefault();
                        ctrl.inputElement.trigger('blur');
                        return false;
                    }
                }
                ctrl.inputElement.on('keyup keypress', disableEnterKey);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    ctrl.inputElement.off('keyup keypress', disableEnterKey);
                });
            },
            /**
             * Init watches sequence
             *
             * @private
             */
            _initWatches: function () {
                this._initStateWatch();
                this._initInputChangeWatch();
                this._initDisableSubmitOnEnter();
            },
            /**
             * Takes an (angular/jquery) element, and applies attributes object with attr method. All properties on
             * attributes object will be assigned to element as attributes.
             *
             * @param {angular.element} element
             * @param {object=} attributes
             * @private
             */
            _assignAttributes: function (element, attributes) {
                if (attributes) {
                    // Assign attributes to element
                    angular.element(element).attr(attributes);
                }
            },
            /**
             * Renders and compiles the input element.
             *
             * @private
             */
            _renderElement: function () {
                // Create element
                this.inputElement = angular.element('<input ng-model="ctrl.model">');
                // Assign attributes to element
                this._assignAttributes(this.inputElement, _.merge({}, {
                    "ng-model-options": "{ updateOn: 'default blur', debounce: { 'default': " + (this.debounce || 400) +
                        ", 'blur': 0 } }"
                }, this.attributes));
                // Compile the element
                this.inputElement = $compile(this.inputElement)(this.$scope);
                // 'Capture' ngModel controller
                this.ngModelCtrl = this.inputElement.controller('ngModel');
                // Append input element to directive element
                this.$element.append(this.inputElement);
            },
            /**
             * Sets the input value.
             *
             * @param {string|number} value
             * @returns {*}
             */
            setInputValue: function (value) {
                return this.inputElement.val(value);
            },
            /**
             * Gets the input value
             *
             * @returns {string}
             */
            getInputValue: function () {
                return this.inputElement.val();
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                ctrl._validations();
                ctrl._renderElement();
                ctrl._initWatches();
            }
        });
        FsGenInputController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<span class="gen-input-wrapper"></span>',
            scope: {},
            link: linkFn,
            controller: FsGenInputController,
            controllerAs: 'ctrl',
            bindToController: {
                genInputId: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                attributes: '=',
                state: '=',
                isImmediate: '@',
                debounce: '@'
            },
            require: ['fsGenInput', '?^^form']
        };
    }
    fsGenInputDirective.$inject = ['assert', '$compile'];
    angular.module('Fortscale.shared.components.fsGenInput')
        .directive('fsGenInput', fsGenInputDirective);
}());

(function () {
    'use strict';
    var IS_NOT_OPTIONAL = false;
    var CAN_NOT_BE_EMPTY = false;
    function CountryCodesUtilService(assert, countryCodes) {
        this.assert = assert;
        this.countryCodes = countryCodes;
    }
    _.merge(CountryCodesUtilService.prototype, {
        _errMsg: 'countryCodesUtils.service: ',
        /**
         * Returns a country object by
         *
         * @param {String} searchBy The property name to search by
         * @param {String} searchValue the value to search by
         * @returns {*|null}
         * @private
         */
        _getCountryObj: function (searchBy, searchValue) {
            // Since the countryCodes object's properties names are country names, there is no need to query when
            // searchBy is 'name', you just need to return the country object.
            if (searchBy === 'name') {
                return this.countryCodes[searchValue] || null;
            }
            else {
                // Query the countryCodes object to get the required country object.
                var query = {};
                query[searchBy] = searchValue;
                return _.filter(this.countryCodes, query)[0] || null;
            }
        },
        /**
         * Validates countryName argument
         *
         * @param {String} methodName
         * @param {String} countryName
         * @private
         */
        _validateCountryName: function (methodName, countryName) {
            this.assert.isString(countryName, 'countryName', this._errMsg + methodName + ': ', IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
        },
        /**
         * Return Alpha2 value by country name.
         *
         * @param {String} countryName
         * @returns {String|Null}
         */
        getAlpha2ByCountryName: function (countryName) {
            this._validateCountryName('getAlpha2ByCountryName', countryName);
            var countryObj = this._getCountryObj('name', countryName.trim().toLowerCase());
            if (countryObj === null) {
                return null;
            }
            return countryObj['alpha-2'];
        },
        /**
         * Return Alpha2 value by country code.
         *
         * @param {String} countryCode
         * @returns {String|Null}
         */
        getAlpha2ByCountryCode: function (countryCode) {
            this.assert.isString(countryCode, 'countryCode', this._errMsg + 'getAlpha2ByCountryCode: ', IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
            var countryObj = this._getCountryObj('country-code', countryCode.time());
            if (countryObj === null) {
                return null;
            }
            return countryObj['alpha-2'];
        },
        /**
         * Return country-code value by country name.
         *
         * @param {String} countryName
         * @returns {String|Null}
         */
        getCountryCodeByCountryName: function (countryName) {
            this._validateCountryName('getAlpha2ByCountryName', countryName);
            var countryObj = this._getCountryObj('name', countryName.trim().toLowerCase());
            if (countryObj === null) {
                return null;
            }
            return countryObj['country-code'];
        },
        /**
         * Returns country name by alpha-2 code
         *
         * @param {String} alpha2
         * @returns {String|Null}
         */
        getCountryNameByAlpha2: function (alpha2) {
            this.assert.isString(alpha2, 'alpha2', this._errMsg + 'getCountryNameByAlpha2: ', IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
            var countryObj = this._getCountryObj('alpha-2', alpha2.trim().toUpperCase());
            if (countryObj === null) {
                return null;
            }
            return countryObj.name;
        },
        /**
         * Returns country name by country-code
         *
         * @param {String} countryCode
         * @returns {String|Null}
         */
        getCountryNameByCountryCode: function (countryCode) {
            this.assert.isString(countryCode, 'countryCode', this._errMsg + 'getCountryNameByAlpha2: ', IS_NOT_OPTIONAL, CAN_NOT_BE_EMPTY);
            var countryObj = this._getCountryObj('country-code', countryCode);
            if (countryObj === null) {
                return null;
            }
            return countryObj.name;
        }
    });
    CountryCodesUtilService.$inject = ['assert', 'countryCodes'];
    angular.module('Fortscale.shared.services.countryCodesUtil', [])
        .service('countryCodesUtil', CountryCodesUtilService);
}());

(function () {
    'use strict';
    function FsIndicatorTypes(assert, $http, BASE_URL, appConfig, dataEntities) {
        this._PATH = '/alerts/exist-anomaly-types';
        this._ERR_MSG = 'FsIndicatorTypes: ';
        this._CONFIG_LOCALE_KEY = 'system.locale.settings';
        this._CONFIG_INDICATOR_KEY = "messages." + appConfig.getConfigItem(this._CONFIG_LOCALE_KEY).value + ".evidence.";
        this._MAJOR_DELIMITER = '@@@';
        this._MINOR_DELIMITER = '@@';
        /**
         * Used to define the indicator type. Single or aggregated. Also used to define the sort order.
         * @type {Array<{id: string, queryFn: Function, sortOrder: number}>}
         * @private
         */
        this._indicator_types = [
            {
                id: 'Single',
                queryFn: function (val) {
                    return !(/daily$|hourly$/.test(val));
                },
                sortOrder: 0
            },
            {
                id: 'Aggregated',
                queryFn: function (val) {
                    return /daily$|hourly$/.test(val);
                },
                sortOrder: 1
            }
        ];
        /**
         * Return the indicator types resource
         *
         * @returns {Promise}
         * @private
         */
        this._getIndicatorsListResource = function () {
            return $http.get(BASE_URL + this._PATH);
        };
        /**
         *
         * @param {Array<string>} list
         * @private
         */
        /**
         *
         * @param {Array<string>} list
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, id: string} | {}>}
         * @private
         */
        this._breakListByValue = function (list) {
            var _this = this;
            return _.map(list, function (listItem) {
                var listItemKeyValueList = listItem.split(_this._MAJOR_DELIMITER);
                if (listItemKeyValueList.length !== 2) {
                    console.warn(_this._ERR_MSG + "Trying to parse an incorrect value; " + listItem);
                    return {};
                }
                var dataSourceId = listItemKeyValueList[0];
                var anomalyTypeFieldName = listItemKeyValueList[1];
                return {
                    id: listItem,
                    dataSourceId: dataSourceId,
                    anomalyTypeFieldName: anomalyTypeFieldName
                };
            });
        };
        /**
         *
         * @param {Array<{dataSourceId: string, anomalyTypeFieldName: string, id: string}>} list
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string, id: string}>}
         */
        this._populateAnomalyName = function (list) {
            var _this = this;
            return _.map(list, function (listItem) {
                // Get anomaly name from config item
                var anomalyTypeConfigItem = appConfig.getConfigItem(_this._CONFIG_INDICATOR_KEY + listItem.dataSourceId + "." +
                    listItem.anomalyTypeFieldName);
                if (!anomalyTypeConfigItem) {
                    anomalyTypeConfigItem =
                        appConfig.getConfigItem(_this._CONFIG_INDICATOR_KEY + listItem.anomalyTypeFieldName);
                }
                // If config item was found, then name would be its value, otherwise set it to anomalyTypeFieldName
                if (anomalyTypeConfigItem && anomalyTypeConfigItem.value) {
                    listItem.anomalyTypeName = anomalyTypeConfigItem.value;
                }
                else {
                    listItem.anomalyTypeName = listItem.anomalyTypeFieldName;
                }
                return listItem;
            });
        };
        //noinspection JSClosureCompilerSyntax
        /**
         *
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string, id: string}>}
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>}
         * @private
         */
        this._populateDataSourceName = function (list) {
            return _.map(list, function (listItem) {
                // Get data entity
                var dataSource = dataEntities.getEntityById(listItem.dataSourceId);
                // If data entity exists set name to dataSourceName otherwise set it listItem.dataSourceId
                if (dataSource) {
                    listItem.dataSourceName = dataSource.name;
                }
                else {
                    listItem.dataSourceName = listItem.dataSourceId;
                }
                return listItem;
            });
        };
        /**
         * Populates anomalyTypeFullName: <dataSourceName - anomalyTypeName>
         *
         * @param list
         * @returns {Array}
         * @private
         */
        this._populateAnomalyFullName = function (list) {
            return _.map(list, function (listItem) {
                listItem.anomalyTypeFullName = listItem.dataSourceName + " - " + listItem.anomalyTypeName;
                return listItem;
            });
        };
        /**
         * Populates indicator types and indicator types order for sorting.
         *
         * @param list
         * @returns {Array}
         * @private
         */
        this._populateIndicatorType = function (list) {
            var _this = this;
            return _.map(list, function (listItem) {
                _.some(_this._indicator_types, function (indicatorTypeQryObj) {
                    if (indicatorTypeQryObj.queryFn(listItem.id)) {
                        listItem.indicatorType = indicatorTypeQryObj.id;
                        listItem.indicatorTypeOrder = indicatorTypeQryObj.sortOrder;
                    }
                    return false;
                });
                return listItem;
            });
        };
        /**
         *
         * @param {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>} list
         * @param {Array<string>} sort the sorting strings
         * @param {Array<string>} order the sorting order
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>}
         * @private
         */
        this._orderPopulatedList = function (list, sort, order) {
            return _.orderBy(list, sort, order);
        };
        /**
         *
         * @param {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>} list
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>}
         * @private
         */
        this._populateFinalizedSinglesList = function (list) {
            var _this = this;
            var groupedListByAnomalyTypeFullName = _.groupBy(list, "anomalyTypeFullName");
            return _.map(groupedListByAnomalyTypeFullName, function (group) {
                var groupObj = _.merge({}, group[0]);
                // Set full id as a csv of ids
                groupObj.id = groupObj.dataSourceId + _this._MAJOR_DELIMITER +
                    _.map(group, function (listItem) { return listItem.anomalyTypeFieldName; }).join(_this._MINOR_DELIMITER);
                return groupObj;
            });
        };
        /**
         *
         * @param {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>} list
         * @returns {Array<{dataSourceId: string, anomalyTypeFieldName: string, anomalyTypeName: string,
         * dataSourceName: string, dataSourceName: string, id: string}>}
         * @private
         */
        this._populateFinalCommonList = function (list) {
            var groupedListByAnomalyTypeFullName = _.groupBy(list, "dataSourceName");
            return _.map(groupedListByAnomalyTypeFullName, function (group) {
                var groupObj = _.merge({}, group[0]);
                groupObj.id = groupObj.dataSourceId;
                groupObj.anomalyTypeFullName = "All " + groupObj.dataSourceName + " Indicators";
                return groupObj;
            });
        };
        /**
         * Takes a list of indicator type ids (anomalyTypeFieldName) and matches the display name taken from messages.
         *
         * @param {Array<string>} list
         * @returns {Array<{id: string, value: string}>}
         * @private
         */
        this._populateIdValueList = function (list) {
            // Break into a list of dataSourceId, anomalyTypeFieldName
            var populatedList = this._breakListByValue(list) || [];
            // Filter out empty objects
            populatedList = populatedList
                .filter(function (listItem) { return !!listItem.id; });
            // add anomaly name for each item on list
            populatedList = this._populateAnomalyName(populatedList);
            // Add data source name for each item on list
            populatedList = this._populateDataSourceName(populatedList);
            // add to list concat value of data source name + anomaly name as anomalyFullName
            populatedList = this._populateAnomalyFullName(populatedList);
            // Add indicator type and indicator type order
            populatedList = this._populateIndicatorType(populatedList);
            // Create final single list
            var finalSinglesList = this._populateFinalizedSinglesList(populatedList);
            // Sort list
            finalSinglesList = this._orderPopulatedList(finalSinglesList, ['dataSourceName', 'indicatorTypeOrder', 'anomalyTypeFullName'], ['asc', 'asc', 'asc']);
            var finalCommonList = this._populateFinalCommonList(populatedList);
            finalCommonList = this._orderPopulatedList(finalCommonList, ['dataSourceName'], ['asc']);
            var finalList = finalCommonList.concat(finalSinglesList);
            // Create a list of id: anomalyTypeFieldName, value: anomalyFullName
            return _.map(finalList, function (listItem) {
                return { id: listItem.id, value: listItem.anomalyTypeFullName };
            });
        };
        /**
         * Gets a list  a list of indicator type ids (anomalyTypeFieldName) from the server,
         * and creates a id-value list to be returned on resolve.
         * On error it will return an empty array.
         *
         * @returns {Promise}
         */
        this.getIndicatorsList = function () {
            var ctrl = this;
            var ERR_MSG = ctrl._ERR_MSG + 'getIndicatorsList: ';
            return ctrl._getIndicatorsListResource()
                .then(function (res) {
                assert.isArray(res.data, 'res.data', ERR_MSG);
                return ctrl._populateIdValueList(res.data);
            })
                .catch(function (err) {
                console.error(ctrl._ERR_MSG + 'Indicators type list process failed.');
                console.error(err);
                return [];
            });
        };
    }
    FsIndicatorTypes.$inject = ['assert', '$http', 'BASE_URL', 'appConfig', 'dataEntities'];
    angular.module('Fortscale.shared.services.fsIndicatorTypes', [])
        .service('fsIndicatorTypes', FsIndicatorTypes);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper', []);
}());

/**
 * This file will contain mapping settings which required  by few indicators mapping
 */
(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .value('indicatorTypeMapper.commonQueryParams', {
        /**
         * Used as a common param configuration
         */
        entityTypeAnomalyTypeCount: {
            context_type: '{{entityTypeFieldName}}',
            context_value: '{{entityName}}',
            feature: '{{anomalyTypeFieldName}}',
            'function': 'Count',
            num_columns: 4
        },
        /**
         * Used as a common param configuration for time aggregation indicators
         */
        aggregationIndicatorsByTime: {
            context_type: '{{entityTypeFieldName | fsRemoveIsExists:\'context.\':true}}',
            context_value: '{{entityName}}',
            feature: '{{anomalyTypeFieldName}}',
            'function': 'distinctEventsByTime'
        },
        /**
         * Used as a common param configuration
         */
        anomalyTypeEntityTypeCount: {
            context_type: '{{anomalyTypeFieldName}}',
            context_value: '{{anomalyValue}}',
            feature: '{{entityTypeFieldName}}',
            'function': 'Count',
            num_columns: 4
        },
        /**
         * param configuration for vpn-session data rate
         */
        entityTypeAnomalyTypeCount30days: {
            context_type: '{{entityTypeFieldName}}',
            context_value: '{{entityName}}',
            feature: '{{anomalyTypeFieldName}}',
            'function': 'VPNSession',
            num_columns: 5,
            time_range: 30
        },
        /**
         * Used as a common param configuration
         */
        entityTypeAnomalyTypeCount5Columns: {
            context_type: '{{entityTypeFieldName}}',
            context_value: '{{entityName}}',
            feature: '{{anomalyTypeFieldName}}',
            'function': 'Count',
            num_columns: 5
        },
    });
}());

/**
 * This file will contain mapping settings which required  all scatter-plot single charts
 */
(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .value('indicatorTypeMapper.abstract-scatter-plot', {
        templateUrl: 'app/layouts/alert/layouts/indicator-templates/singlescatterplot.html',
        settings: {
            scatterSettings: {
                styleSettings: {
                    height: '25rem',
                    width: '100%',
                    padding: '0 1.25rem',
                    boxSizing: 'border-box'
                },
                chartSettings: {
                    xAxis: [{
                            type: "datetime"
                        }],
                    yAxis: {
                        min: 0
                    }
                }
            }
        },
        indicatorClass: 'gen'
    });
}());

/**
 * Settings for indicator which contains heatmp
 */
(function () {
    'use strict';
    function ActivityTimeAnomalyFactory($filter) {
        /**
         * Used as weekDaysUs axis
         */
        var weekDaysUS = [
            'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'
        ];
        /**
         * Used as hours in a day axis.
         */
        var HoursInDay = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23];
        return {
            settings: {
                activityTimeAnomaly: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'hourlyCountGroupByDayOfWeek'
                    },
                    chartSettings: {
                        xAxis: {
                            categories: weekDaysUS.reverse(),
                            title: {
                                text: 'Week days'
                            },
                            labels: {
                                formatter: function () {
                                    return $filter('pascalCase')(this.value);
                                }
                            }
                        },
                        yAxis: {
                            title: {
                                text: 'Hours'
                            },
                            categories: HoursInDay
                        },
                        colorAxis: {
                            min: 1,
                            minColor: '#8fbde4',
                            maxColor: '#2766a9'
                        },
                        title: {
                            text: '{{dataEntitiesIds[0]|entityIdToName}} ' +
                                'Authentication Times (Last 90 days)'
                        },
                        "series": [{
                                "name": "{{dataEntitiesIds[0]|entityIdToName}} " +
                                    "Authentication Times (Last 90 days) "
                            }]
                    }
                }
            }
        };
    }
    ActivityTimeAnomalyFactory.inject = ['$filter'];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.activityTimeAnomaly', ActivityTimeAnomalyFactory);
}());

/**
 * This file will contain mapping settings for serial chart used for aggregation indicators
 */
(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper').
        /**
         * Filter which generate the relevant message key from the anomalyTypeFieldName and title or axisYtitle
         */
        filter('buildAggregatedKey', function () {
        var prefix = "evidence.aggregated.";
        return function (anomalyTypeFieldName, postfix) {
            return prefix + anomalyTypeFieldName + "." + postfix;
        };
    })
        .factory('indicatorTypeMapper.aggregated-serial', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    scatterSettings: {
                        params: commonQueryParams.aggregationIndicatorsByTime,
                        templates: {
                            titles: {
                                'Title-1': '{{ anomalyTypeFieldName  | buildAggregatedKey: \'title\' | translate}}'
                            },
                            valueAxes: {
                                'ValueAxis-1': '{{ anomalyTypeFieldName  | buildAggregatedKey: \'axisYtitle\' | ' +
                                    'translate}}'
                            }
                        },
                        sortData: function (data) {
                            return _.orderBy(data, [function (dataItem) { return parseInt(dataItem.keys[0], 10); }], ['asc']);
                        },
                        dataAdapter: function (indicator, dataItem) {
                            var chartItem = {
                                category: new Date(parseInt(dataItem.keys[0], 10)),
                                originalCategory: dataItem.keys[0],
                                value: dataItem.value
                            };
                            if (dataItem.anomaly) {
                                chartItem.color = '#FF0000';
                            }
                            return chartItem;
                        },
                        handlers: {},
                        chartSettings: {
                            "type": "serial",
                            "categoryField": "category",
                            "startDuration": 1,
                            "color": "#666666",
                            "fontFamily": "'Open Sans', sans-serif",
                            "export": {
                                "enabled": true
                            },
                            "categoryAxis": {
                                "axisColor": "#1C1A1A",
                                "color": "#666666",
                                "fontSize": 10,
                                "gridColor": "#FFFFFF",
                                "parseDates": true,
                                "equalSpacing": true,
                                'minPeriod': 'hh',
                                dateFormats: [{
                                        period: 'fff',
                                        format: 'JJ:NN:SS'
                                    }, {
                                        period: 'ss',
                                        format: 'JJ:NN:SS'
                                    }, {
                                        period: 'mm',
                                        format: 'JJ:NN'
                                    }, {
                                        period: 'hh',
                                        format: 'MMM DD JJ:NN'
                                    }, {
                                        period: 'DD',
                                        format: 'MMM DD'
                                    }, {
                                        period: 'WW',
                                        format: 'MMM DD'
                                    }, {
                                        period: 'MM',
                                        format: 'MMM YYYY'
                                    }, {
                                        period: 'YYYY',
                                        format: 'MMM YYYY'
                                    }]
                            },
                            "chartScrollbar": {
                                "enabled": true
                            },
                            "trendLines": [],
                            "graphs": [
                                {
                                    "colorField": "color",
                                    "columnWidth": 0.6,
                                    "fillAlphas": 1,
                                    "fillColors": "#C9E6F9",
                                    "id": "AmGraph-1",
                                    "lineColor": "#C9E6F9",
                                    "lineColorField": "color",
                                    "title": "graph 1",
                                    "type": "column",
                                    "valueField": "value",
                                    balloonFunction: function (dataItem) {
                                        return moment(dataItem.dataContext.category).utc().format('YYYY MMM DD HH:mm') +
                                            ' : <b>' + dataItem.dataContext.value + '</b>';
                                    }
                                }
                            ],
                            "guides": [],
                            "valueAxes": [
                                {
                                    "id": "ValueAxis-1",
                                    "axisThickness": 0,
                                    "color": "#666666",
                                    "showFirstLabel": false,
                                    "showLastLabel": false,
                                    "tickLength": -1,
                                    "titleBold": false,
                                    "titleColor": "#666666",
                                    "titleFontSize": 14,
                                    "precision": 0,
                                    "minimum": 0
                                }
                            ],
                            "allLabels": [],
                            "balloon": {},
                            "titles": [
                                {
                                    "id": "Title-1",
                                    "size": 15
                                }
                            ]
                        }
                    }
                }
            };
        }]);
}());

/**
 * This file will contain mapping settings for serial chart used for aggregation indicators
 */
(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper').
        /**
         * Filter which generate the relevant message key from the anomalyTypeFieldName and title or axisYtitle
         */
        filter('buildAggregatedKey', function () {
        var prefix = "evidence.aggregated.";
        return function (anomalyTypeFieldName, postfix) {
            return prefix + anomalyTypeFieldName + "." + postfix;
        };
    })
        .factory('indicatorTypeMapper.aggregated-serial-data-rate', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    scatterSettings: {
                        params: commonQueryParams.entityTypeAnomalyTypeCount30days,
                        templates: {
                            titles: {
                                'Title-1': 'VPN Exfiltration Rate for {{entityName}} (Last 30 Days)'
                            }
                        },
                        sortData: function (data) {
                            return _.orderBy(data, [function (dataItem) { return parseInt(dataItem.keys[0], 10); }], ['asc']);
                        },
                        dataAdapter: function (indicator, dataItem) {
                            var chartItem = {
                                category: new Date(parseInt(dataItem.keys[0], 10)),
                                originalCategory: dataItem.keys[0],
                                value: dataItem.value
                            };
                            if (dataItem.anomaly) {
                                chartItem.color = '#FF0000';
                            }
                            return chartItem;
                        },
                        handlers: {
                            "clickGraphItem": function (indicator, item) {
                                // indicatorChartTransitionUtil.go('columnEntity', indicator, item);
                            }
                        },
                        chartSettings: {
                            "type": "serial",
                            "categoryField": "category",
                            "startDuration": 1,
                            "color": "#666666",
                            "fontFamily": "'Open Sans', sans-serif",
                            "export": {
                                "enabled": true
                            },
                            "categoryAxis": {
                                "axisColor": "#1C1A1A",
                                "color": "#666666",
                                "fontSize": 10,
                                "gridColor": "#FFFFFF",
                                "parseDates": true,
                                "equalSpacing": true,
                                'minPeriod': 'hh',
                                dateFormats: [{
                                        period: 'fff',
                                        format: 'JJ:NN:SS'
                                    }, {
                                        period: 'ss',
                                        format: 'JJ:NN:SS'
                                    }, {
                                        period: 'mm',
                                        format: 'JJ:NN'
                                    }, {
                                        period: 'hh',
                                        format: 'MMM DD JJ:NN'
                                    }, {
                                        period: 'DD',
                                        format: 'MMM DD'
                                    }, {
                                        period: 'WW',
                                        format: 'MMM DD'
                                    }, {
                                        period: 'MM',
                                        format: 'MMM YYYY'
                                    }, {
                                        period: 'YYYY',
                                        format: 'MMM YYYY'
                                    }]
                            },
                            "chartScrollbar": {
                                "enabled": true
                            },
                            "trendLines": [],
                            "graphs": [
                                {
                                    "colorField": "color",
                                    "columnWidth": 0.6,
                                    "fillAlphas": 1,
                                    "fillColors": "#C9E6F9",
                                    "id": "AmGraph-1",
                                    "lineColor": "#C9E6F9",
                                    "lineColorField": "color",
                                    "title": "graph 1",
                                    "type": "column",
                                    "valueField": "value",
                                    balloonFunction: function (dataItem) {
                                        return moment(dataItem.dataContext.category).utc().format('YYYY MMM DD HH:mm') + ' : ' +
                                            $filter('prettyBytes')(dataItem.values.value) + '/s';
                                    }
                                }
                            ],
                            "guides": [],
                            "valueAxes": [
                                {
                                    "id": "ValueAxis-1",
                                    "axisThickness": 0,
                                    "color": "#666666",
                                    "showFirstLabel": false,
                                    "showLastLabel": false,
                                    "tickLength": -1,
                                    "titleBold": false,
                                    "titleColor": "#666666",
                                    "titleFontSize": 14,
                                    "precision": 0,
                                    "baseValue": -10,
                                    "title": 'Rate',
                                    labelFunction: function (value) {
                                        return $filter('prettyBytes')(value) + '/s';
                                    }
                                }
                            ],
                            "allLabels": [],
                            "balloon": {},
                            "titles": [
                                {
                                    "id": "Title-1",
                                    "size": 15
                                }
                            ]
                        }
                    }
                }
            };
        }]);
}());

/**
 * This file will contain mapping settings which required  by  date rate indicator
 */
(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.data-rate-scatter-plot', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    scatterSettings: {
                        params: commonQueryParams.entityTypeAnomalyTypeCount30days,
                        chartSettings: {
                            title: {
                                text: 'VPN Exfiltration Rate for {{entityName}} (Last 30 Days)'
                            },
                            yAxis: {
                                title: {
                                    text: 'Rate'
                                }
                            },
                            tooltip: {
                                formatter: function () {
                                    var tooltipText = 'Rate: ' + $filter('prettyBytes')(this.point.y) + '/Sec<br>';
                                    tooltipText += 'Total: ' + this.point.total + '<br>';
                                    tooltipText += 'Duration: ' + this.point.duration + ' (HH:MM:SS)';
                                    return tooltipText;
                                }
                            }
                        }
                    }
                }
            };
        }]);
}());

/**
 * This file contains setting for both column charts in any indicator which display
 * two column charts
 */
(function () {
    'use strict';
    //Adding map of the anomalyTypeFieldName to pretty name,
    //For each chart title (chart1, chart2)
    var indicatorsChartsTitles = {
        normalized_src_machine: {
            title_chart1: 'Source Devices',
            title_chart2: 'Users for Source Device'
        },
        normalized_dst_machine: {
            title_chart1: 'Target Devices',
            title_chart2: 'Users for Target Device'
        },
        country: {
            title_chart1: 'Countries',
            title_chart2: 'Users for'
        },
        db_object: {
            title_chart1: 'DB Objects',
            title_chart2: 'Users for'
        },
        db_username: {
            title_chart1: 'DB Username',
            title_chart2: 'Users for'
        }
    };
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .filter('fetchDualIndicatorMapProperties', function () {
        return function (anomalyTypeFieldName, chartOrder) {
            //Adding a filter which extract the name of the titles, according to
            //anomalyTypeFieldName and chart title
            if (anomalyTypeFieldName && indicatorsChartsTitles[anomalyTypeFieldName]) {
                return indicatorsChartsTitles[anomalyTypeFieldName][chartOrder];
            }
            else if (anomalyTypeFieldName) {
                return anomalyTypeFieldName;
            }
        };
    })
        .factory('indicatorTypeMapper.dual-column', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        'fsIndicatorGraphsHandler',
        'indicatorChartTransitionUtil',
        function ($filter, commonQueryParams, fsIndicatorGraphsHandler, indicatorChartTransitionUtil) {
            return {
                settings: {
                    firstColumn: {
                        params: commonQueryParams.entityTypeAnomalyTypeCount,
                        styleSettings: {},
                        templates: {
                            titles: {
                                'Title-1': '{{dataEntitiesIds[0]|entityIdToName}} ' +
                                    '{{anomalyTypeFieldName | fetchDualIndicatorMapProperties: ' +
                                    '\'title_chart1\'}} for {{entityName}} (Last 90 Days)'
                            }
                        },
                        sortData: function (data) {
                            return _.orderBy(data, ['anomaly', 'value'], ['asc', 'desc']);
                        },
                        dataAdapter: function (indicator, dataItem) {
                            var chartItem = {
                                category: $filter('anomalyTypeFormatter')(dataItem.keys[0], indicator),
                                originalCategory: dataItem.keys[0],
                                value: dataItem.value
                            };
                            if (dataItem.anomaly) {
                                chartItem.color = '#CC3300';
                            }
                            return chartItem;
                        },
                        handlers: {
                            "clickGraphItem": function (indicator, item) {
                                indicatorChartTransitionUtil.go('columnAnomaly', indicator, item);
                            }
                        },
                        chartSettings: {
                            "type": "serial",
                            "categoryField": "category",
                            "plotAreaBorderColor": "#F0F7F8",
                            "colors": [
                                "#9EC8E4"
                            ],
                            "startDuration": 1,
                            "backgroundColor": "#F0F7F8",
                            "fontFamily": "Open Sans",
                            "fontSize": 12,
                            "export": {
                                "enabled": true
                            },
                            "categoryAxis": {
                                "gridPosition": "start",
                                "axisColor": "#BCB5B5",
                                "gridColor": "#FFFFFF",
                                "title": "",
                                "fontFamily": "'Open Sans', sans-serif",
                                fontSize: 10,
                                autoWrap: true,
                                labelFunction: function (value, valueString, axis) {
                                    return value;
                                }
                            },
                            "trendLines": [],
                            "graphs": [
                                {
                                    "colorField": "color",
                                    "columnWidth": 0,
                                    "fillAlphas": 1,
                                    "fillColors": "",
                                    "fixedColumnWidth": 20,
                                    "fontSize": -1,
                                    "id": "AmGraph-1",
                                    "lineColor": "",
                                    "lineColorField": "color",
                                    "title": "graph 1",
                                    "type": "column",
                                    "valueField": "value",
                                    showHandOnHover: true
                                }
                            ],
                            "valueAxes": [
                                {
                                    "id": "ValueAxis-1",
                                    "axisAlpha": 0,
                                    "axisColor": "#",
                                    "fontSize": 12,
                                    "gridColor": "#666666",
                                    "labelOffset": -1,
                                    "showFirstLabel": false,
                                    "title": "Number of Sessions",
                                    "titleColor": "#666666",
                                    "fontFamily": "'Open Sans', sans-serif"
                                }
                            ],
                            "titles": [
                                {
                                    "id": "Title-1",
                                    "fontFamily": "'Open Sans', sans-serif",
                                    "color": "#666666",
                                    "size": 12
                                }
                            ]
                        }
                    },
                    secondColumn: {
                        params: commonQueryParams.anomalyTypeEntityTypeCount,
                        styleSettings: {},
                        templates: {
                            titles: {
                                'Title-1': '{{dataEntitiesIds[0]|entityIdToName}} ' +
                                    '{{anomalyTypeFieldName | fetchDualIndicatorMapProperties: ' +
                                    '\'title_chart2\'}} {{anomalyValue}} (Last 90 Days)'
                            }
                        },
                        sortData: function (data) {
                            return _.orderBy(data, ['anomaly', 'value'], ['asc', 'desc']);
                        },
                        dataAdapter: function (indicator, dataItem) {
                            var chartItem = {
                                category: $filter('anomalyTypeFormatter')(dataItem.keys[0], indicator),
                                originalCategory: dataItem.keys[0],
                                value: dataItem.value
                            };
                            if (dataItem.anomaly) {
                                chartItem.color = '#CC3300';
                            }
                            return chartItem;
                        },
                        handlers: {
                            "clickGraphItem": function (indicator, item) {
                                indicatorChartTransitionUtil.go('columnEntity', indicator, item);
                            }
                        },
                        chartSettings: {
                            "type": "serial",
                            "categoryField": "category",
                            "plotAreaBorderColor": "#F0F7F8",
                            "colors": [
                                "#9EC8E4"
                            ],
                            "startDuration": 1,
                            "backgroundColor": "#F0F7F8",
                            "fontFamily": "Open Sans",
                            "fontSize": 12,
                            "export": {
                                "enabled": true
                            },
                            "categoryAxis": {
                                "gridPosition": "start",
                                "axisColor": "#BCB5B5",
                                "gridColor": "#FFFFFF",
                                "title": "",
                                "fontFamily": "'Open Sans', sans-serif",
                                fontSize: 10,
                                autoWrap: true,
                                labelFunction: function (value, valueString, axis) {
                                    return value;
                                }
                            },
                            "trendLines": [],
                            "graphs": [
                                {
                                    "colorField": "color",
                                    "columnWidth": 0,
                                    "fillAlphas": 1,
                                    "fillColors": "",
                                    "fixedColumnWidth": 20,
                                    "fontSize": -1,
                                    "id": "AmGraph-1",
                                    "lineColor": "",
                                    "lineColorField": "color",
                                    "title": "graph 1",
                                    "type": "column",
                                    "valueField": "value",
                                    showHandOnHover: true
                                }
                            ],
                            "valueAxes": [
                                {
                                    "id": "ValueAxis-1",
                                    "axisAlpha": 0,
                                    "axisColor": "#",
                                    "fontSize": 12,
                                    "gridColor": "#666666",
                                    "labelOffset": -1,
                                    "showFirstLabel": false,
                                    "title": "Number of Sessions",
                                    "titleColor": "#666666",
                                    "fontFamily": "'Open Sans', sans-serif"
                                }
                            ],
                            "titles": [
                                {
                                    "id": "Title-1",
                                    "fontFamily": "'Open Sans', sans-serif",
                                    "color": "#666666",
                                    "size": 12
                                }
                            ]
                        }
                    }
                }
            };
        }]);
}());

/**
 * Settings for indicator which contains heatmp
 */
(function () {
    'use strict';
    function HeatMapFactory($filter) {
        /**
         * Used as weekDaysUs axis
         */
        var weekDaysUS = [
            'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'
        ];
        /**
         * Used as hours in a day axis.
         */
        var HoursInDay = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23];
        return {
            settings: {
                heatmap: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'hourlyCountGroupByDayOfWeek'
                    },
                    styleSettings: {
                        height: '28.125rem'
                    },
                    chartSettings: {
                        chart: {
                            inverted: true
                        },
                        xAxis: {
                            categories: weekDaysUS.reverse(),
                            title: {
                                text: 'Week days'
                            },
                            labels: {
                                formatter: function () {
                                    return $filter('pascalCase')(this.value);
                                }
                            }
                        },
                        yAxis: {
                            title: {
                                text: 'Hours'
                            },
                            categories: HoursInDay
                        },
                        colorAxis: {
                            min: 1,
                            minColor: '#8fbde4',
                            maxColor: '#2766a9'
                        },
                        title: {
                            text: '{{dataEntitiesIds[0]|entityIdToName}} ' +
                                'Authentication Times (Last 90 days)'
                        },
                        "series": [{
                                "name": "{{dataEntitiesIds[0]|entityIdToName}} " +
                                    "Authentication Times (Last 90 days) "
                            }]
                    }
                }
            }
        };
    }
    HeatMapFactory.inject = ['$filter'];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.heatmap', HeatMapFactory);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .filter('buildSingleColumnKey', function () {
        var prefix = "evidence.singlecolumn.title.";
        return function (anomalyTypeFieldName, postfix) {
            return prefix + anomalyTypeFieldName;
        };
    })
        .factory('indicatorTypeMapper.single-column', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    singleColumn: {
                        params: commonQueryParams.entityTypeAnomalyTypeCount5Columns,
                        styleSettings: {
                            height: '24rem',
                            boxSizing: 'border-box',
                            width: '100%',
                            padding: '0 1.25rem'
                        },
                        chartSettings: {
                            title: {
                                text: '<span class="chart-title">' +
                                    '{{anomalyTypeFieldName  | buildSingleColumnKey | translate: this}}' +
                                    '</span>'
                            },
                            "series": [{}]
                        }
                    }
                }
            };
        }]);
}());

(function () {
    'use strict';
    var colors = ["#0D8ECF", "#0D6ECD"];
    var colorIndex = 0;
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .filter('buildPieKey', function () {
        var prefix = "evidence.single.singlePieHistogram.";
        return function (anomalyTypeFieldName, postfix) {
            return prefix + anomalyTypeFieldName + ".chart." + postfix;
        };
    })
        .factory('indicatorTypeMapper.pie', [
        '$filter',
        'indicatorChartTransitionUtil',
        function ($filter, indicatorChartTransitionUtil) {
            return {
                settings: {
                    pie: {
                        params: {
                            context_type: '{{entityTypeFieldName}}',
                            context_value: '{{entityName}}',
                            feature: '{{anomalyTypeFieldName}}',
                            'function': 'Count'
                        },
                        styleSettings: {},
                        templates: {
                            titles: {
                                'Title-1': '{{ anomalyTypeFieldName  | buildPieKey: \'title\' ' +
                                    '| translate: this}}' //"this" refer to the scope (the indicator object)'
                            }
                        },
                        sortData: function (data) {
                            return _.orderBy(data, ['anomaly', 'value'], ['asc', 'desc']);
                        },
                        dataAdapter: function (indicator, dataItem) {
                            var chartItem = {
                                category: $filter('anomalyTypeFormatter')(dataItem.keys[0], indicator),
                                originalCategory: dataItem.keys[0],
                                value: dataItem.value
                            };
                            if (dataItem.anomaly) {
                                chartItem.color = '#CC3300';
                            }
                            else {
                                // Alternate colors
                                chartItem.color = colors[colorIndex % 2];
                                colorIndex += 1;
                            }
                            return chartItem;
                        },
                        handlers: {
                            "clickGraphItem": function (indicator, item) {
                                indicatorChartTransitionUtil.go('pie', indicator, item);
                            }
                        },
                        chartSettings: {
                            "type": "pie",
                            "balloonText": "[[title]]<br><span style='font-size:14px'><b>[[value]]</b> ([[percents]]%)</span>",
                            "innerRadius": "60%",
                            "labelRadius": 10,
                            "pullOutRadius": 10,
                            "radius": "40%",
                            "startRadius": 0,
                            "colors": ["#0D8ECF", "#0D6ECD"],
                            "colorField": "color",
                            "hideLabelsPercent": 10,
                            "maxLabelWidth": 199,
                            "pullOutDuration": 0,
                            "pullOutEffect": "easeOutSine",
                            "startAlpha": 1,
                            "titleField": "category",
                            "valueField": "value",
                            "color": "#989191",
                            "creditsPosition": "bottom-right",
                            "fontFamily": "Open Sans",
                            "fontSize": 12,
                            "processCount": 999,
                            "titles": [
                                {
                                    "id": "Title-1",
                                    "fontFamily": "'Open Sans', sans-serif",
                                    "color": "#666666",
                                    "size": 12
                                }
                            ]
                        }
                    }
                }
            };
        }]);
}());

/**
 * Settings for indicator which contains heatmp
 */
(function () {
    'use strict';
    function ColumnRangeFactory() {
        return {
            settings: {
                columnRange: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'timeIntervals'
                    },
                    styleSettings: {
                        height: '28.125rem'
                    },
                    chartSettings: {
                        chart: {
                            inverted: true
                        },
                        yAxis: {
                            type: 'datetime'
                        },
                        series: [{}]
                    }
                }
            }
        };
    }
    ColumnRangeFactory.inject = [];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.columnRange', ColumnRangeFactory);
}());

/**
 * This file contains setting for both column charts in any indicator which display
 * two column charts
 */
(function () {
    'use strict';
    var aggregatedIndicatorsTablesMap = {};
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .filter('ScatterPieTitleFilter', function () {
        return function (val, propName) {
            if (val && aggregatedIndicatorsTablesMap[val]) {
                return aggregatedIndicatorsTablesMap[val][propName];
            }
            else if (val) {
                return val;
            }
        };
    })
        .factory('indicatorTypeMapper.scatter-pie', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    pie: {
                        params: commonQueryParams.entityTypeActionCodeCount,
                        styleSettings: {
                            height: '24rem'
                        },
                        chartSettings: {
                            title: {
                                text: '<span class="chart-title">' +
                                    '{{dataEntitiesIds[0]|entityIdToName}} Actions on {{anomalyValue}} ' +
                                    '(Last 30 Days)</span>'
                            },
                            yAxis: {
                                title: {
                                    enabled: true,
                                    text: '{{anomalyTypeFieldName | ScatterPieTitleFilter: \'axisYtitlePie\'}}'
                                }
                            },
                            xAxis: {
                                title: {
                                    enabled: true,
                                    text: '{{anomalyTypeFieldName | ScatterPieTitleFilter: \'axisXtitlePie\'}}'
                                }
                            },
                            tooltip: {
                                headerFormat: '',
                                formatter: function () {
                                    return '<b>' + this.point.name + ':</b> ' +
                                        Highcharts.numberFormat(this.y, 0, '', ',') + '<br/>';
                                }
                            }
                        }
                    },
                    scatter: {
                        params: commonQueryParams.entityTypeCountByTime,
                        chartSettings: {
                            title: {
                                text: '<span class="chart-title">' +
                                    '{{dataEntitiesIds[0]|entityIdToName}} Actions on ' +
                                    '{{anomalyValue}} ' +
                                    '(Last 30 days)</span>'
                            },
                            yAxis: {
                                title: {
                                    text: '{{anomalyTypeFieldName | ScatterPieTitleFilter: \'axisYtitleScatter\'}}'
                                }
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                }
            };
        }]);
}());

/**
 * This file contains setting for both column charts in any indicator which display
 * two column charts
 */
(function () {
    'use strict';
    var aggregatedIndicatorsTablesMap = {};
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .filter('ScatterColumnTitleFilter', function () {
        return function (val, propName) {
            if (val && aggregatedIndicatorsTablesMap[val]) {
                return aggregatedIndicatorsTablesMap[val][propName];
            }
            else if (val) {
                return val;
            }
        };
    })
        .factory('indicatorTypeMapper.scatter-column', ['$filter',
        'indicatorTypeMapper.commonQueryParams',
        function ($filter, commonQueryParams) {
            return {
                settings: {
                    column: {
                        params: commonQueryParams.entityTypeActionCodeCount,
                        styleSettings: {
                            height: '24rem'
                        },
                        chartSettings: {
                            title: {
                                text: '<span class="chart-title">' +
                                    '{{dataEntitiesIds[0]|entityIdToName}} Actions on {{anomalyValue}} ' +
                                    '(Last 30 Days)</span>'
                            },
                            yAxis: {
                                title: {
                                    enabled: true,
                                    text: '{{anomalyTypeFieldName | ScatterColumnTitleFilter: \'axisYtitleColumn\'}}'
                                }
                            },
                            xAxis: {
                                title: {
                                    enabled: true,
                                    text: '{{anomalyTypeFieldName | ScatterColumnTitleFilter: \'axisXtitleColumn\'}}'
                                }
                            }
                        }
                    },
                    scatter: {
                        params: commonQueryParams.entityTypeCountByTime,
                        styleSettings: {
                            height: '24rem'
                        },
                        chartSettings: {
                            title: {
                                text: '<span class="chart-title">' +
                                    '{{dataEntitiesIds[0]|entityIdToName}} Actions on ' +
                                    '{{anomalyValue}} ' +
                                    '(Last 30 days)</span>'
                            },
                            yAxis: {
                                title: {
                                    text: '{{anomalyTypeFieldName | ScatterColumnTitleFilter: \'axisYtitleScatter\'}}'
                                }
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                }
            };
        }]);
}());

/**
 * Settings for indicator which contains heatmp
 */
(function () {
    'use strict';
    function sharedCredentialsFactory() {
        return {
            settings: {
                sharedCredentials: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'timeIntervals'
                    },
                    styleSettings: {},
                    templates: {},
                    sortData: function (data) {
                        return _.orderBy(data, ['value'], ['asc']);
                    },
                    dataAdapter: function (indicator, dataItem) {
                        var open = moment(parseInt(dataItem.keys[0], 10)).utc();
                        var close = moment(parseInt(dataItem.keys[1], 10)).utc();
                        var chartItem = {
                            category: dataItem.value,
                            open: open.hour() + open.minute() / 60,
                            openDate: open.format('HH:mm:ss'),
                            close: close.hour() + close.minute() / 60,
                            closeDate: close.format('HH:mm:ss'),
                            indicator: indicator
                        };
                        return chartItem;
                    },
                    handlers: {
                        "clickGraphItem": function (indicator, item) {
                            // indicatorChartTransitionUtil.go('columnAnomaly', indicator, item);
                        }
                    },
                    chartSettings: {
                        "type": "serial",
                        "categoryField": "category",
                        "rotate": true,
                        "startDuration": 1,
                        "fontFamily": "'Open Sans', sans-serif",
                        "categoryAxis": {
                            "gridPosition": "start",
                            "axisAlpha": 0,
                            "axisThickness": 0,
                            "gridColor": "#989191",
                            "gridThickness": 0,
                            "title": "Session Source IP",
                            "titleColor": "#989191",
                            "fontFamily": "'Open Sans', sans-serif"
                        },
                        "colors": [
                            "#0D8ECF"
                        ],
                        "trendLines": [],
                        "graphs": [
                            {
                                "balloonText": "Session Start: <b>[[openDate]]</b><br>Session End: <b>[[closeDate]]</b>",
                                "closeField": "close",
                                "colorField": "color",
                                "fillAlphas": 1,
                                // "fixedColumnWidth": 15,
                                "columnWidth": 0.5,
                                "fontSize": 4,
                                "id": "AmGraph-1",
                                "lineThickness": 0,
                                "negativeFillColors": "#FF0000",
                                "openField": "open",
                                "title": "graph 1",
                                "type": "column"
                            }
                        ],
                        "guides": [],
                        "valueAxes": [
                            {
                                "id": "ValueAxis-1",
                                "stackType": "regular",
                                "axisColor": "#BCB5B5",
                                "gridColor": "#989191",
                                // "labelFrequency": 2,
                                // "minHorizontalGap": 10,
                                // "minVerticalGap": 10,
                                "showFirstLabel": true,
                                "showLastLabel": true,
                                "title": "Time of Day",
                                "titleColor": "#989191",
                                precision: 2,
                                labelFunction: function (value) {
                                    var hours = Math.floor(value);
                                    var minutes = Math.floor((value % 1) * 60);
                                    minutes = minutes < 10 ? '0' + minutes : minutes;
                                    return hours + ':' + minutes;
                                }
                            }
                        ],
                        "allLabels": [],
                        "balloon": {},
                        "titles": [
                            {
                                "color": "#989191",
                                "id": "Title-1",
                                "size": 15,
                                "text": "Concurrent Sessions",
                                "fontFamily": "'Open Sans', sans-serif"
                            }
                        ]
                    }
                }
            }
        };
    }
    sharedCredentialsFactory.inject = [];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.sharedCredentials', sharedCredentialsFactory);
    /**
     a = {
    title: {
        text: 'Overlapping VPN Sessions by Time'
    }
    ,
    yAxis: {
        title: {
            text: 'Time'
        }
    }
    ,
    xAxis: {
        title: {
            text: 'Session Source IP'
        }
    }

}
     **/
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.geo-location', [
        function () {
            return {
                settings: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'Count',
                        num_columns: 4
                    },
                    mapSettings: {
                        type: 'map',
                        mouseWheelZoomEnabled: true,
                        projection: 'miller',
                        imagesSettings: {
                            balloonText: '<span style="font-size:14px;"><b>[[title]]</b>: [[value]]%</span>',
                            selectable: false
                        },
                        areasSettings: {
                            selectedColor: '#024d88',
                            color: '#babdbe',
                            selectable: false
                        },
                        zoomControl: {
                            top: 1,
                            buttonSize: window.innerHeight < 700 ? 25 :
                                window.innerHeight < 1000 ? 30 : 35
                        },
                        dataProvider: {
                            map: 'worldHigh',
                            getAreasFromMap: true,
                            zoomLevel: 1,
                            zoomLatitude: "",
                            zoomLongitude: ""
                        }
                    }
                },
            };
        }]);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.geo-sequence', [
        function () {
            return {
                settings: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        function: 'Count',
                        num_columns: 5,
                        feature: 'country'
                    },
                    usePlanes: true,
                    title: 'Geo Location Sequence Anomaly',
                    mapSettings: {
                        type: 'map',
                        mouseWheelZoomEnabled: true,
                        projection: 'miller',
                        imagesSettings: {
                            balloonText: '<span style="font-size:14px;"><b>[[title]]</b>: [[value]]%</span>',
                            selectable: false,
                            color: "#585869",
                            rollOverColor: "#585869",
                            selectedColor: "#585869",
                            pauseDuration: 0.2,
                            animationDuration: 2.5,
                            adjustAnimationSpeed: true
                        },
                        linesSettings: {
                            color: "#FF0000",
                            alpha: 0.6
                        },
                        areasSettings: {
                            selectedColor: '#024d88',
                            color: '#babdbe',
                            selectable: false
                        },
                        zoomControl: {
                            top: 1,
                            buttonSize: window.innerHeight < 700 ? 25 :
                                window.innerHeight < 1000 ? 30 : 35
                        },
                        dataProvider: {
                            map: 'worldHigh',
                            getAreasFromMap: true,
                            zoomLevel: 1,
                            zoomLatitude: "",
                            zoomLongitude: ""
                        }
                    }
                },
            };
        }]);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMapper.lateralMovement', [
        '$filter',
        function ($filter) {
            return {
                settings: {
                    params: {
                        context_type: '{{entityTypeFieldName}}',
                        context_value: '{{entityName}}',
                        feature: '{{anomalyTypeFieldName}}',
                        'function': 'vpnLateralMovement'
                    },
                    templates: {},
                    preProcessData: function (response, indicator) {
                        var data = response.data;
                        // create user index list
                        var usersList = _.map(_.groupBy(data, 'value'), function (userGroup, key) {
                            return key;
                        });
                        // the session item would have two keys
                        var sessionItems = _.filter(data, function (eventItem) { return eventItem.keys && eventItem.keys.length === 2; });
                        if (sessionItems && sessionItems.length === 1) {
                            // pull out the the session item from the usersList and place it in the end of the list
                            var sessionItem = sessionItems[0];
                            var userIndex = usersList.indexOf(sessionItem.value);
                            usersList.splice(userIndex, 1);
                            usersList.push(sessionItem.value);
                            // Split session into two event items
                            _.remove(data, sessionItem);
                            var startDate = moment(parseInt(sessionItem.keys[0], 10)).utc()
                                .format("MMM D, YYYY, h:mm:ss a");
                            var endDate = moment(parseInt(sessionItem.keys[1], 10)).utc()
                                .format("MMM D, YYYY, h:mm:ss a");
                            var splitSessionItem1 = _.cloneDeep(sessionItem);
                            splitSessionItem1.sessionUserIndex = usersList.indexOf(sessionItem.value) + 1;
                            splitSessionItem1.keys.pop();
                            splitSessionItem1.additionalInformation.session_start_date = startDate;
                            splitSessionItem1.bullet = 'triangleRight';
                            data.push(splitSessionItem1);
                            var splitSessionItem2 = _.cloneDeep(sessionItem);
                            splitSessionItem2.keys.shift();
                            splitSessionItem2.additionalInformation.session_end_date = endDate;
                            splitSessionItem2.sessionUserIndex = usersList.indexOf(sessionItem.value) + 1;
                            splitSessionItem2.bullet = 'triangleLeft';
                            data.push(splitSessionItem2);
                        }
                        // Add user index to each of the items in the list
                        _.each(data, function (eventItem) {
                            if (!eventItem.sessionUserIndex) {
                                eventItem.userIndex = usersList.indexOf(eventItem.value) + 1;
                            }
                        });
                        // Convert into list by date with the desired schema
                        response.data = _.map(response.data, function (eventItem) {
                            var date = moment(parseInt(eventItem.keys[0], 10));
                            var dataItem = {
                                date: new Date(parseInt(eventItem.keys[0], 10)),
                                formatted_date: date.utc().format("MMM D, YYYY, h:mm:ss a"),
                                username: eventItem.value,
                                target_machine: eventItem.additionalInformation.target_machine,
                                normalized_username: eventItem.additionalInformation.normalized_username,
                                entity_id: eventItem.additionalInformation.entity_id,
                                display_name: eventItem.additionalInformation.display_name ||
                                    eventItem.additionalInformation.normalized_username || eventItem.value,
                                usersList: usersList,
                                data_source_id: eventItem.additionalInformation.data_source,
                                data_source: $filter('entityIdToName')(eventItem.additionalInformation.data_source),
                                source_machine: eventItem.additionalInformation.source_machine,
                                event_score: eventItem.additionalInformation.event_score,
                                country_name: eventItem.additionalInformation.country_name,
                                local_ip: eventItem.additionalInformation.local_ip,
                                source_ip: eventItem.additionalInformation.source_ip,
                                session_end_date: eventItem.additionalInformation.session_end_date,
                                session_start_date: eventItem.additionalInformation.session_start_date,
                                bullet: eventItem.bullet
                            };
                            if (eventItem.sessionUserIndex) {
                                dataItem.sessionUserIndex = eventItem.sessionUserIndex;
                            }
                            if (eventItem.userIndex) {
                                dataItem.userIndex = eventItem.userIndex;
                            }
                            return dataItem;
                        });
                        return response;
                    },
                    sortData: function (data) {
                        return _.orderBy(data, [function (dataItem) { return dataItem.date.valueOf(); }], ['asc']);
                    },
                    dataAdapter: function (indicator, dataItem) {
                        return dataItem;
                    },
                    chartSettings: {
                        "type": "serial",
                        "fontFamily": "'Open Sans', sans-serif",
                        "valueAxes": [{
                                "id": "v1",
                                "title": "Users",
                                "titleColor": "#989191",
                                "position": "left",
                                "precision": 0,
                                "tickLength": 1,
                                "labelFunction": function (value, stringValue, axisObject) {
                                    // return the username as label
                                    var username = axisObject.data[0].dataContext.usersList[parseInt(stringValue, 10) -
                                        1];
                                    var item = _.find(axisObject.data, function (axisData) {
                                        return axisData.dataContext.username === username;
                                    });
                                    return (item && item.dataContext && item.dataContext.display_name) || '';
                                },
                                "stackType": "regular",
                                "axisColor": "#BCB5B5",
                                "gridColor": "#989191",
                                "showFirstLabel": false
                            }],
                        "graphs": [{
                                "id": "g1",
                                "valueAxis": "v2",
                                "hideBulletsCount": 50,
                                "lineThickness": 40,
                                "lineColor": "#20acd4",
                                "type": "smoothedLine",
                                "valueField": "sessionUserIndex",
                                balloonFunction: function (item) {
                                    var value = moment(new Date(item.category)).utc()
                                        .format("MMM D, YYYY, h:mm:ss a");
                                    var context = item.dataContext;
                                    var balloonText = "(" + context.data_source + ") " + context.display_name + " <br>logged on from <span style='color: red;'>" + context.source_ip + "</span><br>";
                                    if (context.country_name) {
                                        balloonText += "originating from " + context.country_name + "<br>";
                                    }
                                    if (context.session_start_date) {
                                        balloonText += "Start Time: " + context.session_start_date + "<br>";
                                    }
                                    if (context.session_end_date) {
                                        balloonText += "End Time: " + context.session_end_date + "<br>";
                                    }
                                    balloonText += "Event Score: " + context.event_score;
                                    return balloonText;
                                },
                                "bulletField": "bullet",
                                "bulletColor": "#098cb4",
                                "bulletSize": 20,
                            },
                            {
                                "id": "g2",
                                "valueAxis": "v2",
                                "bullet": "diamond",
                                "bulletBorderAlpha": 1,
                                "bulletColor": "#FF0000",
                                "bulletSize": 20,
                                "hideBulletsCount": 50,
                                "lineThickness": 0,
                                "lineColor": "#ff0000",
                                "type": "smoothedLine",
                                "useLineColorForBulletBorder": true,
                                "valueField": "userIndex",
                                "balloonText": "([[data_source]]) [[display_name]] <br>logged on from <span style='color: red;'>[[source_ip]]</span><br>using [[source_machine]]<br>to [[target_machine]]<br>Event Time: [[formatted_date]]<br>Event Score: [[event_score]]"
                            }],
                        "categoryField": "date",
                        "categoryAxis": {
                            "dashLength": 1,
                            "minorGridEnabled": true,
                            "gridPosition": "start",
                            "axisAlpha": 0,
                            "axisThickness": 0,
                            "gridColor": "#989191",
                            "gridThickness": 0,
                            "title": "",
                            "titleColor": "#989191",
                            "parseDates": false,
                            "equalSpacing": false,
                            "labelFunction": function (stringValue, dateObj) {
                                return moment(dateObj.dataContext.date).utc().format("MMM D HH:mm");
                            }
                        },
                        "balloon": {
                            "borderThickness": 1,
                            "shadowAlpha": 0
                        },
                        "titles": [
                            {
                                "color": "#989191",
                                "id": "Title-1",
                                "size": 15,
                                "text": "Lateral Movement"
                            }
                        ]
                    }
                },
            };
        }]);
}());

/**
 *
 */
var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var deviceUtilsService;
            (function (deviceUtilsService) {
                'use strict';
                var OTHERS_NAME = 'Others';
                var DeviceUtilsService = (function () {
                    function DeviceUtilsService() {
                    }
                    /**
                     * Calculates a device's percent, and store on the device object
                     * @param {number} sum
                     * @param {Array<IUserDevice>} device
                     * @private
                     */
                    DeviceUtilsService.prototype._calcDevicePercent = function (sum, device) {
                        if (sum) {
                            device.percent = Math.round(device.count / sum * 10000) / 100;
                        }
                        else {
                            device.percent = 0;
                        }
                    };
                    /**
                     * This method calculate the sum of all count fields on user device,
                     * and for each device calculate its count / sum * 100 and save it as percentage field on the device
                     * @param devices
                     * @returns {IUserDevice[]}
                     */
                    DeviceUtilsService.prototype.updatePercentageOnDevice = function (devices) {
                        // calc sum
                        var sum = _.sumBy(devices, 'count');
                        // iterate and calc percent
                        _.each(devices, this._calcDevicePercent.bind(this, sum));
                        return devices;
                    };
                    /**
                     * Create and return new device list which not contain the devices with count  = 0
                     * @param devices
                     * @returns {T[]}
                     */
                    DeviceUtilsService.prototype.removeZeroCount = function (devices) {
                        return _.filter(devices, function (device) { return device.count > 0; });
                    };
                    /**
                     * Pulls out 'other' member and puts it in the end of the list.
                     * @param devices
                     * @private
                     */
                    DeviceUtilsService.prototype.repositionOthers = function (devices) {
                        var pluckIndex = -1;
                        _.some(devices, function (device, index) {
                            if (device.deviceName === OTHERS_NAME) {
                                pluckIndex = index;
                                return true;
                            }
                        });
                        if (pluckIndex !== -1) {
                            var device = devices[pluckIndex];
                            device.deviceName = 'Others';
                            devices.splice(pluckIndex, 1);
                            devices.push(device);
                        }
                    };
                    return DeviceUtilsService;
                }());
                angular.module('Fortscale.shared.services')
                    .service('deviceUtilsService', DeviceUtilsService);
            })(deviceUtilsService = services.deviceUtilsService || (services.deviceUtilsService = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

/**
 * indicator-type.map is an angular factory.
 * It is consumed by indicatorTypeMapper service.
 * Its purpose is to provide a mapper object for indicatorTypeMapper service, so the service will be
 * able to decide which indicator correlates to which indicator type.
 * When an indicator type is ascertained, the type object is then returned to the caller of the
 * indicatorTypeMapper service to be used as the caller sees fit.
 *
 * The type objects are used as required.
 * Each base property on indicatorTypeMap is an indicator type.
 * It must have 'queries' property which is an array of objects. Each of those should be a key-value
 * JSON, and an indicator must qualify all key-values in a query object
 * (effectively an AND expression).
 * Example:
 'indicator105': {
                queries: [
                    {
                        dataEntitiesIds: ['vpn'],
                        anomalyTypeFieldName: 'vpn_geo_hopping',
                        evidenceType: 'Notification'
                    }
                ],
                templateUrl: 'app/layouts/alert/layouts/indicator-templates/singlecolumn.html',
                settings: {
                    singleColumn: {
                        params: entityTypeAnomalyTypeCount,
                        chartSettings: {

                            title: {
                                text: 'Countries For User {{entityName}}<br> Last 90 Days'
                            },
                            "series": [{}]
                        }
                    }

                },
                indicatorClass: 'gen'
            }
 * In this example an indicator must have a dataEntitiesIds that equals ['vpn'] and
 * anomalyTypeFieldName that equals 'vpn_geo_hopping' and indicatorType that equals 'Notification' in
 * order to qualify to be 'indicator105' type.
 * 'queries' is an array, so an indicator must qualify to any of the objects in 'queries' to qualify
 * (effectively an OR expression).
 *
 * Once a type has been ascertained, the whole object is returned.
 *
 * 'indicatorClass' is used by alert-tab.controller to determine the entire indicator view. (used by
 * goToindicatorTab method).
 *
 * 'template' or 'templateUrl' is used by indicator-tab-overview.controller . It uses the string
 * (either a direct string in template or a derived string from a template url) to build the
 * chart part of the view (if 'gen' class).
 *
 * 'settings' is an object that holds settingIds, where each id holds 'params' 'styleSettings',
 * and 'chartSettings'.
 *
 * 'params' is used as an interpolation base to build the query params. In the above example params
 * is an object called entityTypeAnomalyTypeCount, which is:
 {
      context_type: '{{entityTypeFieldName}}',
      context_value: '{{entityName}}',
      feature: '{{anomalyTypeFieldName}}',
      'function': 'Count',
      num_columns: 5
  }
 * This will be interpolated against the indicator and set in the query params.
 *
 * 'styleSettings' is used to define the style of the chart container (use in ng-style format).
 *
 * 'chartSettings' is handed over to a fs-chart directive which is merged into the typed settings
 * of a chart type (see shared/components/fs-chart)
 *
 * The settingIds are mapped in the html template. for example:
 * (The singlecoulmn template)
 <fs-dashboard-columns>
 <fs-dashboard-column column-span="15">
 <div class="loading" ng-if="sourceCountriesColumn.loading">Loading...</div>
 <fs-indicator-column settings-id="singleColumn"></fs-indicator-column>

 </fs-dashboard-column>

 </fs-dashboard-columns>

 * singleColumn in the 'settings' property on 'indicator105' is mapped to settings-id="singleColumn"
 *
 * This file uses variables to group common occurrences. For example entityTypeAnomalyTypeCount
 * is used as a common param configuration. Many indicator types use this exact configuration so
 * it makes sense to put it in a variable rather then repeat the code.
 */
(function () {
    'use strict';
    function indicatorTypeMapFactory(aggregatedSerialSettings, dualColumnSettings, singlePieChartSettings, scatterColumnChartSettings, sharedCredentialsSettings, aggregatedSerialDataRateSettings, activityTimeAnomalySettings, geoLocationSettings, geoSequenceSettings, lateralMovementSettings) {
        /**
         * This object is returned as angular.value. It holds all indicator types. Type can be a single
         * indicator or a family of indicator, etc.
         */
        var indicatorTypeMap = {
            'tag': {
                queries: [
                    {
                        anomalyTypeFieldName: 'tag'
                    }
                ],
                indicatorClass: 'tag'
            },
            'sharedCredentials': {
                queries: [
                    {
                        anomalyTypeFieldName: 'VPN_user_creds_share'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/shared-credentials.html',
                settings: sharedCredentialsSettings.settings,
                indicatorClass: 'gen'
            },
            'singleColumnDataRate': {
                queries: [
                    {
                        dataEntitiesIds: ['vpn_session'],
                        anomalyTypeFieldName: 'data_bucket',
                        evidenceType: 'AnomalySingleEvent'
                    }
                ],
                settings: aggregatedSerialDataRateSettings.settings,
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/aggregated-serial.html',
                indicatorClass: 'gen'
            },
            'activityTimeAnomaly': {
                queries: [
                    {
                        anomalyTypeFieldName: 'event_time',
                        evidenceType: 'AnomalySingleEvent'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/activity-time-anomaly.html',
                settings: activityTimeAnomalySettings.settings,
                indicatorClass: 'gen'
            },
            'geoLocation': {
                queries: [
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'country'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/fs-indicator-am-geo-location/fs-indicator-am-geo-location-template.html',
                settings: geoLocationSettings.settings,
                indicatorClass: 'gen'
            },
            'geoLocationSequence': {
                queries: [
                    {
                        anomalyTypeFieldName: 'vpn_geo_hopping'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/fs-indicator-am-geo-location/fs-indicator-am-geo-location-template.html',
                settings: geoSequenceSettings.settings,
                indicatorClass: 'gen'
            },
            'basicTwoHistogramsUser': {
                queries: [
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'normalized_src_machine'
                    },
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'normalized_dst_machine'
                    },
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'action_code'
                    },
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'db_object'
                    },
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'db_username'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/dualcolumn.html',
                settings: dualColumnSettings.settings,
                indicatorClass: 'gen'
            },
            'singlePieHistogram': {
                queries: [
                    {
                        anomalyTypeFieldName: 'auth_method',
                        evidenceType: 'AnomalySingleEvent'
                    },
                    {
                        anomalyTypeFieldName: 'failure_code',
                        evidenceType: 'AnomalySingleEvent'
                    },
                    {
                        anomalyTypeFieldName: 'action_type',
                        evidenceType: 'AnomalySingleEvent'
                    },
                    {
                        anomalyTypeFieldName: 'status',
                        evidenceType: 'AnomalySingleEvent'
                    },
                    {
                        evidenceType: 'AnomalySingleEvent',
                        anomalyTypeFieldName: 'return_code'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/pie.html',
                settings: singlePieChartSettings.settings,
                indicatorClass: 'gen'
            },
            'aggregatedIndicatorWithTime': {
                queries: [
                    {
                        evidenceType: 'AnomalyAggregatedEvent'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/aggregated-serial.html',
                settings: aggregatedSerialSettings.settings,
                indicatorClass: 'gen'
            },
            'lateralMovementIndicator': {
                queries: [
                    {
                        anomalyTypeFieldName: 'VPN_user_lateral_movement'
                    }
                ],
                templateUrl: 'app/layouts/user/components/user-indicator/components/indicator-templates/lateral-movement.html',
                indicatorClass: 'gen',
                settings: lateralMovementSettings.settings
            }
        };
        return indicatorTypeMap;
    }
    indicatorTypeMapFactory.$inject = [
        'indicatorTypeMapper.aggregated-serial',
        'indicatorTypeMapper.dual-column',
        'indicatorTypeMapper.pie',
        'indicatorTypeMapper.scatter-column',
        'indicatorTypeMapper.sharedCredentials',
        'indicatorTypeMapper.aggregated-serial-data-rate',
        'indicatorTypeMapper.activityTimeAnomaly',
        'indicatorTypeMapper.geo-location',
        'indicatorTypeMapper.geo-sequence',
        'indicatorTypeMapper.lateralMovement'
    ];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .factory('indicatorTypeMap', indicatorTypeMapFactory);
}());

/**
 * This service is a mapper service. It returns a type from mapObject if any of the queries
 * meet the condition set in the query.
 * queries list is an 'or' list, meaning that if any of the query objects meet the condition,
 * that type will return.
 * Each query object is an 'And' operator, meaning that all conditions must be fulfilled to match.
 *
 */
(function () {
    'use strict';
    // Dependencies
    var indicatorTypeMap, assert, URLUtils;
    /**
     *
     * @constructor
     */
    function IndicatorTypeMapper(_indicatorTypeMap_, _assert_, _URLUtils_) {
        // Mount dependencies
        if (!indicatorTypeMap) {
            indicatorTypeMap = _indicatorTypeMap_;
        }
        if (!assert) {
            assert = _assert_;
        }
        if (!URLUtils) {
            URLUtils = _URLUtils_;
        }
    }
    _.extend(IndicatorTypeMapper.prototype, {
        _errMsg: 'Fortscale.shared.services.indicatorTypeMapper: indicatorTypeMapper.service: ',
        /**
         * Takes an indicator and returns an indicator type by matching against the queries
         * in the mapObject.
         * It returns null if no type was found.
         *
         * @param {object} indicator
         * @returns {string | null}
         */
        getType: function (indicator) {
            // Init indicatorType variable to return
            var indicatorTypeObject = null;
            // Using 'every' instead of 'each' allows the process to stop by returning false.
            // false is returned when a match is made.
            _.every(indicatorTypeMap, function (mapProperty, indicatorType) {
                // If any of the queries match, the indicatorType is returned.
                if (_.some(mapProperty.queries, function (query) {
                    // Iterate through query properties and all must match.
                    return _.every(query, function (checkValue, checkName) {
                        return _.isEqualWith(indicator[checkName], checkValue, 
                        // The customizer is needed because when Restangular holds an array
                        // it treats it as a list and it adds function and properties to the
                        // array. Worse still, the array is not recognized as array but as
                        // an object. This causes the _.isEqual to return false even though
                        // the arrays are equal. So the arrays need to be converted to
                        // actual arrays.
                        function (valA, valB) {
                            // Convert array-like objects to actual arrays.
                            if (valA.slice && valA.map) {
                                valA = valA.slice(0);
                            }
                            if (valB.slice && valB.map) {
                                valB = valB.slice(0);
                            }
                            return _.isEqual(valA, valB);
                        });
                    });
                })) {
                    // If _.some has returned true, then a match was made, and indicatorType can be returned.
                    indicatorTypeObject = indicatorTypeMap[indicatorType];
                    return false;
                }
                return true; // So as not to stop iteration with undefined
            });
            return indicatorTypeObject;
        },
        /**
         * Calculates the desired href of an indicator in alerts page.
         *
         * @param {string} alertId
         * @param {object=} indicator
         * @param {boolean=} shouldPassSearchParams
         * @param {string=} subRoute
         * @returns {string}
         */
        getTargetUrl: function (alertId, indicator, shouldPassSearchParams, subRoute) {
            var errMsg = this._errMsg + 'getTargetUrl: ';
            // Validations
            assert.isString(alertId, 'alertId', errMsg);
            assert.isObject(indicator, 'indicator', errMsg, true);
            // Set defaults
            if (shouldPassSearchParams === undefined) {
                shouldPassSearchParams = true;
            }
            var targetUrl = '#/alerts/' + alertId;
            // Get an indicator type
            var indicatorType = this.getType(indicator);
            // Build the target url
            if (indicatorType !== null && !subRoute) {
                targetUrl += '/' + indicator.id;
                // Route to 'gen' for general indicators
                if (indicatorType.indicatorClass === 'gen') {
                    targetUrl += '/gen/overview';
                }
                else if (indicatorType.indicatorClass === 'tag') {
                    targetUrl += '/tag';
                }
            }
            else if (subRoute) {
                targetUrl += '/' + subRoute;
            }
            if (shouldPassSearchParams) {
                targetUrl += URLUtils.getSearchQueryString();
            }
            return targetUrl;
        }
    });
    IndicatorTypeMapper.$inject = ['indicatorTypeMap', 'assert', 'URLUtils'];
    angular.module('Fortscale.shared.services.indicatorTypeMapper')
        .service('indicatorTypeMapper', IndicatorTypeMapper);
}());

(function () {
    'use strict';
    function StringUtils() { }
    _.extend(StringUtils.prototype, {
        /**
         * Converts a string to an integer hash
         *
         * @param {string} str
         * @returns {number}
         */
        toIntHash: function (str) {
            var hash = 0, i, chr, len;
            if (str.length === 0) {
                return hash;
            }
            for (i = 0, len = str.length; i < len; i++) {
                chr = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + chr;
                hash |= 0; // Convert to 32bit integer
            }
            return hash;
        },
        /**
         * Converts string to a hash in a certain base.
         *
         * @param {string} str
         * @param {integer=} base Will default to 35
         * @returns {string}
         */
        toBaseHash: function (str, base) {
            base = base || 35;
            return this.toIntHash(str).toString(base);
        },
        // Converts camel case to slug case. Example: convertThis  :  convert-this
        toSlugCase: function (str) {
            var rgx = /([A-Z])/g;
            return str.replace(rgx, function (res) { return '-' + res.toLowerCase(); });
        }
    });
    angular.module('Fortscale.shared.services.stringUtils', [])
        .service('stringUtils', StringUtils);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.services.modelUtils', []);
}());

(function () {
    'use strict';
    function EntityUtils(assert, $http, BASE_URL, fsModals, URLUtils) {
        this.MINIMAL_OPEN_TIME = 1000;
        this._validateEntity = function (entity, errMsg) {
            errMsg = errMsg ? errMsg : '';
            assert.isObject(entity, 'entity', errMsg);
            assert.isString(entity.id, 'entityId', errMsg);
        };
        /**
         * Fetches entity id and type and navigates to user overview if the entity is "User"
         * *
         * @param {String} entityType - alert / coumputer etc...
         * @param {String} entityId (user ID)
         */
        this.navigateToEntityProfile = function (entityType, entityId) {
            // Go to user overview if entity type is User
            if (entityType === 'User') {
                URLUtils.setUrl('user/' + entityId + '/user_overview', false);
            }
        };
        /**
         * Changes a user's follow state
         *
         * @param {object} entity Must be a user
         * @param {boolean} followState If true user followed will be set to true,
         * @param {function=} finalCb A callback function that is invoked at the end of the chain
         * @param {function=} errorCb A callback function that is invoked on error
         * otherwise to false.
         */
        this.changeUserFollowState = function (entity, followState, finalCb, errorCb) {
            var ctrl = this;
            var processPopup, state, status;
            // Validations
            ctrl._validateEntity(entity);
            // Flow methods:
            // Changes the state of followed flag on the user
            function setUserFollowedState() {
                entity.followed = state;
            }
            // Closes the processing modal in minimal time
            function closeModalInMinialTime() {
                return fsModals.minimalClose(processPopup, openTime, ctrl.MINIMAL_OPEN_TIME);
            }
            // Opens a success modal
            function openSuccessModal() {
                return fsModals.openTimedPopup({
                    title: 'Success',
                    text: 'User is now ' + status + '.',
                    topColor: 'green'
                });
            }
            // Opens an error modal
            function openErrorModal() {
                return fsModals.openTimedPopup({
                    title: 'Server error',
                    text: 'There was a server error. Please try again later.',
                    topColor: 'red'
                });
            }
            // Returns the entity
            function returnEntity() {
                return entity;
            }
            // Sets defaults to call backs
            finalCb = finalCb || returnEntity;
            errorCb = errorCb || function () {
                closeModalInMinialTime()
                    .then(openErrorModal);
            };
            // assignments
            state = !!followState;
            status = state ? 'followed' : 'unfollowed';
            // Opens a processing modal
            processPopup = fsModals
                .openProcessingPopup('Processing', 'Changing user status to ' + status + '.');
            // Open time is now
            var openTime = Date.now().valueOf();
            // Change the user's followed state on the server
            return $http.get(BASE_URL + '/analyst/followUser', {
                params: {
                    follow: state,
                    userId: entity.id
                }
            })
                .then(closeModalInMinialTime)
                .then(setUserFollowedState)
                .then(openSuccessModal)
                .then(returnEntity)
                .then(finalCb)
                .catch(errorCb);
        };
    }
    EntityUtils.$inject = ['assert', '$http', 'BASE_URL', 'fsModals', 'URLUtils'];
    angular.module('Fortscale.shared.services.modelUtils')
        .service('entityUtils', EntityUtils);
}());

(function () {
    'use strict';
    function UserUtils(BASE_URL, $http, assert, appConfig, $cacheFactory, $state, $log) {
        this.BASE_URL = BASE_URL;
        this.$http = $http;
        this.assert = assert;
        this.appConfig = appConfig;
        this.$cacheFactory = $cacheFactory;
        this.$state = $state;
        this.$log = $log;
    }
    UserUtils.$inject = ['BASE_URL', '$http', 'assert', 'appConfig', '$cacheFactory', '$state', '$log'];
    /**
     * Takes the order from appConfig and tries to find a username match.
     *
     * @param user
     * @returns {*}
     */
    UserUtils.prototype.getFallBackDisplayNames = function (user) {
        // Set default value
        var fallbackDisplayName = user.id;
        // Get the default order value and convert to list of properties
        var propsCSV = this.appConfig.getConfigValue('default', 'userNameFallbackOrder');
        var props;
        if (propsCSV) {
            props = propsCSV.split(',');
        }
        else {
            props = ['id'];
        }
        // Iterate through list of properties and return the first value found on User
        _.some(props, function (prop) {
            var propTrim = prop.trim();
            if (user[propTrim] && user[propTrim] !== '') {
                fallbackDisplayName = user[propTrim];
                return true;
            }
        });
        // Return the value
        return fallbackDisplayName;
    };
    /**
     * Sets fall back display name property. displayName or noDomainUsername or username
     *
     * @param {*} user
     * @private
     */
    UserUtils.prototype._setFallBackDisplayName = function (user) {
        user.fallBackDisplayName = this.getFallBackDisplayNames(user);
    };
    /**
     * Sets fall back display name property for all users. displayName or noDomainUsername or username
     *
     * @param {array<{displayName: string=, noDomainUsername: string=, username:string}>} users
     */
    UserUtils.prototype.setFallBackDisplayNames = function (users) {
        _.each(users, _.bind(this._setFallBackDisplayName, this));
    };
    /**
     * Prevent duplicated display names for a single user and its duplicates for any list of users.
     *
     * @param {{fallBackDisplayName: string, username: string}} user
     * @param {number} index
     * @param {array<{fallBackDisplayName: string, username: string}>} users
     * @private
     */
    UserUtils.prototype._preventUserDisplayNameDuplication = function (user, index, users) {
        // Create duplications list
        var duplications = _.filter(users.slice(index), function (itUser) {
            return itUser.fallBackDisplayName === user.fallBackDisplayName;
        });
        // If duplications list's length is greater than one, duplications exists and should be handled.
        if (duplications.length > 1) {
            // Handle duplications by adding username in braces.
            _.each(duplications, function (dupUser) {
                dupUser.fallBackDisplayName += ' (' + dupUser.username + ')';
            });
        }
    };
    /**
     * Prevent duplicated display names in any list of users.
     *
     * @param {array<{displayName: string=, noDomainUsername: string=, username:string}>} users
     */
    UserUtils.prototype.preventFallBackDisplayNameDuplications = function (users) {
        _.each(users, this._preventUserDisplayNameDuplication, this);
    };
    /**
     *
     * @param {string} userIds
     * @returns {Promise<T>|*|Promise.<T>|IPromise<TResult>}
     */
    UserUtils.prototype.getUsersDetails = function (userIds) {
        var _this = this;
        // validate user ids
        _.each(userIds, function (userId) {
            _this.assert.isString(userId, 'userId', 'UserUtilsService: getUsersDetails: ');
        });
        // fetch user details
        return this.$http.get(this.BASE_URL + "/user/" + userIds.join(',') + "/details")
            .then(function (res) {
            if (!res.data || !res.data.data) {
                console.error('UserUtilsService: getUsersDetails: Server response does not have data.', res);
                return [];
            }
            return res.data.data;
        })
            .catch(function (err) {
            console.error('UserUtilsService: getUsersDetails: Server response error.', err);
            return [];
        });
    };
    /**
     * Returns a psomise that is resolved on system user tags groups.
     *
     * @returns {Promise<*>}
     */
    UserUtils.prototype.getUsersTagsCount = function () {
        return this.$http.get(this.BASE_URL + "/user/usersTagsCount")
            .then(function (res) {
            // Validate data
            if (!res.data || !res.data.data) {
                console.error('UserUtilsService: getUsersTagsCount: Server response does not have data.', res);
                return {};
            }
            return _.keyBy(res.data.data, 'key');
        })
            .catch(function (err) {
            console.error('UserUtilsService: getUsersTagsCount: Server response error.', err);
            return {};
        });
    };
    UserUtils.prototype.getUserAddress = function (user) {
        var adressItems = [];
        var addressKeys = ['streetAddress', 'adL', 'adC'];
        _.each(addressKeys, function (addressKey) {
            if (user[addressKey]) {
                adressItems.push(user[addressKey]);
            }
        });
        return adressItems.join(', ');
    };
    UserUtils.prototype.setFullAddress = function (user, addressKey) {
        addressKey = addressKey || 'fullAddress';
        user[addressKey] = this.getUserAddress(user);
    };
    UserUtils.prototype.setUsersFullAddress = function (users, addressKey) {
        var _this = this;
        _.each(users, function (user) {
            _this.setFullAddress(user, addressKey);
        });
    };
    UserUtils.prototype.getUserByUsername = function (username) {
        return this.$http.get(this.BASE_URL + "/user", {
            params: {
                page: 1,
                size: 1,
                search_field_contains: username
            }
        })
            .then(function (res) {
            return res.data.data[0];
        });
    };
    angular.module('Fortscale.shared.services.modelUtils')
        .service('userUtils', UserUtils);
}());

(function () {
    'use strict';
    var CLOSE_POPUP_DEFAULT_TIME = 3000;
    function FsModals($rootScope, $modal, $timeout, $q) {
        /**
         * Closes a modal. The modal will be opened for the minimal time provided.
         * @example fsModals.minimalClose(modalInstance, Date.now().valueOf(), 1000);
         *
         * @param {object} modal
         * @param {number} openTime
         * @param {number} minimalTime
         * @param {object=} rslv
         * @param {object=} rjct
         * @returns {Promise}
         */
        this.minimalClose = function (modal, openTime, minimalTime, rslv, rjct) {
            // Returns a promise that is resolved or rejected when modal closes.
            return $q(function (resolve, reject) {
                // When it is time to close, close or dismiss and resolve or reject the promise
                function conclude() {
                    if (!rjct) {
                        modal.close(rslv);
                        resolve(rslv);
                    }
                    else {
                        modal.dismiss(rjct);
                        reject(rslv);
                    }
                }
                // How much time has passed from openTime until now
                var timePassed = Date.now().valueOf() - openTime;
                // If the time passed is less then the minimal time, use timeout to fill extra time,
                // otherwise conclude now.
                if (timePassed < minimalTime) {
                    $timeout(function () {
                        conclude();
                    }, minimalTime - timePassed);
                }
                else {
                    conclude();
                }
            });
        };
        /**
         * Opens a "processing" modal.
         *
         * @param {string} title
         * @param {string} text
         * @returns {*}
         */
        this.openProcessingPopup = function (title, text) {
            var scope = $rootScope.$new();
            scope.loadingModal = {
                title: title,
                text: text
            };
            return $modal.open({
                animation: true,
                templateUrl: 'app/shared/services/fs-modals/layouts/processing.view.html',
                scope: scope,
                windowClass: 'loading-modal-container'
            });
        };
        /**
         * Opened a timed popup that closes after closeTime has passed
         *
         * @param {{title: string=, text: string=, imageSrc: string=, topColor: string=, closeTime: number=}} config
         * @returns {*}
         */
        this.openTimedPopup = function (config) {
            var scope = $rootScope.$new();
            var windowClass = 'timed-popup-container';
            // Create a scope
            scope.popup = {
                title: config.title,
                text: config.text,
                imageSrc: config.imageSrc
            };
            // Open the modal
            var popup = $modal.open({
                animation: true,
                templateUrl: 'app/shared/services/fs-modals/layouts/timed-popup.view.html',
                scope: scope,
                windowClass: windowClass
            });
            // Determine the duration of the popup open time
            var closeTime = config.closeTime || CLOSE_POPUP_DEFAULT_TIME;
            // Create a tentative timeout to close the popup
            $timeout(function () {
                if (popup) {
                    closePopup();
                }
            }, closeTime);
            // Popup close function
            function closePopup() {
                popup.close();
                // Cleanup
                popup = null;
                window.removeEventListener('click', closePopup);
            }
            // Close on click event listener
            window.addEventListener('click', closePopup);
            // Return the popup instance
            return popup;
        };
        /**
         * Opened a popup with "Ok" and "Cancel" buttons
         *
         * @param {{title: string=, text: string=}} config
         * @returns {*}
         */
        this.openOkCancelPopup = function (config) {
            var scope = $rootScope.$new();
            var windowClass = 'ok-cancel-popup-container';
            var popup;
            function modalClose() {
                popup.close();
            }
            function modalDismiss() {
                popup.dismiss();
            }
            // Create a scope
            scope.modalScope = {
                title: config.title,
                clickCancel: modalDismiss,
                clickOk: modalClose
            };
            // Open the modal
            popup = $modal.open({
                animation: true,
                templateUrl: 'app/shared/services/fs-modals/layouts/ok-cancel.view.html',
                scope: scope,
                windowClass: windowClass
            });
            return popup.result;
        };
        /**
         * Opened a popup with "Ok" button
         *
         * @param {{title: string=}} config
         * @returns {*}
         */
        this.openOkPopup = function (config) {
            var scope = $rootScope.$new();
            var windowClass = 'ok-popup-container';
            var popup;
            function modalClose() {
                popup.close();
            }
            // Create a scope
            scope.modalScope = {
                title: config.title,
                clickOk: modalClose
            };
            // Open the modal
            popup = $modal.open({
                animation: true,
                templateUrl: 'app/shared/services/fs-modals/layouts/ok.view.html',
                scope: scope,
                windowClass: windowClass
            });
            return popup.result;
        };
    }
    FsModals.$inject = ['$rootScope', '$modal', '$timeout', '$q'];
    angular.module('Fortscale.shared.services.fsModals', [])
        .service('fsModals', FsModals);
}());

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var fsNanobarAutomation;
            (function (fsNanobarAutomation) {
                'use strict';
                var ERR_MSG = 'Fortscale.shared.services.fsNanobarAutomation: ';
                var NanobarAutomation = (function () {
                    function NanobarAutomation(_nanobarCtrl) {
                        this._nanobarCtrl = _nanobarCtrl;
                        this._ticks = 0;
                        this._tickIndex = 0;
                    }
                    NanobarAutomation.prototype._updateProgress = function () {
                        this._tickIndex += 1;
                        if (this._tickIndex > this._ticks) {
                            this._tickIndex = this._ticks;
                        }
                        this._nanobarCtrl.updateProgress((this._tickIndex / this._ticks * 100) || 0);
                    };
                    NanobarAutomation.prototype.addPromise = function (promise, doNotUpdateOnError) {
                        var _this = this;
                        if (this._ticks === 0) {
                            this._ticks = 2;
                            this._updateProgress();
                        }
                        else {
                            this._ticks += 1;
                        }
                        return promise
                            .then(function () {
                            _this._updateProgress();
                        })
                            .catch(function (err) {
                            if (!doNotUpdateOnError) {
                                _this._updateProgress();
                            }
                            console.error(err);
                        });
                    };
                    NanobarAutomation.prototype.close = function () {
                        this._tickIndex = this._ticks;
                        this._nanobarCtrl.updateProgress(this._ticks / this._tickIndex * 100);
                    };
                    NanobarAutomation.prototype.reset = function () {
                        this._ticks = 0;
                        this._tickIndex = 0;
                    };
                    return NanobarAutomation;
                }());
                var NanobarAutomationService = (function () {
                    function NanobarAutomationService() {
                        this._nanobars = {};
                        this._promiseQue = {};
                    }
                    NanobarAutomationService.prototype._getNanobar = function (nanobarId) {
                        return this._nanobars[nanobarId] || null;
                    };
                    NanobarAutomationService.prototype.addNanobar = function (nanobarId, nanobarCtrl) {
                        this._nanobars[nanobarId] = new NanobarAutomation(nanobarCtrl);
                        if (this._promiseQue[nanobarId] && this._promiseQue[nanobarId].length) {
                            this.addPromises(nanobarId, this._promiseQue[nanobarId]);
                            this._promiseQue[nanobarId] = null;
                        }
                    };
                    NanobarAutomationService.prototype.destroyNanobar = function (nanobarId) {
                        var nanobar = this._getNanobar(nanobarId);
                        if (!nanobar) {
                            console.error(ERR_MSG + 'Nanobar id does not point to a valid nanobar.');
                        }
                        nanobar.close();
                        this._nanobars[nanobarId] = null;
                    };
                    NanobarAutomationService.prototype.addPromise = function (nanobarId, promise, doNotUpdateOnError) {
                        if (doNotUpdateOnError === void 0) { doNotUpdateOnError = false; }
                        var nanobar = this._getNanobar(nanobarId);
                        if (nanobar) {
                            return nanobar.addPromise(promise, doNotUpdateOnError);
                        }
                        else {
                            this._promiseQue[nanobarId] = this._promiseQue[nanobarId] || [];
                            this._promiseQue[nanobarId].push(promise);
                        }
                    };
                    NanobarAutomationService.prototype.addPromises = function (nanobarId, promises, doNotUpdateOnError) {
                        var _this = this;
                        if (doNotUpdateOnError === void 0) { doNotUpdateOnError = false; }
                        return _.map(promises, function (promise) {
                            return _this.addPromise(nanobarId, promise, doNotUpdateOnError);
                        });
                    };
                    NanobarAutomationService.prototype.reset = function (nanobarId) {
                        var nanobar = this._getNanobar(nanobarId);
                        if (nanobar) {
                            nanobar.reset();
                        }
                    };
                    return NanobarAutomationService;
                }());
                angular.module('Fortscale.shared.services.fsNanobarAutomation', [])
                    .service('fsNanobarAutomationService', NanobarAutomationService);
            })(fsNanobarAutomation = services.fsNanobarAutomation || (services.fsNanobarAutomation = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function FsIndexedDBService($q) {
        var service = this;
        /**
         * Cross platform
         */
        service.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        service.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
        service.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;
        service.log = console.log.bind(console);
        service.error = console.error.bind(console);
        /**
         * Standard handler for a request. Adds success, complete, and error failures.
         *
         * @param {*} req
         * @param {function} resolve
         * @param {function} reject
         * @private
         */
        service._standardPromiseHandler = function (req, resolve, reject) {
            req.addEventListener('success', function (res) { return resolve(res); });
            req.addEventListener('complete', function (res) { return resolve(res); });
            req.addEventListener('error', function (err) {
                service.error(err);
                reject(err);
            });
        };
        /**
         * Returns a specific store (or null if no transaction)
         * @param {IDBDatabase} db
         * @param {string} objectStoreName
         * @param {function} resolve
         * @param {function} reject
         * @param {string} errMsg
         * @returns {IDBObjectStore|null}
         * @private
         */
        service._getStore = function (db, objectStoreName, resolve, reject, errMsg) {
            var transaction = service.getTransaction(db, objectStoreName);
            // Validate transaction was made successfully. If not, log and reject promise.
            if (!transaction) {
                service.error(errMsg);
                reject(new Error(errMsg));
                return null;
            }
            service._standardPromiseHandler(transaction, resolve, reject);
            return transaction.objectStore(objectStoreName);
        };
        /**
         * Opens an existing database, or creates a new one for a specific table (dbStore).
         *
         * @param {string} dbName
         * @param {string} dbStoreName
         * @param {string} dbStoreConfig
         * @param {Array<{indexName: string, keyPath: string, options: {}=}>} indices
         * @param {number} rev
         * @returns {Promise}
         */
        service.openDb = function (dbName, dbStoreName, dbStoreConfig, indices, rev) {
            // Set defaults
            dbStoreConfig = dbStoreConfig || {};
            indices = indices || [];
            rev = rev || 1;
            // Create a promise
            return $q(function (resolve, reject) {
                var req = service.indexedDB.open(dbName, rev);
                service._standardPromiseHandler(req, resolve, reject);
                /**
                 * Handler for db upgrade. Will fire when db doesn't exists or revolution is higher than current.
                 * @param evt
                 */
                req.onupgradeneeded = function (evt) {
                    // get the db
                    var db = evt.currentTarget.result;
                    try {
                        // delete the old store
                        db.deleteObjectStore(dbStoreName);
                    }
                    catch (err) {
                    }
                    try {
                        // Create a new store
                        var objectStore = db.createObjectStore(dbStoreName, dbStoreConfig);
                        // Add indices
                        _.each(indices, function (indexObj) {
                            objectStore.createIndex(indexObj.indexName, indexObj.keyPath, indexObj.options || {});
                        });
                    }
                    catch (err) {
                        service.error(err);
                        throw err;
                    }
                };
            })
                .then(function (evt) { return evt.target.result; })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
        /**
         * Deletes a database
         *
         * @param {string} dbName
         * @returns {*}
         */
        service.deleteDB = function (dbName) {
            return $q(function (resolve, reject) {
                var req = service.indexedDB.deleteDatabase(dbName);
                service._standardPromiseHandler(req, resolve, reject);
            })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
        /**
         * Returns a transaction, or null if transaction was unsuccessful
         * @param {IDBDatabase} db
         * @param {string} objectStoreName
         * @returns {IDBTransaction|null}
         */
        service.getTransaction = function (db, objectStoreName) {
            try {
                return db.transaction([objectStoreName], 'readwrite');
            }
            catch (err) {
                service.error(err);
                return null;
            }
        };
        /**
         * Adds an object to a store
         *
         * @param {IDBDatabase} db
         * @param {string} objectStoreName
         * @param {{}} obj
         * @returns {Promise}
         */
        service.addObject = function (db, objectStoreName, obj) {
            return $q(function (resolve, reject) {
                var errMsg = 'FsIndexedDBService: addObject: No transaction';
                // get object store
                var objectStore = service._getStore(db, objectStoreName, resolve, reject, errMsg);
                if (!objectStore) {
                    return reject(errMsg);
                }
                // add the object to store
                var request = objectStore.add(obj);
                // log on any error in request
                request.onerror = function (err) {
                    service.error(err);
                };
            })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
        /**
         * Counts the number of objects in a store by index
         * @param {IDBDatabase} db
         * @param {string} objectStoreName
         * @param {string=} indexName
         * @returns {Promise}
         */
        service.count = function (db, objectStoreName, indexName) {
            var countRequest;
            return $q(function (resolve, reject) {
                var errMsg = 'FsIndexedDBService: count: No transaction';
                // get object store
                var objectStore = service._getStore(db, objectStoreName, resolve, reject, errMsg);
                if (!objectStore) {
                    return reject(errMsg);
                }
                // get index (indexName either received or the first index in store)
                var index = objectStore.index(indexName || objectStore.indexNames[0]);
                // count the item in the store
                countRequest = index.count();
            })
                .then(function () {
                return countRequest.result;
            })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
        /**
         * Gets all items from a store.
         *
         * @param {IDBDatabase} db
         * @param {string} objectStoreName
         * @returns {Promise|*}
         */
        service.findAll = function (db, objectStoreName) {
            return $q(function (resolve, reject) {
                var transaction = db.transaction(objectStoreName, service.IDBTransaction.READ_ONLY);
                var store = transaction.objectStore(objectStoreName);
                var items = [];
                service._standardPromiseHandler(transaction, function () { return resolve(items); }, reject);
                var cursorRequest = store.openCursor();
                cursorRequest.onerror = function (err) {
                    service.error(err);
                };
                cursorRequest.onsuccess = function (evt) {
                    var cursor = evt.target.result;
                    if (cursor) {
                        items.push(cursor.value);
                        cursor.continue();
                    }
                };
            })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
        service.deleteAll = function (db, objectStoreName) {
            var errMsg = 'FsIndexedDBService: deleteAll: ';
            return $q(function (resolve, reject) {
                // get object store
                var objectStore = service._getStore(db, objectStoreName, resolve, reject, errMsg);
                if (!objectStore) {
                    return reject(errMsg);
                }
                // add the object to store
                var request = objectStore.clear();
                // log on any error in request
                request.onerror = function (err) {
                    throw err;
                };
            })
                .catch(function (err) {
                service.error(err);
                throw err;
            });
        };
    }
    FsIndexedDBService.$inject = ['$q'];
    angular.module('Fortscale.shared.services.fsIndexedDBService', [])
        .service('fsIndexedDBService', FsIndexedDBService);
}());

var Fortscale;
(function (Fortscale) {
    (function () {
        'use strict';
        var IndicatorErrorCodesService = (function () {
            function IndicatorErrorCodesService(assert) {
                this.assert = assert;
                // Holds the error codes map
                this._errorCodesMap = new Map();
                // Holds the error message for validations
                this._errorMsg = 'IndicatorErrorCodesService: ';
            }
            /**
             * Gets the errors object that relates to the data entity id
             * @param dataEntityId
             * @private
             */
            IndicatorErrorCodesService.prototype._getErrorsObject = function (dataEntityId) {
                var errorsObject = this._errorCodesMap.get(dataEntityId);
                return errorsObject || null;
            };
            /**
             * Adds an error object to error object map
             * @param dataEntityId
             * @param errorCodesObject
             */
            IndicatorErrorCodesService.prototype.addErrorObject = function (dataEntityId, errorCodesObject) {
                // Validations
                var errMsg = this._errorMsg + "addErrorObject: ";
                this.assert.isString(dataEntityId, 'dataEntityId', errMsg);
                this.assert.isObject(errorCodesObject, 'errorCodesObject', errMsg);
                // Add error codes object
                this._errorCodesMap.set(dataEntityId, errorCodesObject);
            };
            /**
             * Returns a prettified error code if supplied properties are correct,
             * otherwise the original errorCode is returned.
             *
             * @param dataEntityId
             * @param errorCode
             * @returns {string}
             */
            IndicatorErrorCodesService.prototype.getDisplayMessage = function (dataEntityId, errorCode) {
                // Validations
                var errMsg = this._errorMsg + "getDisplayMessage: ";
                this.assert.isString(dataEntityId, 'dataEntityId', errMsg);
                this.assert.isString(errorCode, 'errorCode', errMsg);
                // Get the error object
                var errorObject = this._getErrorsObject(dataEntityId);
                if (errorObject) {
                    // Get the error message treating the errorCode as string
                    var errorDisplayObject = errorObject[errorCode];
                    // If not found try the errorCode as HEX
                    if (_.isUndefined(errorDisplayObject)) {
                        errorDisplayObject = errorObject[parseInt(errorCode)];
                    }
                    return errorDisplayObject ? errorDisplayObject.displayMessage : errorCode;
                }
                // Return null if no errorObject
                return errorCode;
            };
            IndicatorErrorCodesService.NAME_SPACE = 'fsIndicatorErrorCodes';
            IndicatorErrorCodesService.$inject = ['assert'];
            return IndicatorErrorCodesService;
        }());
        angular.module('Fortscale.shared.services.fsIndicatorErrorCodes', [])
            .service('fsIndicatorErrorCodes', IndicatorErrorCodesService);
    }());
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    (function () {
        'use strict';
        var NTLMErrorCodes = {
            0: {
                "description": "Success",
                "displayMessage": "Success"
            },
            3221225572: {
                "description": "user name does not exist",
                "displayMessage": "Username doesn't exist"
            },
            3221225578: {
                "description": "user name is correct but the password is wrong",
                "displayMessage": "Wrong password"
            },
            3221226036: {
                "description": "user is currently locked out",
                "displayMessage": "User is locked out"
            },
            3221225586: {
                "description": "account is currently disabled",
                "displayMessage": "Account is disabled"
            },
            3221225583: {
                "description": "user tried to logon outside his day of week or time of day restrictions",
                "displayMessage": "Logon day/time restrictions"
            },
            3221225584: {
                "description": "workstation restriction",
                "displayMessage": "Workstation restriction"
            },
            3221225875: {
                "description": "account expiration",
                "displayMessage": "Account expiration"
            },
            3221225585: {
                "description": "expired password",
                "displayMessage": "Expired password"
            },
            3221226020: {
                "description": "user is required to change password at next logon",
                "displayMessage": "Change password required"
            },
            3221226021: {
                "description": "evidently a bug in Windows and not a risk",
                "displayMessage": "Windows issue"
            }
        };
        angular.module('Fortscale.shared.services.fsIndicatorErrorCodes')
            .run(['fsIndicatorErrorCodes',
            function (fsIndicatorErrorCodes) {
                fsIndicatorErrorCodes.addErrorObject('ntlm', NTLMErrorCodes);
            }]);
    }());
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    (function () {
        'use strict';
        var KerberosErrorCodes = {
            0x1: {
                "description": "Client's entry in KDC database has expired",
                "displayMessage": "Client's entry in KDC database has expired"
            },
            0x2: {
                "description": "Server's entry in KDC database has expired",
                "displayMessage": "Server's entry in KDC database has expired"
            },
            0x3: {
                "description": "Requested Kerberos version number not supported",
                "displayMessage": "Requested Kerberos version number not supported"
            },
            0x4: {
                "description": "Client's key encrypted in old master key",
                "displayMessage": "Client's key encrypted in old master key"
            },
            0x5: {
                "description": "Server's key encrypted in old master key",
                "displayMessage": "Server's key encrypted in old master key"
            },
            0x6: {
                "description": "Client not found in Kerberos database",
                "displayMessage": "Client not found in Kerberos database"
            },
            0x7: {
                "description": "Server not found in Kerberos database",
                "displayMessage": "Server not found in Kerberos database"
            },
            0x8: {
                "description": "Multiple principal entries in KDC database",
                "displayMessage": "Multiple principal entries in KDC database"
            },
            0x9: {
                "description": "The client or server has a null key (master key)",
                "displayMessage": "The client or server has a null key (master key)"
            },
            0xA: {
                "description": "Ticket (TGT) not eligible for postdating",
                "displayMessage": "Ticket (TGT) not eligible for postdating"
            },
            0xB: {
                "description": "Requested start time is later than end time",
                "displayMessage": "Requested start time is later than end time"
            },
            0xC: {
                "description": "KDC policy rejects request",
                "displayMessage": "KDC policy rejects request"
            },
            0xD: {
                "description": "KDC cannot accommodate requested option",
                "displayMessage": "KDC cannot accommodate requested option"
            },
            0xE: {
                "description": "KDC has no support for encryption type",
                "displayMessage": "KDC has no support for encryption type"
            },
            0xF: {
                "description": "KDC has no support for checksum type",
                "displayMessage": "KDC has no support for checksum type"
            },
            0x10: {
                "description": "KDC has no support for PADATA type (pre-authentication data)",
                "displayMessage": "KDC has no support for PADATA type"
            },
            0x11: {
                "description": "KDC has no support for transited type",
                "displayMessage": "KDC has no support for transited type"
            },
            0x12: {
                "description": "Clients credentials have been revoked",
                "displayMessage": "Clients credentials have been revoked"
            },
            0x13: {
                "description": "Credentials for server have been revoked",
                "displayMessage": "Credentials for server have been revoked"
            },
            0x14: {
                "description": "TGT has been revoked",
                "displayMessage": "TGT has been revoked"
            },
            0x15: {
                "description": "Client not yet validtry again later",
                "displayMessage": "Client not yet valid"
            },
            0x16: {
                "description": "Server not yet validtry again later",
                "displayMessage": "Server not yet valid"
            },
            0x17: {
                "description": "Password has expiredchange password to reset",
                "displayMessage": "Password has expired"
            },
            0x18: {
                "description": "Pre-authentication information was invalid",
                "displayMessage": "Pre-authentication information was invalid"
            },
            0x19: {
                "description": "Additional preauthentication required",
                "displayMessage": "Additional preauthentication required"
            },
            0x1A: {
                "description": "KDC does not know about the requested server",
                "displayMessage": "KDC does not know about the requested server"
            },
            0x1B: {
                "description": "KDC is unavailable",
                "displayMessage": "KDC is unavailable"
            },
            0x1F: {
                "description": "Integrity check on decrypted field failed",
                "displayMessage": "Integrity check on decrypted field failed"
            },
            0x20: {
                "description": "The ticket has expired",
                "displayMessage": "The ticket has expired"
            },
            0x21: {
                "description": "The ticket is not yet valid",
                "displayMessage": "The ticket is not yet valid"
            },
            0x22: {
                "description": "The request is a replay",
                "displayMessage": "The request is a replay"
            },
            0x23: {
                "description": "The ticket is not for us",
                "displayMessage": "The ticket is not for us"
            },
            0x24: {
                "description": "The ticket and authenticator do not match",
                "displayMessage": "The ticket and authenticator do not match"
            },
            0x25: {
                "description": "The clock skew is too great",
                "displayMessage": "The clock skew is too great"
            },
            0x26: {
                "description": "Network address in network layer header doesn't match address inside ticket",
                "displayMessage": "Incorrect network address"
            },
            0x27: {
                "description": "Protocol version numbers don't match (PVNO)",
                "displayMessage": "Protocol version numbers don't match"
            },
            0x28: {
                "description": "Message type is unsupported",
                "displayMessage": "Message type is unsupported"
            },
            0x29: {
                "description": "Message stream modified and checksum didn't match",
                "displayMessage": "Message stream modified and checksum didn't match"
            },
            0x2A: {
                "description": "Message out of order (possible tampering)",
                "displayMessage": "Message out of order (possible tampering)"
            },
            0x2C: {
                "description": "Specified version of key is not available",
                "displayMessage": "Specified version of key is not available"
            },
            0x2D: {
                "description": "Service key not available",
                "displayMessage": "Service key not available"
            },
            0x2E: {
                "description": "Mutual authentication failed",
                "displayMessage": "Mutual authentication failed"
            },
            0x2F: {
                "description": "Incorrect message direction",
                "displayMessage": "Incorrect message direction"
            },
            0x30: {
                "description": "Alternative authentication method required",
                "displayMessage": "Alternative authentication method required"
            },
            0x31: {
                "description": "Incorrect sequence number in message",
                "displayMessage": "Incorrect sequence number in message"
            },
            0x32: {
                "description": "Inappropriate type of checksum in message (checksum may be unsupported)",
                "displayMessage": "Inappropriate type of checksum in message"
            },
            0x33: {
                "description": "Desired path is unreachable",
                "displayMessage": "Desired path is unreachable"
            },
            0x34: {
                "description": "Too much data",
                "displayMessage": "Too much data"
            },
            0x3C: {
                "description": "Generic error; the description is in the e-data field",
                "displayMessage": "Generic error; the description is in the e-data field"
            },
            0x3D: {
                "description": "Field is too long for this implementation",
                "displayMessage": "Field is too long for this implementation"
            },
            0x3E: {
                "description": "The client trust failed or is not implemented",
                "displayMessage": "The client trust failed or is not implemented"
            },
            0x3F: {
                "description": "The KDC server trust failed or could not be verified",
                "displayMessage": "The KDC server trust failed or could not be verified"
            },
            0x40: {
                "description": "The signature is invalid",
                "displayMessage": "The signature is invalid"
            },
            0x41: {
                "description": "A higher encryption level is needed",
                "displayMessage": "A higher encryption level is needed"
            },
            0x42: {
                "description": "User-to-user authorization is required",
                "displayMessage": "User-to-user authorization is required"
            },
            0x43: {
                "description": "No TGT was presented or available",
                "displayMessage": "No TGT was presented or available"
            },
            0x44: {
                "description": "Incorrect domain or principal",
                "displayMessage": "Incorrect domain or principal"
            }
        };
        angular.module('Fortscale.shared.services.fsIndicatorErrorCodes')
            .run(['fsIndicatorErrorCodes',
            function (fsIndicatorErrorCodes) {
                fsIndicatorErrorCodes.addErrorObject('kerberos_logins', KerberosErrorCodes);
                fsIndicatorErrorCodes.addErrorObject('kerberos_tgt', KerberosErrorCodes);
            }]);
    }());
})(Fortscale || (Fortscale = {}));

/**
 * This is an angular-typescript wrapper on top of toastr library.
 */
var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var toastrService;
            (function (toastrService) {
                'use strict';
                var ToastrService = (function () {
                    function ToastrService() {
                        // Set timeOut and extendedTimeOut to 0 to make it sticky
                        toastr.options = _.merge({}, toastr.options, {
                            toastClass: 'fs-toast',
                            showMethod: 'fadeIn',
                            hideMethod: 'fadeOut',
                            hideDuration: 500,
                            positionClass: 'toast-top-center',
                            closeButton: true,
                            timeOut: 3000,
                            iconClasses: {
                                error: 'toast-error',
                                info: 'toast-info',
                                success: 'toast-success',
                                warning: 'toast-warning'
                            }
                        });
                    }
                    Object.defineProperty(ToastrService.prototype, "options", {
                        get: function () {
                            return toastr.options;
                        },
                        set: function (options) {
                            toastr.options = options;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ToastrService.prototype, "version", {
                        get: function () {
                            return toastr.version;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ToastrService.prototype.subscribe = function (callback) {
                        toastr.subscribe(callback);
                    };
                    ToastrService.prototype.clear = function ($toastElement, clearOptions) {
                        toastr.clear($toastElement, clearOptions);
                    };
                    ToastrService.prototype.remove = function ($toastElement) {
                        toastr.remove($toastElement);
                    };
                    ToastrService.prototype.getContainer = function (options, create) {
                        return toastr.getContainer(options, create);
                    };
                    ToastrService.prototype.error = function (message, title, optionsOverride) {
                        return toastr.error(message, title, optionsOverride);
                    };
                    ToastrService.prototype.info = function (message, title, optionsOverride) {
                        return toastr.info(message, title, optionsOverride);
                    };
                    ToastrService.prototype.success = function (message, title, optionsOverride) {
                        return toastr.success(message, title, optionsOverride);
                    };
                    ToastrService.prototype.warning = function (message, title, optionsOverride) {
                        return toastr.warning(message, title, optionsOverride);
                    };
                    ToastrService.$inject = [];
                    return ToastrService;
                }());
                angular.module('Fortscale.shared.services.toastrService', [])
                    .service('toastrService', ToastrService);
            })(toastrService = services.toastrService || (services.toastrService = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));
/**
 *
 * These are the options default values:
 *
{
    tapToDismiss: true,
        toastClass: 'toast',
    containerId: 'toast-container',
    debug: false,

    showMethod: 'fadeIn', //fadeIn, slideDown, and show are built into jQuery
    showDuration: 300,
    showEasing: 'swing', //swing and linear are built into jQuery
    onShown: undefined,
    hideMethod: 'fadeOut',
    hideDuration: 1000,
    hideEasing: 'swing',
    onHidden: undefined,
    closeMethod: false,
    closeDuration: false,
    closeEasing: false,

    extendedTimeOut: 1000,
    iconClasses: {
    error: 'toast-error',
        info: 'toast-info',
        success: 'toast-success',
        warning: 'toast-warning'
},
    iconClass: 'toast-info',
        positionClass: 'toast-top-right',
    timeOut: 5000, // Set timeOut and extendedTimeOut to 0 to make it sticky
    titleClass: 'toast-title',
    messageClass: 'toast-message',
    escapeHtml: false,
    target: 'body',
    closeHtml: '<button type="button">&times;</button>',
    newestOnTop: true,
    preventDuplicates: false,
    progressBar: false
}
 **/

/**
 *
 */
var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var alertUpdatesService;
            (function (alertUpdatesService) {
                'use strict';
                /**
                 * Enums
                 */
                (function (AlertFeedback) {
                    AlertFeedback[AlertFeedback["Approved"] = 0] = "Approved";
                    AlertFeedback[AlertFeedback["Rejected"] = 1] = "Rejected";
                    AlertFeedback[AlertFeedback["None"] = 2] = "None";
                })(alertUpdatesService.AlertFeedback || (alertUpdatesService.AlertFeedback = {}));
                var AlertFeedback = alertUpdatesService.AlertFeedback;
                (function (AlertStatus) {
                    AlertStatus[AlertStatus["Open"] = 0] = "Open";
                    AlertStatus[AlertStatus["Closed"] = 1] = "Closed";
                })(alertUpdatesService.AlertStatus || (alertUpdatesService.AlertStatus = {}));
                var AlertStatus = alertUpdatesService.AlertStatus;
                var AlertUpdatesService = (function () {
                    function AlertUpdatesService($http, BASE_URL) {
                        this.$http = $http;
                        this.BASE_URL = BASE_URL;
                        this.ALERT_URL = this.BASE_URL + '/alerts';
                    }
                    AlertUpdatesService.prototype._getPostUrl = function (alertId) {
                        return this.ALERT_URL + '/' + alertId + '/comments';
                    };
                    AlertUpdatesService.prototype._getDeleteAndUpdateUrl = function (alertId, commentId) {
                        return this._getPostUrl(alertId) + '/' + commentId;
                    };
                    /**
                     * Send HTTP post for adding comment
                     * @param alertId
                     * @param comment
                     * @returns {IHttpPromise<T>} - return promise which contain the comment
                     */
                    AlertUpdatesService.prototype.addComment = function (alertId, comment) {
                        return this.$http.post(this._getPostUrl(alertId), comment);
                    };
                    /**
                     * Send comment delete request and return promise without any bady
                     * @param alertId
                     * @param comment
                     * @returns {IHttpPromise<T>}
                     */
                    AlertUpdatesService.prototype.deleteComment = function (alertId, comment) {
                        var url = this._getDeleteAndUpdateUrl(alertId, comment.commentId);
                        return this.$http.delete(url);
                    };
                    /**
                     * Send comment update request and return promise without any body
                     * @param alertId
                     * @param comment
                     * @returns {IHttpPromise<T>}
                     */
                    AlertUpdatesService.prototype.updateComment = function (alertId, comment) {
                        return this.$http.patch(this._getDeleteAndUpdateUrl(alertId, comment.commentId), comment);
                    };
                    /**
                     * Update the status and feedback of the alert and return promise without any body
                     * @param alertId
                     * @param feedbackBody
                     * @returns {IHttpPromise<T>}
                     */
                    AlertUpdatesService.prototype.updateFeedback = function (alertId, feedbackBody) {
                        /**
                         * Extract the values as string instead of number represents the enum
                         * @type {{status: any, feedback: any}}
                         */
                        var body = {
                            status: AlertStatus[feedbackBody.status],
                            feedback: AlertFeedback[feedbackBody.feedback]
                        };
                        // Create the patch request url
                        var url = this.BASE_URL + '/alerts/' + alertId;
                        return this.$http.patch(url, body);
                    };
                    AlertUpdatesService.$inject = ['$http', 'BASE_URL'];
                    return AlertUpdatesService;
                }());
                angular.module('Fortscale.shared.services')
                    .service('alertUpdatesService', AlertUpdatesService);
            })(alertUpdatesService = services.alertUpdatesService || (services.alertUpdatesService = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));



var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var entityActivityUtils;
            (function (entityActivityUtils) {
                (function (eEntityType) {
                    eEntityType[eEntityType["USER"] = 0] = "USER";
                    eEntityType[eEntityType["DEVICE"] = 1] = "DEVICE";
                    eEntityType[eEntityType["ORGANIZATION"] = 2] = "ORGANIZATION";
                })(entityActivityUtils.eEntityType || (entityActivityUtils.eEntityType = {}));
                var eEntityType = entityActivityUtils.eEntityType;
                var EntityActivityUtilsService = (function () {
                    function EntityActivityUtilsService($http, $q, BASE_URL) {
                        this.$http = $http;
                        this.$q = $q;
                        this.BASE_URL = BASE_URL;
                    }
                    /**
                     * Returns the url for user activity
                     * @param {{id: string}} user
                     * @param {string} endPoint
                     * @returns {string}
                     * @private
                     */
                    EntityActivityUtilsService.prototype._getUserActivityUrl = function (user, endPoint) {
                        return this.BASE_URL + "/user/" + user.id + "/activity" + (endPoint ? '/' + endPoint : '');
                    };
                    /**
                     * Returns the url for organization activity
                     * @param {string} endPoint
                     * @returns {string}
                     * @private
                     */
                    EntityActivityUtilsService.prototype._getOrganizationActivityUrl = function (endPoint) {
                        return this.BASE_URL + "/organization/activity" + (endPoint ? '/' + endPoint : '');
                    };
                    ;
                    /**
                     * Returns a promise that resolves on a user's Top-Countries activity
                     * @param {{}=} user
                     * @param {number=} daysRange
                     * @param {number=} limit
                     * @returns {IHttpPromise<IEntityActivityLocationUser>}
                     * @private
                     */
                    EntityActivityUtilsService.prototype._getUserTopCountries = function (user, daysRange, limit) {
                        var url = this._getUserActivityUrl(user, 'locations');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange,
                                limit: limit
                            }
                        });
                    };
                    /**
                     * Returns a promise that resolves on organization Top-Countries activity
                     * @param {number=} daysRange
                     * @param {number=} limit
                     * @returns {IHttpPromise<IEntityActivityLocationOrganization>}
                     * @private
                     */
                    EntityActivityUtilsService.prototype._getOrganizationTopCountries = function (daysRange, limit) {
                        var url = this._getOrganizationActivityUrl('locations');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange,
                                limit: limit
                            }
                        });
                    };
                    /**
                     * Returns a promise that resolves on a user's authentications activity
                     * @param {{}=} user
                     * @param {number=} daysRange
                     * @returns {IHttpPromise<IEntityActivityLocationUser>}
                     * @private
                     */
                    EntityActivityUtilsService.prototype._getUserAuthentications = function (user, daysRange) {
                        var url = this._getUserActivityUrl(user, 'authentications');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange
                            }
                        });
                    };
                    EntityActivityUtilsService.prototype._getUserWorkingHours = function (user, daysRange) {
                        var url = this._getUserActivityUrl(user, 'working-hours');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange
                            }
                        });
                    };
                    EntityActivityUtilsService.prototype._getUserSourceDevices = function (user, daysRange) {
                        var url = this._getUserActivityUrl(user, 'source-devices');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange
                            }
                        });
                    };
                    EntityActivityUtilsService.prototype._getUserTargetDevices = function (user, daysRange) {
                        var url = this._getUserActivityUrl(user, 'target-devices');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange
                            }
                        });
                    };
                    EntityActivityUtilsService.prototype._getUserDataUsages = function (user, daysRange) {
                        var url = this._getUserActivityUrl(user, 'data-usage');
                        return this.$http.get(url, {
                            params: {
                                time_range: daysRange
                            }
                        });
                    };
                    /**
                     * Returns a promise that resolves on Top-Countries activity
                     *
                     * @param {number} entityType
                     * @param {{}=} entity
                     * @param {number=} daysRange
                     * @param {number=} limit
                     * @returns {IPromise<any>}
                     */
                    EntityActivityUtilsService.prototype.getTopCountries = function (entityType, entity, daysRange, limit) {
                        if (daysRange === void 0) { daysRange = 90; }
                        if (limit === void 0) { limit = 3; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserTopCountries(entity, daysRange, limit);
                                case eEntityType.ORGANIZATION:
                                    return this._getOrganizationTopCountries(daysRange, limit);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            return res.data.data;
                        });
                    };
                    /**
                     * Returns a promise that resolves on authentications activity
                     *
                     * @param {number} entityType
                     * @param {{}=} entity
                     * @param {number=} daysRange
                     * @returns {IPromise<any>}
                     */
                    EntityActivityUtilsService.prototype.getAuthentications = function (entityType, entity, daysRange) {
                        if (daysRange === void 0) { daysRange = 90; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserAuthentications(entity, daysRange);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            if (res.data && res.data.data && res.data.data.length === 1) {
                                return res.data.data[0];
                            }
                            return {
                                success: 0,
                                failed: 0
                            };
                        });
                    };
                    EntityActivityUtilsService.prototype.getWorkingHours = function (entityType, entity, daysRange) {
                        if (daysRange === void 0) { daysRange = 90; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserWorkingHours(entity, daysRange);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            return res.data.data;
                        });
                    };
                    EntityActivityUtilsService.prototype.getSourceDevices = function (entityType, entity, daysRange) {
                        if (daysRange === void 0) { daysRange = 90; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserSourceDevices(entity, daysRange);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            return res.data.data;
                        });
                    };
                    EntityActivityUtilsService.prototype.getTargetDevices = function (entityType, entity, daysRange) {
                        if (daysRange === void 0) { daysRange = 90; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserTargetDevices(entity, daysRange);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            return res.data.data;
                        });
                    };
                    EntityActivityUtilsService.prototype.getDataUsages = function (entityType, entity, daysRange) {
                        if (daysRange === void 0) { daysRange = 90; }
                        var entityTypeSwitch = function () {
                            switch (entityType) {
                                case eEntityType.USER:
                                    return this._getUserDataUsages(entity, daysRange);
                                default:
                                    return null;
                            }
                        }.bind(this);
                        return this.$q.when(entityTypeSwitch())
                            .then(function (res) {
                            return res.data.data;
                        });
                    };
                    EntityActivityUtilsService.$inject = ['$http', '$q', 'BASE_URL'];
                    return EntityActivityUtilsService;
                }());
                angular.module('Fortscale.shared.services.entityActivityUtils', [])
                    .service('entityActivityUtils', EntityActivityUtilsService);
            })(entityActivityUtils = services.entityActivityUtils || (services.entityActivityUtils = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

/**
 *  This new state management service as a few assumption, that you need to be aware when using it:
 *  1. It tested and ment to be only with flat states (each state member should be string, number, or boolean),
 *     working with object might worked but need to be tested mainly when saved to session storage or url.
 *  2. When component loaded, we first try to retrive the state from URL, if no state on URL we try to load it from session storage,
 *     and if it also not exists on the session storage we use the defualt.
 *  3. null values saved on the URL and session storage as empty string. The assumption is empty string always be "no value"
 *     because the rest calls are not diffriniate between empty attribute and not sent attribute.
 *
 */
var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var stateManagementService;
            (function (stateManagementService) {
                'use strict';
                var SESSION_STORAGE_KEY_PREFIX = "fs.state.";
                var StateManagementService = (function () {
                    function StateManagementService(assert, urlStateManager, $window) {
                        this.assert = assert;
                        this.urlStateManager = urlStateManager;
                        this.$window = $window;
                        //Contains map from state id to IStateDefinition
                        this.stateMap = {};
                    }
                    StateManagementService.prototype.initState = function (stateId, initialStateSettings) {
                        //Verify state and stateId
                        this.assert.isString(stateId, "StateId");
                        this.assert.isObject(initialStateSettings, "InitialStateSettings");
                        //Create the state object
                        var state = {
                            initialState: initialStateSettings,
                            currentState: _.clone(initialStateSettings),
                            id: stateId,
                            registeredDelegates: []
                        };
                        //Load the saved state if such exists
                        var previousState = this._getPreviousState(stateId, state.initialState);
                        //Update the changes with the saved state
                        _.merge(state.currentState, previousState);
                        //Create the state map
                        this.stateMap[stateId] = state;
                        //Update the url / session storage + trigger the registerd components if such exists
                        this.updateState(stateId, state.currentState);
                        return state.currentState;
                    };
                    /**
                     * Fetch the prvious state, if such state exists.
                     * Take it from the URL first,
                     * if not on the URL try to take if from the session storage
                     * If not exists on the session storage return empty object
                     * @param stateId
                     * @returns {*}
                     * @private
                     */
                    StateManagementService.prototype._getPreviousState = function (stateId, initialState) {
                        var previousState = this.urlStateManager.getStateByContainerId(stateId);
                        if (!previousState) {
                            previousState = this.$window.sessionStorage.getItem(SESSION_STORAGE_KEY_PREFIX + stateId);
                            if (previousState) {
                                previousState = JSON.parse(previousState);
                            }
                        }
                        _.forOwn(previousState, function (value, key) {
                            var originalIsEmpty = initialState[key] === null || typeof initialState[key] === "undefined";
                            if (value === "" && !originalIsEmpty) {
                                previousState[key] = null;
                            }
                        });
                        return previousState;
                    };
                    /**
                     * Return merge between the current state and the changes
                     * @param stateId
                     * @returns {any}
                     */
                    StateManagementService.prototype.readCurrentState = function (stateId) {
                        var state = this.stateMap[stateId];
                        if (typeof state === "undefined") {
                            return state;
                        }
                        //Merged state- the full state, come from merging the currentState without null into initialState
                        //return _.merge({}, state.initialState, _.omitBy(state.stateChanges, _.isNil));
                        return state.currentState;
                    };
                    /**
                     * Clear all the local user states
                     */
                    StateManagementService.prototype.clearAllStates = function () {
                        var _this = this;
                        var stateId = _.keys(this.stateMap);
                        _.each(stateId, function (sateId) {
                            _this.stateMap[sateId].registeredDelegates = [];
                            delete _this.stateMap[sateId];
                            _this.$window.sessionStorage.removeItem(SESSION_STORAGE_KEY_PREFIX + stateId);
                        });
                    };
                    /**
                     *
                     *
                     * @param stateId -  the id of the state
                     * @param newState - the state values which deffer from the initial values.
                     * @param triggerImmediately - default value is true
                     */
                    StateManagementService.prototype.updateState = function (stateId, newCurrentState, triggerImmediately) {
                        //Verify stateId and newState
                        var ctrl = this;
                        ctrl.assert.isString(stateId, "StateId");
                        ctrl.assert.isObject(newCurrentState, "newState");
                        var state = ctrl.stateMap[stateId];
                        this.assert(state, "State is not initiated", TypeError);
                        state.currentState = newCurrentState;
                        //Take accation immedietly:
                        if (!triggerImmediately) {
                            //Iterate all listeners and execute them with new state
                            _.each(state.registeredDelegates, function (delegate) { return delegate(ctrl.readCurrentState(stateId)); });
                            var currentStateChanges = this._getStateChanges(state);
                            //Update URL and sessopn storage
                            this.urlStateManager.updateUrlStateParameters(stateId, currentStateChanges, true);
                            this.$window.sessionStorage.setItem(SESSION_STORAGE_KEY_PREFIX + stateId, JSON.stringify(currentStateChanges));
                        }
                    };
                    /**
                     *This method return the changes
                     * There is an assumption that the state is flat object.
                     */
                    StateManagementService.prototype._getStateChanges = function (state) {
                        var changesWithNulls = _.pickBy(state.currentState, function (value, key) {
                            return value !== state.initialState[key];
                        });
                        _.forOwn(changesWithNulls, function (value, key) {
                            var originalIsEmpty = state.initialState[key] === null || typeof state.initialState[key] === "undefined";
                            if (value === null && !originalIsEmpty) {
                                changesWithNulls[key] = "";
                            }
                        });
                        return changesWithNulls;
                    };
                    /**
                     * Test if state is different the inital state
                     */
                    StateManagementService.prototype.isStateChanged = function (stateId) {
                        var state = this.stateMap[stateId];
                        var differences = _.omitBy(_.pickBy(state.currentState, function (value, key) {
                            return value !== state.initialState[key];
                        }), _.isNil);
                        return _.keys(differences).length > 0;
                    };
                    StateManagementService.prototype.clearState = function (stateId, override) {
                        var state = this.stateMap[stateId];
                        var newState = _.clone(state.initialState);
                        newState = _.merge(newState, override);
                        this.updateState(stateId, newState);
                    };
                    /**
                     * Add listener to specific state by id.
                     * When state will change, all listeners of the state will be triggered with the new state
                     * @param stateId
                     * @param onStateChangeDelegate - function which get the new state and do something, and don't return anything
                     */
                    StateManagementService.prototype.registerToStateChanges = function (stateId, onStateChangeDelegate) {
                        this.assert.isString(stateId, "StateId");
                        this.assert.isFunction(onStateChangeDelegate, "onStateChangeDelegate");
                        var state = this.stateMap[stateId];
                        this.assert(state, "State is not initiated", TypeError);
                        state.registeredDelegates.push(onStateChangeDelegate);
                    };
                    StateManagementService.$inject = ['assert', 'urlStateManager', '$window'];
                    return StateManagementService;
                }());
                angular.module('Fortscale.shared.services')
                    .service('stateManagementService', StateManagementService);
            })(stateManagementService = services.stateManagementService || (services.stateManagementService = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

/*
 although ammap has methos like getAreaCenterLatitude and getAreaCenterLongitude,
 they are not suitable in quite a lot of cases as the center of some countries
 is even outside the country itself (like US, because of Alaska and Hawaii)
 That's why we have the coordinates stored here
 */
var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var amMaps;
            (function (amMaps) {
                'use strict';
                var latlong = {};
                latlong["AD"] = { "latitude": 42.5, "longitude": 1.5 };
                latlong["AE"] = { "latitude": 24, "longitude": 54 };
                latlong["AF"] = { "latitude": 33, "longitude": 65 };
                latlong["AG"] = { "latitude": 17.05, "longitude": -61.8 };
                latlong["AI"] = { "latitude": 18.25, "longitude": -63.1667 };
                latlong["AL"] = { "latitude": 41, "longitude": 20 };
                latlong["AM"] = { "latitude": 40, "longitude": 45 };
                latlong["AN"] = { "latitude": 12.25, "longitude": -68.75 };
                latlong["AO"] = { "latitude": -12.5, "longitude": 18.5 };
                latlong["AP"] = { "latitude": 35, "longitude": 105 };
                latlong["AQ"] = { "latitude": -90, "longitude": 0 };
                latlong["AR"] = { "latitude": -34, "longitude": -64 };
                latlong["AS"] = { "latitude": -14.3333, "longitude": -170 };
                latlong["AT"] = { "latitude": 47.3333, "longitude": 13.3333 };
                latlong["AU"] = { "latitude": -27, "longitude": 133 };
                latlong["AW"] = { "latitude": 12.5, "longitude": -69.9667 };
                latlong["AZ"] = { "latitude": 40.5, "longitude": 47.5 };
                latlong["BA"] = { "latitude": 44, "longitude": 18 };
                latlong["BB"] = { "latitude": 13.1667, "longitude": -59.5333 };
                latlong["BD"] = { "latitude": 24, "longitude": 90 };
                latlong["BE"] = { "latitude": 50.8333, "longitude": 4 };
                latlong["BF"] = { "latitude": 13, "longitude": -2 };
                latlong["BG"] = { "latitude": 43, "longitude": 25 };
                latlong["BH"] = { "latitude": 26, "longitude": 50.55 };
                latlong["BI"] = { "latitude": -3.5, "longitude": 30 };
                latlong["BJ"] = { "latitude": 9.5, "longitude": 2.25 };
                latlong["BM"] = { "latitude": 32.3333, "longitude": -64.75 };
                latlong["BN"] = { "latitude": 4.5, "longitude": 114.6667 };
                latlong["BO"] = { "latitude": -17, "longitude": -65 };
                latlong["BR"] = { "latitude": -10, "longitude": -55 };
                latlong["BS"] = { "latitude": 24.25, "longitude": -76 };
                latlong["BT"] = { "latitude": 27.5, "longitude": 90.5 };
                latlong["BV"] = { "latitude": -54.4333, "longitude": 3.4 };
                latlong["BW"] = { "latitude": -22, "longitude": 24 };
                latlong["BY"] = { "latitude": 53, "longitude": 28 };
                latlong["BZ"] = { "latitude": 17.25, "longitude": -88.75 };
                latlong["CA"] = { "latitude": 54, "longitude": -100 };
                latlong["CC"] = { "latitude": -12.5, "longitude": 96.8333 };
                latlong["CD"] = { "latitude": 0, "longitude": 25 };
                latlong["CF"] = { "latitude": 7, "longitude": 21 };
                latlong["CG"] = { "latitude": -1, "longitude": 15 };
                latlong["CH"] = { "latitude": 47, "longitude": 8 };
                latlong["CI"] = { "latitude": 8, "longitude": -5 };
                latlong["CK"] = { "latitude": -21.2333, "longitude": -159.7667 };
                latlong["CL"] = { "latitude": -30, "longitude": -71 };
                latlong["CM"] = { "latitude": 6, "longitude": 12 };
                latlong["CN"] = { "latitude": 35, "longitude": 105 };
                latlong["CO"] = { "latitude": 4, "longitude": -72 };
                latlong["CR"] = { "latitude": 10, "longitude": -84 };
                latlong["CU"] = { "latitude": 21.5, "longitude": -80 };
                latlong["CV"] = { "latitude": 16, "longitude": -24 };
                latlong["CX"] = { "latitude": -10.5, "longitude": 105.6667 };
                latlong["CY"] = { "latitude": 35, "longitude": 33 };
                latlong["CZ"] = { "latitude": 49.75, "longitude": 15.5 };
                latlong["DE"] = { "latitude": 51, "longitude": 9 };
                latlong["DJ"] = { "latitude": 11.5, "longitude": 43 };
                latlong["DK"] = { "latitude": 56, "longitude": 10 };
                latlong["DM"] = { "latitude": 15.4167, "longitude": -61.3333 };
                latlong["DO"] = { "latitude": 19, "longitude": -70.6667 };
                latlong["DZ"] = { "latitude": 28, "longitude": 3 };
                latlong["EC"] = { "latitude": -2, "longitude": -77.5 };
                latlong["EE"] = { "latitude": 59, "longitude": 26 };
                latlong["EG"] = { "latitude": 27, "longitude": 30 };
                latlong["EH"] = { "latitude": 24.5, "longitude": -13 };
                latlong["ER"] = { "latitude": 15, "longitude": 39 };
                latlong["ES"] = { "latitude": 40, "longitude": -4 };
                latlong["ET"] = { "latitude": 8, "longitude": 38 };
                latlong["EU"] = { "latitude": 47, "longitude": 8 };
                latlong["FI"] = { "latitude": 62, "longitude": 26 };
                latlong["FJ"] = { "latitude": -18, "longitude": 175 };
                latlong["FK"] = { "latitude": -51.75, "longitude": -59 };
                latlong["FM"] = { "latitude": 6.9167, "longitude": 158.25 };
                latlong["FO"] = { "latitude": 62, "longitude": -7 };
                latlong["FR"] = { "latitude": 46, "longitude": 2 };
                latlong["GA"] = { "latitude": -1, "longitude": 11.75 };
                latlong["GB"] = { "latitude": 54, "longitude": -2 };
                latlong["GD"] = { "latitude": 12.1167, "longitude": -61.6667 };
                latlong["GE"] = { "latitude": 42, "longitude": 43.5 };
                latlong["GF"] = { "latitude": 4, "longitude": -53 };
                latlong["GH"] = { "latitude": 8, "longitude": -2 };
                latlong["GI"] = { "latitude": 36.1833, "longitude": -5.3667 };
                latlong["GL"] = { "latitude": 72, "longitude": -40 };
                latlong["GM"] = { "latitude": 13.4667, "longitude": -16.5667 };
                latlong["GN"] = { "latitude": 11, "longitude": -10 };
                latlong["GP"] = { "latitude": 16.25, "longitude": -61.5833 };
                latlong["GQ"] = { "latitude": 2, "longitude": 10 };
                latlong["GR"] = { "latitude": 39, "longitude": 22 };
                latlong["GS"] = { "latitude": -54.5, "longitude": -37 };
                latlong["GT"] = { "latitude": 15.5, "longitude": -90.25 };
                latlong["GU"] = { "latitude": 13.4667, "longitude": 144.7833 };
                latlong["GW"] = { "latitude": 12, "longitude": -15 };
                latlong["GY"] = { "latitude": 5, "longitude": -59 };
                latlong["HK"] = { "latitude": 22.25, "longitude": 114.1667 };
                latlong["HM"] = { "latitude": -53.1, "longitude": 72.5167 };
                latlong["HN"] = { "latitude": 15, "longitude": -86.5 };
                latlong["HR"] = { "latitude": 45.1667, "longitude": 15.5 };
                latlong["HT"] = { "latitude": 19, "longitude": -72.4167 };
                latlong["HU"] = { "latitude": 47, "longitude": 20 };
                latlong["ID"] = { "latitude": -5, "longitude": 120 };
                latlong["IE"] = { "latitude": 53, "longitude": -8 };
                latlong["IL"] = { "latitude": 31.5, "longitude": 34.75 };
                latlong["IN"] = { "latitude": 20, "longitude": 77 };
                latlong["IO"] = { "latitude": -6, "longitude": 71.5 };
                latlong["IQ"] = { "latitude": 33, "longitude": 44 };
                latlong["IR"] = { "latitude": 32, "longitude": 53 };
                latlong["IS"] = { "latitude": 65, "longitude": -18 };
                latlong["IT"] = { "latitude": 42.8333, "longitude": 12.8333 };
                latlong["JM"] = { "latitude": 18.25, "longitude": -77.5 };
                latlong["JO"] = { "latitude": 31, "longitude": 36 };
                latlong["JP"] = { "latitude": 36, "longitude": 138 };
                latlong["KE"] = { "latitude": 1, "longitude": 38 };
                latlong["KG"] = { "latitude": 41, "longitude": 75 };
                latlong["KH"] = { "latitude": 13, "longitude": 105 };
                latlong["KI"] = { "latitude": 1.4167, "longitude": 173 };
                latlong["KM"] = { "latitude": -12.1667, "longitude": 44.25 };
                latlong["KN"] = { "latitude": 17.3333, "longitude": -62.75 };
                latlong["KP"] = { "latitude": 40, "longitude": 127 };
                latlong["KR"] = { "latitude": 37, "longitude": 127.5 };
                latlong["KW"] = { "latitude": 29.3375, "longitude": 47.6581 };
                latlong["KY"] = { "latitude": 19.5, "longitude": -80.5 };
                latlong["KZ"] = { "latitude": 48, "longitude": 68 };
                latlong["LA"] = { "latitude": 18, "longitude": 105 };
                latlong["LB"] = { "latitude": 33.8333, "longitude": 35.8333 };
                latlong["LC"] = { "latitude": 13.8833, "longitude": -61.1333 };
                latlong["LI"] = { "latitude": 47.1667, "longitude": 9.5333 };
                latlong["LK"] = { "latitude": 7, "longitude": 81 };
                latlong["LR"] = { "latitude": 6.5, "longitude": -9.5 };
                latlong["LS"] = { "latitude": -29.5, "longitude": 28.5 };
                latlong["LT"] = { "latitude": 55, "longitude": 24 };
                latlong["LU"] = { "latitude": 49.75, "longitude": 6 };
                latlong["LV"] = { "latitude": 57, "longitude": 25 };
                latlong["LY"] = { "latitude": 25, "longitude": 17 };
                latlong["MA"] = { "latitude": 32, "longitude": -5 };
                latlong["MC"] = { "latitude": 43.7333, "longitude": 7.4 };
                latlong["MD"] = { "latitude": 47, "longitude": 29 };
                latlong["ME"] = { "latitude": 42.5, "longitude": 19.4 };
                latlong["MG"] = { "latitude": -20, "longitude": 47 };
                latlong["MH"] = { "latitude": 9, "longitude": 168 };
                latlong["MK"] = { "latitude": 41.8333, "longitude": 22 };
                latlong["ML"] = { "latitude": 17, "longitude": -4 };
                latlong["MM"] = { "latitude": 22, "longitude": 98 };
                latlong["MN"] = { "latitude": 46, "longitude": 105 };
                latlong["MO"] = { "latitude": 22.1667, "longitude": 113.55 };
                latlong["MP"] = { "latitude": 15.2, "longitude": 145.75 };
                latlong["MQ"] = { "latitude": 14.6667, "longitude": -61 };
                latlong["MR"] = { "latitude": 20, "longitude": -12 };
                latlong["MS"] = { "latitude": 16.75, "longitude": -62.2 };
                latlong["MT"] = { "latitude": 35.8333, "longitude": 14.5833 };
                latlong["MU"] = { "latitude": -20.2833, "longitude": 57.55 };
                latlong["MV"] = { "latitude": 3.25, "longitude": 73 };
                latlong["MW"] = { "latitude": -13.5, "longitude": 34 };
                latlong["MX"] = { "latitude": 23, "longitude": -102 };
                latlong["MY"] = { "latitude": 2.5, "longitude": 112.5 };
                latlong["MZ"] = { "latitude": -18.25, "longitude": 35 };
                latlong["NA"] = { "latitude": -22, "longitude": 17 };
                latlong["NC"] = { "latitude": -21.5, "longitude": 165.5 };
                latlong["NE"] = { "latitude": 16, "longitude": 8 };
                latlong["NF"] = { "latitude": -29.0333, "longitude": 167.95 };
                latlong["NG"] = { "latitude": 10, "longitude": 8 };
                latlong["NI"] = { "latitude": 13, "longitude": -85 };
                latlong["NL"] = { "latitude": 52.5, "longitude": 5.75 };
                latlong["NO"] = { "latitude": 62, "longitude": 10 };
                latlong["NP"] = { "latitude": 28, "longitude": 84 };
                latlong["NR"] = { "latitude": -0.5333, "longitude": 166.9167 };
                latlong["NU"] = { "latitude": -19.0333, "longitude": -169.8667 };
                latlong["NZ"] = { "latitude": -41, "longitude": 174 };
                latlong["OM"] = { "latitude": 21, "longitude": 57 };
                latlong["PA"] = { "latitude": 9, "longitude": -80 };
                latlong["PE"] = { "latitude": -10, "longitude": -76 };
                latlong["PF"] = { "latitude": -15, "longitude": -140 };
                latlong["PG"] = { "latitude": -6, "longitude": 147 };
                latlong["PH"] = { "latitude": 13, "longitude": 122 };
                latlong["PK"] = { "latitude": 30, "longitude": 70 };
                latlong["PL"] = { "latitude": 52, "longitude": 20 };
                latlong["PM"] = { "latitude": 46.8333, "longitude": -56.3333 };
                latlong["PR"] = { "latitude": 18.25, "longitude": -66.5 };
                latlong["PS"] = { "latitude": 32, "longitude": 35.25 };
                latlong["PT"] = { "latitude": 39.5, "longitude": -8 };
                latlong["PW"] = { "latitude": 7.5, "longitude": 134.5 };
                latlong["PY"] = { "latitude": -23, "longitude": -58 };
                latlong["QA"] = { "latitude": 25.5, "longitude": 51.25 };
                latlong["RE"] = { "latitude": -21.1, "longitude": 55.6 };
                latlong["RO"] = { "latitude": 46, "longitude": 25 };
                latlong["RS"] = { "latitude": 44, "longitude": 21 };
                latlong["RU"] = { "latitude": 60, "longitude": 100 };
                latlong["RW"] = { "latitude": -2, "longitude": 30 };
                latlong["SA"] = { "latitude": 25, "longitude": 45 };
                latlong["SB"] = { "latitude": -8, "longitude": 159 };
                latlong["SC"] = { "latitude": -4.5833, "longitude": 55.6667 };
                latlong["SD"] = { "latitude": 15, "longitude": 30 };
                latlong["SE"] = { "latitude": 62, "longitude": 15 };
                latlong["SG"] = { "latitude": 1.3667, "longitude": 103.8 };
                latlong["SH"] = { "latitude": -15.9333, "longitude": -5.7 };
                latlong["SI"] = { "latitude": 46, "longitude": 15 };
                latlong["SJ"] = { "latitude": 78, "longitude": 20 };
                latlong["SK"] = { "latitude": 48.6667, "longitude": 19.5 };
                latlong["SL"] = { "latitude": 8.5, "longitude": -11.5 };
                latlong["SM"] = { "latitude": 43.7667, "longitude": 12.4167 };
                latlong["SN"] = { "latitude": 14, "longitude": -14 };
                latlong["SO"] = { "latitude": 10, "longitude": 49 };
                latlong["SR"] = { "latitude": 4, "longitude": -56 };
                latlong["ST"] = { "latitude": 1, "longitude": 7 };
                latlong["SV"] = { "latitude": 13.8333, "longitude": -88.9167 };
                latlong["SY"] = { "latitude": 35, "longitude": 38 };
                latlong["SZ"] = { "latitude": -26.5, "longitude": 31.5 };
                latlong["TC"] = { "latitude": 21.75, "longitude": -71.5833 };
                latlong["TD"] = { "latitude": 15, "longitude": 19 };
                latlong["TF"] = { "latitude": -43, "longitude": 67 };
                latlong["TG"] = { "latitude": 8, "longitude": 1.1667 };
                latlong["TH"] = { "latitude": 15, "longitude": 100 };
                latlong["TJ"] = { "latitude": 39, "longitude": 71 };
                latlong["TK"] = { "latitude": -9, "longitude": -172 };
                latlong["TM"] = { "latitude": 40, "longitude": 60 };
                latlong["TN"] = { "latitude": 34, "longitude": 9 };
                latlong["TO"] = { "latitude": -20, "longitude": -175 };
                latlong["TR"] = { "latitude": 39, "longitude": 35 };
                latlong["TT"] = { "latitude": 11, "longitude": -61 };
                latlong["TV"] = { "latitude": -8, "longitude": 178 };
                latlong["TW"] = { "latitude": 23.5, "longitude": 121 };
                latlong["TZ"] = { "latitude": -6, "longitude": 35 };
                latlong["UA"] = { "latitude": 49, "longitude": 32 };
                latlong["UG"] = { "latitude": 1, "longitude": 32 };
                latlong["UM"] = { "latitude": 19.2833, "longitude": 166.6 };
                latlong["US"] = { "latitude": 38, "longitude": -97 };
                latlong["UY"] = { "latitude": -33, "longitude": -56 };
                latlong["UZ"] = { "latitude": 41, "longitude": 64 };
                latlong["VA"] = { "latitude": 41.9, "longitude": 12.45 };
                latlong["VC"] = { "latitude": 13.25, "longitude": -61.2 };
                latlong["VE"] = { "latitude": 8, "longitude": -66 };
                latlong["VG"] = { "latitude": 18.5, "longitude": -64.5 };
                latlong["VI"] = { "latitude": 18.3333, "longitude": -64.8333 };
                latlong["VN"] = { "latitude": 16, "longitude": 106 };
                latlong["VU"] = { "latitude": -16, "longitude": 167 };
                latlong["WF"] = { "latitude": -13.3, "longitude": -176.2 };
                latlong["WS"] = { "latitude": -13.5833, "longitude": -172.3333 };
                latlong["YE"] = { "latitude": 15, "longitude": 48 };
                latlong["YT"] = { "latitude": -12.8333, "longitude": 45.1667 };
                latlong["ZA"] = { "latitude": -29, "longitude": 24 };
                latlong["ZM"] = { "latitude": -15, "longitude": 30 };
                latlong["ZW"] = { "latitude": -20, "longitude": 30 };
                angular.module('Fortscale.shared.services')
                    .constant('amMapsCountryLatLong', latlong);
            })(amMaps = services.amMaps || (services.amMaps = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var services;
        (function (services) {
            var amMaps;
            (function (amMaps) {
                'use strict';
                var amMapsUtilsInsertConfigDefault = {
                    minBubbleSize: 10,
                    maxBubbleSize: 30
                };
                var AmMapsUtils = (function () {
                    function AmMapsUtils(assert, amMapsCountryLatLong) {
                        this.assert = assert;
                        this.amMapsCountryLatLong = amMapsCountryLatLong;
                    }
                    /**
                     * Validates inser config countries
                     * @param {Array<IAmMapsUtilsInsertCountriesConfig>} countries
                     * @param {string} errMsg
                     * @private
                     */
                    AmMapsUtils.prototype._validateCountries = function (countries, errMsg) {
                        var _this = this;
                        this.assert.isArray(countries, 'countries', errMsg);
                        _.each(countries, function (country, index) {
                            _this.assert.isString(country.alpha2, "countries: index: " + index + ", country.alpha2", errMsg);
                            _this.assert.isString(country.name, "countries: index: " + index + ", country.name", errMsg);
                            _this.assert(_.isNumber(country.value), errMsg + ("countries: index: " + index + ", country.value: Must be a number."), TypeError);
                        });
                    };
                    AmMapsUtils.prototype._validateInsertConfig = function (config, errMsg, mapIsOptional) {
                        // validate config
                        this.assert.isObject(config, 'config', errMsg);
                        // validate map
                        this.assert.isObject(config.map, 'map', errMsg, mapIsOptional);
                        if (config.map) {
                            this.assert(config.map.dataProvider, errMsg + 'config.map object is not a valid map object.');
                        }
                        // validate minBubbleSize
                        if (!_.isUndefined(config.minBubbleSize)) {
                            this.assert(_.isNumber(config.minBubbleSize), errMsg + "config.minBubbleSize must be a number.", TypeError);
                            this.assert(config.minBubbleSize > 0, errMsg + "config.minBubbleSize must be greater than zero.", TypeError);
                        }
                        // validate maxBubbleSize
                        if (!_.isUndefined(config.maxBubbleSize)) {
                            this.assert(_.isNumber(config.maxBubbleSize), errMsg + "config.maxBubbleSize must be a number.", TypeError);
                            this.assert(config.maxBubbleSize > 0, errMsg + "config.maxBubbleSize must be greater than zero.", TypeError);
                        }
                        // validate maxBubbleSize relation to minBubbleSize
                        if (!_.isUndefined(config.minBubbleSize) && !_.isUndefined(config.maxBubbleSize)) {
                            this.assert(config.maxBubbleSize >= 0, config.minBubbleSize + "config.maxBubbleSize must be greater or equal to config.minBubbleSize.", TypeError);
                        }
                        // validate maxBubbleSize when no minBubbleSize
                        if (_.isUndefined(config.minBubbleSize) && !_.isUndefined(config.maxBubbleSize)) {
                            this.assert(config.maxBubbleSize >= amMapsUtilsInsertConfigDefault.minBubbleSize, errMsg +
                                "config.maxBubbleSize must be greater or equal to config.minBubbleSize default which is " +
                                amMapsUtilsInsertConfigDefault.minBubbleSize, RangeError);
                        }
                        // validate minBubbleSize when no maxBubbleSize
                        if (!_.isUndefined(config.minBubbleSize) && _.isUndefined(config.maxBubbleSize)) {
                            this.assert(config.minBubbleSize <= amMapsUtilsInsertConfigDefault.maxBubbleSize, errMsg +
                                "config.maxBubbleSize must be greater or equal to config.minBubbleSize default which is " +
                                amMapsUtilsInsertConfigDefault.minBubbleSize, RangeError);
                        }
                    };
                    /**
                     * Returns a merged new object with the defaults and user config
                     *
                     * @param {IAmMapsUtilsInsertConfig} config
                     * @returns {IAmMapsUtilsInsertConfig}
                     * @private
                     */
                    AmMapsUtils.prototype._getInsertConfig = function (config) {
                        return _.merge({}, amMapsUtilsInsertConfigDefault, config);
                    };
                    AmMapsUtils.prototype.getBubbleDef = function (country, maxSquare, minSquare, maxValue, minValue) {
                        var value = country.value;
                        // calculate size of a bubble
                        var square = ((value - minValue) || 0.001) / ((maxValue - minValue) || 0.001) * (maxSquare - minSquare) +
                            minSquare;
                        if (square < minSquare) {
                            square = minSquare;
                        }
                        var size = Math.sqrt(square / (Math.PI * 2));
                        var def = {
                            title: country.name,
                            value: country.value,
                            color: country.color || '#FF0000',
                            longitude: this.amMapsCountryLatLong[country.alpha2].longitude,
                            latitude: this.amMapsCountryLatLong[country.alpha2].latitude,
                        };
                        if (country.anomaly) {
                            def.imageURL = 'assets/images/location_anomaly.png';
                            def.width = 24;
                            def.height = 24;
                        }
                        else {
                            def.type = 'circle';
                            def.width = size;
                            def.height = size;
                        }
                        return def;
                    };
                    AmMapsUtils.prototype._getBubblesDef = function (config) {
                        var _this = this;
                        if (config.countries.length === 0) {
                            return [];
                        }
                        // get config options
                        config = this._getInsertConfig(config);
                        var images = (config.map && config.map.dataProvider.images) || [];
                        // it's better to use circle square to show difference between values, not a radius
                        var maxSquare = config.maxBubbleSize * config.maxBubbleSize * 2 * Math.PI;
                        var minSquare = config.minBubbleSize * config.minBubbleSize * 2 * Math.PI;
                        var maxValue = _.maxBy(config.countries, 'value').value;
                        var minValue = _.minBy(config.countries, 'value').value;
                        _.each(config.countries, function (country) {
                            images.push(_this.getBubbleDef(country, maxSquare, minSquare, maxValue, minValue));
                        });
                        return images;
                    };
                    /**
                     * Returns a LatLong object for a specific alpha2 country code. Returns null if no country code is found
                     *
                     * @param {string} Alpha2
                     * @returns {{latitude: number, longitude: number}|null}
                     */
                    AmMapsUtils.prototype.getLatLongByAlpha2Code = function (Alpha2) {
                        return this.amMapsCountryLatLong[Alpha2] || null;
                    };
                    AmMapsUtils.prototype.getBubbles = function (config) {
                        // validate config
                        var errMsg = this._ERR_MSG + 'getBubbles: ';
                        this._validateInsertConfig(config, errMsg, true);
                        this._validateCountries(config.countries, errMsg + 'config: ');
                        return this._getBubblesDef(config);
                    };
                    /**
                     * Inserts bubbles into a map.
                     *
                     * @param {IAmMapsUtilsInsertConfig} config
                     */
                    AmMapsUtils.prototype.insertBubbles = function (config) {
                        // validate config
                        var errMsg = this._ERR_MSG + 'insertBubbles: ';
                        this._validateInsertConfig(config, errMsg, false);
                        this._validateCountries(config.countries, errMsg + 'config: ');
                        config.map.dataProvider.images = this._getBubblesDef(config);
                    };
                    AmMapsUtils.prototype._getCountriesLatLong = function (config) {
                        var _this = this;
                        return _.map(
                        // filter countries to only include countries that exist in amMapsCountryLatLong
                        _.filter(config.countries, function (country) { return _this.amMapsCountryLatLong[country.alpha2]; }), 
                        // return
                        function (country) {
                            return {
                                longitude: _this.amMapsCountryLatLong[country.alpha2].longitude,
                                latitude: _this.amMapsCountryLatLong[country.alpha2].latitude
                            };
                        });
                    };
                    AmMapsUtils.prototype.getLines = function (config) {
                        // validate config
                        var errMsg = this._ERR_MSG + 'getBubbles: ';
                        this._validateInsertConfig(config, errMsg, true);
                        var lines = this._getCountriesLatLong(config);
                        this._getCountriesLatLong(config);
                        return [
                            {
                                id: "plane-line",
                                arc: -0.85,
                                alpha: 0.3,
                                latitudes: _.map(lines, 'latitude'),
                                longitudes: _.map(lines, 'longitude')
                            },
                            {
                                id: "plane-shadow",
                                arc: 0,
                                alpha: 0,
                                latitudes: _.map(lines, 'latitude'),
                                longitudes: _.map(lines, 'longitude')
                            }
                        ];
                    };
                    AmMapsUtils.prototype.getAlertImage = function () {
                        return {
                            svgPath: "m2,106h28l24,30h72l-44,-133h35l80,132h98c21,0 21,34 0,34l-98,0 -80,134h-35l43,-133h-71l-24,30h-28l15,-47",
                            color: "#AA0000",
                            scale: 0.03,
                            positionScale: 1.8
                        };
                    };
                    AmMapsUtils.prototype.getPlaneImage = function () {
                        return [
                            {
                                svgPath: "m2,106h28l24,30h72l-44,-133h35l80,132h98c21,0 21,34 0,34l-98,0 -80,134h-35l43,-133h-71l-24,30h-28l15,-47",
                                positionOnLine: 0,
                                color: "#AA0000",
                                animateAlongLine: true,
                                lineId: "plane-line",
                                flipDirection: true,
                                loop: true,
                                scale: 0.03,
                                positionScale: 1.8
                            },
                            {
                                svgPath: "m2,106h28l24,30h72l-44,-133h35l80,132h98c21,0 21,34 0,34l-98,0 -80,134h-35l43,-133h-71l-24,30h-28l15,-47",
                                positionOnLine: 0,
                                color: "#000000",
                                alpha: 0.1,
                                animateAlongLine: true,
                                lineId: "plane-shadow",
                                flipDirection: true,
                                loop: true,
                                scale: 0.03,
                                positionScale: 1.3
                            }
                        ];
                    };
                    AmMapsUtils.$inject = ['assert', 'amMapsCountryLatLong'];
                    return AmMapsUtils;
                }());
                angular.module('Fortscale.shared.services')
                    .service('amMapsUtils', AmMapsUtils);
            })(amMaps = services.amMaps || (services.amMaps = {}));
        })(services = shared.services || (shared.services = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    angular.module('Fortscale.shared.filters', []);
}());

(function () {
    'use strict';
    var _errMsg = 'Fortscale.shared.filters: pageToOffset: ';
    function pageToOffset(assert) {
        /**
         * Filter
         * takes a pageNum and pageAmount and converts it to offset
         *
         * @param {string | number} pageNumStr
         * @param {string | number} pageSizeStr
         * @returns {number | undefined}
         */
        function pageToOffsetFilter(pageNumStr, pageSizeStr) {
            // Return undefined if no pageNum is received
            if (!angular.isDefined(pageNumStr)) {
                return undefined;
            }
            // Convert values to integers if they are not integers
            var pageNum = parseInt(pageNumStr);
            var pageSize = parseInt(pageSizeStr);
            // Validate values
            assert(!_.isNaN(pageNum) && angular.isNumber(NaN), _errMsg +
                'pageNumStr argument must be a number.', TypeError);
            assert(angular.isDefined(pageSizeStr), _errMsg +
                'pageSize argument must be provided.', ReferenceError);
            assert(!_.isNaN(pageSize) && angular.isNumber(pageSize), _errMsg +
                'pageSize argument must be a number.', TypeError);
            assert(pageSize !== 0, _errMsg +
                'pageSize argument must not be equal to 0.', RangeError);
            // return the offset
            return (pageNum - 1) * pageSize;
        }
        return pageToOffsetFilter;
    }
    pageToOffset.$inject = ['assert'];
    angular.module('Fortscale.shared.filters')
        .filter('pageToOffset', pageToOffset);
}());

(function () {
    'use strict';
    function unixToTimeStamp() {
        /**
         * Takes a unix time stamp and convert it to timestamp in milliseconds
         *
         * @param {string|undefined} val
         * @returns {string|undefined}
         */
        function unixToTimeStampFilter(val) {
            // If val is falsy return it.
            if (!val) {
                return val;
            }
            var values = val.split(',');
            var timeStamps = _.map(values, function (timeStr) {
                var trimmedTimeStr = timeStr.trim();
                // If its a string and the length of unix, add '000' and return
                if (/^(\d{10})$/.test(trimmedTimeStr)) {
                    return trimmedTimeStr + '000';
                }
                // If previous condition is false then return the value as is.
                throw new RangeError('unixToTimeStamp.filter: csv must be of 10 ' +
                    'chars long unix time stamps. "' + trimmedTimeStr + '" is not.');
            });
            // Return a CSV
            return timeStamps.join(',');
        }
        return unixToTimeStampFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('unixToTimeStamp', unixToTimeStamp);
}());

(function () {
    'use strict';
    function entityIdToName(dataEntities) {
        function entityIdToNameFilter(id) {
            var entityObject = dataEntities.getEntityById(id);
            return (entityObject && entityObject.name) || id;
        }
        return entityIdToNameFilter;
    }
    entityIdToName.$inject = ['dataEntities'];
    angular.module('Fortscale.shared.filters')
        .filter('entityIdToName', entityIdToName);
}());

(function () {
    'use strict';
    function durationToPrettyTime(utils) {
        function durationToPrettyTimeFilter(duration) {
            if (duration === undefined || duration === null) {
                return duration;
            }
            return utils.duration.prettyTime(duration * 1000);
        }
        return durationToPrettyTimeFilter;
    }
    durationToPrettyTime.$inject = ['utils'];
    angular.module('Fortscale.shared.filters')
        .filter('durationToPrettyTime', durationToPrettyTime);
}());

(function () {
    'use strict';
    function pascalCase() {
        function pascalCaseFilter(val) {
            if (val !== undefined && _.isString(val) && val !== '') {
                var str = val.toLowerCase();
                str = str.charAt(0).toUpperCase() + str.slice(1);
                return str;
            }
            return val;
        }
        return pascalCaseFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('pascalCase', pascalCase);
}());

(function () {
    'use strict';
    function ouDisplay() {
        function ouDisplayFilter(val) {
            var rgx = /=/;
            if (rgx.test(val)) {
                return val.split('=')[1];
            }
            return val;
        }
        return ouDisplayFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('ouDisplay', ouDisplay);
}());

/**
 * Based on this solution:
 * http://stackoverflow.com/questions/15900485/correct-way-to-convert-size-in-bytes-to-kb-mb-gb-in-javascript
 *
 * Converts Bytes to pretty bytes.
 */
(function () {
    'use strict';
    function prettyBytes() {
        return function (bytes, precision) {
            if (bytes === null || bytes === undefined) {
                return bytes;
            }
            if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
                return '-';
            }
            bytes = parseFloat(bytes);
            if (bytes === 0) {
                return '0 Byte';
            }
            if (typeof precision !== 'number') {
                precision = 1;
            }
            var k = 1000; // or 1024 for binary
            var dm = precision + 1 || 3;
            var sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            var i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('prettyBytes', prettyBytes);
}());

(function () {
    'use strict';
    function prettyOU($sce) {
        /**
         * Converts a raw string to pretty ou string
         * @example this: "ou=admin" will be this: "Admin"
         *
         * @param {string} ouValue
         * @returns {string}
         */
        function valToPrettyOu(ouValue) {
            // If starts with OU=
            if (/^ou=/i.test(ouValue)) {
                // Remove first three chars and trim
                ouValue = ouValue.substr(3).trim();
                if (ouValue.length === 0) {
                    return '';
                }
                // If length is one
                if (ouValue.length === 1) {
                    return ouValue.toUpperCase();
                }
                // If length greater then one, uppercase first letter and return
                return ouValue.charAt(0).toUpperCase() + ouValue.substr(1);
            }
            return ouValue;
        }
        /**
         * Create an ou group element with href
         *
         * @param {string} ouValue
         * @returns {IAugmentedJQuery}
         */
        function createGroupElement(ouValue) {
            // Create the pretty ou value
            var prettyVal = valToPrettyOu(ouValue);
            // create an anchor element
            var el = angular.element("<a>" + prettyVal + "</a>");
            // add ng-href attribute
            el.attr('href', "#/d/explore/users?filters=users.ou=~" + prettyVal);
            // return the element
            return el;
        }
        /**
         * Create ou groups container element that holds all ou groups element.
         * @param {string} ouValues
         * @returns {IAugmentedJQuery}
         */
        function createGroupsElement(ouValues) {
            // Create a span element to contain the groups
            var containerEl = angular.element('<span class="ou-groups-container" style="display: flex; flex-flow: column nowrap;"></span>');
            // populate the element
            var ouGroups = _.map(ouValues, createGroupElement);
            _.each(ouGroups, function (ouGroup) {
                containerEl.append(ouGroup);
            });
            return containerEl;
        }
        /**
         * If received string starts with OU= then remove it and uppercase first letter
         *
         * @param {string} ouStr
         * @returns {IAugmentedJQuery|string}
         */
        function prettyOUFilter(ouStr) {
            // Return the value as is if its not a sting.
            if (!_.isString(ouStr)) {
                return ouStr;
            }
            //Split into csv
            var ouValues = ouStr.split(',');
            // If length is zero
            if (ouValues.length === 0) {
                return 'No Organizational unit';
            }
            var el = createGroupsElement(ouValues);
            return $sce.trustAsHtml(el);
        }
        return prettyOUFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('prettyOU', ['$sce', prettyOU]);
}());

(function () {
    'use strict';
    function stringToDate(assert) {
        function stringToDateFilter(stringDate, dateFormat) {
            assert.isString(stringDate, 'stringDate', 'stringToDate.filter: ');
            assert.isString(dateFormat, 'dateFormat', 'stringToDate.filter: ');
            return moment(stringDate).format(dateFormat);
        }
        return stringToDateFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('stringToDate', ['assert', stringToDate]);
}());

(function () {
    'use strict';
    function prettyMessage($filter, assert, appConfig) {
        var _CONFIG_LOCALE_KEY = 'system.locale.settings';
        /**
         * This filter will look for the key in the messages and return the message
         * If the message exists - return the value of the message
         * If the value is not exists - return valueIfNotExits.
         * If the value is not exists and valueIfNotExists is not defined - return the original key
         *
         * @param {*} value
         * @param {{}} valueIfNotExists - optional value
         * @returns {*}
         */
        function prettyMessageFilter(messageKey, valueIfNotExists) {
            assert.isString(messageKey, 'message key is not defined');
            var messagePrefix = 'messages.' + appConfig.getConfigItem(_CONFIG_LOCALE_KEY).value;
            var fullMessageKey = messagePrefix + "." + messageKey;
            var configItem = appConfig.getConfigItem(fullMessageKey);
            if (configItem !== undefined && configItem !== null) {
                return configItem.value;
            }
            else {
                if ((valueIfNotExists !== undefined) && (valueIfNotExists !== '')) {
                    return valueIfNotExists;
                }
                else {
                    return messageKey;
                }
            }
        }
        return prettyMessageFilter;
    }
    prettyMessage.$inject = ['$filter', 'assert', 'appConfig'];
    angular.module('Fortscale.shared.filters')
        .filter('prettyMessage', prettyMessage);
}());

(function () {
    'use strict';
    function prettyAlertName($filter, assert) {
        /**
         * This filter will look for the alert name in messages and return the message
         * If the message exists - return the value of the message
         * or the original key if not exists
         *
         * @param {{name: string, timeframe: string}} alert
         * @returns {string}
         */
        function prettyAlertNameFilter(alert) {
            if (!alert) {
                return '';
            }
            assert.isString(alert.name, 'alert.name', 'prettyAlertNameFilter: ');
            var fullKey = "alert." + alert.name + ".name";
            var prettyAlertName = $filter('prettyMessage')(fullKey, alert.name);
            if (alert && alert.timeframe) {
                prettyAlertName = "\n                    " + prettyAlertName + " | <span class=\"alert-timeframe-tag alert-timeframe-tag--" + alert.timeframe.toLowerCase() + "\">\n                        " + alert.timeframe + "\n                    </span>";
            }
            return prettyAlertName;
        }
        return prettyAlertNameFilter;
    }
    prettyAlertName.$inject = ['$filter', 'assert'];
    angular.module('Fortscale.shared.filters')
        .filter('prettyAlertName', prettyAlertName);
}());

(function () {
    'use strict';
    function round() {
        function roundFilter(value) {
            var parsedVal = parseInt(value, 10);
            if (isNaN(parsedVal)) {
                return value;
            }
            return Math.round(parsedVal);
        }
        return roundFilter;
    }
    round.$inject = [];
    angular.module('Fortscale.shared.filters')
        .filter('round', round);
}());

(function () {
    'use strict';
    function encodeUrlComponent() {
        function encodeUrlComponentFilter(value) {
            if (!_.isString(value)) {
                return value;
            }
            return window.encodeURIComponent(value);
        }
        return encodeUrlComponentFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('encodeUrlComponent', encodeUrlComponent);
}());

(function () {
    'use strict';
    function trancateDecimal() {
        /**
         * This function get a string, if the string is number,
         * and the fraction part is equals to zero, return the number without the fraction part.
         * For any other scenario, return the string as it is.
         * @param valueAsString
         * @returns {*}
         */
        function trancateDecimalFilter(valueAsString) {
            //IF not a number - return the value as it is
            var trimmedValueAsString = valueAsString.trim();
            if (isNaN(trimmedValueAsString) ||
                !/[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/.test(valueAsString) || /^0x/.test(valueAsString)) {
                return valueAsString;
            }
            var numberAsInt = parseInt(trimmedValueAsString);
            var numberAsFloat = parseFloat(trimmedValueAsString);
            if (numberAsInt - numberAsFloat === 0) {
                return numberAsInt;
            }
            else {
                return numberAsFloat;
            }
        }
        return trancateDecimalFilter;
    }
    trancateDecimal.$inject = [];
    angular.module('Fortscale.shared.filters')
        .filter('trancateDecimal', trancateDecimal);
}());

(function () {
    'use strict';
    function orNA() {
        function orNAFilter(val) {
            if (val === null || val === undefined || val === "") {
                return "N/A";
            }
            return val;
        }
        return orNAFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('orNA', orNA);
}());

(function () {
    'use strict';
    /**
     * Returns a filter
     *
     * @returns {function(any): number}
     */
    function orZero() {
        /**
         * if val is "falsy" return 0
         *
         * @param {any} number
         * @returns number
         */
        return function (val) {
            if (!val) {
                return 0;
            }
            return val;
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('orZero', [orZero]);
}());

(function () {
    'use strict';
    var errMsg = 'anomalyTypeFormatter.filter: ';
    function anomalyTypeFormatter($filter, assert, fsIndicatorErrorCodes) {
        function pipeNumberFormatterFilter(value) {
            return $filter('trancateDecimal')(value);
        }
        function pipeShortDateFilter(value) {
            return $filter('date')(new Date(value), 'yyyy-MM-dd HH:mm');
        }
        function pipeDataUsageAnomalyFilter(value) {
            return value + '/s';
        }
        function pipeFailureCodeAnomalyFilter(errorCode, indicator) {
            var dataEntityId = indicator.dataEntitiesIds[0];
            return fsIndicatorErrorCodes.getDisplayMessage(dataEntityId, errorCode);
        }
        function pipeFormatByIndicator(value, indicator) {
            /**
             * The filter config list.
             * @type {Array<{name: string, queries: Array<{}>, filter: function}>}
             */
            var filterConfigList = [
                {
                    name: "Bytes",
                    queries: [
                        {
                            anomalyType: "Downloaded Bytes"
                        },
                        {
                            anomalyType: "Data Usage Anomaly"
                        },
                        {
                            anomalyType: "High Volume of Printed Data"
                        }
                    ],
                    filter: $filter('prettyBytes')
                },
                {
                    name: "Data Usage Anomaly",
                    queries: [
                        {
                            anomalyType: "Data Usage Anomaly"
                        }
                    ],
                    filter: pipeDataUsageAnomalyFilter
                },
                {
                    name: "Short Time",
                    queries: [
                        {
                            anomalyType: "Time"
                        },
                        {
                            anomalyType: "Activity Time Anomaly"
                        }
                    ],
                    filter: pipeShortDateFilter
                },
                {
                    name: "Failure Code",
                    queries: [
                        {
                            anomalyTypeFieldName: "failure_code"
                        }
                    ],
                    filter: pipeFailureCodeAnomalyFilter
                }
            ];
            /**
             * Checks if indicator.key equals the provided value
             *
             * @param {*} value
             * @param {string} key
             * @returns {boolean}
             */
            function matchQueryField(value, key) {
                return indicator[key] === value;
            }
            /**
             * Iterates through query field and return true if all query fields match
             *
             * @param {{}} query
             * @returns {boolean}
             */
            function matchQuery(query) {
                return _.every(query, matchQueryField);
            }
            /**
             * Returns true if any of the queries is a match
             *
             * @param {Array<{}>} queries
             * @returns {boolean}
             */
            function isAnyFilterQueryMatch(queries) {
                return _.some(queries, matchQuery);
            }
            /**
             * If any of the queries in the filter config object match the indicator, pipe the value through filter
             *
             * @param {{name: string, queries: Array<{}>, filter: function}} filterConfigObj
             * @param {*} value
             * @returns {*}
             */
            function tentativelyPipeFilter(filterConfigObj, value) {
                if (isAnyFilterQueryMatch(filterConfigObj.queries)) {
                    return filterConfigObj.filter(value, indicator);
                }
                return value;
            }
            // Iterate through queryConfigList and pipe the value through any filter that has a query match
            _.each(filterConfigList, function (filterConfigObj) {
                value = tentativelyPipeFilter(filterConfigObj, value);
            });
            return value;
        }
        /**
         * This filter will find if any filter query matches the indicator. If it does, the value will be piped via the
         * filter.
         *
         * @param {*} value
         * @param {{}} indicator
         * @returns {*}
         */
        function anomalyTypeFormatterFilter(value, indicator) {
            // Make sure indicator is provided
            assert.isObject(indicator, 'indicator', errMsg);
            // Convert numbers to integer (default formatter)
            value = pipeNumberFormatterFilter(value);
            // Match filter queries and pipe the filters
            value = pipeFormatByIndicator(value, indicator);
            // Return the formatted value
            return value;
        }
        return anomalyTypeFormatterFilter;
    }
    anomalyTypeFormatter.$inject = ['$filter', 'assert', 'fsIndicatorErrorCodes'];
    angular.module('Fortscale.shared.filters')
        .filter('anomalyTypeFormatter', anomalyTypeFormatter);
}());

/**
 * Based on https://github.com/jdpedrie/angularjs-ordinal-filter
 * This filter converts val into an ordinal value.
 * Example: 1 => st
 * Example: 2 => nd
 */
(function () {
    'use strict';
    function fsOrdinal() {
        /**
         *
         * @param {string} val
         * @returns {string}
         */
        function fsOrdinalFilter(val) {
            val = parseInt(val, 10);
            return Math.floor(val / 10) === 1 ? 'th' :
                (val % 10 === 1 ? 'st' :
                    (val % 10 === 2 ? 'nd' :
                        (val % 10 === 3 ? 'rd' : 'th')));
        }
        return fsOrdinalFilter;
    }
    angular.module('Fortscale.shared.filters')
        .filter('fsOrdinal', fsOrdinal);
}());

/**
 * Converts integer value to a humanized moment duration.
 * Example: 60, "days" => 2 months
 * example: 7, "days" => 1 week
 */
(function () {
    'use strict';
    var allowedUnits = ['seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'];
    function fsPrettyDuration(assert) {
        function fsPrettyDurationFilter(val, sourceUnits) {
            // Validations
            assert.isString(sourceUnits, 'sourceUnits', 'fsPrettyDuration.filter: ', false, false);
            assert(allowedUnits.indexOf(sourceUnits.trim()) !== -1, "fsPrettyDuration.filter: sourceUnits argument must be on of the following: " + allowedUnits.join(', '), RangeError);
            val = parseInt(val, 10);
            assert(!isNaN(val), "fsPrettyDuration.filter: value could not be parsed to int.", TypeError);
            // Convert val to string
            var s = moment.duration(val, sourceUnits).humanize();
            // Remove "a ", for example "a month" will become "month"
            s = s.replace('a ', '');
            return s;
        }
        return fsPrettyDurationFilter;
    }
    fsPrettyDuration.$inject = [
        'assert'
    ];
    angular.module('Fortscale.shared.filters')
        .filter('fsPrettyDuration', fsPrettyDuration);
}());

(function () {
    'use strict';
    /**
     * Returns a filter
     *
     * @returns {function(any): number}
     */
    function fsDTHumanize() {
        return function (val, timeUnit) {
            if (!timeUnit) {
                return val;
            }
            var durationInt = parseInt(val, 10);
            var duration = moment.duration(durationInt, timeUnit);
            var humanized = duration.humanize();
            if (humanized.indexOf('a ') === 0) {
                return "Last " + humanized.substr(2);
            }
            return "Last " + humanized;
        };
    }
    function fsDTDiffHumanize() {
        return function (val) {
            var time = parseInt(val, 10);
            var diff = moment().diff(time);
            var duration = moment.duration(diff, 'milliseconds');
            return duration.humanize();
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('fsDTHumanize', [fsDTHumanize])
        .filter('fsDTDiffHumanize', [fsDTDiffHumanize]);
}());

/**
 * Filter that returns only items without matching items in the provided list.
 */
(function () {
    'use strict';
    function notIn(assert) {
        /**
         *
         * @param {Array<*>} val
         * @param {{compareKey: string, list: Array<*>}} mapObj
         * @returns {Array<*>}
         */
        function argIsObject(val, mapObj) {
            if (!mapObj || !mapObj.list) {
                return val;
            }
            // Validations
            assert.isString(mapObj.compareKey, 'mapObj.compareKey', 'fsNotIn.filter: ');
            assert.isArray(mapObj.list, 'mapObj.list', 'fsNotIn.filter: ');
            // Returns only items that have no matching item in mapObj.list
            return _.filter(val, function (item) {
                return _.every(mapObj.list, function (listItem) {
                    return listItem[mapObj.compareKey] !== item[mapObj.compareKey];
                });
            });
        }
        return function (val, arg2) {
            if (!val) {
                return val;
            }
            // Validations
            if (!_.isArray(val)) {
                console.warn('fsNotIn.filter: Trying to filter a non Array argument', val);
                return val;
            }
            // Check overloading and invoke right method
            if (_.isArray(arg2)) {
            }
            else if (_.isObject(arg2)) {
                return argIsObject(val, arg2);
            }
            else {
                console.error('fsNotIn.filter: Second argument must be an array or an object.');
                return val;
            }
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('fsNotIn', ['assert', notIn]);
}());

(function () {
    'use strict';
    /**
     * Returns a filter
     *
     * @returns {function(any): number}
     */
    function fsPartialStrong($sce) {
        /**
         * This filter get text, and part of substring of this text,
         * it returns html which emphasis the the sub text (if such given).
         * Pay attention that angular process html only if you use it has ng-html-bind and not {{}}
         *
         *  prefixOnly - IF TRUE - mark only textToMakeStronger which is in the begining of the text
         *  condition-optional. If false, return the original value
         *
         */
        return function (val, textToMakeStronger, prefixOnly, allowBoldCondition) {
            if (allowBoldCondition === false) {
                return val;
            }
            //If no val or no textToMakeStronger return the value.
            if (!textToMakeStronger || !val) {
                return val;
            }
            var fullTextLower = val.toLowerCase();
            var strongTextLower = textToMakeStronger.toLowerCase();
            var startIndex = -1;
            if (prefixOnly) {
                startIndex = fullTextLower.startsWith(strongTextLower) ? 0 : -1;
            }
            else {
                //Extract the start and end indexes of the part which should be emphasis
                startIndex = fullTextLower.indexOf(strongTextLower);
            }
            if (startIndex === -1) {
                return val;
            }
            var endIndex = startIndex + strongTextLower.length;
            //Rebuild the string with the strong part
            var beforeStrongPart = val.substr(0, startIndex);
            var strongPart = val.substr(startIndex, strongTextLower.length);
            var afterStrongPart = val.substring(endIndex);
            var newHTMLUntrusted = beforeStrongPart + "<span style='color: #024d89;font-weight: 700;'>" + strongPart + "</span>" + afterStrongPart;
            return $sce.trustAsHtml(newHTMLUntrusted);
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('fsPartialStrong', ['$sce', fsPartialStrong]);
}());

(function () {
    'use strict';
    /**
     * Returns a filter
     *
     * @returns {function(any): number}
     */
    function fsRemoveIsExists() {
        /**
         * This filter get text, and part of substring of this text,
         * it returns the text without the prefix

         *
         *  prefixOnly - IF TRUE - mark only textToRemove which is in the beginning of the text
         *  condition-optional. If false, return the original value
         *
         */
        return function (val, textToRemove, prefixOnly) {
            //If no val or no textToMakeStronger return the value.
            if (!textToRemove || !val) {
                return val;
            }
            var fullTextLower = val.toLowerCase();
            var strongTextLower = textToRemove.toLowerCase();
            var startIndex = -1;
            if (prefixOnly) {
                startIndex = fullTextLower.startsWith(strongTextLower) ? 0 : -1;
            }
            else {
                //Extract the start and end indexes of the part which should be emphasis
                startIndex = fullTextLower.indexOf(strongTextLower);
            }
            if (startIndex === -1) {
                return val;
            }
            var endIndex = startIndex + strongTextLower.length;
            //Rebuild the string without the removed part
            var beforeRemovePart = val.substr(0, startIndex);
            var afterRemovePart = val.substring(endIndex);
            var newText = beforeRemovePart + afterRemovePart;
            return newText;
        };
    }
    angular.module('Fortscale.shared.filters')
        .filter('fsRemoveIsExists', fsRemoveIsExists);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.directives', [
        'Fortscale.shared.directives.fsStateContainer',
        'Fortscale.shared.components.fsResourceStore',
        'Fortscale.shared.directives.fsHrefAlert',
        'Fortscale.shared.directives.fsUserTagDetails'
    ]);
}());

(function () {
    'use strict';
    /**
     * Holds a default state adapter. Used when fetching data. Causes any _NONE_ or _ALL_ values
     * to be null
     *
     * @type {Array}
     */
    var DEFAULT_STATE_ADAPTER = [
        {
            queryValue: '_NONE_',
            changeTo: null
        },
        {
            queryValue: '_ALL_',
            changeTo: null
        }
    ];
    /**
     * StateContainerController constructor
     *
     * @param {angular.$scope} $scope
     * @param {angular.$element} $element
     * @param {object} dependencyMounter
     * @constructor
     */
    function StateContainerController($scope, $element, dependencyMounter) {
        var ctrl = this;
        ctrl._isStateInitialized = false;
        ctrl._init($scope, $element, dependencyMounter);
        /**
         * Used as a delegate for anything that wants to notify pre-state to state change.
         * It's an instance property so it would be possible to preserve binding to the instance.
         *
         */
        ctrl.applyPreState = function () {
            return ctrl._applyPreState();
        };
        /**
         * Used as a delegate for anything that wants to update a specific control state
         * It's an instance property so it would be possible to preserve binding to the instance.
         *
         * @param {{id: string, type: string, value: *, immediate: boolean=}} ctrlState
         */
        ctrl.updateCtrlState = function (ctrlState) {
            return ctrl._updateCtrlState(ctrlState);
        };
        /**
         * Used as a delegate for anything that needs to get its own state from stateModel
         * Returns the value of a specific property on the state object.
         * It's an instance property so it would be possible to preserve binding to the instance.
         *
         * @param {string} controlId
         * @returns {*}
         */
        ctrl.fetchStateById = function (controlId) {
            return ctrl._fetchStateById(controlId);
        };
        /**
         * Start data fetching service, and places the result on the control instance as dataModel
         * Used as a delegate by anything that needs to refresh the data.
         * It's an instance property so it would be possible to preserve binding to the instance.
         *
         * @returns {HttpPromise}
         */
        ctrl.refreshData = function () {
            return ctrl._fetchData();
        };
    }
    // Controller prototype
    angular.extend(StateContainerController.prototype, {
        /**
         * PRIVATE METHODS
         */
        /**
         * Initiates state object by duplicating provided stateModel
         * and placing it on instance as stateModel
         *
         * @private
         */
        _initState: function () {
            this.stateModel = null;
        },
        /**
         * Initiates the child state controllers reference list on instance
         * as _childStateContainerCtrls
         *
         * @private
         */
        _initChildStateRefList: function () {
            this._childStateContainerCtrls = [];
        },
        /**
         * Initiates the parent state controllers reference on instance
         * as _parentStateContainerCtrl
         *
         * @private
         */
        _initParenStateRef: function () {
            this._parentStateContainerCtrl = null;
        },
        /**
         * Inits a resource, using resourceFactory
         *
         * @private
         */
        _initResource: function () {
            if (this._resourceSettings) {
                // Validate resource settings if not string
                if (!_.isString(this._resourceSettings)) {
                    this._validateResourceSettings('_initResource', this._resourceSettings);
                }
                // interpolate the settings
                var interpolated = this.interpolation.interpolate(this._resourceSettings, this.stateModel);
                // create the resource and store it as _resource
                this._resource = this.resourceFactory.create(interpolated.entity);
            }
        },
        /**
         * Registers a (potentially) parent StateContainerController controller
         * by placing it on instance as _parentStateContainerCtrl
         *
         * @param  {StateContainerController} stateContainerCtrl
         * @private
         */
        _registerParentController: function (stateContainerCtrl) {
            var errMsgStart = 'StateContainerController: _registerParentController: ';
            // Validate stateContainerCtrl is an instance of StateContainerController
            if (!(stateContainerCtrl instanceof StateContainerController)) {
                throw new TypeError(errMsgStart +
                    'stateContainerCtrl argument must be an instance of StateContainerController.');
            }
            this._parentStateContainerCtrl = stateContainerCtrl;
        },
        /**
         * Iterates through _childStateContainerCtrls,
         * and for each child-control invokes updateState(this.stateModel, doNotOverride)
         *
         * @param {boolean=} doNotOverride If true, the new state will not override existing values.
         * @param {boolean=} doNotFetchData If true, _fetchData will not be invoked.
         * @param {boolean=} doGetFromUrl If true, merge with state from url
         * @param {object=} alterState An object that should be used instead of the instance's
         * stateModel
         * @private
         */
        _updateChildStates: function (doNotOverride, doNotFetchData, doGetFromUrl, alterState) {
            var ctrl = this;
            angular.forEach(this._childStateContainerCtrls, function (childCtrl) {
                // This is used to determine which state to pass
                var targetState = alterState || ctrl.stateModel;
                // if true will tell updateState to permeate only the received state,
                // and not the entire state
                var doPermeateGottenState = angular.isDefined(alterState);
                childCtrl.updateState(targetState, doNotOverride, doNotFetchData, doGetFromUrl, doPermeateGottenState);
            });
        },
        /**
         * Iterates through _childStateContainerCtrls,
         * and for each ctrl it invokes its updateCtrlsState.
         *
         * @param {{id: string, type: string, value: *, immediate: boolean=}} ctrlState
         * @private
         */
        _ctrlUpdateChildStates: function (ctrlState) {
            angular.forEach(this._childStateContainerCtrls, function (ctrl) {
                ctrl._updateCtrlState(ctrlState, true);
            });
        },
        /**
         * Checks if the instance has a parent controller
         *
         * @returns {boolean} true if instance has no parent controller
         * @private
         */
        _isRootState: function () {
            return !this._parentStateContainerCtrl;
        },
        /**
         * For each data fetching type, fetch data and return an http promise
         *
         * @returns {Promise}
         * @private
         */
        _initDataFetchingService: function () {
            // Validate
            this.assert(angular.isDefined(this._resourceSettings), this._validateStartMessage +
                ' _initDataFetchingService: _resourceSettings must be defined.', ReferenceError);
            // interpolate the settings
            var interpolated = this.interpolation.interpolate(this._resourceSettings, this.stateModel, this._stateAdapter);
            this.objectUtils.removeNulls(interpolated.params, '');
            // If it has an id then we need to get a single resource
            if (interpolated.id) {
                return this._resource.get(interpolated.id, interpolated.params);
            }
            else {
                return this._resource.getList(interpolated.params);
            }
        },
        /**
         * Checks if the state container needs to get data.
         * It checks if it has any _queryTemplate
         *
         * @returns {boolean}
         * @private
         */
        _isDataRequired: function () {
            return !!this._resource;
        },
        /**
         * Start data fetching service, and places the result on the control instance as dataModel
         *
         * @private
         */
        _fetchData: function () {
            var ctrl = this;
            ctrl.errorModel = null;
            ctrl.isLoading = true;
            var promise = ctrl._initDataFetchingService()
                .then(function (data) {
                if (ctrl._resourceAdapter) {
                    return ctrl._resourceAdapter(data);
                }
                return data;
            })
                .then(function (data) {
                ctrl.isLoading = false;
                ctrl.dataModel = data;
            })
                .catch(function (res) {
                ctrl.isLoading = false;
                ctrl.dataModel = null;
                ctrl.errorModel = res || {
                    message: 'Connection error'
                };
                ctrl.$log.error(ctrl.errorModel);
            });
            // Give back promise to dataFetchDelegate
            ctrl.onDataFetch({ promise: promise });
            return promise;
        },
        /**
         * Should be invoked when the controller is root controller
         * and data permeation process needs to begin.
         * Updates all child states.
         *
         * @private
         */
        _startInitialStateUpdate: function () {
            // Get state from url if state has not yet initialized
            if (!this._isStateInitialized) {
                var urlState = this.urlStateManager.getStateByContainerId(this.containerId);
                var convertedUrlState;
                if (urlState) {
                    var urlStateKeys = Object.keys(urlState);
                    convertedUrlState = {};
                    urlStateKeys.forEach(function (urlStateKey) {
                        convertedUrlState[urlStateKey] = {
                            value: urlState[urlStateKey]
                        };
                    });
                }
                this.stateModel = angular.merge(this.stateModel, convertedUrlState);
            }
            // Update all children states
            this._updateChildStates(true, false, true);
            // Get data if required and _isStateInitialized is false
            // We use '_isStateInitialized is false' because there can be several calls to
            // _startInitialStateUpdate in the initial render of the page.
            // So !this._isStateInitialized will make sure no unwanted calls to the server are made
            if (this._isDataRequired() && !this._isStateInitialized) {
                this._fetchData();
            }
            // Set flag to let everyone in contact with this container know that it's state has
            // been initialized.
            this._isStateInitialized = true;
        },
        /**
         * Validation error message start
         * @type string
         * @private
         */
        _validateStartMessage: 'fs-state-container: ',
        /**
         * Validates ctrlState object. It verifies id, and type.
         *
         * @param {string} caller
         * @param {{id: string, type: string, value: *, immediate: boolean=}} ctrlState
         * @private
         */
        _validateCtrlState: function (caller, ctrlState) {
            var message = this._validateStartMessage + caller + ': ';
            // Validate ctrlState object
            this.assert(angular.isDefined(ctrlState), message + 'ctrlState argument must be provided.', ReferenceError);
            this.assert(angular.isObject(ctrlState), message + 'ctrlState argument must be an object.', TypeError);
            // Validate ctrlState.id
            this.assert(angular.isDefined(ctrlState.id), message +
                'ctrlState argument must have an "id" property.', ReferenceError);
            this.assert(angular.isString(ctrlState.id), message +
                'ctrlState.id must be a string.', TypeError);
            this.assert(ctrlState.id !== '', message +
                'ctrlState.id must not be an empty string.', RangeError);
            // Validate ctrlState.type
            this.assert(angular.isDefined(ctrlState.type), message +
                'ctrlState argument must have an "type" property.', ReferenceError);
            this.assert(angular.isString(ctrlState.type), message +
                'ctrlState.type must be a string.', TypeError);
            // Validate against known types which are listed on control-types.const.js
            var controlTypes = Object.keys(this.controlTypes);
            this.assert(controlTypes.indexOf(ctrlState.type.toUpperCase()) > -1, message + 'ctrlState.type must be a valid type: ' + controlTypes.join(', ') +
                ', and it is "' + ctrlState.type.toUpperCase() + '"', RangeError);
        },
        _validateResourceSettings: function (caller, resourceSettings) {
            var message = this._validateStartMessage + caller + ': ';
            // resource settings must have an entity string
            this.assert(angular.isDefined(resourceSettings.entity), message +
                'resourceSettings must have an "entity" property.', ReferenceError);
            this.assert(angular.isString(resourceSettings.entity), message +
                'resourceSettings.entity must be a string.', TypeError);
            this.assert(resourceSettings.entity !== '', message +
                'resourceSettings.entity must not be an empty string.', RangeError);
            // If resourceSettings.id is defined, it must be a non empty string
            if (angular.isDefined(resourceSettings.id)) {
                this.assert(angular.isString(resourceSettings.id), message +
                    'resourceSettings.id must be a string.', TypeError);
                this.assert(resourceSettings.id !== '', message +
                    'resourceSettings.id must not be an empty string.', RangeError);
            }
        },
        /**
         * Gets the specific state object for this ctrl (by id).
         * Iterates through the url state keys, and sets the values on the stateModel.
         *
         * @private
         */
        _mergeUrlState: function () {
            var ctrl = this;
            // Get this container's state from the url
            var urlState = ctrl.urlStateManager.getStateByContainerId(ctrl.containerId);
            // If this container has no state then early return
            if (!urlState) {
                return;
            }
            // Get the url state's keys
            var urlStateKeys = Object.keys(urlState);
            // Iterate through the keys
            urlStateKeys.forEach(function (urlStateKey) {
                // Set the object's value property to the value of urlState[urlStateKey]
                // Example: If ctrl.stateModel is {},
                // and urlState is {control: 'someValue'} then
                // ctrl.stateModel will hold {control1: {value: 'someValue'}}
                // For each key create an object if one does not exist
                ctrl.stateModel[urlStateKey] = ctrl.stateModel[urlStateKey] ?
                    ctrl.stateModel[urlStateKey] : {};
                // For each key set the value
                ctrl.stateModel[urlStateKey].value = urlState[urlStateKey];
            });
        },
        /**
         * Takes an object that is the target state, a state object, and a property name.
         * The method will set the targetState with the preValue value of the state's object
         * property. For example targetState = {}, state = {control1: {preValue: 'someValue'}},
         * stateProperty = 'control1'. After this function targetState will look like this:
         * targetState = {control1: {value: 'someValue'}}
         *
         * @param {object} targetState
         * @param {object} state
         * @param {string} stateProperty
         * @private
         */
        _populateActionStateObject: function (targetState, state, stateProperty) {
            // Create container object if one does not exist
            targetState[stateProperty] = targetState[stateProperty] ?
                targetState[stateProperty] : {};
            // Put preValue into stateObject that should be permeated
            targetState[stateProperty].value = state[stateProperty].preValue;
        },
        /**
         * Takes a name of a property (on stateModel) and deletes its property's preValue property.
         *
         * @param {string} stateProperty
         * @private
         */
        _deletePreValue: function (stateProperty) {
            delete this.stateModel[stateProperty].preValue;
        },
        /**
         * Takes a targetState object, iterates through it to create a hashMap and updates the url
         *
         * @param {object} targetState
         * @private
         */
        _applyTargetStateToUrl: function (targetState) {
            // Convert targetState format to urlState format
            var urlTargetState = {};
            var targetStateKeys = Object.keys(targetState);
            targetStateKeys.forEach(function (targetStateKey) {
                if (targetState[targetStateKey].value !== undefined) {
                    urlTargetState[targetStateKey] = targetState[targetStateKey].value;
                }
            });
            // Update url if urlTargetState has keys
            if (Object.keys(urlTargetState).length) {
                this.urlStateManager
                    .updateUrlStateParameters(this.containerId, urlTargetState);
            }
        },
        /**
         * Applies the pre-state.
         * Iterates through stateModel and applies the pre-value state to the state.
         *
         * @private
         */
        _applyPreState: function () {
            var ctrl = this;
            var actionState = {};
            var isActionStateUpdated = false;
            //iterate through stateModel
            var stateProperties = Object.keys(ctrl.stateModel);
            //forEach property, check if it has preValue defined
            stateProperties.forEach(function (stateProperty) {
                if (angular.isDefined(ctrl.stateModel[stateProperty].preValue)) {
                    // Set flag that state was updated for future reference
                    if (!isActionStateUpdated) {
                        isActionStateUpdated = true;
                    }
                    // Put preValue into stateObject that should be permeated
                    ctrl._populateActionStateObject(actionState, ctrl.stateModel, stateProperty);
                    // Delete preValue
                    ctrl._deletePreValue(stateProperty);
                }
            });
            // Only update state if any pre-state were digested
            if (isActionStateUpdated) {
                // update Url
                ctrl._applyTargetStateToUrl(actionState);
                // Update state
                ctrl.updateState(actionState, false, false, false, true);
            }
        },
        /**
         * Takes a ctrlState object, and updates the state based on the id of the control.
         * If update is flagged as immediate, state permeation will begin.
         * If update is flagged as not DATA (ctrlState.type), then permeation process will be
         * flagged with doNotFetchData, which would mean not data will be fetched.
         *
         *
         * @param {{id: string, type: string, value: *, immediate: boolean=}} ctrlState
         * @param {boolean=} invokedByParent If true no validation and url update will happen
         */
        _updateCtrlState: function (ctrlState, invokedByParent) {
            // Validate (if invokedByIterator is not true) ctrlState
            if (!invokedByParent) {
                this._validateCtrlState('updateCtrlState', ctrlState);
            }
            // Make sure control object exists
            if (!this.stateModel) {
                this.stateModel = {};
            }
            if (!angular.isDefined(this.stateModel[ctrlState.id])) {
                this.stateModel[ctrlState.id] = {};
            }
            // Create path to be updated.
            var path = ctrlState.id + (ctrlState.immediate ? '.value' : '.preValue');
            // Update the state
            this.updateStateByPath(path, ctrlState.value);
            // If update is flagged as immediate,
            // and this function was not invoked by updateCtrlsState.
            if (ctrlState.immediate) {
                // If not invoked by a parent controller then update the url
                if (!invokedByParent) {
                    this.urlStateManager
                        .updateUrlStateParameter(this.containerId, ctrlState.id, ctrlState.value);
                }
                // Update children
                this._ctrlUpdateChildStates(ctrlState);
                // If isDataRequired and is of type data, fetch data
                if (this._isDataRequired() &&
                    ctrlState.type.toUpperCase() === this.controlTypes.DATA) {
                    this._fetchData();
                }
            }
        },
        /**
         * Returns the value of a specific property on the state object.
         * The value returned is stateModel[controlId].value or null if
         * stateModel[controlId] is undefined.
         *
         * @param {string} controlId
         * @returns {*|null}
         */
        _fetchStateById: function (controlId) {
            if (this.stateModel && this.stateModel[controlId]) {
                if (this.stateModel[controlId].value !== undefined) {
                    return this.stateModel[controlId].value;
                }
            }
            return null;
        },
        /**
         * PUBLIC METHODS
         */
        /**
         * Updates the state model on the instance, and all its subsequent children
         * If it needs to get data (_isDataRequired), _fetchData is invoked.
         *
         * @param {object} state The state to be digested
         * @param {boolean=} doNotOverride If true, the new state will not override existing values.
         * @param {boolean=} doNotFetchData If true, _fetchData will not be invoked.
         * @param {boolean=} doGetFromUrl If true, merge with state from url
         * @param {boolean=} doPermeateGottenState If true, permeates only the recieved state and
         * not its entire instance's state. Used when permeating a cluster of pre-values.
         */
        updateState: function (state, doNotOverride, doNotFetchData, doGetFromUrl, doPermeateGottenState) {
            if (doNotOverride) {
                this.stateModel = angular.merge({}, state, this.stateModel);
            }
            else {
                this.stateModel = angular.merge({}, this.stateModel, state);
            }
            if (doGetFromUrl) {
                // Get state from url
                this._mergeUrlState();
            }
            this._initResource();
            // update children states
            if (doPermeateGottenState) {
                this._updateChildStates(doNotOverride, doNotFetchData, doGetFromUrl, state);
            }
            else {
                this._updateChildStates(doNotOverride, doNotFetchData, doGetFromUrl);
            }
            // Get data if required
            if (this._isDataRequired() && !doNotFetchData) {
                this._fetchData();
            }
            this._isStateInitialized = true;
        },
        /**
         * Returns a value from state model based on a received path
         *
         * @returns {object}
         */
        fetchStateByPath: function (path) {
            // $parse returns a link function.
            // The link function is invoked with stateModel as context.
            return this.$parse(path)(this.stateModel);
        },
        /**
         * Provides a precision tool for setting a value in a specific path in the state
         *
         * Please do not delete this function for now even if its not in use.
         * If you do, angles will loose their wings.
         * Puppies will die. Rivers will dry. Mothers will cry. Grandmas will sigh.
         * Delete after september 2015 (only if not in use)
         *
         * @param {string} path
         * @param {*} value
         */
        updateStateByPath: function (path, value) {
            // Puts temporarily the value to assign on __assignValue
            this.stateModel.__assignValue = value;
            // Create the assignment expression to be parsed
            var assignmentExpression = path + '=__assignValue';
            // $parse returns a link function.
            // The link function is invoked with stateModel as context.
            this.$scope.$eval(assignmentExpression, this.stateModel);
            // Remove temporary property
            delete this.stateModel.__assignValue;
        },
        /**
         * Registers a (potentially) child StateContainerController controller
         * by adding it to _childStateContainerCtrls
         *
         * @param {StateContainerController} childStateContainerCtrl
         */
        registerChildController: function (childStateContainerCtrl) {
            var errMsgStart = 'StateContainerController: _registerChildController: ';
            // Validate childStateContainerCtrl is an instance of StateContainerController
            if (!(childStateContainerCtrl instanceof StateContainerController)) {
                throw new TypeError(errMsgStart +
                    'stateContainerCtrl argument must be an instance of StateContainerController.');
            }
            // Verify it is not already on the array
            if (this._childStateContainerCtrls.indexOf(childStateContainerCtrl) > -1) {
                return;
            }
            // Add stateContainerCtrl to list
            this._childStateContainerCtrls.push(childStateContainerCtrl);
        },
        /**
         * Removes child state container controller from _childStateContainerCtrls if its there.
         * Returns true if successfully spliced, and false if not spliced.
         *
         * @param {StateContainerController} childStateContainerCtrl
         * @returns {boolean}
         */
        unregisterChildController: function (childStateContainerCtrl) {
            var pos = this._childStateContainerCtrls.indexOf(childStateContainerCtrl);
            if (pos === -1) {
                return false;
            }
            this._childStateContainerCtrls.splice(pos, 1);
            return true;
        },
        /**
         * Init function
         *
         * @private
         */
        _init: function _init($scope, $element, dependencyMounter) {
            this._initState();
            this._initChildStateRefList();
            this._initParenStateRef();
            this.$scope = $scope;
            this.$element = $element;
            // This will place on the prototype the following dependencies.
            // Dependencies can be accessed via the instance's 'this'
            dependencyMounter.mountOnConstructor(StateContainerController, [
                '$parse', 'assert', 'controlTypes', 'urlStateManager', '$log',
                'resourceFactory', 'interpolation', 'objectUtils'
            ]);
        }
    });
    function fsStateContainer(assert) {
        function linkFn(scope, element, attr, parentCtrl) {
            /**
             * VARIABLES
             */
            // Reference the controller
            var ctrl = scope.stateContainer;
            /**
             * METHODS
             */
            /**
             * Register parent and child controllers if parent controller exists.
             */
            function registerCtrls() {
                if (parentCtrl) {
                    ctrl._registerParentController(parentCtrl);
                    parentCtrl.registerChildController(ctrl);
                }
            }
            /**
             * Stores the value of queryTemplate attribute onto _queryTemplate
             */
            function initStateValues() {
                // We use this method to create a bind-value-once-one-way :)
                //ctrl.stateModel = scope.$eval(attr.stateModel);
                ctrl.stateModel = angular.merge({}, ctrl._stateModel);
            }
            /**
             * Stores the value of queryTemplate attribute onto _queryTemplate
             */
            function initQueryValues() {
                // We use this method to create a bind-value-once-one-way :)
                ctrl._queryTemplate = scope.$eval(attr.queryTemplate);
            }
            /**
             * Creates a local state adapter from DEFAULT_STATE_ADAPTER and a received state adapter
             */
            function initStateAdapter() {
                ctrl._stateAdapter = _.merge({}, DEFAULT_STATE_ADAPTER, ctrl.stateAdapter);
            }
            /**
             * WATCHERS
             */
            /**
             * Init watch on destroy
             */
            function initWatchDestroy() {
                // When invoked will remove the current controller from the parent
                function unregisterChildFromParent() {
                    if (parentCtrl) {
                        parentCtrl.unregisterChildController(ctrl);
                    }
                }
                // When invoked will cause a $destroy on the current scope
                function destroyScope() {
                    scope.$destroy();
                }
                scope.$on('$destroy', unregisterChildFromParent);
                // Make sure that if element is removed (with element.remove())
                // its scope will be destroyed
                element.on('$destroy', destroyScope);
            }
            /**
             * Inits all watchers
             */
            function initWatchers() {
                initWatchDestroy();
            }
            /**
             * INIT
             */
            function init() {
                assert(angular.isDefined(attr.containerId), 'fsStateContainer: linkFn: ' +
                    'directive must be provided with a containerId', ReferenceError);
                // Register the parent controller if one exists.
                registerCtrls();
                // Init values
                initStateValues();
                initQueryValues();
                initStateAdapter();
                // Init resource
                ctrl._initResource();
                // Init watchers
                initWatchers();
                // Start initial state update if state is root
                if (ctrl._isRootState()) {
                    ctrl._startInitialStateUpdate();
                }
                // If the parent has an _isStateInitialized flag set to true,
                // this means that state permeation has already occurred for the parent.
                // In this case, this ctrl must start its own initialization process.
                if (ctrl._parentStateContainerCtrl &&
                    ctrl._parentStateContainerCtrl._isStateInitialized) {
                    // Get the parent's state
                    ctrl.stateModel = angular.merge({}, ctrl._parentStateContainerCtrl.stateModel, ctrl.stateModel);
                    ctrl._startInitialStateUpdate();
                }
            }
            init();
        }
        StateContainerController.$inject = ['$scope', '$element', 'dependencyMounter'];
        return {
            restrict: 'E',
            scope: true,
            require: '?^^fsStateContainer',
            controller: StateContainerController,
            controllerAs: 'stateContainer',
            bindToController: {
                _stateModel: '=stateModel',
                _resourceSettings: '=resourceSettings',
                _resourceAdapter: '=resourceAdapter',
                stateAdapter: '=stateAdapter',
                containerId: '@containerId',
                onDataFetch: '&'
            },
            link: linkFn
        };
    }
    angular.module('Fortscale.shared.directives.fsStateContainer', [
        'Fortscale.shared.services.dependencyMounter',
        'Fortscale.shared.services.assert',
        'Fortscale.shared.fsStateContainer.controlTypes',
        'Fortscale.shared.fsStateContainer.urlStateManager',
        'Fortscale.shared.services.objectUtils',
        'Fortscale.shared.services',
        'restangular'
    ])
        .directive('fsStateContainer', ['assert', fsStateContainer]);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.fsStateContainer.controlTypes', [])
        .constant('controlTypes', {
        UI: 'UI',
        DATA: 'DATA'
    });
}());

(function () {
    'use strict';
    function UrlStateManager($location, objectUtils) {
        /**
         * The object returned by $location.search
         *
         * @type {object|null}
         * @private
         */
        this._locationSearchObject = null;
        /**
         * The object built for the app's use.
         * Where the _locationSearchObject might hold something like {'state1.value1': 'someValue'}
         * this object will hole {state1: {value1: 'someValue'}};
         *
         * @type {object|null}
         * @private
         */
        this._searchObject = null;
        /**
         * This method recursively builds _searchObject.
         * It will turn {'state1.value1': 'someValue'} into
         * {state1: {value1: 'someValue'}}
         *
         * @param {object} obj The object that will host the values
         * @param {string} path Dot delimited namespace
         * @param {*} value The value to be hosted
         * @returns {object}
         * @private
         */
        this._setValueByPath = function (obj, path, value) {
            function parseValue(value) {
                try {
                    return JSON.parse(value);
                }
                catch (e) {
                    return value;
                }
            }
            // Split path into path nodes
            var pathNodes = path.split('.');
            // If there is only one node, then the object will hold the node as
            // key, and set value to it. This ends the recursion.
            if (pathNodes.length === 1) {
                obj[pathNodes] = parseValue(value);
                return obj;
            }
            // Take the first node out of the array
            var currentPathNode = pathNodes.shift();
            // Set a new object to the path (or use existing object)
            // If for any reason the previous value is not an object,
            // The value will be overridden.
            obj[currentPathNode] = angular.isObject(obj[currentPathNode]) ?
                obj[currentPathNode] : {};
            // Rejoin the path into dot delimited string, and run the recursion with
            // The relevant object, the relevant path, and the value.
            this._setValueByPath(obj[currentPathNode], pathNodes.join('.'), value);
        };
        /**
         * Returns the interpreted search object
         *
         * @returns {Object|null}
         * @private
         */
        this._getSearchObject = function () {
            var self = this;
            // Get angular's search object
            var searchObject = $location.search();
            // Check if the angular's search object and the stored search object
            // are the same. If they are, this means that the interpreted search
            // object is valid and can be returned without reinterpreting the
            // search object
            if (angular.equals(self._locationSearchObject, searchObject)) {
                return self._searchObject;
            }
            // This branch happens if the stored locationSearchObject and angular's
            // Search object are not the same. This means that _searchObject is no
            // longer valid, and needs to be reinterpreted.
            // Create a new object for _searchObject
            self._searchObject = {};
            // Set the new searchObject to _locationSearchObject for future comparison
            self._locationSearchObject = searchObject;
            objectUtils.createFromFlattened(searchObject, self._searchObject);
            return self._searchObject;
        };
        /**
         * Takes a containerId and returns the state object of that container.
         *
         * @param {string} containerId The name (id) of the stateContainer.
         * @returns {*|null}
         */
        this.getStateByContainerId = function (containerId) {
            // Get the entire state
            var state = this._getSearchObject();
            // Return the relevant state object
            return angular.isDefined(state[containerId]) ? state[containerId] : null;
        };
        /**
         * Takes stateId (state container name) and a paramId (param name)
         * and sets the value to the search string in the url.
         * A new history will be added.
         *
         * @param {string} containerId The name of the state
         * @param {string} paramId The name of the paramater
         * @param {*} value Any value to be stored
         */
        this.updateUrlStateParameter = function (containerId, paramId, value) {
            // Create the key string
            var hashMap = {};
            hashMap[paramId] = value;
            var futureState = objectUtils.flattenToNamespace(hashMap, containerId);
            // Merge futureState into current state (so current state will not be lost)
            futureState = angular.merge({}, $location.search(), futureState);
            // Set the value to the search string
            $location.search(futureState);
        };
        /**
         * Takes stateId (state container name) and a hashMap object
         * and sets the values of the hashMap to the url search string.
         *
         * @param containerId The name of the state
         * @param {object} hashMap A key-value object, where the key is the paramId
         */
        this.updateUrlStateParameters = function (containerId, hashMap, rebuildStateCompletly) {
            // Create a new object for the future state
            var futureState = objectUtils.flattenToNamespace(hashMap, containerId);
            if (rebuildStateCompletly) {
                var locationWithoutState = _.pickBy($location.search(), function (value, key) {
                    return !_.startsWith(key, containerId);
                });
                futureState = angular.merge({}, locationWithoutState, futureState);
            }
            else {
                // Merge futureState into current state (so current state will not be lost)
                futureState = angular.merge({}, $location.search(), futureState);
            }
            // Set new search string
            $location.search(futureState);
        };
    }
    UrlStateManager.$inject = [
        '$location',
        'objectUtils'
    ];
    angular.module('Fortscale.shared.fsStateContainer.urlStateManager', [
        'Fortscale.shared.services.objectUtils'
    ])
        .service('urlStateManager', UrlStateManager);
}());

(function () {
    'use strict';
    function ResourceFactory(Restangular) {
        var self = this;
        self.create = function (entity) {
            // validate setting
            return Restangular.all(entity);
        };
    }
    ResourceFactory.$inject = ['Restangular'];
    angular.module('Fortscale.shared.directives.fsStateContainer')
        .service('resourceFactory', ResourceFactory);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components', [
        'Fortscale.shared.components.fsControls',
        'Fortscale.shared.components.fsTable',
        'Fortscale.shared.components.fsChart',
        'Fortscale.shared.components.fsSplitter',
        'Fortscale.shared.components.fsMultiselect',
        'Fortscale.shared.components.fsSeverityTag',
        'Fortscale.shared.components.fsMultiselectAutocomplete',
        'Fortscale.shared.components.alertFeedback',
        'Fortscale.shared.components.fsScoreIcon',
        'Fortscale.shared.components.fsFlag',
        'Fortscale.shared.components.fsSvgIcon',
        'Fortscale.shared.components.fsNanobar',
        // Controls
        'Fortscale.shared.components.fsDatePicker',
        'Fortscale.shared.components.fsDateRange',
        'Fortscale.shared.components.fsSimpleTabsStrip',
        'Fortscale.shared.components.fsDateRange',
        'Fortscale.shared.components.fsMinScore',
        'Fortscale.shared.components.fsSelect',
        'Fortscale.shared.components.fsAutocomplete',
        'Fortscale.shared.components.fsGenInput'
    ]);
}());

(function () {
    'use strict';
    function fsControlsDirective() {
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsControlsController() { }
        angular.extend(FsControlsController.prototype, {
            /**
             * PUBLIC METHODS
             */
            /**
             * On submit, it resets the form (to disable submit button until next change),
             * then invokes submitDelegate if it's defined
             */
            submit: function submit(formCtrl) {
                // Reset form
                formCtrl.$setPristine();
                // If submitDelegate was provided, and it is a function,
                // invoke it.
                if (angular.isFunction(this.submitDelegate)) {
                    this.submitDelegate();
                }
            }
        });
        return {
            restrict: 'E',
            templateUrl: 'app/shared/components/fs-controls/fs-controls.view.html',
            scope: true,
            transclude: true,
            controller: FsControlsController,
            controllerAs: 'controls',
            bindToController: {
                title: '@',
                className: '@',
                hideUpdate: '@',
                submitDelegate: '='
            }
        };
    }
    fsControlsDirective.$inject = [];
    angular.module('Fortscale.shared.components.fsControls', [])
        .directive('fsControls', fsControlsDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsTable', ['kendo.directives', 'Fortscale.shared.services.dateRanges', 'Utils']);
}());

(function () {
    'use strict';
    /**
     * Holds custom sorting
     */
    var customSort = {
        generic: function (fieldName) {
            return function (a, b, descending) {
                return ((descending !== undefined) ? -1 : 1) * (a[fieldName] - b[fieldName]);
            };
        }
    };
    customSort.number = customSort.generic;
    function fsTableDirective() {
        function linkFn(scope, element, attrs, ctrl) {
            // Binding to the table data
            scope.$watch(function () {
                return ctrl._watchTableModel();
            }, function () {
                return ctrl._watchTableModelAction();
            });
            ctrl._initPagingSettings();
            if (ctrl.fetchStateDelegate) {
                scope.$watch(function () {
                    return ctrl.fetchStateDelegate(ctrl.tableId);
                }, ctrl._fetchStateDelegateWatchAction.bind(ctrl));
            }
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsTableController($element, $scope, $compile) {
            this.init($element, $scope, $compile);
        }
        angular.extend(FsTableController.prototype, {
            /**
             * Validations
             */
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateFetchStateDelegate: function _validateFetchStateDelegate() {
                if (this.fetchStateDelegate && !angular.isFunction(this.fetchStateDelegate)) {
                    throw new TypeError('fsTable.directive: FsTableController: ' +
                        'If fetchStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Validate updateStateDelegate.
             * Throw TypeError if updateStateDelegate is received and is not a function
             * @private
             */
            _validateUpdateStateDelegate: function _validateUpdateStateDelegate() {
                if (this.updateStateDelegate && !angular.isFunction(this.updateStateDelegate)) {
                    throw new TypeError('fsTable.directive: FsTableController: ' +
                        'If updateStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Validate values of sort direction
             * @private
             */
            _validateSortDirection: function _validateSortDirection() {
                if (this.sortDirection &&
                    this.sortDirection !== 'DESC' &&
                    this.sortDirection !== 'ASC') {
                    throw new Error('fsTable.directive: FsTableController: ' +
                        'If updateStateDelegate is provided, it must be "DESC" or "ASC".');
                }
            },
            /**
             * Validate page size
             * @private
             */
            _validatePageSize: function _validatePageSize() {
                if (this.pageSize) {
                    if (!angular.isNumber(this.pageSize)) {
                        throw new TypeError('fsTable.directive: FsTableController: ' +
                            'If pageSize is provided, it must be a number.');
                    }
                    if (this.pageSize < 1) {
                        throw new RangeError('fsTable.directive: FsTableController: ' +
                            'If pageSize is provided, it must greater then 0.');
                    }
                }
            },
            /**
             * Validate the page number
             * @private
             */
            _validatePage: function _validatePage() {
                if (this.page) {
                    if (!angular.isNumber(this.page)) {
                        throw new TypeError('fsTable.directive: FsTableController: ' +
                            'If page is provided, it must be a number.');
                    }
                    if (this.page < 1) {
                        throw new RangeError('fsTable.directive: FsTableController: ' +
                            'If page is provided, it must greater then 0.');
                    }
                }
            },
            /**
             * Initial validation of the controller's constructor.
             * Flow:
             * Invoke _validateFetchStateDelegate
             * Invoke _validateUpdateStateDelegate
             *
             * @private
             */
            _validate: function _validate() {
                this._validateFetchStateDelegate();
                this._validateUpdateStateDelegate();
                this._validateSortDirection();
                this._validatePageSize();
                this._validatePage();
            },
            /**
             * PRIVATE METHODS
             */
            /**
             * Places data on tableSettings model (this is a kendo-ui requirement).
             *
             * @param {array<object>} data
             * @private
             */
            _expandTableSettings: function _expandTableSettings(data) {
                var ctrl = this;
                var meta = data._meta;
                var gridData = {
                    data: data,
                    total: meta.page ? meta.page.totalElements : meta.total
                };
                //Display paging footer with it's abilities, only if
                // this.tableSettings.alwaysPageable set to true, or total amount of rows greater
                // then the page size.
                var pageable = false;
                var sortable = false;
                if ((this.tableSettings && this.tableSettings.alwaysPageable) ||
                    gridData.total && gridData.total > ctrl.pageSize) {
                    pageable = {
                        pageSizes: ctrl.pageSizes,
                        pageSize: ctrl.pageSize,
                        page: ctrl.page
                    };
                }
                if (this.tableSettings && this.tableSettings.sortable) {
                    sortable = this.tableSettings.sortable;
                }
                ctrl.localTableSettings = _.merge({}, {
                    dataSource: {
                        data: gridData,
                        schema: {
                            data: "data",
                            total: "total"
                        },
                        page: ctrl.page,
                        serverPaging: true,
                        serverSorting: false
                    },
                    pageable: pageable,
                    sortable: sortable,
                    detailExpand: function (e) {
                        e.detailRow.addClass('expanded');
                    },
                    detailCollapse: function (e) {
                        e.detailRow.removeClass('expanded');
                    }
                }, this.tableSettings, this._localSort);
                // If detailTableSettings exists, this means that hierarchy is required
                if (this.detailTableModelName) {
                    ctrl.localTableSettings.detailInit = ctrl._detailInit.bind(ctrl);
                }
                // Add custom sorting
                this._setCustomSort(ctrl.localTableSettings.columns);
            },
            /**
             * Create and render the sub table.
             *
             * @param e
             * @private
             */
            _detailInit: function (e) {
                var ctrl = this;
                e.detailRow.addClass('expanded');
                //e.detailRow.find('.k-hierarchy-cell')
                //    .append('<span class="l-shape-vertical"></span>')
                //    .append('<span class="l-shape-horizontal"></span>');
                e.detailRow.find('.k-hierarchy-cell').remove();
                e.detailRow.find('.k-detail-cell').attr('colspan', '9');
                ctrl.localDetailTableSettings = _.merge({}, this.detailTableSettings, {
                    dataSource: {
                        data: e.data[ctrl.detailTableModelName],
                        serverPaging: false,
                        serverSorting: false
                    },
                    pageable: false,
                    sortable: true
                });
                // Create an angular table element from kendo-grid directive
                var tableElement = this._createKendoGridElement();
                tableElement.attr('options', 'table.localDetailTableSettings');
                tableElement.addClass('details-table');
                // Compile and link table element
                tableElement = this._compileKendoGridElement(tableElement);
                // Add distinction to header
                tableElement.find('tr').first().addClass('details-table-header');
                //var element = $("<div/>").kendoGrid(this.localDetailTableSettings);
                //element = ctrl.$compile(element)(ctrl.$scope);
                tableElement.appendTo(e.detailCell);
                ctrl.detailTableWrapper = tableElement;
            },
            /**
             * Creates an angular element from a kendo-grid tag and returns it.
             *
             * @returns {angular.element}
             * @private
             */
            _createKendoGridElement: function _createKendoGridElement() {
                return angular.element('<kendo-grid class="fs-table" options=' +
                    '"table.localTableSettings"  ' +
                    'k-on-data-bound="table.onDataBound(kendoEvent)"' +
                    '>' +
                    '</kendo-grid>');
            },
            /**
             * Sets grouping dynamically. Returns true if new grouping has been set, otherwise it returns false.
             *
             * @param {} dataSource
             * @param {Array<{}>} sortList
             * @param {Array<{}>} columnsList
             * @returns {boolean}
             * @private
             */
            _setGrouping: function (dataSource, sortList, columnsList) {
                var groupingList = [];
                // Make sure all lists are populated as required
                if (sortList && sortList[0] && columnsList && columnsList.length) {
                    // Find the column that corresponds to the sort field
                    var column = _.find(columnsList, { field: sortList[0].field });
                    if (column && column.groupField) {
                        // populate a grouping object
                        groupingList = [{
                                field: column.groupField,
                                dir: sortList[0].dir
                            }];
                    }
                }
                // If no group is made, them remove groups from dataSource and return true
                if (groupingList.length === 0 && dataSource.group().length !== 0) {
                    dataSource.group(groupingList);
                    return true;
                }
                // If the newly created grouping object equals the current, then return false without setting
                if (groupingList.length === 0 ||
                    (dataSource.group()[0] &&
                        dataSource.group()[0].field === groupingList[0].field &&
                        dataSource.group()[0].dir === groupingList[0].dir)) {
                    return false;
                }
                // Set new grouping and return true
                dataSource.group(groupingList);
                return true;
            },
            /**
             * Iterates through columns, and if any have "customSort" it will mount a custom sort function on the
             * column.
             *
             * @param {Array<{}>} columns
             * @private
             */
            _setCustomSort: function (columns) {
                _.each(columns, function (column) {
                    if (column.customSort && column.field) {
                        column.sortable = {
                            compare: customSort[column.customSort](column.field)
                        };
                    }
                });
            },
            /**
             * Kendo's event - triggers when page size changed, page changed, column sorted or other things
             * changed.
             * If page or page size changed- we like to update the state immediately
             * @param arg
             */
            onDataBound: function (arg) {
                var ctrl = this;
                var ds = arg.sender.dataSource;
                // Add class to last and one to last tr's
                var tableRows = arg.sender.items();
                var tableRowsLength = tableRows.length;
                if (tableRowsLength > 5) {
                    $([tableRows[tableRowsLength - 1], tableRows[tableRowsLength - 2]])
                        .addClass('fs-table-last-rows');
                }
                if (this._setGrouping(arg.sender.dataSource, ds.sort(), arg.sender.columns)) {
                    return;
                }
                //User change the page size
                if (ds._pageSize && ds._pageSize !== ctrl.pageSize) {
                    //Page size changed
                    ctrl._updateStateAndExecuteUpdateStateDelegate(ds._pageSize, 1);
                    return; //End function
                }
                //User click on column sort
                if (ds.sort() && ds.sort()[0] &&
                    // The sorting is different for details-table
                    !arg.sender.element.hasClass('details-table')) {
                    // Make sure is not inner table
                    if (this.detailTableWrapper &&
                        arg.sender.wrapper[0] === this.detailTableWrapper[0]) {
                        return;
                    }
                    var sortData = ds.sort()[0];
                    var sortDir = sortData.dir.toUpperCase();
                    var sortField = sortData.field;
                    if (sortField !== ctrl.sortBy || sortDir !== ctrl.sortDirection) {
                        // Create a new local sort object
                        ctrl._localSort = {
                            dataSource: {
                                sort: {
                                    dir: sortDir.toLowerCase(),
                                    field: sortField
                                }
                            }
                        };
                        ctrl._updateStateAndExecuteUpdateStateDelegate(null, 1, sortData.field, sortDir);
                        return; //End function
                    }
                }
                //User change page
                if (ds._page && ds._page !== +ctrl.page) {
                    //First page is 1.
                    ctrl._updateStateAndExecuteUpdateStateDelegate(null, ds._page);
                    return; //End function
                }
            },
            /**
             * @param pageSize -           The new size of the page
             * @param page -               The new page number
             * @param sortBy -             Field id - to sort by
             * @param sortDirection -      Sort direction - DESC / ASC
             * @private
             *
             * This method get the abouve parameters, set them on the controller + state
             * and execute the updateStateDelegate
             */
            _updateStateAndExecuteUpdateStateDelegate: function (pageSize, page, sortBy, sortDirection) {
                var ctrl = this;
                var state = {};
                //Update the controller and state
                ctrl._setToStateAndController(ctrl, state, 'pageSize', pageSize);
                ctrl._setToStateAndController(ctrl, state, 'page', page);
                ctrl._setToStateAndController(ctrl, state, 'sortBy', sortBy);
                ctrl._setToStateAndController(ctrl, state, 'sortDirection', sortDirection);
                // If _updatedInternalState flag is true, this means that state was updated from
                // the external state (by fetchStateDelegate) and it does not need to update the
                // external state.
                if (ctrl.updateStateDelegate) {
                    //Invoke ctrl.updateStateDelegate
                    ctrl.updateStateDelegate({
                        id: ctrl.tableId,
                        type: 'DATA',
                        value: state,
                        immediate: true
                    });
                }
            },
            /**
             *  That method get property and value, and if it's not null it set it on the controller.
             *  After that it take the value of the property ---from the controller---
             *  and set it on the state object.
             *
             * @param ctrl
             * @param stateObject
             * @param propertyName
             * @param value
             * @private
             */
            _setToStateAndController: function (ctrl, stateObject, propertyName, value) {
                if (angular.isDefined(value) && value !== null) {
                    ctrl[propertyName] = value;
                }
                stateObject[propertyName] = ctrl[propertyName];
            },
            /**
             * Takes a tableElement angular element, compiles it, and returns it.
             *
             * @param {angular.element} tableElement
             * @returns {angular.element}
             * @private
             */
            _compileKendoGridElement: function _compileKendoGridElement(tableElement) {
                return this.$compile(tableElement)(this.$scope);
            },
            /**
             * Takes a compiled and linked tableElement, and places it on the DOM, replacing current element.
             *
             * @param {angular.element} tableElement
             * @private
             */
            _replaceElementWithKendoElement: function _replaceElementWithKendoElement(tableElement) {
                var prevKendoElement = this.$element.find('[kendo-grid]');
                prevKendoElement.remove();
                this.$element.append(tableElement);
            },
            /**
             * PUBLIC METHODS
             */
            renderTable: function renderTable() {
                var ctrl = this;
                function _renderSequence() {
                    // Places data on tableSettings model
                    ctrl._expandTableSettings(ctrl.tableModel);
                    // Create an angular table element from kendo-grid directive
                    var tableElement = ctrl._createKendoGridElement();
                    // Compile and link table element
                    tableElement = ctrl._compileKendoGridElement(tableElement);
                    // Replace element with new table element
                    ctrl._replaceElementWithKendoElement(tableElement);
                    ctrl._tableElement = tableElement;
                }
                // Make sure data is valid by checking it exists, it has an array data property.
                if (ctrl.tableModel && angular.isArray(ctrl.tableModel)) {
                    if (ctrl.tableModel.length) {
                        _renderSequence();
                    }
                    else if (!ctrl.tableModel.length && ctrl.tableModel._meta &&
                        this.tableModel._meta.total > 0) {
                        //There is data for filter, but no data for page
                        //The table will navigate to last exists page.
                        var lastPageIndex = _.ceil(ctrl.tableModel._meta.total / ctrl.pageSize);
                        ctrl._updateStateAndExecuteUpdateStateDelegate(ctrl.pageSize, lastPageIndex);
                    }
                    else {
                        // Clean out the directive's element if no alerts are found in model or its meta.
                        ctrl.$element[0].innerHTML = '';
                    }
                }
            },
            /**
             * WATCHERS
             */
            /**
             * A watch function. Returns instance's tableModel property
             *
             * @returns {object}
             * @private
             */
            _watchTableModel: function _watchTableModel() {
                return this.tableModel;
            },
            /**
             * A watch action function. Fires when this.tableModel changes.
             * Invokes renderTable, to render the table when data changes.
             *
             * @private
             */
            _watchTableModelAction: function _watchTableModelAction() {
                if (this.tableModel) {
                    this.renderTable();
                }
            },
            /**
             * This method triggered each time that fetchStateDelegate(ctrl.tableId)
             * return different answer.
             * The method update the controller
             *
             * @param newVal - state object
             * @param oldVal - state object
             * @private
             */
            _fetchStateDelegateWatchAction: function (newVal, oldVal) {
                var ctrl = this;
                if (newVal && (ctrl.pageSize !== newVal.pageSize ||
                    ctrl.page !== newVal.page ||
                    ctrl.sortDirection !== newVal.sortDirection ||
                    ctrl.sortBy !== newVal.sortBy)) {
                    ctrl.page = newVal.page;
                    ctrl.pageSize = newVal.pageSize;
                    ctrl.sortBy = newVal.sortBy;
                    ctrl.sortDirection = newVal.sortDirection;
                    // Create a local search object
                    if (_.isString(ctrl.sortDirection) && ctrl.sortDirection !== '') {
                        ctrl._localSort = {
                            dataSource: {
                                sort: {
                                    dir: ctrl.sortDirection.toLowerCase(),
                                    field: ctrl.sortBy
                                }
                            }
                        };
                    }
                }
            },
            /**
             * Set default values for paging
             * @private
             */
            _initPagingSettings: function _initPagingSettings() {
                if (!this.pageSizes) {
                    this.pageSizes = [10, 20, 50, 100];
                }
                if (!this.pageSize) {
                    this.pageSize = 10;
                }
            },
            /**
             * Init
             */
            init: function init($element, $scope, $compile) {
                // Put dependencies on the instance
                var ctrl = this;
                ctrl.$element = $element;
                ctrl.$scope = $scope;
                ctrl.$compile = $compile;
                ctrl._validate();
            }
        });
        FsTableController.$inject = ['$element', '$scope', '$compile'];
        return {
            restrict: 'E',
            scope: true,
            link: linkFn,
            controller: FsTableController,
            controllerAs: 'table',
            bindToController: {
                tableId: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                tableSettings: '=',
                detailTableSettings: '=',
                tableModel: '=',
                detailTableModelName: '@',
                pageSizes: '=?',
                pageSize: '=?',
                sortBy: '=?',
                sortDirection: '=?'
            },
            require: 'fsTable'
        };
    }
    fsTableDirective.$inject = [];
    angular.module('Fortscale.shared.components.fsTable')
        .directive('fsTable', fsTableDirective);
}());

(function () {
    'use strict';
    function fsTableCollapsibleList() {
        /**
        * The directive's controller function
        *
        * @constructor
        */
        function FsTableCollapsibleListController() {
            this.maxDisplayLength = 3;
            this.showFullList = false;
        }
        angular.extend(FsTableCollapsibleListController.prototype, {
            /**
             * This method controls if we see only the first 3 items in the list or all of them
             */
            showFullListFn: function showFullList() {
                var ctrl = this;
                if (ctrl.showFullList) {
                    ctrl.showFullList = false;
                    this.maxDisplayLength = 3;
                }
                else {
                    ctrl.showFullList = true;
                    this.maxDisplayLength = ctrl.listCollection.length;
                }
            }
        });
        return {
            templateUrl: 'app/shared/components/fs-table/fs-table-collapsible-list/' +
                'fs-table-collapsible-list.view.html',
            restrict: 'E',
            controller: FsTableCollapsibleListController,
            controllerAs: 'entity',
            scope: {},
            bindToController: {
                titleId: '=',
                titleName: '=',
                listCollection: '=',
                listCollectionDisplayField: '='
            }
        };
    }
    fsTableCollapsibleList.$inject = [];
    angular.module('Fortscale.shared.components.fsTable')
        .directive('fsTableCollapsibleList', fsTableCollapsibleList);
}());

(function () {
    'use strict';
    function fsTableActionsDirective(assert, URLUtils, fsResourceStore, indicatorTypeMapper) {
        /**
        * The directive's controller function
        *
        * @constructor
        */
        function FsTableActionsController() {
            this.init();
        }
        angular.extend(FsTableActionsController.prototype, {
            /**
             * Validations
             */
            _validate: function _validate() {
                var errStart = 'FsTableActionsController._validate: ';
                // Validate `exploreId`
                assert(angular.isString(this.exploreId), errStart + '`exploreId` must be a String', TypeError);
                assert(this.exploreId.length, errStart + '`exploreId` must not be empty', RangeError);
                // Validate `baseUrl`
                assert(angular.isString(this.baseUrl), errStart + '`baseUrl` must be a String', TypeError);
                assert(this.baseUrl.length, errStart + '`baseUrl` must not be empty', RangeError);
            },
            /**
             * PUBLIC METHODS
             */
            /**
             * Trigger a URL change to explore a specific Alert
             */
            exploreAlert: function () {
                var targetUrl = this.baseUrl + '/' + this.exploreId;
                var alert = fsResourceStore.fetchResourceItemById('alerts', this.exploreId);
                // Find an indicator that has an indicator type
                var indicator = null;
                var indicatorType = null;
                _.every(alert.evidences, function (iIndicator) {
                    var iIndicatorType = indicatorTypeMapper.getType(iIndicator);
                    if (iIndicatorType !== null) {
                        indicator = iIndicator;
                        indicatorType = iIndicatorType;
                    }
                });
                // Build the target url
                if (indicatorType !== null) {
                    targetUrl += '/' + indicator.id;
                    // Route to 'gen' for general indicators
                    if (indicatorType.indicatorClass === 'gen') {
                        targetUrl += '/gen/overview';
                    }
                    else if (indicatorType.indicatorClass === 'tag') {
                        targetUrl += '/tag';
                    }
                }
                URLUtils.setUrl(targetUrl, true);
            },
            /**
             * Init
             */
            init: function () {
                this._validate();
            }
        });
        return {
            templateUrl: 'app/shared/components/fs-table/fs-table-actions/' +
                'fs-table-actions.view.html',
            restrict: 'E',
            controller: FsTableActionsController,
            controllerAs: 'actions',
            scope: {},
            bindToController: {
                exploreId: '=',
                baseUrl: '='
            }
        };
    }
    fsTableActionsDirective.$inject = ['assert', 'URLUtils', 'fsResourceStore',
        'indicatorTypeMapper'];
    angular.module('Fortscale.shared.components.fsTable')
        .directive('fsTableActions', fsTableActionsDirective);
}());

(function () {
    'use strict';
    /**
     * Uses example:
     * 	<fs-date-range date-range-id="dr1" fetch-state-delegate="::overview.getRangeState"
     * 	update-state-delegate="::overview.setRangeState"></fs-date-range>
     */
    function fsDateRangeDirective() {
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsDateRangeController($scope, $timeout, utils, $filter) {
            this.init($scope, $timeout, utils, $filter);
        }
        angular.extend(FsDateRangeController.prototype, {
            //Set the "from" and "to" to cover the last 7 dats
            setLast7Days: function () {
                var currentMoment = this.utils.date.getMoment('now');
                this.endTime = currentMoment.toDate();
                currentMoment = this.utils.date.getMoment('now');
                this.startTime = currentMoment.subtract(7, 'days').toDate();
            },
            //Set the "from" and "to" to cover the last month
            setLastMonth: function () {
                var currentMoment = this.utils.date.getMoment('now');
                this.endTime = currentMoment.toDate();
                currentMoment = this.utils.date.getMoment('now');
                this.startTime = currentMoment.subtract(1, 'months').toDate();
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                if (this.fetchStateDelegate && !angular.isFunction(this.fetchStateDelegate)) {
                    throw new TypeError('fsDateRange.directive: FsDateRangeController: ' +
                        'If fetchStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                if (this.updateStateDelegate && !angular.isFunction(this.updateStateDelegate)) {
                    throw new TypeError('fsDateRange.directive: FsDateRangeController: ' +
                        'If updateStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * update start and end time when fetchStateDelegate changed
             * @param newVal
             * @private
             */
            _fetchStateDelegateWatchAction: function (newVal) {
                var ctrl = this;
                if (angular.isString(newVal)) {
                    var values = newVal.split(',');
                    var startTimeUnix = values[0];
                    var endTimeUnix = values[1];
                    if (ctrl.startTimeUnix !== startTimeUnix || ctrl.endTimeUnix !== endTimeUnix) {
                        ctrl.startTimeUnix = startTimeUnix;
                        ctrl.endTimeUnix = endTimeUnix;
                        var startTimeDateText = ctrl.$filter('date')(startTimeUnix * 1000, 'MM/dd/yyyy', 'UTC');
                        ctrl.startTime = ctrl.utils.date.getMoment(startTimeDateText, false, 'MM/DD/YYYY').toDate();
                        var endTimeDateText = ctrl.$filter('date')(endTimeUnix * 1000, 'MM/dd/yyyy', 'UTC');
                        ctrl.endTime = ctrl.utils.date.getMoment(endTimeDateText, false, 'MM/DD/YYYY').toDate();
                    }
                }
            },
            /**
             * when startTime or endTime changed- this method invoke updateStateDelegate
             * with the new values, and convert to long value of the date.
             * If the system use UTC - we also convert the time to UTC using
             * ctrl.utils.date.getMoment
             *
             * @param newValues - array of [startTime, endTime]
             * @param oldValues - array of [startTime, endTime]
             * @private
             */
            _startTimeEndTimeWatchAction: function (newValues, oldValues) {
                var ctrl = this;
                if (newValues && newValues[0] && newValues[1] &&
                    (oldValues[0] !== newValues[0] || oldValues[1] !== newValues[1])) {
                    //invoke updateStateDelegate only if it defined
                    if (this.updateStateDelegate) {
                        var startTimeMoment = ctrl._prepareSelectedDate(newValues[0]);
                        var endTimeMoment = ctrl._prepareSelectedDate(newValues[1]);
                        if (endTimeMoment) {
                            endTimeMoment.endOf('day');
                        }
                        var value = '' +
                            ctrl.utils.date.toUnixTimestamp(startTimeMoment) + ',' +
                            ctrl.utils.date.toUnixTimestamp(endTimeMoment);
                        this.updateStateDelegate({
                            id: ctrl.dateRangeId,
                            type: 'DATA',
                            value: value,
                            immediate: this._immediate
                        });
                    }
                    if (this.formCtrl) {
                        this.formCtrl.$setDirty();
                    }
                }
            },
            /**
             * This method get a date object, truncate the hours/minutes/seconds etc...,
             * and convert the date to the time zone according to configuration.
             * The method ignores the original time zone
             *
             * @param {Date} time date object, in any timeozne
             * @return  The method returns a moment object,
             * representing the selected date with the application
             * timezone according to application's configuration.
             *
             * Throw TypeError if time is not a date or not defined
             * @private
             *
             */
            _prepareSelectedDate: function (time) {
                if (!(time instanceof Date)) {
                    throw new TypeError('fsDateRange.directive: FsDateRangeController: ' +
                        'time must be defined and be an Object of type Date');
                }
                var ctrl = this;
                var dateFormat = 'MM/dd/yyyy';
                var dateFilterFn = ctrl.$filter('date');
                var timeText = dateFilterFn(time, dateFormat);
                return ctrl.utils.date.getMoment(timeText, null, 'MM/DD/YYYY');
            },
            /**
             * This function compare start time and end time
             * (and ignores hours, minutes, seconds ...),
             * and return true if they are not the same
             *
             * @returns {boolean} true when start time and end time on different days,
             * false if they are on the same day
             */
            isStartTimeAndEndTimeOnDifferentDays: function () {
                var ctrl = this;
                var dateFilterFn = ctrl.$filter('date');
                if (!angular.isDefined(ctrl.startTime) || !angular.isDefined(ctrl.endTime)) {
                    return false;
                }
                return dateFilterFn(ctrl.startTime).valueOf() !==
                    dateFilterFn(ctrl.endTime).valueOf();
            },
            /**
             * Init
             */
            init: function init($scope, $timeout, utils, $filter) {
                var ctrl = this;
                ctrl._immediate = this._immediate ? ctrl._immediate : false; //this._immediate is false by default
                // Put dependencies on the instance
                ctrl.$scope = $scope;
                ctrl.utils = utils;
                ctrl.$filter = $filter;
                ctrl._validateGetStateFn();
                ctrl._validateSetStateFn();
                //Init default values
                ctrl.setLast7Days();
                //Listen when state delegate return different value
                if (ctrl.fetchStateDelegate) {
                    $scope.$watch(function () {
                        return ctrl.fetchStateDelegate(ctrl.dateRangeId);
                    }, ctrl._fetchStateDelegateWatchAction.bind(ctrl));
                }
                //When startTime or endTime changed - 	 update the state
                $scope.$watchGroup([
                    function () {
                        return ctrl.startTime;
                    },
                    function () {
                        return ctrl.endTime;
                    }
                ], ctrl._startTimeEndTimeWatchAction.bind(ctrl));
                $scope.$on('control:reset', function (event, eventData) {
                    if (eventData.controlId === ctrl.dateRangeId) {
                        ctrl.setLast7Days();
                    }
                });
            }
        });
        FsDateRangeController.$inject = ['$scope', '$timeout', 'utils', '$filter'];
        function linkFn(scope, element, attr, formCtrl) {
            scope.dateRange.formCtrl = formCtrl;
        }
        return {
            restrict: 'E',
            scope: {},
            controller: FsDateRangeController,
            controllerAs: 'dateRange',
            templateUrl: 'app/shared/components/controls/fs-daterange/fs-daterange.view.html',
            bindToController: {
                dateRangeId: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                label: '@',
                _immediate: '@?immediate',
            },
            link: linkFn,
            require: '?^^form'
        };
    }
    fsDateRangeDirective.$inject = [];
    angular.module('Fortscale.shared.components.fsDateRange', ["kendo.directives", 'Utils'])
        .directive('fsDateRange', fsDateRangeDirective);
}());

(function () {
    'use strict';
    function fsSimpleTabsStripDirective($state) {
        function FsSimpleTabsStripController() {
        }
        FsSimpleTabsStripController.prototype.isTabActive = function (stateName) {
            return $state.includes(stateName);
        };
        return {
            restrict: 'E',
            scope: {},
            controller: FsSimpleTabsStripController,
            controllerAs: 'ctrl',
            bindToController: {
                bullets: '=',
                getHrefDelegate: '='
            },
            templateUrl: 'app/shared/components/controls/fs-simple-tabs-strip/fs-simple-tabs-strip.html'
        };
    }
    fsSimpleTabsStripDirective.$inject = ['$state'];
    angular.module('Fortscale.shared.components.fsSimpleTabsStrip', [])
        .directive('fsSimpleTabsStrip', fsSimpleTabsStripDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsDatePicker', [
        //Dependencies
        'Utils'
    ]);
}());

(function () {
    'use strict';
    function fsDatePickerDirective(dateRanges) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrl
         */
        function linkFn(scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            ctrl.formCtrl = ctrls[1];
            ctrl._renderDatePicker();
            ctrl._setPickerDefaultValue();
            ctrl._setInputChangeHandler();
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsDatePickerController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsDatePickerController.prototype, {
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateGetStateFn: function () {
                if (this.fetchStateDelegate && !angular.isFunction(this.fetchStateDelegate)) {
                    throw new TypeError('fsDatePicker.directive: FsDatePickerController: ' +
                        'If fetchStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Validate fetchStateDelegate.
             * Throw TypeError if fetchStateDelegate is received and is not a function
             * @private
             */
            _validateSetStateFn: function () {
                if (this.updateStateDelegate && !angular.isFunction(this.updateStateDelegate)) {
                    throw new TypeError('fsDatePicker.directive: FsDatePickerController: ' +
                        'If updateStateDelegate is provided, it must be a function.');
                }
            },
            /**
             * Directive validation sequence
             *
             * @private
             */
            _validations: function () {
                this._validateGetStateFn();
                this._validateSetStateFn();
            },
            /**
             * Tests for all digits string. Returns true if all digits
             *
             * @param value
             * @returns {boolean}
             * @private
             */
            _isStringInteger: function (value) {
                return /^\d*$/.test(value);
            },
            /**
             */
            /**
             * Returns a date value (timestamp) from a Date, a string, a string representing an int, or an int.
             *
             * @param {string|number|Date} value
             * @returns {*}
             * @private
             */
            _getDateValueFromGenericValue: function (value) {
                if (_.isString(value) && this._isStringInteger(value)) {
                    value = parseInt(value, 10);
                }
                return new Date(value).valueOf();
            },
            /**
             * Returns the value of the the state by the id
             * @returns {*}
             * @private
             */
            _stateWatchFn: function () {
                return this.fetchStateDelegate(this.datePickerId);
            },
            /**
             * Watch action function . Sets the value to the picker if state has changed.
             *
             * @param newState
             */
            stateWatchActionFn: function (newState) {
                if (newState && this._getDateValueFromGenericValue(newState) !== this.getPickerValue().valueOf()) {
                    this.setPickerValue(newState);
                }
            },
            /**
             * Initiates state watch
             *
             * @returns {*|function()}
             * @private
             */
            _initStateWatch: function () {
                return this.$scope.$watch(this._stateWatchFn.bind(this), this.stateWatchActionFn.bind(this));
            },
            /**
             * Init watches sequence
             *
             * @private
             */
            _initWatches: function () {
                this._watchStateDeregister = this._initStateWatch();
            },
            /**
             * Handler function for picker value change. Updates state (via updateStateDelegate), and sets the form
             * dirty, if form was recognized.
             *
             * @param {Event} evt
             * @private
             */
            _pickerChangeHandler: function (evt) {
                var date = this.getPickerValue().valueOf();
                this.updateStateDelegate({
                    id: this.datePickerId,
                    type: 'DATA',
                    value: date,
                    immediate: false
                });
                if (this.formCtrl) {
                    this.$scope.$apply(this.formCtrl.$setDirty.bind(this.formCtrl));
                }
            },
            /**
             * Finds the date-picker element, and renders the date range picker with kendoDatePicker
             *
             * @private
             */
            _renderDatePicker: function () {
                this.datePickerElement = this.$element.find('.date-picker').kendoDatePicker({
                    change: this._pickerChangeHandler.bind(this)
                });
                this.datePickerKendoController = this.datePickerElement.data("kendoDatePicker");
            },
            /**
             * Sets the default value to the picker. In no default value is provided, the default value will be today.
             *
             * @returns {*}
             * @private
             */
            _setPickerDefaultValue: function () {
                var initVal = this.initialValue || dateRanges.getStartOfDayByDaysAgo(0);
                return this.setPickerValue(initVal);
            },
            /**
             * input change handler. When the input element changes, will change the value of the picker and fire
             * 'change' event.
             *
             * @param {Event} evt
             * @private
             */
            _inputChangeHandler: function (evt) {
                var newDate = new Date(evt.target.value);
                if (newDate.valueOf() !== this.getPickerValue().valueOf()) {
                    this.setPickerValue(newDate);
                    this.datePickerKendoController.trigger('change');
                }
            },
            /**
             * Sets an input change handler.
             *
             * @private
             */
            _setInputChangeHandler: function () {
                this.$element.find('input').on('change', this._inputChangeHandler.bind(this));
            },
            /**
             * Sets the picker value.
             *
             * @param {string|number|Date} value
             * @returns {*}
             */
            setPickerValue: function (value) {
                value = this._getDateValueFromGenericValue(value);
                return this.datePickerKendoController.value(new Date(value));
            },
            /**
             * Gets the picker value
             *
             * @returns {Date}
             */
            getPickerValue: function () {
                return this.datePickerKendoController.value();
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                ctrl._validations();
                ctrl._initWatches();
            }
        });
        FsDatePickerController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<input class="date-picker" />',
            scope: {},
            link: linkFn,
            controller: FsDatePickerController,
            controllerAs: 'ctrl',
            bindToController: {
                datePickerId: '@',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                initialValue: '@'
            },
            require: ['fsDatePicker', '?^^form']
        };
    }
    fsDatePickerDirective.$inject = ['dateRanges'];
    angular.module('Fortscale.shared.components.fsDatePicker')
        .directive('fsDatePicker', fsDatePickerDirective);
}());

(function () {
    'use strict';
    function fsSplitter(assert, utils) {
        function linkFn(scope, element, attrs, ctrl, transclude) {
            // Init splitter
            var settings = _.merge({}, ctrl._settings, {
                collapse: function () {
                    ctrl._splitterCollapseHandler();
                },
                expand: function () {
                    ctrl._splitterExpandHandler();
                }
            });
            element.kendoSplitter(settings);
            ctrl.splitterElement = element.data('kendoSplitter');
            // Init watches
            if (ctrl.fetchStateDelegate) {
                scope.$watch(ctrl._watchState.bind(ctrl), ctrl._watchStateAction.bind(ctrl));
            }
        }
        /**
         * The directive's controller function
         * Added instead of using a Link function
         * Properties are bound on the Controller instance and available in the view
         *
         * @constructor
         */
        function FsSplitterController($scope, $element, $attrs) {
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.init();
        }
        _.merge(FsSplitterController.prototype, {
            /**
             * Action for state.collapsed.
             *
             * @param {string} collapsed When 'true' its the same as true
             * @private
             */
            _watchStateCollapseAction: function (collapsed) {
                if (collapsed !== undefined &&
                    collapsed !== this.state.collapsed) {
                    if (collapsed === 'true') {
                        this._collapsePane();
                    }
                    else {
                        this._expandPane();
                    }
                    this.state.collapsed = collapsed;
                }
            },
            /**
             * A watch state function (registered with $watch)
             *
             * @returns {*}
             * @private
             */
            _watchState: function () {
                return this.fetchStateDelegate(this._id);
            },
            /**
             * A watch state action function. Fires when state changes.
             *
             * @param {object} newVal
             * @private
             */
            _watchStateAction: function (newVal) {
                if (newVal) {
                    if (!this.state) {
                        this.state = {};
                    }
                    this._watchStateCollapseAction(newVal.collapsed);
                }
            },
            /**
             * Updates the state's control.
             *
             * @private
             */
            _updateControl: function () {
                this.updateStateDelegate({
                    id: this._id,
                    type: 'ui',
                    value: this.state,
                    immediate: 'true'
                });
            },
            /**
             * Collapses the first pane.
             *
             * @private
             */
            _collapsePane: function () {
                this.splitterElement.collapse(".k-pane");
            },
            /**
             * Expands the first pane.
             *
             * @private
             */
            _expandPane: function () {
                this.splitterElement.expand(".k-pane");
            },
            /**
             * Splitter collapse event handler. Sets internal state (for dirty checking)
             * and updates the control.
             *
             * @private
             */
            _splitterCollapseHandler: function () {
                this.state = this.state || {};
                this.state.collapsed = 'true';
                // Trigger apply because the event is not an angular event.
                this.$scope.$apply(function () {
                    this._updateControl();
                }.bind(this));
            },
            /**
             * Splitter expand event handler. Sets internal state (for dirty checking)
             * and updates the control.
             *
             * @private
             */
            _splitterExpandHandler: function () {
                this.state = this.state || {};
                this.state.collapsed = 'false';
                // Trigger apply because the event is not an angular event.
                this.$scope.$apply(function () {
                    this._updateControl();
                }.bind(this));
            },
            /**
             * Init
             */
            init: function init() {
            }
        });
        FsSplitterController.$inject = ['$scope', '$element', '$attrs'];
        return {
            restrict: 'A',
            scope: true,
            controller: FsSplitterController,
            controllerAs: 'splitter',
            bindToController: {
                _settings: '=splitterSettings',
                _id: '@splitterId',
                fetchStateDelegate: '=',
                updateStateDelegate: '='
            },
            link: linkFn
        };
    }
    fsSplitter.$inject = ['assert', 'utils'];
    angular.module('Fortscale.shared.components.fsSplitter', [])
        .directive('fsSplitter', fsSplitter);
}());

(function () {
    'use strict';
    /**
     * Holds the global state of all multiselect drop downs. Used to determine if any are opened.
     *
     * @type {boolean}
     * @private
     */
    var _anyDropdownOpened = false;
    function fsMultiselect(assert) {
        /**
         * The link function
         *
         * @param scope
         * @param element
         * @param attrs
         * @param ctrl
         */
        function linkFn(scope, element, attrs, ctrl /**, transclude**/) {
            ctrl._linkInit();
        }
        /**
         * The directive's controller function
         * Added instead of using a Link function
         * Properties are bound on the Controller instance and available in the view
         *
         * @constructor
         */
        function FsMultiselectController($scope, $element, $attrs, $timeout) {
            var ctrl = this;
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.$timeout = $timeout;
            // Bind to controller instance
            this.windowClickHandler = function (evt) {
                ctrl._windowClickHandler(evt);
            };
            this._ctrlInit();
        }
        _.merge(FsMultiselectController.prototype, {
            _errMsg: 'fsMultiselect.directive: ',
            /**
             * Validates listData. Validates each item for value id and unique.
             *
             * @param {array<{id: string, value: string}>} listData
             * @param errMsg
             * @private
             */
            _validateListData: function (listData, errMsg) {
                // Validate values and ids
                _.each(listData, function (dataItem) {
                    // validate value
                    assert.isString(dataItem.value, 'dataItem.value', errMsg);
                    // Validate ids
                    assert.isString(dataItem.id, 'dataItem.id', errMsg);
                });
                // Validate uniques
                var values = _.map(listData, 'value');
                var ids = _.map(listData, 'id');
                assert(values.length === _.uniq(values).length, errMsg + 'value property\'s values must be unique.', RangeError);
                assert(ids.length === _.uniq(ids).length, errMsg + 'id property\'s values must be unique.', RangeError);
            },
            /**
             * Control init validations. Validates directive's arguments
             * @param errMsg
             * @private
             */
            _ctrlValidations: function (errMsg) {
                assert.isString(this.multiselectId, 'multiselectId', errMsg);
                assert.isString(this._initialState, '_initialState', errMsg, true);
                assert.isString(this.label, 'label', errMsg, true);
                assert.isArray(this._listData, 'listData', errMsg);
                this._validateListData(this._listData, errMsg + 'listData argument: ');
                assert.isFunction(this.fetchStateDelegate, 'fetchStateDelegate', errMsg);
                assert.isFunction(this.updateStateDelegate, 'updateStateDelegate', errMsg);
            },
            /**
             * A handler for any window click. Should close the dropdown if the click is outside the dropdown.
             *
             * @param evt
             * @private
             */
            _windowClickHandler: function (evt) {
                // If the click is outside the dropdown - fire cancelClickHandler
                if (!this.$element.find('.fs-multiselect-dropdown-list')[0].contains(evt.target)) {
                    this.cancelClickHandler();
                }
                // If the click is on the drop-down openener, stop propagation so drop down will not reopen
                if (this.$element.find('.fs-multiselect-value')[0].contains(evt.target)) {
                    evt.stopImmediatePropagation();
                }
            },
            /**
             * Initates window click listener
             * @private
             */
            _initWindowClickListener: function () {
                window.addEventListener('click', this.windowClickHandler, true);
            },
            /**
             * Removes window click listener
             * @private
             */
            _removeWindowClickListener: function () {
                window.removeEventListener('click', this.windowClickHandler, true);
            },
            /**
             * Watch state function.
             *
             * @returns {*}
             * @private
             */
            _watchStateFn: function () {
                return this.fetchStateDelegate(this.multiselectId);
            },
            /**
             * Watch state action function.
             * Handles digestion of incoming state (which items are checked), and select all state.
             *
             * @param state
             * @private
             */
            _watchStateActionFn: function (state) {
                if (state) {
                    this._setAllUnchecked();
                    this._digestIncomingState(state);
                    this._setAllSelected();
                }
                else {
                    this._initAllSelectedState();
                }
            },
            /**
             * Watch list data
             *
             * @returns {*}
             * @private
             */
            _watchListDataFn: function () {
                return this._listData;
            },
            /**
             * Watch list data action function.
             * Handles digestion of incoming state (which items are checked), and select all state.
             *
             * @param state
             * @private
             */
            _watchListDataActionFn: function (listData) {
                if (listData && listData.length > 0) {
                    //this._ctrlInit();
                    this.listData = _.cloneDeep(this._listData);
                    this._watchStateActionFn(this.fetchStateDelegate(this.multiselectId));
                }
            },
            /**
             * Fires when 'control:reset' event is broadcasted.
             * It resets the control to its initial state and updates state.
             *
             * @param event
             * @param eventData
             * @private
             */
            _controlResetRequestHandler: function (event, eventData) {
                var ctrl = this;
                if (eventData.controlId && eventData.controlId === ctrl.multiselectId) {
                    // Since this is like receiving external state,
                    // _watchStateActionFn is the perfect method to use
                    ctrl._watchStateActionFn(ctrl._initialState);
                    // Clear the form
                    ctrl.$scope.dropdownForm.$setPristine();
                    // Get the value to set it to the pre-state
                    var state = ctrl._getMultiselectState();
                    // Set pre-state
                    ctrl.updateStateDelegate({
                        id: ctrl.multiselectId,
                        immediate: this._immediate,
                        type: 'data',
                        value: state
                    });
                }
            },
            /**
             * Handler for scope destroy.
             * Sets _anyDropdownOpened to false.
             *
             * @private
             */
            _scopeDestroyHandler: function () {
                _anyDropdownOpened = false;
                this._removeWindowClickListener();
            },
            /**
             * Initates all relevan watches.
             *
             * @private
             */
            _initWatches: function () {
                var ctrl = this;
                // Init state watch
                ctrl.$scope.$watch(ctrl._watchStateFn.bind(ctrl), ctrl._watchStateActionFn.bind(ctrl));
                //Init list options change watcher
                ctrl.$scope.$watch(ctrl._watchListDataFn.bind(ctrl), ctrl._watchListDataActionFn.bind(ctrl));
                ctrl.$scope.$on('$destroy', ctrl._scopeDestroyHandler.bind(ctrl));
                ctrl.$scope.$on('control:reset', ctrl._controlResetRequestHandler.bind(ctrl));
            },
            /**
             * Before receiving external state, set the default to all selected.
             *initToSelectAll - if true - all be selected, if false, nothing will be selected
             * @private
             */
            _initAllSelectedState: function () {
                var dataItems = this._listData.concat(this.listData);
                var shouldSelectAll = this.lastSelected === 'All'; //If selectAll is false, none will be selected
                // Iterate through concatinated array and turn on checked for each item.
                _.each(dataItems, function (dataItem) {
                    dataItem.checked = shouldSelectAll;
                });
                // Put the view value in value property on the controller instance.
                this.value = this._getMultiselectViewValue();
                this.allSelected = shouldSelectAll;
            },
            /**
             * Sel all items as unchecked.
             *
             * @private
             */
            _setAllUnchecked: function () {
                var dataItems = this._listData.concat(this.listData);
                // Iterate through concatinated array and turn on checked for each item.
                _.each(dataItems, function (dataItem) {
                    dataItem.checked = false;
                });
            },
            /**
             * Returns the multiselect state. Multiselect state is a csv string of
             * checked items ids. If all or none are selected, the return value is null.
             *
             * @returns {string|null}
             * @private
             */
            _getMultiselectState: function () {
                // Get all checked items from model state
                var checked = _.filter(this.listData, { checked: true });
                // init value variable
                // If value has an initial state, the value needs to be explicitly '_NONE_'
                // or '_ALL_'
                var value = (this._initialState === undefined) ? null : '_NONE_';
                // If there are any checked and not all are checked in :
                if (checked.length > 0 && checked.length < this.listData.length) {
                    // The value is a csv string of all checked items ids.
                    value = _.map(checked, function (item) {
                        return item.id;
                    }).join(',');
                }
                else if (checked.length === this.listData.length) {
                    value = (this._initialState === undefined) ? null : '_ALL_';
                }
                // Return a csv or null
                return value;
            },
            /**
             * Receives a list of checked view items. Returns a csv of item.value.
             * Used in 'short' lists.
             *
             * @param {Array<{value: string}>} checkedItems
             * @returns {string}
             * @private
             */
            _getShortViewValue: function (checkedItems) {
                return _.map(checkedItems, function (item) {
                    return item.value;
                }).join('; ');
            },
            keyPress: function (e) {
                if (e.keyCode === 27) {
                    this.okClickHandler();
                }
            },
            /**
             * Receives a list of checked view items. Returns  '1 item' if there is only one item,
             * or it returns '<n> items' if there are more then one item. Used in 'long' lists.
             *
             * @param {Array<{value: string}>} checkedItems
             * @returns {string}
             * @private
             */
            _getLongViewValue: function (checkedItems) {
                if (checkedItems.length > 1) {
                    return checkedItems.length + ' items';
                }
                else {
                    return '1 item';
                }
            },
            /**
             * Returns the view value to be displayed in the drop down button.
             * If all are selected, 'All' is returned.
             * If none are selected, 'None' is returned.
             * If list is short, a ';' delimited string of item.value is returnd.
             * if list is long, '<n> items' (or '1 item') is returned.
             *
             * @returns {string}
             * @private
             */
            _getMultiselectViewValue: function () {
                // Gets a list of all checked items
                var checked = _.filter(this._listData, { checked: true });
                // If there are any checked items and non all items are checked:
                if (checked.length > 0 && checked.length < this._listData.length) {
                    //Per Uri's request - always show the values, seperated
                    return this._getShortViewValue(checked);
                }
                else if (checked.length === this._listData.length) {
                    return 'All';
                }
                else {
                    return 'None';
                }
            },
            /**
             * Takes a csv string, an creates an id list. Turns on 'checked' for each of the
             * received items in both model state and view state.
             *
             * @param {string} state a csv string
             * @private
             */
            _digestIncomingState: function (state) {
                var ids;
                // Get ids from csv
                if (state === '_NONE_') {
                    ids = '';
                }
                else if (state === '_ALL_') {
                    ids = _.map(this._listData, 'id');
                }
                else {
                    ids = state.split(',');
                }
                // Iterate through ids
                _.each(ids, _.bind(function (id) {
                    // Create one array that holds both model state objects and view state objects,
                    // that have a received id.
                    // This works because the lists hold objects and changes are made by reference.
                    var dataItems = [];
                    dataItems = dataItems.concat(_.filter(this._listData, { id: id }));
                    dataItems = dataItems.concat(_.filter(this.listData, { id: id }));
                    // Iterate through concatinated array and turn on checked for each item.
                    _.each(dataItems, function (dataItem) {
                        dataItem.checked = true;
                    });
                }, this));
                // Put the view value in value property on the controller instance.
                this.value = this._getMultiselectViewValue();
            },
            /**
             * Checks if all checked are true in a received list.
             *
             * @param {Array<{checked: boolean}>} listData
             * @returns {boolean}
             * @private
             */
            _isAllSelected: function (listData) {
                return _.every(listData, function (dataItem) {
                    return dataItem.checked;
                });
            },
            /**
             * Set allSelected property with true or false based on the result of isAllSelected.
             *
             * @private
             */
            _setAllSelected: function () {
                this.allSelected = this._isAllSelected(this.listData);
            },
            /**
             * Sets all checked to true/false (based on the received 'checked' argument)
             * in view model.
             *
             * @param {boolean} checked
             * @private
             */
            _checkAllInView: function (checked) {
                _.each(this.listData, function (dataItem) {
                    dataItem.checked = checked;
                });
            },
            /**
             * Finds the drop down element and returns it.
             *
             * @returns {*}
             * @private
             */
            _getDropdownElement: function () {
                return this.$element.find('.fs-multiselect-dropdown-list');
            },
            /**
             * This method is exposed for testing purposes only!
             * Sets the value of _anyDropdownOpened
             *
             * @param {*} val
             * @private
             */
            __setAnyDropdownOpened: function (val) {
                _anyDropdownOpened = val;
            },
            /**
             * This method is exposed for testing purposes only!
             * Gets the value of _anyDropdownOpened
             *
             * @returns {boolean}
             * @private
             */
            __getAnyDropdownOpened: function () {
                return _anyDropdownOpened;
            },
            /**
             * This variable holds threshold number between 'long' list and 'short' list
             */
            longListThreshold: 10,
            /**
             * Hides the drop-down menu, and sets the global _anyDropdownOpened to false.
             */
            hideDropdown: function () {
                this._dropDownElement.removeClass('show');
                _anyDropdownOpened = false;
                this._removeWindowClickListener();
            },
            /**
             * Shows the drop down menu if no drop downs are opened globally.
             * Sets the global _anyDropdownOpened to true so no other drop-downs may be opened.
             */
            showDropdown: function () {
                if (!(this._dropDownElement.hasClass('show') ||
                    _anyDropdownOpened)) {
                    this._dropDownElement.addClass('show');
                    _anyDropdownOpened = true;
                    this.setLocation();
                    // Init document click watch
                    this._initWindowClickListener();
                }
            },
            /**
             * Handler for 'Select all' item click. If sets all view items to checked/unchecked.
             */
            selectAllHandler: function () {
                // if all view items are selected: deselect all
                if (this._isAllSelected(this.listData)) {
                    this._checkAllInView(false);
                    this.allSelected = false;
                }
                else {
                    this._checkAllInView(true);
                    this.allSelected = true;
                }
                // Set the form to dirty so 'Ok' button will be activated.
                this.$scope.dropdownForm.$setDirty();
            },
            /**
             * Single item select handler. Fires _setAllSelected to determine the state of
             * 'Select all'.
             */
            selectSingleHandler: function (evt) {
                this._setAllSelected();
                // If original top was registered then use it to set the scroll to the original position
                // This takes care of a bug where clicking on the list caused the scroll of the list to
                // drop to the bottom
                if (this._originalScrollTop) {
                    this._originalScrollTop.element.scrollTop = this._originalScrollTop.scrollTop;
                    this._originalScrollTop = null;
                }
            },
            /**
             * A precursor to selectSingleHandler method. This registers the original scroll top so
             * selectSingleHandler can then use it to set the scroll back to when it was started before
             * clicking had changed it
             * @param element
             * @param evt
             */
            setListContainerScroll: function (element, evt) {
                var container = element.parentElement;
                this._originalScrollTop = { element: container, scrollTop: container.scrollTop };
            },
            /**
             * OK Click handler.
             * Hides the drop-down, merges the view state into the model state, sets the view
             * value, sets the form pristine, and updates the state in the state container.
             */
            okClickHandler: function () {
                this.hideDropdown();
                this._listData = _.cloneDeep(this.listData);
                this.value = this._getMultiselectViewValue();
                this.lastSelected = this.value;
                this.$scope.dropdownForm.$setPristine();
                var state = this._getMultiselectState();
                this.updateStateDelegate({
                    id: this.multiselectId,
                    immediate: this._immediate,
                    type: 'data',
                    value: state
                });
            },
            /**
             * Cancel click handler.
             * Hides the drop-down, sets the form pristine to disable OK button, resets view
             * state to the model state, and determine allSelected state.
             */
            cancelClickHandler: function () {
                this.hideDropdown();
                this.$scope.dropdownForm.$setPristine();
                this.listData = _.cloneDeep(this._listData);
                this._setAllSelected();
            },
            setLocation: function (setTransition) {
                var _this = this;
                var _setLocation = function () {
                    var windowHeight = window.innerHeight;
                    var dropdownBottom = _this._dropDownElement[0].getBoundingClientRect().bottom;
                    var transform = _this._dropDownElement[0].style.transform.split(',');
                    var translateY = transform.length > 1 ? parseFloat(transform[1]) : 0;
                    if (windowHeight - 120 < dropdownBottom) {
                        var delta = (dropdownBottom + translateY) - windowHeight + 120;
                        _this._dropDownElement.css('transform', "translate3d(0, -" + delta + "px, 0)");
                    }
                    if (windowHeight - 120 > dropdownBottom) {
                        _this._dropDownElement.css('transform', "translate3d(0, 0, 0)");
                    }
                };
                if (setTransition) {
                    this._dropDownElement.css('transition', 'transform 0.5s ease-in-out');
                    this.$timeout(_setLocation, 200);
                }
                else {
                    this._dropDownElement.css('transition', '');
                    _setLocation();
                }
            },
            /**
             * Inits
             */
            /**
             * Controller init function
             *
             * @private
             */
            _ctrlInit: function _ctrlInit() {
                this._ctrlValidations(this._errMsg + '_ctrlInit: ');
                // Clone states
                // _listData is the model state
                // listData is the view state
                this._listData = _.cloneDeep(this._listData);
                this.listData = _.cloneDeep(this._listData);
                this._immediate = this._immediate ? this._immediate : false; //this._immediate is false by default
            },
            /**
             * Link function init function
             *
             * @private
             */
            _linkInit: function () {
                // Get dropdown element
                this._dropDownElement = this._getDropdownElement();
                // Init watches
                this.lastSelected = 'None'; //Init with none
                this._initWatches();
            }
        });
        FsMultiselectController.$inject = ['$scope', '$element', '$attrs', '$timeout'];
        return {
            restrict: 'E',
            templateUrl: 'app/shared/components/fs-multiselect/fs-multiselect.view.html',
            scope: {},
            controller: FsMultiselectController,
            controllerAs: 'multiselect',
            bindToController: {
                _listData: '=listData',
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                multiselectId: '@multiselectId',
                label: '@label',
                _initialState: '@initialState',
                _immediate: '@?immediate',
                //Count labels should be array of two strings, the first one is the label for count one item (I.E. User)
                //The second string should be the label for count of more then one item (I.E Users)
                //To display the count, each item in listData must have attribute of 'count' on it.
                countLabels: '=countLabels'
            },
            link: linkFn
        };
    }
    fsMultiselect.$inject = ['assert'];
    angular.module('Fortscale.shared.components.fsMultiselect', [
        'kendo.directives'
    ])
        .directive('fsMultiselect', fsMultiselect);
}());

(function () {
    'use strict';
    function fsMultiselectAutocomplete(assert, $http, Restangular) {
        /**
         * The link function
         *
         * @param scope
         * @param element
         * @param attrs
         * @param ctrl
         */
        function linkFn(scope, element, attrs, ctrl /**, transclude**/) {
            ctrl._linkInit();
        }
        /**
         * The directive's controller function
         * Added instead of using a Link function
         * Properties are bound on the Controller instance and available in the view
         *
         * @constructor
         */
        function FsMultiselectAutocompleteController($scope, $element, $attrs, $timeout) {
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.$timeout = $timeout;
            this._ctrlInit();
        }
        _.merge(FsMultiselectAutocompleteController.prototype, {
            _errMsg: 'fsMultiselectAutocomplete.directive: ',
            /**
             * Control init validations. Validates directive's arguments
             * @param errMsg
             * @private
             */
            _ctrlValidations: function (errMsg) {
                assert.isString(this.multiselectAutocompleteId, 'multiselectAutocompleteId', errMsg);
                assert.isString(this.label, 'label', errMsg, true);
                assert.isString(this.entity, 'entity', errMsg);
                assert.isString(this.textField, 'textField', errMsg);
                assert.isString(this.valueField, 'valueField', errMsg);
                assert.isString(this.queryTextField, 'queryTextField', errMsg, true);
                assert.isString(this.queryValueField, 'queryValueField', errMsg, true);
                assert.isFunction(this.fetchStateDelegate, 'fetchStateDelegate', errMsg);
                assert.isFunction(this.updateStateDelegate, 'updateStateDelegate', errMsg);
            },
            /**
             * Watch state function.
             *
             * @returns {*}
             * @private
             */
            _watchStateFn: function () {
                return this.fetchStateDelegate(this.multiselectAutocompleteId);
            },
            /**
             * Watch state action function.
             * Handles digestion of incoming state.
             *
             * @param state
             * @private
             */
            _watchStateActionFn: function (state) {
                if (state === null) {
                    return;
                }
                var ctrl = this;
                // Create query
                var query = {};
                if (ctrl.queryTextField) {
                    query[ctrl.queryTextField] = state;
                }
                // Get list of entities
                Restangular.all(ctrl.entity).getList(query)
                    .then(function (entities) {
                    // Add and select list of entities to multi select
                    var el = ctrl._getElementData();
                    var data = el.dataSource.data();
                    _.each(entities, function (entity) {
                        data.push(entity);
                    });
                    el.dataSource.data(data);
                    el.value(state.split(','));
                    // Register the state for future diff examination
                    ctrl._lastMultiselectValue = el.value();
                });
            },
            /**
             * Fires when 'control:reset' event is broadcasted.
             * It resets the control to its initial state and updates state.
             *
             * @param event
             * @param eventData
             * @private
             */
            _controlResetRequestHandler: function (event, eventData) {
                // Set the data array to empty array
                this._multiselectValue([]);
                this._setState(null);
                this._initMultiselect();
            },
            /**
             * Calculates the total of the returned entities. Used by multiselect options.
             *
             * @param {object} data
             * @returns {number}
             * @private
             */
            _multiselectOptionsTotal: function (data) {
                return (data.data && data.data.length) || 0;
            },
            /**
             * Mapper function to create a filter. Used by multiselect options.
             *
             * @param data
             * @param type
             * @returns {{} | undefined}
             * @private
             */
            _multiselectOptionsParameterMap: function (data, type) {
                if (!this.queryValueField) {
                    return;
                }
                if (type === 'read') {
                    if (data && data.filter && data.filter.filters &&
                        data.filter.filters[0]) {
                        var value = data.filter.filters[0].value;
                        var paramMap = {};
                        paramMap[this.queryValueField] = value;
                        return paramMap;
                    }
                }
            },
            /**
             * Multi select select handler. Used by multiselect options. Calcs the desired state
             * and sets it.
             *
             * @param {Object} e
             * @private
             */
            _multiselectOptionsSelectHandler: function (e) {
                var dataItem = e.sender.dataSource.view()[e.item.index()];
                var ids = this._multiselectValue();
                //detect if id is in ids
                if (!_.some(ids, function (id, index) {
                    // If item's id is in ids, splice it out
                    if (id === dataItem.id) {
                        ids.splice(index, 1);
                        return true;
                    }
                    return false;
                })) {
                    // If item's id is not in ids, put it in
                    ids.push(dataItem[this.valueField]);
                }
                this._setState(ids.join(','));
            },
            /**
             * Multi select change handler. Used by multiselect options. Finds if
             * there is a difference between the last registered value and the current.
             * If there's a difference then an item was removed, and state needs to be updated.
             *
             * @param e
             * @private
             */
            _multiselectOptionsChangeHandler: function (e) {
                var diff = _.difference(this._lastMultiselectValue || [], e.sender.value());
                if (diff.length > 0) {
                    var ids = this._multiselectValue();
                    this._setState(ids.join(','));
                }
                this._lastMultiselectValue = e.sender.value();
            },
            /**
             * Creates the multiselect options
             *
             * @private
             */
            _initMultiselectOptions: function () {
                var ctrl = this;
                this.multiselectOptions = {
                    placeholder: this.label ? this.label : 'Enter Text',
                    dataTextField: ctrl.textField,
                    dataValueField: ctrl.valueField,
                    valuePrimitive: true,
                    autoBind: false,
                    minLength: 3,
                    dataSource: {
                        type: 'odata',
                        serverFiltering: true,
                        schema: {
                            data: 'data',
                            total: ctrl._multiselectOptionsTotal
                        },
                        transport: {
                            read: {
                                url: '/fortscale-webapp/api/entities',
                                type: 'GET',
                                dataType: 'json'
                            },
                            parameterMap: ctrl._multiselectOptionsParameterMap.bind(ctrl)
                        }
                    },
                    select: ctrl._multiselectOptionsSelectHandler.bind(ctrl),
                    change: ctrl._multiselectOptionsChangeHandler.bind(ctrl),
                    filtering: function (e) {
                        // Make sure that backspace does not break the code
                        if (!e.filter || !e.filter.value) {
                            e.preventDefault();
                        }
                    }
                };
            },
            /**
             * Returns the multiselect api.
             *
             * @returns {*}
             * @private
             */
            _getElementData: function () {
                return this.multiselectAutocompleteSelectElement.data('kendoMultiSelect');
            },
            /**
             * Gets or sets the multiselect value.
             *
             * @param {Array=} val
             * @returns {Array}
             * @private
             */
            _multiselectValue: function (val) {
                // Get kendo element controller
                var kendoElementCtrl = this._getElementData();
                // Set value if value is provided
                if (!_.isNil(val)) {
                    kendoElementCtrl.value(val);
                    kendoElementCtrl.refresh();
                }
                return kendoElementCtrl.value();
            },
            _initMultiselect: function () {
                this.multiselectAutocompleteSelectElement = this.$element
                    .find('.multiselectAutocompleteSelect');
                this.multiselectAutocompleteSelectElement
                    .kendoMultiSelect(this.multiselectOptions);
            },
            /**
             * Initates all relevan watches.
             *
             * @private
             */
            _initWatches: function () {
                var ctrl = this;
                // Init state watch
                ctrl.$scope.$watch(ctrl._watchStateFn.bind(ctrl), ctrl._watchStateActionFn.bind(ctrl));
                ctrl.$scope.$on('control:reset', ctrl._controlResetRequestHandler.bind(ctrl));
            },
            /**
             * Sets state to state container
             *
             * @param {string} state
             * @private
             */
            _setState: function (state) {
                this.updateStateDelegate({
                    id: this.multiselectAutocompleteId,
                    immediate: this._immediate,
                    type: 'data',
                    value: state
                });
            },
            /**
             * Controller init function
             *
             * @private
             */
            _ctrlInit: function _ctrlInit() {
                this._ctrlValidations(this._errMsg + '_ctrlInit: ');
                this._immediate = this._immediate ? this._immediate : false; //this._immediate is false by default
            },
            /**
             * Link function init function
             *
             * @private
             */
            _linkInit: function () {
                // Init multiselect options
                this._initMultiselectOptions();
                // Init multiselect
                this._initMultiselect();
                // Init watches
                this._initWatches();
            }
        });
        FsMultiselectAutocompleteController.$inject = ['$scope', '$element', '$attrs', '$timeout'];
        return {
            restrict: 'E',
            templateUrl: 'app/shared/components/fs-multiselect-autocomplete/fs-multiselect-autocomplete.view.html',
            scope: {},
            controller: FsMultiselectAutocompleteController,
            controllerAs: 'multiselectAutocomplete',
            bindToController: {
                fetchStateDelegate: '=',
                updateStateDelegate: '=',
                multiselectAutocompleteId: '@',
                label: '@',
                entity: '@',
                textField: '@',
                valueField: '@',
                queryTextField: '@',
                queryValueField: '@',
                _immediate: '@?immediate',
            },
            link: linkFn
        };
    }
    fsMultiselectAutocomplete.$inject = ['assert', '$http', 'Restangular'];
    angular.module('Fortscale.shared.components.fsMultiselectAutocomplete', [
        'kendo.directives'
    ])
        .directive('fsMultiselectAutocomplete', fsMultiselectAutocomplete);
}());

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsSeverityTag;
            (function (fsSeverityTag) {
                var fsSeverityTagComponent = {
                    templateUrl: 'app/shared/components/fs-severity-tag/fs-severity-tag.component.html',
                    bindings: {
                        severity: '@'
                    }
                };
                angular.module('Fortscale.shared.components.fsSeverityTag', [])
                    .component('fsSeverityTag', fsSeverityTagComponent);
            })(fsSeverityTag = components.fsSeverityTag || (components.fsSeverityTag = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsNanobar;
            (function (fsNanobar) {
                var NanobarController = (function () {
                    function NanobarController($scope, $element, assert, fsNanobarAutomationService, $timeout) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.fsNanobarAutomationService = fsNanobarAutomationService;
                        this.$timeout = $timeout;
                        this.ERR_MSG = 'fsNanobarDirective: fsNanobarController: ';
                    }
                    NanobarController.prototype._validateId = function () {
                        this.assert.isString(this.nanobarId, this.ERR_MSG + "Directive must receive a nanobar Id.");
                    };
                    NanobarController.prototype._validateOptions = function () {
                        if (this.nanobarOptions) {
                            this.assert.isString(this.nanobarOptions.classname, 'nanobarOptions.classname', this.ERR_MSG, true);
                            this.assert.isString(this.nanobarOptions.id, 'nanobarOptions.id', this.ERR_MSG, true);
                            this.assert.isString(this.nanobarOptions.color, 'nanobarOptions.color', this.ERR_MSG, true);
                        }
                    };
                    /**
                     * Validates 'progress' argument.
                     * @private
                     */
                    NanobarController.prototype._validateProgress = function () {
                        this.assert(_.isNumber(this.nanobarProgress), this.ERR_MSG + "progress argument must be a number", TypeError);
                        this.assert(this.nanobarProgress >= 0, this.ERR_MSG + "progress argument must be => 0. its " + this.nanobarProgress, RangeError);
                        this.assert(this.nanobarProgress <= 100, this.ERR_MSG + "progress argument must be <= 100. its " + this.nanobarProgress, RangeError);
                    };
                    /**
                     * Updates progress to nanobar
                     * @private
                     */
                    NanobarController.prototype._updateProgress = function () {
                        if (this.nanobar) {
                            $(this.nanobar.el).find('.bar').css({ backgroundColor: this.nanobarOptions.color || '#000000' });
                            this.nanobar.go(this.nanobarProgress);
                        }
                    };
                    /**
                     * Handler for 'progress' change
                     * @private
                     */
                    NanobarController.prototype._progressHandler = function () {
                        var _this = this;
                        if (this.nanobarProgress === null || this.nanobarProgress === undefined) {
                            return;
                        }
                        // validate progress
                        this._validateProgress();
                        this._updateProgress();
                        if (this.nanobarProgress === 100) {
                            this.$timeout(function () {
                                if (_this.nanobarProgress === 100) {
                                    _this.fsNanobarAutomationService.reset(_this.nanobarId);
                                }
                            }, 1000);
                        }
                    };
                    /**
                     * Creates a nanobar options. target is taken from the provided options or from the element
                     * @returns {INanobarOptions}
                     * @private
                     */
                    NanobarController.prototype._createNanobarOptions = function () {
                        if (this.nanobarOptions) {
                            // Copy options
                            var options = _.merge({}, this.nanobarOptions);
                            // decide on target element. If not targetGlobal then target is either explicit or parent of element
                            if (!this.nanobarOptions.targetGlobal) {
                                options.target = (this.nanobarOptions || {}).target || this.$element.parent()[0];
                            }
                            return options;
                        }
                    };
                    /**
                     * Set the bar color if received in options
                     * @private
                     */
                    NanobarController.prototype._setBarColor = function () {
                        // Set color
                        if (this.nanobarOptions && this.nanobarOptions.color) {
                            $(this.nanobar.el).find('.bar').css('background-color', this.nanobarOptions.color);
                        }
                    };
                    /**
                     * Creates a nanobar instance
                     */
                    NanobarController.prototype.renderNanobar = function () {
                        var nanobarOptions = this._createNanobarOptions();
                        this.nanobar = new Nanobar(nanobarOptions);
                        this._setBarColor();
                    };
                    NanobarController.prototype.updateProgress = function (progress) {
                        this.nanobarProgress = progress;
                        this._progressHandler();
                    };
                    NanobarController.prototype.$onInit = function () {
                        var _this = this;
                        // Validations
                        this._validateId();
                        this._validateOptions();
                        this.fsNanobarAutomationService.addNanobar(this.nanobarId, this);
                        // init cleanup
                        this.$scope.$on('$destroy', function () {
                            $(_this.nanobar.el).remove();
                            _this.nanobar = null;
                        });
                    };
                    ;
                    NanobarController.$inject = ['$scope', '$element', 'assert', 'fsNanobarAutomationService', '$timeout'];
                    return NanobarController;
                }());
                var linkFn = function (scope, instanceElement, instanceAttributes, controller, transclude) {
                    controller.renderNanobar();
                };
                var fsNanobarFn = function () {
                    var nanobarDirective = {
                        controller: NanobarController,
                        controllerAs: 'nanobarCtrl',
                        bindToController: {
                            nanobarId: '@',
                            // nanobarProgress: '<',
                            nanobarOptions: '<'
                        },
                        link: linkFn
                    };
                    return nanobarDirective;
                };
                angular.module('Fortscale.shared.components.fsNanobar', [])
                    .directive('fsNanobar', fsNanobarFn);
            })(fsNanobar = components.fsNanobar || (components.fsNanobar = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function FsScoreIcon() {
        function linkFn(scope, element, attr, ctrl) {
            element.addClass(ctrl._getScoreRangeClass(ctrl.score));
            if (ctrl.score) {
                element.parent().attr('title', 'score: ' + ctrl.score);
            }
        }
        function FsScoreIconController() {
        }
        _.merge(FsScoreIconController.prototype, {
            /**
             * Holds the color ranges. gte -> greater then or equal
             */
            _scoreRanges: [
                {
                    gte: 95,
                    className: 'fs-score-icon-red'
                },
                {
                    gte: 80,
                    className: 'fs-score-icon-orange'
                },
                {
                    gte: 50,
                    className: 'fs-score-icon-yellow'
                }
            ],
            /**
             * Takes a score, and iterates through _scoreRanges to find the first condition it
             * matches. Once a match is made, _scoreRanges.className is returned.
             * If no match is found, fs-score-icon-hide is returned
             *
             * @param {number} score
             * @returns {string}
             * @private
             */
            _getScoreRangeClass: function (score) {
                var scoreRangeClass = 'fs-score-icon-hide';
                _.some(this._scoreRanges, function (scoreRange) {
                    if (score >= scoreRange.gte) {
                        scoreRangeClass = scoreRange.className;
                        return true;
                    }
                    return false;
                });
                return scoreRangeClass;
            }
        });
        FsScoreIconController.$inject = [];
        return {
            restrict: 'E',
            replace: true,
            template: '<div class="fs-score-icon" title="{{\'Score: \' + scoreIcon.score}}">' +
                '<i class="fa fa-square"></i></div>',
            link: linkFn,
            scope: {},
            controller: FsScoreIconController,
            controllerAs: 'scoreIcon',
            bindToController: {
                score: '='
            }
        };
    }
    FsScoreIcon.$inject = [];
    angular.module('Fortscale.shared.components.fsScoreIcon', [])
        .directive('fsScoreIcon', FsScoreIcon);
}());

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsCardHeader;
            (function (fsCardHeader) {
                var CardHeaderController = (function () {
                    function CardHeaderController() {
                    }
                    return CardHeaderController;
                }());
                var CardHeaderComponent = {
                    controller: CardHeaderController,
                    bindings: {
                        cardTitle: '@'
                    },
                    templateUrl: 'app/shared/components/fs-card-header/fs-card-header.component.html'
                };
                angular.module('Fortscale.shared.components')
                    .component('fsCardHeader', CardHeaderComponent);
            })(fsCardHeader = components.fsCardHeader || (components.fsCardHeader = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart', []);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.general', {
        chart: {
            plotBackgroundColor: null,
            plotBorderWidth: null,
            plotShadow: false
        },
        credits: {
            enabled: false
        }
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.pie', {
        chart: {
            type: 'pie'
        },
        tooltip: {
            pointFormat: '</div>{series.name}: <b>{point.y}</b>',
            backgroundColor: 'rgba(245, 245, 245, 0.8)'
        },
        plotOptions: {
            pie: {
                allowPointSelect: true,
                cursor: 'pointer',
                dataLabels: {
                    enabled: true,
                    format: '<span class="pie-chart-data-label">{point.name}: ' +
                        '<span style="color: blue;">{point.y}</span>' +
                        ' ({point.percentage:.1f} %)<span>',
                    shadow: false,
                    useHTML: false,
                    style: {
                        textShadow: false,
                        fontFamily: '"Open Sans", sans-serif'
                    }
                }
            }
        },
        series: [{
                "colorByPoint": true
            }]
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.heatmap', {
        chart: {
            type: 'heatmap'
        },
        tooltip: {
            pointFormat: 'Logged in <b>{point.value}</b> times'
        },
        series: [{
                borderWidth: 1,
                dataLabels: {
                    enabled: true,
                    color: '#fff',
                    style: {
                        textShadow: '1px 1px 0 #777, -1px -1px 0 #777'
                    }
                }
            }]
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.column', {
        chart: {
            type: 'column'
        },
        legend: {
            enabled: false
        },
        xAxis: {
            type: 'category',
            labels: {
                style: {
                    fontSize: '12px',
                    fontFamily: 'Verdana, sans-serif'
                }
            }
        },
        tooltip: {
            enabled: false
        },
        plotOptions: {
            column: {
                cursor: 'pointer',
                dataLabels: {
                    enabled: true,
                    style: {
                        textShadow: ''
                    },
                    useHTML: true
                }
            },
            series: {
                color: '#373298'
            }
        }
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.scatter', {
        chart: {
            type: 'scatter',
            zoomType: 'xy'
        },
        legend: {
            enabled: false
        },
        tooltip: {
            pointFormat: '{series.name}: <b>{point.y}</b>'
        },
        plotOptions: {
            scatter: {
                marker: {
                    radius: 3,
                    states: {
                        hover: {
                            enabled: true,
                            lineColor: 'rgba(143,189.228,0.5)'
                        }
                    }
                },
                states: {
                    hover: {
                        marker: {
                            enabled: false
                        }
                    }
                }
            }
        },
        series: [{
                turboThreshold: 4000
            }],
        xAxis: [{
                type: 'datetime',
                color: 'rgba(143,189.228,0.5)',
                startOnTick: false,
                lineWidth: 0,
                minorGridLineWidth: 0,
                lineColor: 'transparent',
                minorTickLength: 0,
                tickLength: 0
            }],
        yAxis: {
            minTickInterval: 1
        }
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.columnRange', {
        chart: {
            type: 'columnrange'
        },
        legend: {
            enabled: false
        },
        colors: [
            'rgba(103, 132, 185, 0.8)',
            'rgba(195, 124, 183, 0.8)',
            'rgba(245, 164, 153, 0.8)',
            'rgba(176, 199, 94, 0.8)',
            'rgba(242, 196, 70, 0.8)',
            'rgba(103, 185, 181, 0.8)',
            'rgba(233, 152, 72, 0.8)',
            'rgba(162, 141, 214, 0.8)',
            'rgba(143, 189, 228, 0.8)',
            'rgba(129, 206, 158, 0.8)'
        ],
        plotOptions: {
            series: {
                colorByPoint: true,
                pointWidth: 20
            }
        },
        xAxis: {
            type: 'category',
            labels: {
                style: {
                    fontSize: '12px',
                    fontFamily: '\'Roboto\', sans-serif',
                    color: '#818285'
                }
            }
        },
        yAxis: {
            labels: {
                style: {
                    fontSize: '12px',
                    fontFamily: '\'Roboto\', sans-serif',
                    color: '#818285'
                }
            }
        },
        tooltip: {
            enabled: false
        }
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsChart')
        .value('fsChart.settings.line', {
        series: [
            {
                data: []
            }
        ]
    });
}());

(function () {
    'use strict';
    function ChartModelMapping() {
    }
    _.merge(ChartModelMapping.prototype, {
        /**
         * An adapter that takes the data model and creates a new array with new objects
         * that are mapped according to the provided mapObject.
         *
         * @param {object} mapObject
         * @param {Array<object>} data
         * @returns {Array<object>}
         */
        mapData: function (mapObject, data) {
            // Return a map
            return _.map(data, function (dataRow) {
                // Create a new object for each member in the array
                var obj = {};
                // Iterate through the map object, and attach a new property to obj
                // for each property on mapObject
                _.each(mapObject, function (mapProp, key) {
                    // When the map property value is a string,
                    // use key as prop name on the new obj, and then use the string value
                    // as key name for dataRow, and set the value to the object.
                    // Example: if mapObject is {y: 'count'} then new object will be:
                    // {y: dataRow.count}
                    if (_.isString(mapProp)) {
                        obj[key] = dataRow[mapProp];
                    }
                    else if (_.isObject(mapProp)) {
                        // If mapProp is an object, this means that we need to do something
                        // more complex then simple mapping.
                        // The value of the map property should be an object
                        // that has two properties: key, fn. Key will be the key on dataRow,
                        // and fn will be a function that takes:
                        // dataRow[mapProp.key], dataRow, data, mapProp
                        // and should return a value. That value will be set to obj.
                        obj[key] = mapProp.fn(dataRow[mapProp.key], dataRow, data, mapObject);
                    }
                    else {
                        // This will throw if mapProp is not a string or an object.
                        throw new Error('map property must be a string or an object.');
                    }
                    if (obj[key] === undefined) {
                        delete obj[key];
                    }
                });
                return obj;
            });
        }
    });
    ChartModelMapping.$inject = [];
    angular.module('Fortscale.shared.components.fsChart')
        .service('chartModelMapping', ChartModelMapping);
}());

(function () {
    'use strict';
    function ChartSettings($injector) {
        this.$injector = $injector;
    }
    _.merge(ChartSettings.prototype, {
        getSettings: function (type, settings) {
            var generalSettings = this.$injector.get('fsChart.settings.general');
            var defaultSettings = this.$injector.get('fsChart.settings.' + type);
            settings = settings || {};
            return _.merge({}, generalSettings, defaultSettings, settings);
        }
    });
    ChartSettings.$inject = ['$injector'];
    angular.module('Fortscale.shared.components.fsChart')
        .service('chartSettings', ChartSettings);
}());

(function () {
    'use strict';
    function fsChartDirective(assert, chartSettings, chartModelMapping) {
        var errorMsg = 'fsChart.directive: ';
        /**
         * Controller constructor
         *
         * @constructor
         */
        function FsChartController($scope, $element, $attrs) {
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.init();
        }
        angular.extend(FsChartController.prototype, {
            /**
             * Validations
             */
            /**
             * @param {string=} errorMsg
             * @private
             */
            _validateModel: function (errorMsg) {
                errorMsg = errorMsg || '';
                // model should be an array
                assert(_.isArray(this._model), errorMsg + 'provided model must be an array.', TypeError);
            },
            /**
             * @param {string=} errorMsg
             * @private
             */
            _validateSettings: function (errorMsg) {
                errorMsg = errorMsg || '';
                // Settings - if provided - should be an object.
                assert(_.isObject(this.settings), errorMsg + 'provided settings must be an object.', TypeError);
            },
            _validateMapSettings: function (errorMsg) {
                errorMsg = errorMsg || '';
                // Settings - if provided - should be an object.
                if (this._mapSettings) {
                    assert(_.isObject(this._mapSettings), errorMsg + 'provided map settings must be an object.', TypeError);
                }
            },
            _validateStyleSettings: function (errorMsg) {
                errorMsg = errorMsg || '';
                // Settings - if provided - should be an object.
                if (this._styleSettings) {
                    assert(_.isObject(this._styleSettings), errorMsg + 'provided style settings must be an object.', TypeError);
                }
            },
            /**
             * Validates a required string type attribute
             *
             * @param {string} name
             * @param {string=} errorMsg
             * @private
             */
            _validateString: function (name, errorMsg) {
                errorMsg = errorMsg || '';
                // should be provided
                assert(!_.isUndefined(this[name]), errorMsg + name + ' must be provided in the directive html declaration.', ReferenceError);
                // should be a string
                assert(_.isString(this[name]), errorMsg + 'provided ' + name + ' must be a string.', TypeError);
                // should not be an empty string
                assert(this[name] !== '', errorMsg + 'provided ' + name + ' must not be an empty string.', RangeError);
            },
            /**
             * Runs through required directive validations
             *
             * @param {string=} errorMsg
             * @private
             */
            _validations: function (errorMsg) {
                errorMsg = errorMsg || '';
                this._validateSettings(errorMsg);
                this._validateMapSettings(errorMsg);
                this._validateStyleSettings(errorMsg);
                this._validateString('_chartType', errorMsg);
            },
            /**
             * Init functions
             */
            /**
             * Initiates settings. These are common pie chart settings and can be overridden.
             *
             * @private
             */
            _initSettings: function () {
                this._settings = chartSettings.getSettings(this._chartType, this.settings);
            },
            /**
             * Sets style object to be used for styling the graphs container
             *
             * @private
             */
            _initStyling: function () {
                this._containerStyle = _.merge({
                    'minWidth': '25%', 'width': 'auto', 'maxWidth': '100%', margin: '0 auto', height: '20vw'
                }, this._styleSettings);
            },
            /**
             * Watch functions
             */
            /**
             * watch function. returns _model. Will cause _watchModelAction (implicitly) to fire
             * when _model changes.
             *
             * @returns {*}
             * @private
             */
            _watchModel: function () {
                return this._model;
            },
            /**
             * watch model action. When _model changes, the directive will render the graph.
             *
             * @param {*} newVal
             * @private
             */
            _watchModelAction: function (newVal) {
                // Only render if newVal exists
                if (newVal !== undefined) {
                    this._validateModel(errorMsg + '_watchModelAction: ');
                    this._render();
                }
            },
            /**
             * Set a $watch for _model
             *
             * @private
             */
            _initModelWatch: function () {
                this.$scope.$watch(this._watchModel.bind(this), this._watchModelAction.bind(this));
            },
            /**
             * Creates a timeout that is cleared on the next invocation, which creates a throttle.
             * After 500ms fires _resizeHandler
             *
             * @private
             */
            _watchResizeAction: function () {
                clearTimeout(this._preResizeTimeout);
                this._preResizeTimeout = setTimeout(this._resizeHandler.bind(this), 200);
            },
            /**
             * Redraws the chart.
             *
             * @private
             */
            _resizeHandler: function () {
                // Remove animation from settings
                var settings = _.merge({}, this._settings, {
                    plotOptions: {
                        series: {
                            animation: false
                        }
                    }
                });
                // Redraw table
                this._chartContainer.highcharts(settings);
            },
            /**
             * Should rerender the chart when resize has finished
             *
             * @private
             */
            _initResizeWatch: function () {
                var ctrl = this;
                function resizeAction() {
                    ctrl._watchResizeAction();
                }
                window.addEventListener('resize', resizeAction, false);
                // Cleanup
                ctrl.$scope.$on('$destroy', function () {
                    window.removeEventListener('resize', resizeAction, false);
                });
            },
            /**
             * Initiates watches
             *
             * @private
             */
            _initWatches: function () {
                this._initModelWatch();
                this._initResizeWatch();
            },
            /**
             * Takes generic data list, and by using _mapName and _mapY it creates a new list of
             * objects that is given as data to the chart.
             *
             * @param {array} dataList
             * @returns {array}
             * @private
             */
            _mapData: function (dataList) {
                if (this._mapSettings) {
                    return chartModelMapping.mapData(this._mapSettings, dataList);
                }
                return dataList;
            },
            /**
             * Processes the data and renders the chart.
             *
             * @private
             */
            _render: function () {
                // Sometimes highcharts does not render the chart. We use $applyAsync to delay
                // render till the end of the current digest cycle, giving highchart the time
                // it needs.
                this.$scope.$applyAsync(function () {
                    // If no series, create an empty array
                    this._settings.series = this._settings.series || [];
                    if (this._settings.isMultiSeries) {
                        this._settings.series = _.map(this._model, _.bind(function (serie) {
                            var obj = {};
                            if (serie.name) {
                                obj.name = serie.name;
                            }
                            if (serie.color) {
                                obj.color = serie.color;
                            }
                            if (serie.data) {
                                obj.data = this._mapData(serie.data);
                            }
                            return obj;
                        }, this));
                    }
                    else {
                        this._settings.series[0].data = this._mapData(this._model);
                    }
                    this._chartContainer.highcharts(this._settings);
                }.bind(this));
            },
            /**
             * A deep merge of received settings with default settings.
             * The received settings take precedence.
             *
             * @private
             */
            _mergeExternalSettings: function () {
                _.merge(this._settings, this.settings);
            },
            /**
             * The init function.
             */
            init: function init() {
                this._chartContainer = this.$element.find('.container');
                this._validations(errorMsg + 'init: ');
                this._initSettings();
                this._initStyling();
                this._mergeExternalSettings();
                this._initWatches();
            }
        });
        FsChartController.$inject = ['$scope', '$element', '$attrs'];
        return {
            templateUrl: 'app/shared/components/fs-chart/fs-chart.view.html',
            restrict: 'E',
            scope: true,
            controller: FsChartController,
            controllerAs: 'chart',
            bindToController: {
                _chartType: '@chartType',
                _mapSettings: '=mapSettings',
                settings: '=',
                _styleSettings: '=styleSettings',
                _model: '=model'
            }
        };
    }
    fsChartDirective.$inject = ['assert', 'chartSettings', 'chartModelMapping'];
    angular.module('Fortscale.shared.components.fsChart')
        .directive('fsChart', fsChartDirective);
}());

(function () {
    'use strict';
    function FsUserTagDetails() {
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsUserTagDetailsController($scope, $element, $attrs) {
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
        }
        FsUserTagDetailsController.$inject = ['$scope', '$element', '$attrs'];
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'app/shared/directives/fs-user-tag-details/fs-user-tag-details.html',
            scope: {},
            controller: FsUserTagDetailsController,
            controllerAs: 'details',
            bindToController: {
                bottomLabel: '@',
                rightLeftCornerLabel: '@',
                imgSrc: '@',
                tagHref: '@'
            }
        };
    }
    FsUserTagDetails.$inject = [];
    angular.module('Fortscale.shared.directives.fsUserTagDetails', [])
        .directive('fsUserTagDetails', FsUserTagDetails);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsResourceStore', [
        'Fortscale.shared.services.assert'
    ]);
}());

(function () {
    'use strict';
    function FsResourceStore(fsResourceStoreService) {
        /**
         * Controller constructor
         *
         * @param $scope
         * @constructor
         */
        function FsResourceController($scope) {
            this.$scope = $scope;
            this.init();
        }
        _.merge(FsResourceController.prototype, {
            /**
             * resource watch function.
             *
             * @returns {*}
             *
             * @private
             */
            _resourceWatchFn: function () {
                return this._resource;
            },
            /**
             * resource watch action function. Invokes fsResourceStoreService.storeResource with
             * the resource.
             *
             * @param {*} resource
             * @private
             */
            _resourceWatchActionFn: function (resource) {
                if (resource !== undefined) {
                    fsResourceStoreService.storeResource(this._resourceName, resource, !!this._purgeOnExpire);
                }
            },
            /**
             * Initiates resource watch
             *
             * @private
             */
            _initResourceWatch: function () {
                this.$scope.$watch(this._resourceWatchFn.bind(this), this._resourceWatchActionFn.bind(this));
            },
            /**
             * Initiate all watches
             *
             * @private
             */
            _initWatches: function () {
                this._initResourceWatch();
            },
            /**
             * Controller init function.
             */
            init: function () {
                this._initWatches();
            }
        });
        FsResourceController.$inject = ['$scope'];
        return {
            restrict: 'E',
            scope: {},
            controller: FsResourceController,
            controllerAs: 'fsResource',
            bindToController: {
                _resourceName: '@resourceName',
                _resource: '=resource',
                _purgeOnExpire: '@purgeOnExpire'
            }
        };
    }
    FsResourceStore.$inject = ['fsResourceStore'];
    angular.module('Fortscale.shared.components.fsResourceStore')
        .directive('fsResourceStore', FsResourceStore);
}());

(function () {
    'use strict';
    function FsResourceStoreProvider() {
        /**
         * Determines the expiration duration. Defaults to one hour in milliseconds.
         *
         * @type {number}
         * @private
         */
        var _expireDuration = 1000 * 60 * 60;
        /**
         * Sets the expiration duration.
         *
         * @param {number} duration
         */
        this.setExpireDuration = function (duration) {
            _expireDuration = duration;
        };
        /**
         * Gets the expiration duration.
         *
         * @returns {number}
         */
        this.getExpireDuration = function () {
            return _expireDuration;
        };
        /**
         * Flag that states if the resource should be purged on expiration. Defaults to false.
         *
         * @type {boolean}
         * @private
         */
        var _purgeOnExpire = false;
        /**
         * Sets purge on expire flag.
         *
         * @param {boolean} val
         */
        this.setPurgeOnExpire = function (val) {
            _purgeOnExpire = val;
        };
        /**
         * Gets purge on expire flag.
         *
         * @returns {boolean}
         */
        this.getPurgeOnExpire = function () {
            return _purgeOnExpire;
        };
        /**
         *
         * @constructor
         */
        function FsResourceStoreService(assert) {
            /**
             * Holds all the reources.
             *
             * @private
             */
            this._resources = {};
            /**
             * Checks if a resource is expired.
             *
             * @param {object} resourceWrapper
             * @returns {boolean}
             * @private
             */
            this._isExpired = function (resourceWrapper) {
                var now = new Date();
                return (resourceWrapper.updateTime.valueOf() + _expireDuration < now.valueOf());
            };
            /**
             *
             * @param {string} resourceName
             * @param {object} resource
             * @param {boolean=} purgeOnExpire
             */
            this.storeResource = function (resourceName, resource, purgeOnExpire) {
                if (purgeOnExpire === undefined) {
                    purgeOnExpire = _purgeOnExpire;
                }
                this._resources[resourceName] = {
                    updateTime: new Date(),
                    resource: resource,
                    purgeOnExpire: purgeOnExpire
                };
            };
            /**
             * Gets a resource by its name. If expired and purgeOnExpire is true,
             * the resource is purged, and null is returned. If expired an purgeOnExpire is false,
             * a '_isExpired' property will be added to the resource and set to true.
             * If no resource is found, null is returned.
             *
             * @param {string} resourceName
             * @returns {object|null}
             */
            this.fetchResource = function (resourceName) {
                // Get the resource
                var resourceWrapper = this._resources[resourceName];
                // if no resource is found return null
                if (!resourceWrapper) {
                    return null;
                }
                // If resource is expired
                if (this._isExpired(resourceWrapper)) {
                    // If purgeOnExpire is true, delete the resource and return null
                    if (resourceWrapper.purgeOnExpire) {
                        delete this._resources[resourceName];
                        return null;
                    }
                    // If pureOnExpire is false, add '_isExpired' property to resource
                    resourceWrapper.resource._isExpired = true;
                }
                // Return the resource
                return resourceWrapper.resource;
            };
            /**
             * Returns a specific resource item by its id. It fetches the resource by its name.
             * If resource is null, null is returned.
             * The resource is queried for a specific resource item, and if a resource is not found,
             * null is returned. If resource is expired, _isExpired will be added to the resource
             * item.
             *
             * @param {string} resourceName
             * @param {string} resourceId
             * @param {string=} idKey Defaults to 'id'
             * @returns {* | null}
             */
            this.fetchResourceItemById = function (resourceName, resourceId, idKey) {
                // set idKey default value if false
                idKey = idKey || 'id';
                // Get the resource
                var resource = this.fetchResource(resourceName);
                // If resource is null return null
                if (resource === null) {
                    return null;
                }
                // Build the query
                var query = {};
                query[idKey] = resourceId;
                // Get resource item
                var resourceItem = _.find(resource, query);
                // If resourceItem is undefined return null
                if (resourceItem === undefined) {
                    return null;
                }
                // If resource is expired, set _isExpired on resourceItem
                if (resource._isExpired) {
                    resourceItem._isExpired = true;
                }
                // Return the resourceItem
                return resourceItem;
            };
        }
        this.$get = ['assert', function (assert) {
                return new FsResourceStoreService(assert);
            }];
    }
    angular.module('Fortscale.shared.components.fsResourceStore')
        .provider('fsResourceStore', FsResourceStoreProvider);
}());

(function () {
    'use strict';
    function fsHrefAlertDirective(indicatorTypeMapper) {
        function linkFn($scope, $element, $attr, ctrl) {
            // Set mouseClickHandler. Its set as an instance method so it will have the ctrl in its
            // context
            ctrl.mouseClickHandler = function () {
                var alert = ctrl.alertModel;
                var subRoute = $attr.subRoute;
                // Set the element's href
                $element.attr('href', ctrl._getInvestigateHref(alert, subRoute));
            };
            ctrl._init();
        }
        /**
         *
         * @param $scope
         * @param $element
         * @constructor
         */
        function FsHrefAlertController($scope, $element) {
            this.$scope = $scope;
            this.$element = $element;
        }
        _.merge(FsHrefAlertController.prototype, {
            /**
             * Generates a url for the <a>'s href. It uses the
             *
             * @param {object} alert
             * @returns {string}
             */
            _getInvestigateHref: function (alert, subRoute) {
                var indicators = _.orderBy(alert.evidences, 'startDate', 'desc');
                var indicator = this.indicatorModel || indicators[0];
                return indicatorTypeMapper.getTargetUrl(alert.id, indicator, undefined, subRoute);
            },
            /**
             * Initiates watches on the element. Watch for click and context menu. On either
             * populates href attribute.
             *
             * @private
             */
            _initWatches: function () {
                this.$element.on('click', this.mouseClickHandler);
                this.$element.on('contextmenu', this.mouseClickHandler);
                // Cleanup watch
                this.$scope.$on('$destroy', this._watchCleanup.bind(this));
            },
            /**
             * Removes watches
             *
             * @private
             */
            _watchCleanup: function () {
                this.$element.off('click', this.mouseClickHandler);
                this.$element.off('contextmenu', this.mouseClickHandler);
            },
            _init: function () {
                this._initWatches();
            }
        });
        FsHrefAlertController.$inject = ['$scope', '$element'];
        return {
            restrict: 'A',
            link: linkFn,
            controller: FsHrefAlertController,
            controllerAs: 'hrefAlertCtrl',
            bindToController: {
                alertModel: '=',
                indicatorModel: '=',
                subRoute: '@'
            }
        };
    }
    fsHrefAlertDirective.$inject = ['indicatorTypeMapper'];
    angular.module('Fortscale.shared.directives.fsHrefAlert', [])
        .directive('fsHrefAlert', fsHrefAlertDirective);
}());

(function () {
    'use strict';
    angular.module('Fortscale.shared.components.fsFlag', []);
}());

(function () {
    'use strict';
    function fsFlagDirective(countryCodesUtil) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         */
        function linkFn(scope, element, attrs) {
            // Link function logic
            var alpha2Code = scope.ctrl._getAlpha2Code();
            if (alpha2Code) {
                element.addClass('flag-icon-' + alpha2Code);
            }
            if (!!scope.ctrl.squared) {
                element.addClass('flag-icon-squared');
            }
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsFlagController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsFlagController.prototype, {
            /**
             * Returns alpha-2 code from directive statement
             *
             * @returns {String|null}
             * @private
             */
            _getAlpha2Code: function () {
                var ctrl = this;
                var alpha2Code = null;
                if (ctrl.countryName) {
                    alpha2Code = countryCodesUtil.getAlpha2ByCountryName(ctrl.countryName);
                }
                else if (ctrl.countryCode) {
                    alpha2Code = countryCodesUtil.getAlpha2ByCountryCode(ctrl.countryCode);
                }
                else if (ctrl.countryAlpha2) {
                    alpha2Code = ctrl.countryAlpha2;
                }
                alpha2Code = alpha2Code ? alpha2Code.trim().toLowerCase() : null;
                return alpha2Code;
            },
            /**
             * Init
             */
            init: function init() {
                // Init logic
            }
        });
        FsFlagController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            template: '<div class="fs-flag flag-icon"></div>',
            replace: true,
            scope: {},
            link: linkFn,
            controller: FsFlagController,
            controllerAs: 'ctrl',
            bindToController: {
                countryName: '@',
                countryAlpha2: '@',
                countryCode: '@',
                squared: '@'
            }
        };
    }
    fsFlagDirective.$inject = ['countryCodesUtil'];
    angular.module('Fortscale.shared.components.fsFlag')
        .directive('fsFlag', fsFlagDirective);
}());

var fortscale;
(function (fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsHeaderBar;
            (function (fsHeaderBar) {
                var FsHeaderBarController = (function () {
                    function FsHeaderBarController($element, $scope, userUtils, $state, auth, stateManagementService) {
                        var _this = this;
                        this.$element = $element;
                        this.$scope = $scope;
                        this.userUtils = userUtils;
                        this.$state = $state;
                        this.auth = auth;
                        this.stateManagementService = stateManagementService;
                        // Defined in constructor so the 'this' will be bound to the instance
                        this.goToUserProfile = function (updateObj) {
                            // Clear user search control
                            $('#main_user_search').find('input').val('');
                            // Go to state
                            _this.$state.go('user.baseline', { userId: updateObj.value });
                        };
                    }
                    FsHeaderBarController.prototype._initSettingsMenu = function () {
                        var el = this.$element.find('.fs-header-bar-component--icons-container--settings-menu');
                        el.kendoMenu({});
                    };
                    FsHeaderBarController.prototype._initUserControllSettings = function () {
                        var ctrl = this;
                        ctrl.userControlSettings = {
                            dataValueField: 'id',
                            dataTextField: 'fallBackDisplayName',
                            /**
                             * Takes received users and creates fallBack display name for each, and prevents duplications.
                             * @param users
                             */
                            dataTextFn: function (users) {
                                ctrl.userUtils.setFallBackDisplayNames(users);
                                ctrl.userUtils.preventFallBackDisplayNameDuplications(users);
                            },
                            placeholder: 'Search User'
                        };
                    };
                    FsHeaderBarController.prototype._initUserControlResource = function () {
                        this.userControlResource = {
                            entity: 'user',
                            params: {
                                page: 1,
                                size: 10,
                                sort_field: 'displayName',
                                sort_direction: 'ASC',
                                search_field_contains: '{{search}}'
                            }
                        };
                    };
                    FsHeaderBarController.prototype.toggleSearch = function () {
                        this.searchBoxElement.toggleClass('active');
                        // Set focus to search
                        if (this.searchBoxElement.hasClass('active')) {
                            this.searchBoxElement.find('input').focus();
                        }
                    };
                    FsHeaderBarController.prototype.closeSearch = function () {
                        this.searchBoxElement.removeClass('active');
                    };
                    FsHeaderBarController.prototype.logout = function () {
                        var stateManagementService = this.stateManagementService;
                        stateManagementService.clearAllStates();
                        this.auth.logout();
                    };
                    FsHeaderBarController.prototype.$onInit = function () {
                        this._initUserControllSettings();
                        this._initUserControlResource();
                        this._initSettingsMenu();
                        this.searchBoxElement = this.$element.find('.main-user-search');
                        this.$scope.$root.$on('$stateChangeSuccess', this.closeSearch.bind(this));
                    };
                    FsHeaderBarController.$inject = ['$element', '$scope', 'userUtils', '$state', 'auth', 'stateManagementService'];
                    return FsHeaderBarController;
                }());
                var fsHeaderBarComponent = {
                    templateUrl: 'app/shared/components/fs-header-bar/fs-header-bar.component.html',
                    controller: FsHeaderBarController,
                    bindings: {
                        loggedInUser: '<'
                    }
                };
                angular.module('Fortscale.shared.components')
                    .component('fsHeaderBar', fsHeaderBarComponent);
            })(fsHeaderBar = components.fsHeaderBar || (components.fsHeaderBar = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = fortscale.shared || (fortscale.shared = {}));
})(fortscale || (fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsLoader;
            (function (fsLoader) {
                var LOADER_SHOW_FIELD_NAME = 'loaderShow';
                var LOADER_COLOR_FIELD_NAME = 'loaderColor';
                var LOADER_MASK_COLOR_FIELD_NAME = 'loaderMaskColor';
                var SPINNER_SELECTOR = '.fs-loader-spinner';
                var MASK_OVERLAY_SELECTOR = '.fs-loader-overlay';
                var FsLoaderController = (function () {
                    function FsLoaderController() {
                    }
                    return FsLoaderController;
                }());
                function fsLoaderDirectiveFunction() {
                    var fsLoaderDirective = {
                        templateUrl: 'app/shared/components/fs-loader/fs-loader.component.html',
                        controller: FsLoaderController,
                        controllerAs: '$ctrl',
                        bindToController: (_a = {},
                            _a[LOADER_SHOW_FIELD_NAME] = '<',
                            _a[LOADER_COLOR_FIELD_NAME] = '@',
                            _a[LOADER_MASK_COLOR_FIELD_NAME] = '@',
                            _a
                        ),
                        compile: function (templateElement, templateAttributes) {
                            // Set box color
                            if (templateAttributes[LOADER_COLOR_FIELD_NAME]) {
                                var cubes = templateElement.find(SPINNER_SELECTOR);
                                cubes.css('background-color', templateAttributes[LOADER_COLOR_FIELD_NAME]);
                            }
                            // Set mask color
                            if (templateAttributes[LOADER_MASK_COLOR_FIELD_NAME]) {
                                var mask = templateElement.find(MASK_OVERLAY_SELECTOR);
                                mask.css('background-color', templateAttributes[LOADER_MASK_COLOR_FIELD_NAME]);
                            }
                            return {};
                        }
                    };
                    return fsLoaderDirective;
                    var _a;
                }
                angular.module('Fortscale.shared.components')
                    .directive('fsLoader', fsLoaderDirectiveFunction);
            })(fsLoader = components.fsLoader || (components.fsLoader = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsSvgIcon;
            (function (fsSvgIcon) {
                var ERR_MSG = 'fsSvgIcon.directive: ';
                var SVGIconController = (function () {
                    function SVGIconController($scope, $element, assert) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                    }
                    /**
                     * Adds '#' to symbol name
                     * @private
                     */
                    SVGIconController.prototype._setSymbolNameSelector = function () {
                        this.symbolNameSelector = '#' + this.symbolName;
                    };
                    /**
                     * Takes the attributes object, iterates and sets attributes on the svg element
                     * @private
                     */
                    SVGIconController.prototype._assignAttributes = function () {
                        if (this.attributes) {
                            this.$element.find('svg').attr(this.attributes);
                        }
                    };
                    SVGIconController.prototype.$onInit = function () {
                        this.assert.isString(this.symbolName, 'symbolName', ERR_MSG + 'init: ', false, false);
                        this.assert.isObject(this.attributes, 'attributes', ERR_MSG + 'init: ', true);
                        this._setSymbolNameSelector();
                        this._assignAttributes();
                    };
                    SVGIconController.$inject = ['$scope', '$element', 'assert'];
                    return SVGIconController;
                }());
                var FsSvgIconOptions = {
                    template: "<svg\n        viewBox=\"0 0 20 20\"\n        preserveAspectRatio=\"none\"\n        width=\"16\"\n        height=\"16\"\n        ng-class=\"$ctrl.symbolName\">\n            <use xlink:href=\"{{$ctrl.symbolNameSelector}}\"></use>\n        </svg>",
                    bindings: {
                        symbolName: '@',
                        attributes: '<',
                    },
                    controller: SVGIconController
                };
                angular.module('Fortscale.shared.components.fsSvgIcon', [])
                    .component('fsSvgIcon', FsSvgIconOptions);
            })(fsSvgIcon = components.fsSvgIcon || (components.fsSvgIcon = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsUserTooltip;
            (function (fsUserTooltip) {
                var TEMPLATE_URL = 'app/shared/components/fs-alerts-tooltip/fs-alerts-tooltip-internal.template.html';
                function fsAlertsTooltipDirective($compile, $templateCache) {
                    var AlertsTooltipController = (function () {
                        function AlertsTooltipController($scope, $element) {
                            this.$scope = $scope;
                            this.$element = $element;
                            this.alreadyConstructed = false;
                            /**
                             * Tooltip local settings object
                             *
                             * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                             * @private
                             */
                            this._tooltipSettings = {
                                className: 'user-tooltip',
                                stem: true,
                                stemLength: 8,
                                stemBase: 12,
                                hideDelay: 0.3,
                                tipJoint: 'top',
                                fixed: true,
                                removeElementsOnHide: false,
                                group: 'users',
                                background: '#f0f7f8',
                                borderRadius: 3,
                                borderColor: '#f0f7f8',
                                shadow: true,
                                shadowBlur: 15,
                                shadowOffset: [0, 0],
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                containInViewport: true,
                                offset: [0, 0],
                                showOn: "creation"
                            };
                        }
                        /**
                         * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                         *
                         * @returns {HTMLElement|null}
                         * @private
                         */
                        AlertsTooltipController.prototype._getTargetElement = function () {
                            if (this.tooltipTargetSelector) {
                                var closest = this.$element.closest(this.tooltipTargetSelector);
                                var inner = this.$element.find(this.tooltipTargetSelector);
                                return closest.length ? closest[0] :
                                    inner.length ? inner[0] : null;
                            }
                            return null;
                        };
                        /**
                         * Initiates the tooltip settings (creates an instance settings)
                         *
                         * @private
                         */
                        AlertsTooltipController.prototype._initSettings = function () {
                            this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                                target: this._getTargetElement(),
                            }, this._externalTooltipSettings ? this._externalTooltipSettings : {});
                        };
                        /**
                         * Renders the tooltip
                         *
                         * @private
                         */
                        AlertsTooltipController.prototype._initTooltip = function () {
                            // Set this as ctrl for the callbacks
                            var ctrl = this;
                            var template = $templateCache.get(TEMPLATE_URL);
                            var tooltipContent = $compile(angular.element(template))(ctrl.$scope);
                            ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                            ctrl._tooltip.setContent(tooltipContent);
                            // Prevent close on mouseover tooltip
                            ctrl._tooltip.content.on({
                                mouseenter: function () {
                                    ctrl._tooltip._abortHiding();
                                },
                                mouseleave: function () {
                                    ctrl._tooltip.prepareToHide();
                                }
                            });
                            ctrl._tooltip.activate();
                        };
                        /**
                         * Cleansup the tooltip when the scope is destroyed
                         *
                         * @private
                         */
                        AlertsTooltipController.prototype._initCleanup = function () {
                            var _this = this;
                            this.$scope.$on('$destroy', function () {
                                _this._tooltip.adapter.remove(_this._tooltip.container);
                                _this._tooltip.container = null;
                                _this._tooltip.tooltipElement = null;
                                _this._tooltip = null;
                            });
                        };
                        AlertsTooltipController.prototype.showTooltip = function () {
                            this._initTooltip();
                            this._initCleanup();
                        };
                        AlertsTooltipController.prototype.$onInit = function () {
                            this.tooltipTargetSelector = "user-alerts-for-tooltip";
                            this._initSettings();
                        };
                        AlertsTooltipController.$inject = ['$scope', '$element'];
                        return AlertsTooltipController;
                    }());
                    return {
                        restrict: 'A',
                        controller: AlertsTooltipController,
                        controllerAs: '$ctrl',
                        template: '<div class="user-alerts-for-tooltip" ng-mouseover="$ctrl.showTooltip()"><ng-transclude></ng-transclude></a>',
                        transclude: true,
                        scope: {},
                        bindToController: {
                            alerts: '<',
                            userId: '<',
                            _externalTooltipSettings: '<tooltipSettings',
                            internalHtml: '<'
                        }
                    };
                }
                fsAlertsTooltipDirective.$inject = ['$compile', '$templateCache'];
                angular.module('Fortscale.shared.components')
                    .directive('fsAlertsTooltip', fsAlertsTooltipDirective);
            })(fsUserTooltip = components.fsUserTooltip || (components.fsUserTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsUserTooltip;
            (function (fsUserTooltip) {
                var TEMPLATE_URL = 'app/shared/components/fs-user-devices-tooltip/fs-user-devices-tooltip-internal.template.html';
                function fsUserDevicesTooltipDirective($compile, $templateCache) {
                    var UserDevicesTooltipController = (function () {
                        function UserDevicesTooltipController($scope, $element) {
                            this.$scope = $scope;
                            this.$element = $element;
                            /**
                             * Tooltip local settings object
                             *
                             * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                             * @private
                             */
                            this._tooltipSettings = {
                                className: 'user-tooltip',
                                stem: true,
                                stemLength: 8,
                                stemBase: 12,
                                hideDelay: 0.3,
                                tipJoint: 'top',
                                fixed: true,
                                removeElementsOnHide: false,
                                group: 'users',
                                background: '#f0f7f8',
                                borderRadius: 3,
                                borderColor: '#f0f7f8',
                                shadow: true,
                                shadowBlur: 15,
                                shadowOffset: [0, 0],
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                containInViewport: true,
                                offset: [0, 0]
                            };
                        }
                        /**
                         * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                         *
                         * @returns {HTMLElement|null}
                         * @private
                         */
                        UserDevicesTooltipController.prototype._getTargetElement = function () {
                            if (this.tooltipTargetSelector) {
                                var closest = this.$element.closest(this.tooltipTargetSelector);
                                var inner = this.$element.find(this.tooltipTargetSelector);
                                return closest.length ? closest[0] :
                                    inner.length ? inner[0] : null;
                            }
                            return null;
                        };
                        /**
                         * Initiates the tooltip settings (creates an instance settings)
                         *
                         * @private
                         */
                        UserDevicesTooltipController.prototype._initSettings = function () {
                            this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                                target: this._getTargetElement(),
                            }, this._externalTooltipSettings ? this._externalTooltipSettings : {});
                        };
                        /**
                         * Renders the tooltip
                         *
                         * @private
                         */
                        UserDevicesTooltipController.prototype._initTooltip = function () {
                            // Set this as ctrl for the callbacks
                            var ctrl = this;
                            var template = $templateCache.get(TEMPLATE_URL);
                            var tooltipContent = $compile(angular.element(template))(ctrl.$scope);
                            ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                            ctrl._tooltip.setContent(tooltipContent);
                            // Prevent close on mouseover tooltip
                            ctrl._tooltip.content.on({
                                mouseenter: function () {
                                    ctrl._tooltip._abortHiding();
                                },
                                mouseleave: function () {
                                    ctrl._tooltip.prepareToHide();
                                }
                            });
                        };
                        /**
                         * Cleansup the tooltip when the scope is destroyed
                         *
                         * @private
                         */
                        UserDevicesTooltipController.prototype._initCleanup = function () {
                            var _this = this;
                            this.$scope.$on('$destroy', function () {
                                if (_this._tooltip != null) {
                                    _this._tooltip.adapter.remove(_this._tooltip.container);
                                    _this._tooltip.container = null;
                                    _this._tooltip.tooltipElement = null;
                                    _this._tooltip = null;
                                }
                            });
                        };
                        UserDevicesTooltipController.prototype.showTooltip = function () {
                            this._initTooltip();
                            this._initCleanup();
                        };
                        UserDevicesTooltipController.prototype.$onInit = function () {
                            this.tooltipTargetSelector = "user-devices-for-tooltip";
                            this._initSettings();
                        };
                        UserDevicesTooltipController.$inject = ['$scope', '$element'];
                        return UserDevicesTooltipController;
                    }());
                    return {
                        restrict: 'A',
                        controller: UserDevicesTooltipController,
                        controllerAs: '$ctrl',
                        scope: {},
                        transclude: true,
                        template: '<div class="user-devices-for-tooltip" ng-mouseover="$ctrl.showTooltip()"><ng-transclude></ng-transclude></a>',
                        bindToController: {
                            devices: '<',
                            _externalTooltipSettings: '<tooltipSettings'
                        }
                    };
                }
                fsUserDevicesTooltipDirective.$inject = ['$compile', '$templateCache'];
                angular.module('Fortscale.shared.components')
                    .directive('fsUserDevicesTooltip', fsUserDevicesTooltipDirective);
            })(fsUserTooltip = components.fsUserTooltip || (components.fsUserTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsUserTooltip;
            (function (fsUserTooltip) {
                var TEMPLATE_URL = 'app/shared/components/fs-user-tooltip/fs-user-tooltip.template.html';
                function fsUserTooltipDirective($compile, $templateCache) {
                    var UserTooltipController = (function () {
                        function UserTooltipController($scope, $element) {
                            this.$scope = $scope;
                            this.$element = $element;
                            /**
                             * Tooltip local settings object
                             *
                             * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                             * @private
                             */
                            this._tooltipSettings = {
                                className: 'user-tooltip',
                                stem: true,
                                stemLength: 8,
                                stemBase: 12,
                                hideDelay: 0.3,
                                tipJoint: 'top',
                                fixed: true,
                                removeElementsOnHide: false,
                                group: 'users',
                                background: '#f0f7f8',
                                borderRadius: 3,
                                borderColor: '#f0f7f8',
                                shadow: true,
                                shadowBlur: 15,
                                shadowOffset: [0, 0],
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                containInViewport: true,
                                offset: [0, 0]
                            };
                        }
                        /**
                         * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                         *
                         * @returns {HTMLElement|null}
                         * @private
                         */
                        UserTooltipController.prototype._getTargetElement = function () {
                            if (this.tooltipTargetSelector) {
                                var closest = this.$element.closest(this.tooltipTargetSelector);
                                var inner = this.$element.find(this.tooltipTargetSelector);
                                return closest.length ? closest[0] :
                                    inner.length ? inner[0] : null;
                            }
                            return null;
                        };
                        /**
                         * Initiates the tooltip settings (creates an instance settings)
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initSettings = function () {
                            this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                                target: this._getTargetElement(),
                            }, this._externalTooltipSettings ? this._externalTooltipSettings : {});
                        };
                        /**
                         * Renders the tooltip
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initTooltip = function () {
                            // Set this as ctrl for the callbacks
                            var ctrl = this;
                            var template = $templateCache.get(TEMPLATE_URL);
                            var tooltipContent = $compile(angular.element(template))(ctrl.$scope);
                            ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                            ctrl._tooltip.setContent(tooltipContent);
                            // Prevent close on mouseover tooltip
                            ctrl._tooltip.content.on({
                                mouseenter: function () {
                                    ctrl._tooltip._abortHiding();
                                },
                                mouseleave: function () {
                                    ctrl._tooltip.prepareToHide();
                                }
                            });
                        };
                        /**
                         * Cleansup the tooltip when the scope is destroyed
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initCleanup = function () {
                            var _this = this;
                            this.$scope.$on('$destroy', function () {
                                _this._tooltip.adapter.remove(_this._tooltip.container);
                                _this._tooltip.container = null;
                                _this._tooltip.tooltipElement = null;
                                _this._tooltip = null;
                            });
                        };
                        UserTooltipController.prototype.$onInit = function () {
                            this._initSettings();
                            this._initTooltip();
                            this._initCleanup();
                        };
                        UserTooltipController.$inject = ['$scope', '$element'];
                        return UserTooltipController;
                    }());
                    return {
                        restrict: 'A',
                        controller: UserTooltipController,
                        controllerAs: '$ctrl',
                        scope: {},
                        bindToController: {
                            user: '<fsUserTooltip',
                            tooltipTargetSelector: '@',
                            tooltipAlert: '<',
                            miniTooltip: '<',
                            _externalTooltipSettings: '<tooltipSettings'
                        }
                    };
                }
                fsUserTooltipDirective.$inject = ['$compile', '$templateCache'];
                angular.module('Fortscale.shared.components')
                    .directive('fsUserTooltip', fsUserTooltipDirective);
            })(fsUserTooltip = components.fsUserTooltip || (components.fsUserTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsIndicatorsTooltip;
            (function (fsIndicatorsTooltip) {
                var TEMPLATE_URL = 'app/shared/components/fs-indicators-tooltip/fs-indicators-tooltip.template.html';
                function fsIndicatorsTooltipDirective($compile, $templateCache) {
                    var UserTooltipController = (function () {
                        function UserTooltipController($scope, $element) {
                            this.$scope = $scope;
                            this.$element = $element;
                            /**
                             * Tooltip local settings object
                             *
                             * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                             * @private
                             */
                            this._tooltipSettings = {
                                className: 'indicators-tooltip',
                                stem: true,
                                stemLength: 8,
                                stemBase: 12,
                                hideDelay: 0.3,
                                tipJoint: 'top',
                                fixed: true,
                                removeElementsOnHide: false,
                                group: 'indicators',
                                background: '#f0f7f8',
                                borderRadius: 3,
                                borderColor: '#f0f7f8',
                                shadow: true,
                                shadowBlur: 15,
                                shadowOffset: [0, 0],
                                shadowColor: 'rgba(0, 0, 0, 0.5)',
                                containInViewport: true,
                                offset: [0, 0]
                            };
                        }
                        /**
                         * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                         *
                         * @returns {JQuery|null}
                         * @private
                         */
                        UserTooltipController.prototype._getTargetElement = function () {
                            if (this.tooltipTargetSelector) {
                                var elementFind = this.$element.find(this.tooltipTargetSelector);
                                var elementClosest = this.$element.closest(this.tooltipTargetSelector);
                                return (elementFind || elementClosest || this.$element)[0];
                            }
                            this.$element;
                        };
                        /**
                         * Initiates the tooltip settings (creates an instance settings)
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initSettings = function () {
                            this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                                target: this._getTargetElement(),
                            }, this._externalTooltipSettings ? this._externalTooltipSettings : {});
                        };
                        /**
                         * Renders the tooltip
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initTooltip = function () {
                            // Set this as ctrl for the callbacks
                            var ctrl = this;
                            var template = $templateCache.get(TEMPLATE_URL);
                            var tooltipContent = $compile(angular.element(template))(ctrl.$scope);
                            ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                            ctrl._tooltip.setContent(tooltipContent);
                            // Prevent close on mouseover tooltip
                            ctrl._tooltip.content.on({
                                mouseenter: function () {
                                    ctrl._tooltip._abortHiding();
                                },
                                mouseleave: function () {
                                    ctrl._tooltip.prepareToHide();
                                }
                            });
                        };
                        /**
                         * Cleansup the tooltip when the scope is destroyed
                         *
                         * @private
                         */
                        UserTooltipController.prototype._initCleanup = function () {
                            var _this = this;
                            this.$scope.$on('$destroy', function () {
                                _this._tooltip.adapter.remove(_this._tooltip.container);
                                _this._tooltip.container = null;
                                _this._tooltip.tooltipElement = null;
                                _this._tooltip = null;
                            });
                        };
                        UserTooltipController.prototype.$onInit = function () {
                            var _this = this;
                            this.$scope.$applyAsync(function () {
                                _this._initSettings();
                                _this._initTooltip();
                                _this._initCleanup();
                            });
                        };
                        UserTooltipController.$inject = ['$scope', '$element'];
                        return UserTooltipController;
                    }());
                    return {
                        restrict: 'A',
                        controller: UserTooltipController,
                        controllerAs: '$ctrl',
                        scope: {},
                        bindToController: {
                            indicators: '<',
                            alertModel: '<',
                            tooltipTargetSelector: '@',
                            _externalTooltipSettings: '<tooltipSettings'
                        }
                    };
                }
                fsIndicatorsTooltipDirective.$inject = ['$compile', '$templateCache'];
                angular.module('Fortscale.shared.components')
                    .directive('fsIndicatorsTooltip', fsIndicatorsTooltipDirective);
            })(fsIndicatorsTooltip = components.fsIndicatorsTooltip || (components.fsIndicatorsTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsTag;
            (function (fsTag) {
                var ABOUT_TO_REMOVE_CLASS_NAME = 'about-to-remove';
                var TagController = (function () {
                    function TagController($element, $scope) {
                        this.$element = $element;
                        this.$scope = $scope;
                    }
                    /**
                     * Sets 'about-to-remove' class on the element, or removes it.
                     *
                     * @param {boolean} state
                     */
                    TagController.prototype.setAboutToRemove = function (state) {
                        if (state) {
                            this.$element.addClass(ABOUT_TO_REMOVE_CLASS_NAME);
                        }
                        else {
                            this.$element.removeClass(ABOUT_TO_REMOVE_CLASS_NAME);
                        }
                    };
                    TagController.prototype.$onInit = function () {
                    };
                    TagController.$inject = ['$element', '$scope'];
                    return TagController;
                }());
                var fsTagComponent = {
                    controller: TagController,
                    templateUrl: 'app/shared/components/fs-tag/fs-tag.component.html',
                    bindings: {
                        tag: '<',
                        removeTagDelegate: '&',
                    }
                };
                angular.module('Fortscale.shared.components')
                    .component('fsTag', fsTagComponent);
            })(fsTag = components.fsTag || (components.fsTag = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsTableScrollable;
            (function (fsTableScrollable_1) {
                var FETCH_AHEAD_PAGES = 5;
                var TableScrollableController = (function () {
                    function TableScrollableController($scope, $element, $compile, $q, stateManagementService) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$compile = $compile;
                        this.$q = $q;
                        this.stateManagementService = stateManagementService;
                        this.pagesCache = [];
                    }
                    /**
                     * Takes a tableElement angular element, compiles it, and returns it.
                     *
                     * @param {angular.element} tableElement
                     * @returns {angular.element}
                     * @private
                     */
                    TableScrollableController.prototype._compileKendoGridElement = function (tableElement) {
                        return this.$compile(tableElement)(this.$scope);
                    };
                    /**
                     * Creates an angular element from a kendo-grid tag and returns it.
                     *
                     * @returns {angular.element}
                     * @private
                     */
                    TableScrollableController.prototype._createKendoGridElement = function () {
                        return angular.element('<kendo-grid class="fs-table-scrollable" options=' +
                            '"$ctrl.tableSettings" > ' +
                            '</kendo-grid>');
                    };
                    /**
                     * Register _reloadTable to be executed when state changed
                     * @private
                     */
                    TableScrollableController.prototype._initStateChangeWatch = function () {
                        this.stateManagementService.registerToStateChanges(this.stateId, this._reloadTable.bind(this));
                    };
                    /**
                     * Reload the table again.
                     * Should be called when filter or sort change
                     * @private
                     */
                    TableScrollableController.prototype._reloadTable = function () {
                        this._removeTableElement();
                        this._renderTable();
                    };
                    /**
                     * Remove the table from the DOM
                     * @private
                     */
                    TableScrollableController.prototype._removeTableElement = function () {
                        var prevKendoElement = this.$element.find('[kendo-grid]');
                        prevKendoElement.remove();
                    };
                    /**
                     * Render the table into the DOM
                     * @private
                     */
                    TableScrollableController.prototype._renderTable = function () {
                        var tableElement = this._createKendoGridElement();
                        // Compile and link table element
                        tableElement = this._compileKendoGridElement(tableElement);
                        this.$element.append(tableElement);
                        this._tableElement = tableElement;
                    };
                    TableScrollableController.prototype.$onInit = function () {
                        this._initStateChangeWatch();
                        this._initReadDataDelegate();
                        this._renderTable();
                    };
                    /**
                     * This method intiate the read function on the transport.
                     * If we are not using cache, the transport will be the delegate as retrieved from outside.
                     * If we are using cache, the delegate will be wrapped by  _readDataWrapper, and read function of the transport
                     * will be the _readDataWrapper which contain the delegate
                     *
                     * if no dataSource.transport configured the user will get an error.
                     * @private
                     */
                    TableScrollableController.prototype._initReadDataDelegate = function () {
                        this.useCache = !!this.useCache;
                        if (this.tableSettings.dataSource && this.tableSettings.dataSource.transport) {
                            this.tableSettings.dataSource.transport.read = this._readDataWrapper.bind(this);
                        }
                        else {
                            throw new Error("Table settings must have 'dataSource.trasnport' property");
                        }
                    };
                    /**
                     * This method called from the grid when have new page should be loaded (only if useCache = true)
                     * The method check if the page already in cache. If it does it return the page immedietly,
                     * if not it called to "readWithCache" to load several pages and store the in the cache for future use
                     * @param options -
                     * @private
                     */
                    TableScrollableController.prototype._readDataWrapper = function (options) {
                        //page number start from 1. Cache start from index 0.
                        var pageNumber = options.data.page;
                        var pageSize = options.data.pageSize;
                        var pagePromise;
                        if (!this.useCache) {
                            pagePromise = this.readDataDelegate({ "pageNumber": pageNumber, "pageSize": pageSize });
                        }
                        else {
                            pagePromise = this.readWithCache(pageNumber, pageSize);
                        }
                        pagePromise.then(function (page) {
                            options.success(page);
                        });
                    };
                    /**
                     * That method load FETCH_AHEAD_PAGES number of pages, and add them to the cache.
                     *
                     * @param page - start from 1
                     * @param pageSize
                     * @returns {function(any=): JQueryPromise<T>|function(string=, Object=): JQueryPromise<any>|IPromise<T>}
                     */
                    TableScrollableController.prototype.readWithCache = function (pageNumber, pageSize) {
                        var ctrl = this;
                        //If page already loaded
                        if (typeof ctrl.pagesCache[pageNumber - 1] === "object") {
                            var data = { data: ctrl.pagesCache[pageNumber - 1], total: ctrl.totalPages };
                            //let deferred:any = this.$q.defer();
                            //deferred.resolve(data);
                            //return deferred.promise;
                            return this.$q.when(data);
                        }
                        else {
                            //Page should be loaded with cache. Each call retrieve "pagesGroup " according to amount in FETCH_AHEAD_PAGES
                            var groupRequestSize = FETCH_AHEAD_PAGES * pageSize; //Each call fetch 3 pages.
                            var groupRequestPageNumber_1 = Math.ceil(pageNumber / FETCH_AHEAD_PAGES); //The group number for the server request
                            return this.readDataDelegate({ "pageNumber": groupRequestPageNumber_1, "pageSize": groupRequestSize })
                                .then(function (data) {
                                // Validate data
                                if (data) {
                                    var firstResultPageNumber = (groupRequestPageNumber_1 - 1) * FETCH_AHEAD_PAGES + 1;
                                    ctrl._savePagesToCache(data.data, firstResultPageNumber, pageSize);
                                    ctrl.totalPages = data.total;
                                }
                                return { data: ctrl.pagesCache[pageNumber - 1], total: ctrl.totalPages };
                            });
                        }
                    };
                    /**
                     * Split the data retrieved from the server (the response should contain FETCH_AHEAD_PAGES* page_size rows)
                     * into FETCH_AHEAD_PAGES and add each one to the cache in right index.
                     * @param data
                     * @param firstResultPageNumber
                     * @param pageSize
                     * @private
                     */
                    TableScrollableController.prototype._savePagesToCache = function (data, firstResultPageNumber, pageSize) {
                        for (var i = 0; i < FETCH_AHEAD_PAGES; i++) {
                            var pageData = data.splice(0, pageSize);
                            this.pagesCache[firstResultPageNumber + i - 1] = pageData;
                        }
                    };
                    TableScrollableController.$inject = ['$scope', '$element', '$compile', "$q", 'stateManagementService'];
                    return TableScrollableController;
                }());
                var fsTableScrollable = {
                    controller: TableScrollableController,
                    templateUrl: 'app/shared/components/fs-table-scrollable/fs-table-scrollable.view.html',
                    bindings: {
                        stateId: '<',
                        tableSettings: '<',
                        readDataDelegate: '&',
                        useCache: '<'
                    }
                };
                angular.module('Fortscale.shared.components')
                    .component('fsTableScrollable', fsTableScrollable);
            })(fsTableScrollable = components.fsTableScrollable || (components.fsTableScrollable = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function CloseAlertModalInstanceCtrl($scope, $modalInstance, inputParams) {
        this.$scope = $scope;
        this.$modalInstance = $modalInstance;
        this.inputParams = inputParams;
        this.init();
    }
    angular.extend(CloseAlertModalInstanceCtrl.prototype, {
        /**
         * When user click on OK button-
         * resolve the modal promise and send the model (the feedback of the alert)
         */
        clickOk: function () {
            this.$modalInstance.close(this.model);
        },
        /**
         * When user click on cancel button-
         * resolve the modal promise and return 'cancel'
         */
        clickCancel: function () {
            this.$modalInstance.dismiss('cancel');
        },
        /**
         * Convert the options of the feedback from enum object to array of "key" & "value"
         * @param options
         * @returns {Array} array of objects with "key" and "value" for the feedback radio buttons
         * @private
         */
        _getOptionsAsArray: function (options) {
            var optionsArray = [];
            _.forIn(options, function (key, value) {
                optionsArray.push({
                    value: value,
                    key: key
                });
            });
            return optionsArray;
        },
        /**
         * Init the controller
         */
        init: function () {
            var ctrl = this;
            ctrl.alert = ctrl.inputParams.alert;
            ctrl.model = {
                closeAlertStatus: '',
                inputParams: ctrl.inputParams,
            };
            //Init the feedback options list for the radio buttons
            ctrl.optionsList = ctrl._getOptionsAsArray(ctrl.inputParams.options);
        }
    });
    CloseAlertModalInstanceCtrl.$inject = [
        '$scope',
        '$modalInstance',
        'inputParams'
    ];
    angular.module('Fortscale.shared.components.alertFeedback')
        .controller('CloseAlertModalInstanceCtrl', CloseAlertModalInstanceCtrl);
}());

(function () {
    'use strict';
    function OpenAlertModalInstanceCtrl($scope, $modalInstance, inputParams) {
        this.$scope = $scope;
        this.$modalInstance = $modalInstance;
        this.inputParams = inputParams;
        this.init();
    }
    angular.extend(OpenAlertModalInstanceCtrl.prototype, {
        /**
         * When user click on OK button-
         * resolve the modal promise and send the model (the feedback of the alert)
         */
        clickOk: function () {
            this.$modalInstance.close(this.model);
        },
        /**
         * When user click on cancel button-
         * resolve the modal promise and return 'cancel'
         */
        clickCancel: function () {
            this.$modalInstance.dismiss('cancel');
        },
        /**
         * Inits the controller
         */
        init: function () {
            var ctrl = this;
            ctrl.model = {
                inputParams: ctrl.inputParams
            };
        }
    });
    OpenAlertModalInstanceCtrl.$inject = [
        '$scope',
        '$modalInstance',
        'inputParams'
    ];
    angular.module('Fortscale.shared.components.alertFeedback').controller('OpenAlertModalInstanceCtrl', OpenAlertModalInstanceCtrl);
}());

(function () {
    'use strict';
    /**
     * This modal show success message after alert was closed or reopened
     * @param $scope
     * @param $modalInstance
     * @param inputParams
     * @constructor
     */
    function FeedbackResultModalInstanceCtrl($scope, $modalInstance, inputParams) {
        var ctrl = this;
        ctrl.$scope = $scope;
        ctrl.$modalInstance = $modalInstance;
        ctrl.inputParams = inputParams;
        /**
         * Used to fixate activation context and invoke _removeClickListener and _closeModal
         */
        ctrl.closeModal = function () {
            ctrl._removeClickListener();
            ctrl._closeModal();
        };
        ctrl.init();
    }
    angular.extend(FeedbackResultModalInstanceCtrl.prototype, {
        /**
         * Closes the modal
         *
         * @private
         */
        _closeModal: function () {
            this.$modalInstance.dismiss();
        },
        /**
         * Removes click event listener
         *
         * @private
         */
        _removeClickListener: function () {
            window.removeEventListener('click', this.closeModal, true);
        },
        /**
         * Used to cleanup all listeners
         *
         * @private
         */
        _cleanup: function () {
            this._removeClickListener();
        },
        /**
         * Initates watches
         *
         * @private
         */
        _initWatches: function () {
            window.addEventListener('click', this.closeModal, true);
            this.$scope.$on('$destroy', this._cleanup.bind(this));
        },
        /**
         * Init the controller
         */
        init: function () {
            var ctrl = this;
            ctrl.newAlertStatus = ctrl.inputParams.newAlertStatus;
            ctrl.specificBodyMessage = ctrl.inputParams.specificBodyMessage;
            ctrl._initWatches();
        }
    });
    FeedbackResultModalInstanceCtrl.$inject = [
        '$scope',
        '$modalInstance',
        'inputParams'
    ];
    angular.module('Fortscale.shared.components.alertFeedback')
        .controller('FeedbackResultModalInstanceCtrl', FeedbackResultModalInstanceCtrl);
}());

(function () {
    'use strict';
    /**
     * This modal present error message after chagne alert status failed.
     * @param $scope
     * @param $modalInstance
     * @param inputParams
     * @constructor
     */
    function FeedbackFailureModalInstanceCtrl($scope, $modalInstance, inputParams) {
        this.$scope = $scope;
        this.$modalInstance = $modalInstance;
        this.inputParams = inputParams;
        this.init();
    }
    angular.extend(FeedbackFailureModalInstanceCtrl.prototype, {
        /**
         * When user click on OK button-
         * resolve the modal promise close the modal
         */
        clickOk: function () {
            this.$modalInstance.close();
        },
        /**
         * Init the controller
         */
        init: function () {
            var ctrl = this;
            ctrl.newAlertStatus = ctrl.inputParams.newAlertStatus;
            ctrl.specificBodyMessage = ctrl.inputParams.specificBodyMessage;
        }
    });
    FeedbackFailureModalInstanceCtrl.$inject = [
        '$scope',
        '$modalInstance',
        'inputParams'
    ];
    angular.module('Fortscale.shared.components.alertFeedback')
        .controller('FeedbackFailureModalInstanceCtrl', FeedbackFailureModalInstanceCtrl);
}());

(function () {
    'use strict';
    angular.module('Fortscale')
        .value('indicatorSeverities', {
        Critical: {
            order: 0,
            id: 'critical',
            name: 'Critical',
            count: 0
        },
        High: {
            order: 1,
            id: 'high',
            name: 'High',
            count: 0
        },
        Medium: {
            order: 2,
            id: 'medium',
            name: 'Medium',
            count: 0
        },
        Low: {
            order: 3,
            id: 'low',
            name: 'Low',
            count: 0
        }
    });
}());

(function () {
    'use strict';
    angular.module('Fortscale.layouts', [
        'Fortscale.layouts.overview',
        'Fortscale.layouts.reports',
        'ui.bootstrap',
        'Fortscale.layouts.configuration',
        'Fortscale.layouts.pxgridConfiguration',
        'Fortscale.layouts.user',
        'Fortscale.layouts.users'
    ]);
}());

(function () {
    'use strict';
    /**
     * Handle Alerts page
     */
    function AlertsController($scope, $element, alertsResourceSettings, alertsTableSettings, alertsIndicatorsTableSettings, splitterSettings, filtersPaneSettings, alertsMainState, tagsList, indicatorTypeList, dependencyMounter) {
        var _this = this;
        var ctrl = this;
        dependencyMounter.mountOnConstructor(AlertsController, ['interpolation', 'utils',
            'fsResourceStore', 'BASE_URL', '$http', 'URLUtils', 'indicatorSeverities', 'entityUtils', 'page',
            'dateRanges', 'appConfig', '$state', 'fsDownloadFile', 'fsNanobarAutomationService']);
        // Set instance variables
        ctrl.$scope = $scope;
        ctrl.$element = $element;
        ctrl.alertsResourceSettings = _.merge({}, alertsResourceSettings);
        ctrl.alertsTableSettings = _.merge({}, alertsTableSettings);
        ctrl.alertsIndicatorsTableSettings = _.merge({}, alertsIndicatorsTableSettings);
        ctrl.fsSplitterSettings = _.merge({}, splitterSettings);
        ctrl.filtersPaneSettings = _.merge({}, filtersPaneSettings);
        ctrl.alertsMainState = _.merge({}, alertsMainState);
        ctrl.tagsList = _.merge({}, tagsList);
        ctrl.indicatorTypeList = _.merge([], indicatorTypeList);
        ctrl._alertsMainStateDefault = _.merge({}, alertsMainState);
        ctrl._defaultDaysRange = this.appConfig.getConfigValue('ui.' + this.$state.current.name, 'daysRange');
        ctrl.alertsResourceAdapter = function (data) {
            return ctrl._alertsResourceAdapter(data);
        };
        ctrl.filtersPaneSettings.tagsFilter = ctrl.tagsList;
        ctrl.NANOBAR_ID = 'alerts';
        ctrl.dataFetchDelegate = function (promise) {
            ctrl.fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        ctrl._init();
    }
    angular.extend(AlertsController.prototype, {
        /**
         * Adds a startOfDay field for grouping purposes
         *
         * @param {Array} data
         * @returns {Array}
         * @private
         */
        _alertsResourceAdapter: function (data) {
            var ctrl = this;
            _.each(data, function (row) {
                row.startDateDay = ctrl.utils.date.getMoment(row.startDate, null)
                    .startOf('day').unix() + '000';
                row.indicatorsNum = row.evidences.length;
                // Add alert id and user id to indicator to populate ui-sref directive
                _.each(row.evidences, function (indicator) {
                    indicator.alert = {
                        id: row.id,
                        entityId: row.entityId
                    };
                });
            });
            return data;
        },
        _addDefaultDateRange: function () {
            this.alertsMainState.date_range_filter = {
                value: this.dateRanges.getByDaysRange(this._defaultDaysRange, 'short')
            };
        },
        /**
         * Broadcasts an event that requests all controls (by control id) to reset.
         * It provides on the eventData the control id to reset, and the initial state.
         *
         * @param {object} stateContainer
         * @param {string} tableId
         * @param {Array<string>} controlIds
         */
        clearFilters: function (stateContainer, tableId, controlIds) {
            var ctrl = this;
            //   this.resetPreStateTablePageNumber(stateContainer, tableId);
            _.each(controlIds, function (id) {
                ctrl.$scope.$broadcast('control:reset', {
                    controlId: id,
                    initialState: (ctrl._alertsMainStateDefault[id] &&
                        ctrl._alertsMainStateDefault[id].value) || null
                });
            });
        },
        /**
         * Fetches user id and navigates to user overview
         * TODO: Replace dataQuery api with entity restful api
         *
         * @param {object} alert
         */
        navigateToEntityProfile: function (alert) {
            this.entityUtils.navigateToEntityProfile(alert.entityType, alert.entityId);
        },
        getAlertsCSV: function (stateContainer, alertsResourceSettings) {
            var interpolatedParams = this.interpolation.interpolate(alertsResourceSettings, stateContainer.stateModel);
            delete interpolatedParams.page;
            delete interpolatedParams.size;
            var excludedValues = ["", "_ALL_"];
            //Copy all the attributes from interpolatedParams.params to filterParams, Except attributes with values from excludedValues array
            var filterParams = _.omitBy(interpolatedParams.params, function (value, key) {
                return _.indexOf(excludedValues, value) > -1;
            });
            var query = $.param(filterParams);
            var src = this.BASE_URL + "/alerts/export?" + query;
            this.fsDownloadFile.openIFrame(src);
        },
        /**
         * Returns a sorted array of severities
         *
         * @param {{}} severitiesObj
         * @returns {Array|undefined}
         */
        getSeveritiesCount: function (severitiesObj) {
            // return an array only if severitiesObj received
            if (severitiesObj) {
                // Create a new severities count list: Array<{name: string, count: number}>
                this._totalSeveritiesCount = _.map(_.sortBy(this.indicatorSeverities, 'order'), function (indicatorSeverity) {
                    return _.merge({}, indicatorSeverity, { count: severitiesObj[indicatorSeverity.name] });
                });
                // The newly created list can not be returned as is, because angular will identify the new object as
                // a change, and will start a new digest cycle to make sure the object is stable. It will never be
                // stable if that object is returned. Therefore we need to store the object in a property on the
                // instance, and compare it manually to the latest object delivered. If the objects are equal,
                // return the latest one, and not the new one. This will satisfy angular and no unneeded cycles will
                // occur.
                // If no _LatestTotalSeveritiesCount then set it and return _totalSeveritiesCount
                if (this._LatestTotalSeveritiesCount === undefined) {
                    this._LatestTotalSeveritiesCount = this._totalSeveritiesCount;
                    return this._totalSeveritiesCount;
                }
                // Equate the two lists (_totalSeveritiesCount and _LatestTotalSeveritiesCount). If the values are
                // not equal set _LatestTotalSeveritiesCount and return _totalSeveritiesCount.
                if (!_.every(this._totalSeveritiesCount, _.bind(function (sc, index) {
                    return (sc.count === this._LatestTotalSeveritiesCount[index].count);
                }, this))) {
                    this._LatestTotalSeveritiesCount = this._totalSeveritiesCount;
                    return this._totalSeveritiesCount;
                }
                return this._LatestTotalSeveritiesCount;
            }
        },
        /**
         * Init function of the controller
         *
         * @private
         */
        _init: function _init() {
            this.page.setPageTitle("Alerts");
            this._addDefaultDateRange();
        }
    });
    AlertsController.$inject = ['$scope', '$element', 'alertsResourceSettings',
        'alertsTableSettings', 'alertsIndicatorsTableSettings', 'splitterSettings',
        'filtersPaneSettings', 'alertsMainState', 'tagsList', 'indicatorTypeList',
        'dependencyMounter'];
    angular.module('Fortscale')
        .controller('AlertsController', AlertsController);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var alertsPageResolve = {
        alertsResourceSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/alerts.resource.json');
            }
        ],
        alertsTableSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/alerts-table.settings.json');
            }
        ],
        alertsIndicatorsTableSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/alerts-indicators-table.settings.json');
            }
        ],
        alertsMainState: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/alerts-main.state.json');
            }
        ],
        splitterSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/splitter.settings.json');
            }
        ],
        filtersPaneSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/alerts/settings/filters-pane.settings.json');
            }
        ],
        tagsList: [
            'BASE_URL',
            '$http',
            function (BASE_URL, $http) {
                return $http
                    .get(BASE_URL + '/tags/user_tags')
                    .then(function (res) {
                    res.data.data = _.map(res.data.data, function (tag) {
                        return {
                            id: tag.name,
                            value: tag.displayName
                        };
                    });
                    return res.data;
                });
            }
        ],
        indicatorTypeList: [
            'fsIndicatorTypes',
            function (fsIndicatorTypes) {
                return fsIndicatorTypes.getIndicatorsList();
            }
        ]
    };
    angular.module('Fortscale.layouts')
        .constant('alertsPageResolve', alertsPageResolve);
}());

(function () {
    'use strict';
    //For how long to display the status change success modal
    var MILISECONDS_TO_DISPLAY_SUCCESS_MODAL = 3000;
    function FsAlertsRecordMenu(assert, indicatorTypeMapper) {
        /**
         * The link function
         *
         * @param scope
         * @param element
         */
        function linkFn(scope, element) {
            // Assign ctrl
            var ctrl = scope.recordMenuCtrl;
            assert(_.isObject(ctrl.dataItem), 'FsAlertsRecordMenu.directive: ' +
                'item must be provided.');
            // Assign ts and set required class
            var td = ctrl.td = element.closest('td');
            td.addClass('fs-alert-record-menu-cell');
            ctrl.isOpened = false;
            // Add td click handler (and its deregister)
            function tdClickHandler(evt) {
                ctrl._tdClickHandler(evt);
            }
            td.on('click', tdClickHandler);
            // Cleanup
            function cleanup() {
                td.off('click', tdClickHandler);
                ctrl._deregisterGlobalListener();
            }
            scope.$on('$destroy', cleanup);
            element.on('destroy', cleanup);
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsAlertsRecordMenuController($scope, $element, $attrs, alertFeedback, $timeout) {
            // Put dependencies on the controller instance
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.alertFeedback = alertFeedback;
            this.$timeout = $timeout;
        }
        _.merge(FsAlertsRecordMenuController.prototype, {
            /**
             * Click handler for the table cell.
             * Invokes _closeMenu/_openMenu (based on 'opened' class)
             *
             * @private
             */
            _tdClickHandler: function () {
                if (this.td.hasClass('opened')) {
                    this._closeMenu();
                }
                else {
                    this._openMenu();
                }
            },
            /**
             * Adds a gloabal click listener. This is used to close the menu if clicked outside the
             * table cell.
             *
             * @returns {Function} unregister function
             * @private
             */
            _addGlobalListener: function () {
                var ctrl = this;
                function clickHandler(evt) {
                    // Close only if click is not a part of that specific menu
                    if ($(evt.target).closest('td')[0] !== ctrl.td[0]) {
                        ctrl._closeMenu();
                    }
                }
                window.addEventListener('click', clickHandler, false);
                return function () {
                    window.removeEventListener('click', clickHandler, false);
                };
            },
            /**
             * Removes global listener (if one exists)
             *
             * @private
             */
            _deregisterGlobalListener: function () {
                if (this._globalListenerDeregister) {
                    this._globalListenerDeregister();
                    this._globalListenerDeregister = null;
                }
            },
            /**
             * Opens the menu
             *
             * @private
             */
            _openMenu: function () {
                this.td.addClass('opened');
                this._globalListenerDeregister = this._addGlobalListener();
                this.isOpened = true;
                this.$scope.$apply();
            },
            /**
             * Closes the menu, and deregisters the global listener.
             *
             * @private
             */
            _closeMenu: function () {
                this.td.removeClass('opened');
                this._deregisterGlobalListener();
                this.isOpened = false;
                this.$scope.$apply();
            },
            /**
             * This method close opened alert or re-open closed alert
             * and display success or failure message, and refresh the grid
             * @param alert -  the alert details
             */
            changeAlertStatus: function (alert) {
                var ctrl = this;
                var promiseResults;
                var newStatus;
                //Trigger the close alert or re-open alert flow
                if (alert.status === 'Open') {
                    promiseResults = ctrl.alertFeedback.handleCloseAlertPopupFlow(alert);
                    newStatus = 'closed';
                }
                else {
                    promiseResults = ctrl.alertFeedback.handleOpenAlertPopupFlow(alert);
                    newStatus = 'open';
                }
                //Update the screen after the operation complete
                promiseResults.then(function (res) {
                    ctrl.refreshTable();
                    ctrl.fireAlertStateUpdated(res);
                    var responsePopupInstance = ctrl.alertFeedback.showResponseSuccessPopup(newStatus);
                    ctrl._dismissSuccssFailPopup(responsePopupInstance);
                })
                    .catch(function (e) {
                    //If e equals 'cancel' the user cancel the change.
                    //If e don't equals 'cancel' - some error has happend.
                    if (e !== 'cancel') {
                        ctrl.alertFeedback.showResponseFailurePopup(newStatus);
                    }
                });
            },
            /**
             * Dismiss the popup after 3 seconds
             * @param responsePopupInstance
             * @private
             */
            _dismissSuccssFailPopup: function (responsePopupInstance) {
                this.$timeout(function () {
                    responsePopupInstance.dismiss();
                }, MILISECONDS_TO_DISPLAY_SUCCESS_MODAL);
            },
            /**
             * Generates a url for the <a>'s href. It uses the
             *
             * @param {object} alert
             * @returns {string}
             */
            getInvestigateHref: function (alert) {
                return indicatorTypeMapper.getTargetUrl(alert.id, alert.evidences[0]);
            },
            /**
             * That method refresh the alerts table in the main "alerts" page.
             */
            refreshTable: function () {
                var ctrl = this;
                if (ctrl.stateContainer) {
                    //Extract the state object of the table
                    var tableState = ctrl.stateContainer.fetchStateById(ctrl.tableId);
                    //Update the table
                    ctrl.stateContainer.updateCtrlState({
                        id: ctrl.tableId,
                        immediate: true,
                        type: 'data',
                        value: tableState
                    });
                }
            },
            /**
             * When alert status changes, an event is emitted with the changed alert
             *
             * @param res
             */
            fireAlertStateUpdated: function (res) {
                var modifiedAlert = _.merge({}, this.dataItem);
                modifiedAlert.status = res.config.data.status === 'open' ? 'Open' : 'Closed';
                modifiedAlert.feedback = res.config.data.feedback.charAt(0).toUpperCase() +
                    res.config.data.feedback.substr(1);
                this.$scope.$root.$broadcast('fsAlertsRecordMenu:alertUpdated', modifiedAlert, res);
            }
        });
        FsAlertsRecordMenuController.$inject = ['$scope', '$element', '$attrs', 'alertFeedback', '$timeout'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/alerts/components/fs-alerts-record-menu/' +
                'fs-alerts-record-menu.view.html',
            scope: {},
            controller: FsAlertsRecordMenuController,
            controllerAs: 'recordMenuCtrl',
            bindToController: {
                dataItem: '=item',
                tableId: '@',
                stateContainer: '='
            },
            link: linkFn
        };
    }
    FsAlertsRecordMenu.$inject = ['assert', 'indicatorTypeMapper'];
    angular.module('Fortscale.layouts')
        .directive('fsAlertsRecordMenu', FsAlertsRecordMenu);
}());

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            angular.module('Fortscale.layouts.user', []);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            'use strict';
            angular.module('Fortscale.layouts.user')
                .config([
                '$stateProvider',
                function ($stateProvider) {
                    $stateProvider
                        .state('username', {
                        url: '/username/:username',
                        controller: (function () {
                            function UsernameController($stateParams, userUtils, $location, $log, toastrService) {
                                userUtils.getUserByUsername($stateParams.username)
                                    .then(function (user) {
                                    $location.path("/user/" + user.id + "/baseline");
                                    $location.replace();
                                })
                                    .catch(function (err) {
                                    toastrService.error('There was an unexpected server error while trying to load a user profile', 'User Profile Error');
                                    $log.error(err);
                                    $location.path("/overview");
                                    $location.replace();
                                });
                            }
                            UsernameController.$inject = ['$stateParams', 'userUtils', '$location', '$log', 'toastrService'];
                            return UsernameController;
                        }()),
                    })
                        .state('user', {
                        url: '/user/:userId',
                        templateUrl: 'app/layouts/user/user.view.html',
                        controller: 'UserController',
                        controllerAs: 'userCtrl'
                    })
                        .state('user.baseline', {
                        url: '/baseline',
                        controller: 'userAttributesController',
                        controllerAs: 'attrCtrl',
                        templateUrl: 'app/layouts/user/components/user-attributes/user-attributes.view.html'
                    })
                        .state('user.alert-overview', {
                        url: '/alert/:alertId',
                        templateUrl: 'app/layouts/user/components/user-alert-overview/user-alert-overview.view.html',
                        controller: 'userAlertOverviewController',
                        controllerAs: 'userAlertOverviewController'
                    })
                        .state('user.indicator', {
                        url: '/alert/:alertId/indicator/:indicatorId',
                        templateUrl: 'app/layouts/user/components/user-indicator/user-indicator.view.html',
                        controller: 'userIndicatorController',
                        controllerAs: 'userIndicatorCtrl'
                    });
                }
            ]);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var Activities = (function () {
                function Activities() {
                    this.organization = {
                        topCountries: null
                    };
                    this.user = {
                        topCountries: null,
                        authentications: null,
                        workingHours: null,
                        sourceDevices: null,
                        targetDevices: null,
                        dataUsages: null
                    };
                }
                return Activities;
            }());
            user.Activities = Activities;
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var UserTagsUtilsService = (function () {
                function UserTagsUtilsService(tagsUtils, toastrService) {
                    this.tagsUtils = tagsUtils;
                    this.toastrService = toastrService;
                }
                /**
                 * Removes a tag from a user,
                 * @param {ITagDefinition} tag
                 * @param {{}} user
                 */
                UserTagsUtilsService.prototype.removeTag = function (tag, user) {
                    var _this = this;
                    return this.tagsUtils.removeTag(user.id, tag.name)
                        .then(function () {
                        user.tags = _.filter(user.tags, function (userTagName) {
                            return userTagName !== tag.name;
                        });
                        // this.toastrService.info(
                        //     `Tag <b>${tag.displayName}</b> was successfully removed from <b>${user.fallBackDisplayName}</b>.`);
                        return user;
                    })
                        .catch(function (err) {
                        console.error(err);
                        _this.toastrService.error("There was an error trying to remove tag <b>" + tag.displayName + "</b> to user <b>" + user.fallBackDisplayName + "</b>.<br>Please try again later.");
                    });
                };
                /**
                 * Adds a tag to the user
                 * @param {ITagDefinition} tag
                 * @param {{}} user
                 * @returns {IPromise<TResult>}
                 */
                UserTagsUtilsService.prototype.addTag = function (tagName, user, tagDisplayName) {
                    var _this = this;
                    return this.tagsUtils.addTag(user.id, tagName)
                        .then(function () {
                        user.tags.push(tagName);
                        return user;
                    })
                        .catch(function (err) {
                        console.error(err);
                        _this.toastrService.error("There was an error trying to add tag <b>" + (tagDisplayName ? tagDisplayName : tagName) + "</b> to user <b>" + user.fallBackDisplayName + "</b>.<br>Please try again later.");
                    });
                };
                /**
                 * Adds a new tag to system and to user
                 * @param tagName
                 * @param tags
                 * @param user
                 * @returns {ng.IPromise<any>}
                 */
                UserTagsUtilsService.prototype.addNewTag = function (tagName, tags, user) {
                    var _this = this;
                    function findTagNameInTags(tags, tagName) {
                        return (_.find < (tags, { name: tagName }) || _.find(tags, { displayName: tagName }));
                    }
                    // find the new tag (if exists)
                    var tag = findTagNameInTags(tags, tagName);
                    // If tag is found, validate, if valid add it to user
                    if (tag) {
                        // Check if tag is fixed
                        if (!tag.active) {
                            this.toastrService.error("The tag <b>" + tag.displayName + "</b> is an inactive tag, and can not be added.");
                            return null;
                        }
                        // Check if user has tag
                        var userHasTag = _.some(user.tags, function (userTag) { return userTag === tag.name; });
                        if (userHasTag) {
                            this.toastrService.error("The user is already tagged with a tag named <b>" + (tag.displayName || tagName) + "</b>.");
                            return null;
                        }
                        // Add tag to user if tag is not fixed and the user does not already have the tag
                        return this.addTag(tag.name, user)
                            .then(function (user) {
                            return { user: user, tags: tags };
                        });
                    }
                    // Create the new tag and add it to the user
                    return this.tagsUtils.createNewTag(tagName)
                        .then(function (_tags) {
                        //place new tags list in tags variable for future reference
                        tags = _tags;
                        // Add tag to user
                        return _this.addTag(findTagNameInTags(tags, tagName), user);
                    })
                        .then(function (user) {
                        return { user: user, tags: tags };
                    })
                        .catch(function (err) {
                        _this.toastrService.error("There was an error trying to add new tag <b>" + tagName + "</b> to user <b>" + user.fallBackDisplayName + "</b>.<br>Please try again later.");
                    });
                };
                UserTagsUtilsService.$inject = ['tagsUtils', 'toastrService'];
                return UserTagsUtilsService;
            }());
            angular.module('Fortscale.layouts.user')
                .service('userTagsUtils', UserTagsUtilsService);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var UserWatchUtil = (function () {
                function UserWatchUtil(BASE_URL, $http) {
                    this.BASE_URL = BASE_URL;
                    this.$http = $http;
                    this.CHANGE_USER_WATCH_STATE_PATH = this.BASE_URL + '/analyst/followUser';
                }
                /**
                 * Changes a user's watch state
                 * @param {{}} user
                 * @param {boolean} state
                 * @returns {IPromise<TResult>}
                 */
                UserWatchUtil.prototype.changeUserWatchState = function (user, state) {
                    return this.$http.get(this.CHANGE_USER_WATCH_STATE_PATH, {
                        params: {
                            follow: state,
                            userId: user.id
                        }
                    })
                        .then(function (res) {
                        user.followed = state;
                        return user;
                    });
                };
                UserWatchUtil.$inject = ['BASE_URL', '$http'];
                return UserWatchUtil;
            }());
            angular.module('Fortscale.layouts.user')
                .service('userWatchUtil', UserWatchUtil);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserIndicatorsUtilsService = (function () {
                function UserIndicatorsUtilsService(appConfig, indicatorSymbolMap, $interpolate, $filter) {
                    this.appConfig = appConfig;
                    this.indicatorSymbolMap = indicatorSymbolMap;
                    this.$interpolate = $interpolate;
                    this.$filter = $filter;
                    this._CONFIG_LOCALE_KEY = 'system.locale.settings';
                    this._CONFIG_INDICATOR_KEY_PREFIX = "messages." + this.appConfig.getConfigItem(this._CONFIG_LOCALE_KEY).value + ".evidence";
                    this._INDICATOR_CONFIG_DESCRIPTION_KEY = 'desc';
                    this._INDICATOR_CONFIG_TIME_LINE_KEY = 'timeline';
                }
                /**
                 * Returns an indicator's description
                 * @param indicator
                 * @returns {any}
                 */
                UserIndicatorsUtilsService.prototype.getIndicatorDescription = function (indicator) {
                    var configItem = this.appConfig.getConfigItem(this._CONFIG_INDICATOR_KEY_PREFIX + "." + indicator.anomalyTypeFieldName + "." + this._INDICATOR_CONFIG_DESCRIPTION_KEY);
                    if (configItem && configItem.value) {
                        return configItem.value;
                    }
                    return '';
                };
                /**
                 * Returns an indicator timeLine description
                 * @param indicator
                 * @returns {any}
                 */
                UserIndicatorsUtilsService.prototype.getIndicatorTimelineDescription = function (indicator) {
                    var configItem = this.appConfig.getConfigItem(this._CONFIG_INDICATOR_KEY_PREFIX + "." + indicator.anomalyTypeFieldName + "." + this._INDICATOR_CONFIG_TIME_LINE_KEY);
                    if (configItem && configItem.value) {
                        var filterFn = this.$filter('anomalyTypeFormatter');
                        var locals = {
                            value: filterFn(indicator.anomalyValue, indicator)
                        };
                        return this.$interpolate(configItem.value)(locals);
                    }
                    return '';
                };
                /**
                 * Returns an indicator's symbol name (svg icon)
                 * @param indicator
                 * @returns {string}
                 */
                UserIndicatorsUtilsService.prototype.getIndicatorSymbolName = function (indicator) {
                    return this.indicatorSymbolMap.getSymbolName(indicator);
                };
                /**
                 * Orders the indicators list and returns a sorted list
                 * @param indicators
                 * @returns {T[]}
                 */
                UserIndicatorsUtilsService.prototype.orderIndicators = function (indicators) {
                    if (!indicators) {
                        return;
                    }
                    return _.orderBy(indicators, ['startDate'], ['asc']);
                };
                /**
                 * Filters the indicators list (takes out 'tag' indicators) and returns the list
                 * @param indicators
                 * @returns {any[]|string[]|T[]}
                 */
                UserIndicatorsUtilsService.prototype.filterIndicators = function (indicators) {
                    if (!indicators) {
                        return;
                    }
                    return _.filter(indicators, function (indicator) { return indicator.anomalyTypeFieldName !== 'tag'; });
                };
                /**
                 * Get subset of tag indicators only
                 * @param indicators
                 * @returns {any[]|string[]|T[]}
                 */
                UserIndicatorsUtilsService.prototype.getTagsIndicators = function (indicators) {
                    if (!indicators) {
                        return;
                    }
                    return _.filter(indicators, function (indicator) { return indicator.anomalyTypeFieldName === 'tag'; });
                };
                UserIndicatorsUtilsService.$inject = ['appConfig', 'indicatorSymbolMap', '$interpolate', '$filter'];
                return UserIndicatorsUtilsService;
            }());
            angular.module('Fortscale.layouts.user')
                .service('userIndicatorsUtils', UserIndicatorsUtilsService);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserAlertsUtilsService = (function () {
                function UserAlertsUtilsService(appConfig, $filter, tagUtilsService, $q) {
                    this.appConfig = appConfig;
                    this.$filter = $filter;
                    this.tagUtilsService = tagUtilsService;
                    this.$q = $q;
                    this._CONFIG_LOCALE_KEY = 'system.locale.settings';
                    this._CONFIG_ALERT_KEY_PREFIX = "messages." + this.appConfig.getConfigItem(this._CONFIG_LOCALE_KEY).value + ".alert";
                    this._ALERT_CONFIG_DESCRIPTION_KEY = 'desc';
                }
                /**
                 * Returns an alerts's description
                 * @param indicator
                 * @returns {any}
                 */
                UserAlertsUtilsService.prototype.getAlertDescription = function (alert) {
                    var configItem = this.appConfig.getConfigItem(this._CONFIG_ALERT_KEY_PREFIX + "." + alert.name + "." + this._ALERT_CONFIG_DESCRIPTION_KEY);
                    if (configItem && configItem.value) {
                        return configItem.value;
                    }
                    return alert.name;
                };
                /**
                 * The string for data sources with seperator from all the evidences, without duplication
                 * @param evidencesList
                 * @returns {string}
                 */
                UserAlertsUtilsService.prototype.getDataSources = function (evidencesList) {
                    var _this = this;
                    var dataSources = _.map(evidencesList, function (evidence) {
                        return _this.$filter("entityIdToName")(evidence.dataEntitiesIds[0]);
                    });
                    dataSources = _.uniq(dataSources);
                    return dataSources.join(", ");
                };
                /**
                 * The string for tag names with seperator from all tag evidences, without duplication
                 * @param tagEvidencesList
                 * @returns {promise}
                 */
                UserAlertsUtilsService.prototype.getTags = function (tagEvidencesList) {
                    var _this = this;
                    var tags = _.map(tagEvidencesList, function (evidence) {
                        return evidence.anomalyValue;
                    });
                    return this.$q(function (resolve, reject) {
                        if (_this._checkIfAllTagsInCache(tags)) {
                            resolve(_this._getTagsDisplayNames(tags));
                        }
                        else {
                            _this.tagUtilsService.getTags().then(function (tagList) {
                                _this._tagsCache = tagList.data;
                                resolve(_this._getTagsDisplayNames(tags));
                            });
                        }
                    });
                };
                UserAlertsUtilsService.prototype._checkIfAllTagsInCache = function (tags) {
                    var _this = this;
                    var allTagExits = true;
                    _.each(tags, function (tag) {
                        var tagObject = _.find(_this._tagsCache, { name: tag });
                        if (!tagObject) {
                            allTagExits = false;
                        }
                    });
                    return allTagExits;
                };
                /*
                 * We assume that all tags exists in cache
                 */
                UserAlertsUtilsService.prototype._getTagsDisplayNames = function (tags) {
                    var _this = this;
                    var prettyTags = [];
                    _.each(tags, function (tagName) {
                        var tag = _.find(_this._tagsCache, { name: tagName });
                        if (tag) {
                            prettyTags.push(tag.displayName);
                        }
                        else {
                            prettyTags.push(tagName);
                        }
                    });
                    return prettyTags.join(", ");
                };
                UserAlertsUtilsService.$inject = ['appConfig', '$filter', 'tagsUtils', '$q'];
                return UserAlertsUtilsService;
            }());
            angular.module('Fortscale.layouts.user')
                .service('userAlertsUtils', UserAlertsUtilsService);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var IndicatorChartTransitionUtil = (function () {
                function IndicatorChartTransitionUtil(dateRanges, $location, $rootScope) {
                    this.dateRanges = dateRanges;
                    this.$location = $location;
                    this.$rootScope = $rootScope;
                    var ctrl = this;
                    this._transitions = {
                        columnAnomaly: function (indicator, item) {
                            ctrl.$rootScope.$applyAsync(function () {
                                ctrl.$location.path("/d/explore/" + indicator.dataEntitiesIds[0])
                                    .search({
                                    filters: ctrl._getFilterFieldNameByAnomalyContext(indicator, item),
                                    default_filters: ctrl._getDefaultFiltes(indicator, item)
                                });
                            });
                        },
                        columnEntity: function (indicator, item) {
                            ctrl.$rootScope.$applyAsync(function () {
                                ctrl.$location.path("/d/explore/" + indicator.dataEntitiesIds[0])
                                    .search({
                                    filters: ctrl._getFilterFieldNameByEntityContext(indicator),
                                    default_filters: ctrl._getDefaultFiltes(indicator, item)
                                });
                            });
                        }
                    };
                }
                IndicatorChartTransitionUtil.prototype._getFilterFieldNameByAnomalyContext = function (indicator, item) {
                    return indicator.dataEntitiesIds[0] + "." + indicator.anomalyTypeFieldName + "=" + (item.item.originalCategory || item.item.category);
                };
                IndicatorChartTransitionUtil.prototype._getFilterFieldNameByEntityContext = function (indicator) {
                    return indicator.dataEntitiesIds[0] + ".normalized_username=" + indicator.entityName;
                };
                IndicatorChartTransitionUtil.prototype._getDefaultFiltes = function (indicator, item) {
                    var dateRange = this.dateRanges.getByDaysRange(90).replace(',', '::');
                    return indicator.dataEntitiesIds[0] + ".event_time_utc=:" + dateRange + "," + indicator.dataEntitiesIds[0] + ".event_score=>=0";
                };
                IndicatorChartTransitionUtil.prototype.go = function (type, indicator, item) {
                    var transitionFn = this._transitions[type];
                    if (transitionFn) {
                        transitionFn(indicator, item);
                    }
                };
                IndicatorChartTransitionUtil.$inject = ['dateRanges', '$location', '$rootScope'];
                return IndicatorChartTransitionUtil;
            }());
            angular.module('Fortscale.shared.services.indicatorTypeMapper')
                .service('indicatorChartTransitionUtil', IndicatorChartTransitionUtil);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var symbolsMap = [
                {
                    symbolName: 'indicator-authentication-icon',
                    anomalyType: [
                        'auth_method',
                        'Failure Code Anomaly',
                        'High Number of Failed Authentications',
                        'High Number of Successful Authentications',
                    ]
                },
                {
                    symbolName: 'indicator-data-usage-icon',
                    anomalyType: [
                        'Data Usage Anomaly',
                        'Database Object Anomaly',
                        'Database Server Anomaly',
                        'Database Username Anomaly',
                        'high Number of Accessed Database Objects',
                        'High Number of Database Servers',
                        'High Number of Database Users',
                        'High Number of Printed Pages',
                        'High Number of Successful Actions',
                        'High Volume of Printed Data',
                        'Printer Anomaly'
                    ]
                },
                {
                    symbolName: 'indicator-location-icon',
                    anomalyType: [
                        'Geolocation Anomaly',
                        'Geolocation Sequence Anomaly',
                        'High Number of Source Countries'
                    ]
                },
                {
                    symbolName: 'indicator-user-devices-icon',
                    anomalyType: [
                        'High Number of Source Devices',
                        'Source Device Anomaly',
                    ]
                },
                {
                    symbolName: 'indicator-target-devices-icon',
                    anomalyType: [
                        'High Number of Target Devices',
                        'Target Device Anomaly',
                    ]
                },
                {
                    symbolName: 'indicator-working-hours-icon',
                    anomalyType: [
                        'Activity Time Anomaly'
                    ]
                }
            ];
            var DEFAULT_SYMBOL_NAME = 'indicator-general-icon';
            var IndicatorSymbolMapService = (function () {
                function IndicatorSymbolMapService() {
                }
                /**
                 * Takes an indicator and tries to find on the SymbolMap if the anomalyType correlates to any of the definitions
                 * If so the symbolName is returned from the map, otherwise the default symbol name is returned.
                 * @param indicator
                 * @returns {string}
                 */
                IndicatorSymbolMapService.prototype.getSymbolName = function (indicator) {
                    var symbolName;
                    _.some(symbolsMap, function (symbolType) {
                        if (symbolType.anomalyType.indexOf(indicator.anomalyType) !== -1) {
                            symbolName = symbolType.symbolName;
                            return true;
                        }
                    });
                    return symbolName || DEFAULT_SYMBOL_NAME;
                };
                return IndicatorSymbolMapService;
            }());
            angular.module('Fortscale.layouts.user')
                .service('indicatorSymbolMap', IndicatorSymbolMapService);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            'use strict';
            var UpperBarController = (function () {
                function UpperBarController($scope, $element, $timeout) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$timeout = $timeout;
                    this.isWatchRequestPending = false;
                    this.WATCH_BUTTON_SELECTOR = '.watch-user-button-watch';
                    this.UNWATCH_BUTTON_SELECTOR = '.watch-user-button-unwatch';
                    this.ANIMATION_TIME = 500;
                }
                UpperBarController.prototype._shrinkElement = function (element) {
                    element.css('transform', 'scaleY(0)');
                };
                UpperBarController.prototype._expandElement = function (element) {
                    element.css('transform', 'scaleY(1)');
                };
                UpperBarController.prototype._setTransitions = function (shrinkElement, expandElement) {
                    shrinkElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.84, 0.15) 0s";
                    expandElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.5, 1) " + this.ANIMATION_TIME / 2 / 1000 + "s";
                };
                UpperBarController.prototype._initialWatchButtonFlip = function () {
                    var selector = this.isUserFollowed ? this.UNWATCH_BUTTON_SELECTOR : this.WATCH_BUTTON_SELECTOR;
                    var element = this.$element.find(selector);
                    this._expandElement(element);
                };
                UpperBarController.prototype._watchButtonFlip = function () {
                    var _this = this;
                    var shrinkSelector = this.isUserFollowed ? this.WATCH_BUTTON_SELECTOR : this.UNWATCH_BUTTON_SELECTOR;
                    var expandSelector = this.isUserFollowed ? this.UNWATCH_BUTTON_SELECTOR : this.WATCH_BUTTON_SELECTOR;
                    var shrinkElement = this.$element.find(shrinkSelector);
                    var expandElement = this.$element.find(expandSelector);
                    this._setTransitions(shrinkElement, expandElement);
                    this.$scope.$applyAsync(function () {
                        _this._shrinkElement(shrinkElement);
                        _this._expandElement(expandElement);
                    });
                };
                UpperBarController.prototype.toggleUserWatchDelegate = function () {
                    if (this.isWatchRequestPending) {
                        return;
                    }
                    this.isWatchRequestPending = true;
                    this._toggleUserWatchDelegate();
                };
                UpperBarController.prototype.$onInit = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.user && _this.user.followed; }, function (isUserFollowed) {
                        if (isUserFollowed !== undefined) {
                            _this.isWatchRequestPending = false;
                            if (_this.isUserFollowed !== undefined) {
                                _this.isUserFollowed = isUserFollowed;
                                _this._watchButtonFlip();
                            }
                            else {
                                _this.isUserFollowed = isUserFollowed;
                                _this._initialWatchButtonFlip();
                            }
                        }
                    });
                };
                UpperBarController.$inject = ['$scope', '$element', '$timeout'];
                return UpperBarController;
            }());
            var userUpperBarComponent = {
                controller: UpperBarController,
                templateUrl: 'app/layouts/user/components/user-upper-bar/user-upper-bar.component.html',
                bindings: {
                    user: '<userModel',
                    tags: '<',
                    removeTagDelegate: '&',
                    addTagDelegate: '&',
                    //addNewTagDelegate: '&',
                    _toggleUserWatchDelegate: '&toggleUserWatchDelegate',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userUpperBar', userUpperBarComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            'use strict';
            var ProfileController = (function () {
                function ProfileController() {
                }
                ProfileController.prototype.$onInit = function () {
                };
                ProfileController.$inject = [];
                return ProfileController;
            }());
            var userProfileComponent = {
                controller: ProfileController,
                templateUrl: 'app/layouts/user/components/user-profile/user-profile.component.html',
                bindings: {
                    user: '<userModel'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userProfile', userProfileComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            'use strict';
            var TagsController = (function () {
                function TagsController($window, $scope, $element, $timeout) {
                    this.$window = $window;
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$timeout = $timeout;
                    this.NEW_TAG_INPUT_SELECTOR = '.add-tag-section--new-tag-input';
                }
                /**
                 * Click handler for clicking anywhere. It will check if the click is outside of the dropdown, and if so it will close.
                 *
                 * @param {Event} evt
                 * @private
                 */
                TagsController.prototype._dropDownWindowClickHandler = function (evt) {
                    var _this = this;
                    if (this.$element[0] === evt.target || !!this.$element.has(evt.target).length) {
                        return;
                    }
                    else {
                        this.$scope.$applyAsync(function () {
                            _this._deactivateDropDown();
                        });
                    }
                };
                /**
                 * Activate click watch for the entire document. It also contains the deregister assignment, and the cleanup.
                 * @private
                 */
                TagsController.prototype._addDropDownWindowClickWatch = function () {
                    var ctrl = this;
                    // click handler function. Wraps the "real" function to fix the "this" while allowing deregistering.
                    function dropDownOnWindowClickHandler(evt) {
                        ctrl._dropDownWindowClickHandler(evt);
                    }
                    // Deregister assignment.
                    this.dropDownWindowClickDeregister = function () {
                        ctrl.$window.removeEventListener('click', dropDownOnWindowClickHandler, true);
                    };
                    // Add click handler
                    ctrl.$window.addEventListener('click', dropDownOnWindowClickHandler, true);
                    // Add cleanup handler
                    ctrl.$scope.$on('$destroy', this.dropDownWindowClickDeregister);
                };
                /**
                 * Activates the dropdown
                 * @private
                 */
                TagsController.prototype._activateDropDown = function () {
                    this.showAddTag = true;
                    this._addDropDownWindowClickWatch();
                };
                /**
                 * Deactivates the dropdown
                 * @private
                 */
                TagsController.prototype._deactivateDropDown = function () {
                    this.showAddTag = false;
                    if (this.dropDownWindowClickDeregister) {
                        this.dropDownWindowClickDeregister();
                    }
                };
                /**
                 * When component holds both the user object and the system tags, it will convert all the user tags into ITagDefinitions
                 * @private
                 */
                TagsController.prototype._initUserTags = function () {
                    var _this = this;
                    this.userTags = [];
                    _.each(this.user.tags, function (tagName) {
                        var tag = _.filter(_this.tags, { name: tagName })[0];
                        if (tag) {
                            _this.userTags.push(tag);
                        }
                    });
                };
                /**
                 * Watch for user and tags. Act when both are present.
                 * @private
                 */
                TagsController.prototype._initWatches = function () {
                    var _this = this;
                    this.$scope.$watchGroup([
                        function () { return _this.user; },
                        function () { return _this.tags; }
                    ], function (_a) {
                        var user = _a[0], tags = _a[1];
                        // // immute states
                        // this.user = _.cloneDeep(user);
                        // this.tags = _.cloneDeep(tags);
                        // init tags if there's a user and tags
                        if (user && tags) {
                            _this._initUserTags();
                        }
                    });
                };
                /**
                 * Toggles dropdown on and off
                 */
                TagsController.prototype.toggleDropDown = function () {
                    if (this.showAddTag) {
                        this._deactivateDropDown();
                    }
                    else {
                        this._activateDropDown();
                    }
                };
                /**
                 * Toggles add-new-tag state
                 */
                TagsController.prototype.toggleAddNewTag = function () {
                    this._deactivateDropDown();
                    this.showNewTag = !this.showNewTag;
                    this.newTagModel = null;
                    if (this.showNewTag) {
                        this.$timeout(function () {
                            this.$element.find(this.NEW_TAG_INPUT_SELECTOR).focus();
                        }.bind(this), 200);
                    }
                };
                /**
                 * Closes dropdown and invokes delegate
                 * @param {ITagDefinition} tag
                 */
                TagsController.prototype.addTagItem = function (tag) {
                    this._deactivateDropDown();
                    this.addTagDelegate({ tag: tag });
                };
                /**
                 * Handler for input keypress. Fires addNewTagDelegate when key is 13 (i.e. Enter)
                 * @param {KeyboardEvent} evt
                 */
                TagsController.prototype.newTagKeyPressHandler = function (evt) {
                    if (evt.keyCode === 13) {
                        if (this.newTagModel) {
                            //this.addNewTagDelegate({tagName: this.newTagModel});
                            var tag = { name: this.newTagModel, displayName: this.newTagModel, active: true, createsIndicator: false, rules: undefined,
                                isAssignable: undefined, predefined: false };
                            this.addTagDelegate({ tag: tag });
                            this.newTagModel = null;
                            this.showNewTag = false;
                        }
                    }
                    else if (evt.keyCode === 27) {
                        this.showNewTag = false;
                        this.newTagModel = null;
                    }
                };
                /**
                 * Handler for input lost focus. Fires addNewTagDelegate.
                 */
                TagsController.prototype.newTagLostFocusHandler = function () {
                    this.showNewTag = false;
                    this.newTagModel = null;
                };
                TagsController.prototype.$onInit = function () {
                    this._initWatches();
                };
                TagsController.$inject = ['$window', '$scope', '$element', '$timeout'];
                return TagsController;
            }());
            var userTagsComponent = {
                controller: TagsController,
                templateUrl: 'app/layouts/user/components/user-tags/user-tags.component.html',
                bindings: {
                    user: '<userModel',
                    tags: '<tags',
                    removeTagDelegate: '&',
                    addTagDelegate: '&',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userTags', userTagsComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            'use strict';
            var ActivityCountriesController = (function () {
                function ActivityCountriesController($scope, $element, countryCodesUtil, amMapsUtils) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.countryCodesUtil = countryCodesUtil;
                    this.amMapsUtils = amMapsUtils;
                    this.areasOn = true;
                    this.imagesOn = true;
                }
                /**
                 * Adds percent to each user-country
                 * @returns {IAugmentedActivityUserCountry[]}
                 * @private
                 */
                ActivityCountriesController.prototype._AugmentUserCountries = function () {
                    var _this = this;
                    var userCountries = _.cloneDeep(this._userCountries);
                    var sum = _.sumBy(userCountries, 'count');
                    _.each(userCountries, function (userCountry) {
                        userCountry.percent = Math.round(userCountry.count / sum * 10000) / 100;
                        userCountry.alpha2 = _this.countryCodesUtil.getAlpha2ByCountryName(userCountry.country);
                    });
                    return userCountries;
                };
                /**
                 * Sorts user countries
                 *
                 * @returns {IAugmentedActivityUserCountry[]}
                 * @private
                 */
                ActivityCountriesController.prototype._sortUserCountries = function () {
                    return _.orderBy(this.userCountries, [
                        function (userCountry) { return userCountry.country === 'Others'; },
                        'count'
                    ], [
                        'asc',
                        'desc'
                    ]);
                };
                /**
                 * Returns a list of areas to be used in the map
                 * @returns {Array<{id: string, color: string}>}
                 * @private
                 */
                ActivityCountriesController.prototype._getAreasForMapDataProvider = function () {
                    var _this = this;
                    return _.map(this.organizationCountries, function (orgCountry) {
                        return {
                            id: _this.countryCodesUtil.getAlpha2ByCountryName(orgCountry.country),
                            color: '#024d88'
                        };
                    });
                };
                /**
                 * Returns a list of image map config objects.
                 * @returns {IAmMapsUtilsBubbleConfig[]}
                 * @private
                 */
                ActivityCountriesController.prototype._getBubbles = function () {
                    return this.amMapsUtils.getBubbles({
                        map: this.map,
                        // Filter out countries without alpha2 (i.e. others) and map to return map config objects
                        countries: _.map(_.filter(this.userCountries, 'alpha2'), function (userCountry) {
                            return {
                                alpha2: userCountry.alpha2,
                                name: userCountry.country,
                                value: userCountry.percent,
                                color: 'rgba(83, 194, 228, 0.5)'
                            };
                        })
                    });
                };
                /**
                 * Returns a list of relevant map objects to be used as a zoom group
                 * @param {{}} map
                 * @param {boolean=} withoutOrganization
                 * @param {boolean=} withoutUser
                 * @returns {Array<{}>}
                 * @private
                 */
                ActivityCountriesController.prototype._getRelevantMapObjects = function (map, withoutOrganization, withoutUser) {
                    var _this = this;
                    var zoomToAreasIds;
                    // Add organization map ids (if not withoutOrganization)
                    if (withoutOrganization) {
                        zoomToAreasIds = [];
                    }
                    else {
                        zoomToAreasIds = _.map(this.organizationCountries, function (oCountry) { return _this.countryCodesUtil.getAlpha2ByCountryName(oCountry.country); });
                    }
                    // Add user map ids (if not withoutUser)
                    if (!withoutUser) {
                        _.each(this.userCountries, function (userCountry) { return zoomToAreasIds.push(userCountry.alpha2); });
                    }
                    // take ids and get map objects. Push map object to zoomToAreas.
                    var zoomToAreas = [];
                    _.each(zoomToAreasIds, function (id) {
                        var area = map.getObjectById(id);
                        if (area) {
                            zoomToAreas.push(area);
                        }
                    });
                    return zoomToAreas;
                };
                /**
                 * Initiates the amMap map object
                 * @private
                 */
                ActivityCountriesController.prototype._initMap = function () {
                    if (!this.userCountries || !this.organizationCountries) {
                        return;
                    }
                    var ctrl = this;
                    // Create a map
                    this.map = AmCharts.makeChart('top-countries-map', {
                        type: 'map',
                        projection: 'miller',
                        imagesSettings: {
                            balloonText: '<span style="font-size:14px;"><b>[[title]]</b>: [[value]]%</span>',
                            selectable: false
                        },
                        areasSettings: {
                            selectedColor: '#024d88',
                            color: '#babdbe',
                            selectable: false
                        },
                        listeners: [
                            {
                                event: 'rendered',
                                method: function (evt) {
                                    ctrl.mapOriginalZoomX = evt.chart.zoomX();
                                    ctrl.mapOriginalZoomY = evt.chart.zoomY();
                                    setTimeout(function () {
                                        evt.chart.zoomToGroup(ctrl._getRelevantMapObjects(evt.chart));
                                    }, 500);
                                }
                            }
                        ],
                        zoomControl: {
                            top: 1,
                            buttonSize: window.innerHeight < 700 ? 25 :
                                window.innerHeight < 1000 ? 30 : 35
                        },
                        dataProvider: {
                            map: 'worldHigh',
                            getAreasFromMap: true,
                            areas: this._getAreasForMapDataProvider(),
                            images: this._getBubbles(),
                            zoomLevel: 1,
                            zoomLatitude: "",
                            zoomLongitude: ""
                        }
                    });
                };
                /**
                 * Rerenders the map in the previous zoom level and position
                 * @private
                 */
                ActivityCountriesController.prototype._rerenderMap = function () {
                    this.map.dataProvider.zoomLevel = this.map.zoomLevel();
                    this.map.dataProvider.zoomLatitude = this.map.zoomLatitude();
                    this.map.dataProvider.zoomLongitude = this.map.zoomLongitude();
                    this.map.validateData();
                    var groups = this._getRelevantMapObjects(this.map, !this.areasOn, !this.imagesOn);
                    if (groups.length) {
                        this.map.zoomToGroup(groups);
                    }
                    else {
                        this.map.zoomTo(1, this.mapOriginalZoomX, this.mapOriginalZoomY);
                    }
                };
                /**
                 * Initiates user countries watch
                 * @private
                 */
                ActivityCountriesController.prototype._initUserCountriesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._userCountries; }, function () {
                        if (_this._userCountries) {
                            _this.userCountries = _this._AugmentUserCountries();
                            _this.userCountries = _this._sortUserCountries();
                            _this._initMap();
                        }
                    });
                };
                /**
                 * Initiates watch on _organizationCountries. Clones it when arrives (for immutability)
                 * @private
                 */
                ActivityCountriesController.prototype._initOrganizationCountriesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._organizationCountries; }, function () {
                        if (_this._organizationCountries) {
                            _this.organizationCountries =
                                _.cloneDeep(_this._organizationCountries);
                            _this.mapAreas = _this._getAreasForMapDataProvider();
                            _this._initMap();
                        }
                    });
                };
                /**
                 * Resize handler. Will redraw the map on a resize.
                 *
                 * @private
                 */
                ActivityCountriesController.prototype._initResizeWatch = function () {
                    var ctrl = this;
                    function resizeHandler() {
                        ctrl.map.clear();
                        ctrl.map = null;
                        delete ctrl["map"];
                        ctrl._initMap();
                    }
                    window.addEventListener('resize', resizeHandler, false);
                    this.$scope.$on('$destroy', function () {
                        window.removeEventListener('resize', resizeHandler, false);
                    });
                };
                /**
                 * A cb function that is used in a filter to remove out any members with a count of zero
                 * @param {IActivityUserCountry} userCountry
                 * @returns {boolean}
                 */
                ActivityCountriesController.prototype.hideZeroCountFilter = function (userCountry) {
                    return userCountry.count !== 0;
                };
                /**
                 * Changes the state of the map's Areas (i.e. organization).
                 */
                ActivityCountriesController.prototype.toggleAreas = function () {
                    if (!this.areasOn) {
                        this.map.dataProvider.areas = this._getAreasForMapDataProvider();
                    }
                    else {
                        this.map.dataProvider.areas = [];
                    }
                    this.areasOn = !this.areasOn;
                    this._rerenderMap();
                };
                /**
                 * Changes the state of the map's images (i.e. user bubbles)
                 */
                ActivityCountriesController.prototype.toggleImages = function () {
                    if (!this.imagesOn) {
                        this.map.dataProvider.images = this._getBubbles();
                    }
                    else {
                        this.map.dataProvider.images = [];
                    }
                    this.imagesOn = !this.imagesOn;
                    this._rerenderMap();
                };
                ActivityCountriesController.prototype.$onInit = function () {
                    this._initUserCountriesWatch();
                    this._initOrganizationCountriesWatch();
                    this._initResizeWatch();
                };
                ActivityCountriesController.$inject = ['$scope', '$element', 'countryCodesUtil', 'amMapsUtils'];
                return ActivityCountriesController;
            }());
            var userActivityCountriesComponent = {
                controller: ActivityCountriesController,
                templateUrl: 'app/layouts/user/components/user-activity-countries/user-activities-countries.component.html',
                bindings: {
                    _userCountries: '<userCountries',
                    _organizationCountries: '<organizationCountries',
                    user: '<userModel'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userActivityCountries', userActivityCountriesComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var ActivityAuthenticationController = (function () {
                function ActivityAuthenticationController($scope, $timeout) {
                    this.$scope = $scope;
                    this.$timeout = $timeout;
                    this.authPercent = 100;
                }
                /**
                 * Takes received data and calculates the success failure and icon ratio.
                 * @private
                 */
                ActivityAuthenticationController.prototype._changeAuthPercents = function () {
                    // Calc basic
                    var total = this.authentications.success + this.authentications.failed;
                    var success = this.authentications.success / total;
                    var failure = 1 - success;
                    // Normalize results to show
                    this.successPercent = Math.round(success * 100) || 0;
                    this.failurePercent = Math.round(failure * 100) || 0;
                    // Normalize icon ratio to show. The ratio is smaller than 100% because of the way icons are placed.
                    this.authPercent = (Math.round(success * 74) + 13) || 100;
                };
                ActivityAuthenticationController.prototype.$onInit = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.authentications; }, function () {
                        if (_this.authentications) {
                            _this.$timeout(_this._changeAuthPercents.bind(_this), 500);
                        }
                    });
                };
                ActivityAuthenticationController.$inject = ['$scope', '$timeout'];
                return ActivityAuthenticationController;
            }());
            var activityAuthenticationComponent = {
                controller: ActivityAuthenticationController,
                templateUrl: 'app/layouts/user/components/user-activity-authentication/user-activity-authentication.component.html',
                bindings: {
                    authentications: '<'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userActivityAuthentication', activityAuthenticationComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var ActivityWorkingHoursController = (function () {
                function ActivityWorkingHoursController($scope, $timeout) {
                    this.$scope = $scope;
                    this.$timeout = $timeout;
                }
                /**
                 * "Activates" an hour (which will, via the template, add an 'active' class to the hour-bar)
                 * @param hour
                 * @private
                 */
                ActivityWorkingHoursController.prototype._setHourActive = function (hour) {
                    hour.active = !hour.active;
                };
                /**
                 * Iterates through received working hours, and activates each corresponding hour on workingHours.
                 * @private
                 */
                ActivityWorkingHoursController.prototype._digestWorkingHours = function () {
                    var _this = this;
                    // Reset the index, and sort received working hours (to make sure hours are in order)
                    var index = 0;
                    var workingHours = _.sortBy(this._workingHours, 'hour');
                    // Iterate through received working hours, and turn on each of this.workingHours
                    _.each(workingHours, function (workingHour) {
                        // Make sure received hours do not break the method.
                        if (workingHour.hour > 24 || workingHour.hour < 1) {
                            return;
                        }
                        // Move forward on this.workingHours, and stop and set when an hour matches.
                        var cont = true;
                        while (cont) {
                            if (_this.workingHours[index].hour === workingHour.hour) {
                                // Activate hour with a timeout to create a cascade effect.
                                _this.$timeout(_this._setHourActive.bind(_this, _this.workingHours[index]), index * 100);
                                cont = false;
                            }
                            index += 1;
                        }
                    });
                };
                /**
                 * Creates a new working hours list and returns it
                 * @returns {Array}
                 * @private
                 */
                ActivityWorkingHoursController.prototype._generateWorkingHoursList = function () {
                    var wh = [];
                    for (var i = 1; i <= 24; i += 1) {
                        wh.push({
                            hour: i,
                            active: false
                        });
                    }
                    return wh;
                };
                /**
                 * Sets to this.workingHours a list of deactivated IWorkingHour
                 * @private
                 */
                ActivityWorkingHoursController.prototype._initWorkingHours = function () {
                    this.workingHours = this._generateWorkingHoursList();
                };
                /**
                 * Sets watch to received workingHours. When workingHours is received a new list is set to this.workingHours,
                 * and the received items are digested.
                 * @private
                 */
                ActivityWorkingHoursController.prototype._initWorkingHoursWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._workingHours; }, function (workingHours) {
                        if (workingHours && workingHours.length) {
                            _this._initWorkingHours();
                            _this._digestWorkingHours();
                        }
                    });
                };
                /**
                 * Generates the time as an am/pm string
                 * @param workingHour
                 * @returns {any}
                 */
                ActivityWorkingHoursController.prototype.getHourBarTitle = function (workingHour) {
                    var hour = workingHour.hour % 12;
                    var isAm = workingHour.hour < 13;
                    if (hour === 0) {
                        hour = 12;
                        isAm = !isAm;
                    }
                    return hour + (isAm ? ' AM' : ' PM');
                };
                ;
                ActivityWorkingHoursController.prototype.$onInit = function () {
                    // init working hours
                    this._initWorkingHours();
                    this._initWorkingHoursWatch();
                };
                ActivityWorkingHoursController.$inject = ['$scope', '$timeout'];
                return ActivityWorkingHoursController;
            }());
            var activityWorkingHoursComponent = {
                controller: ActivityWorkingHoursController,
                templateUrl: 'app/layouts/user/components/user-activity-working-hours/user-activity-working-hours.component.html',
                bindings: {
                    _workingHours: '<workingHours'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userActivityWorkingHours', activityWorkingHoursComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var ActivityDevicesController = (function () {
                function ActivityDevicesController($scope, $timeout, deviceUtilsService) {
                    this.$scope = $scope;
                    this.$timeout = $timeout;
                    this.deviceUtilsService = deviceUtilsService;
                    this._devices = [];
                    this.devices = null;
                }
                //Remove all devices with no count, if any returned from server.
                ActivityDevicesController.prototype._removeZeroCount = function (devices) {
                    //return new array of IUserDevices with devices
                    return _.filter(devices, function (device) { return device.count > 0; });
                };
                /**
                 * Takes received source devices, sorts, repositions 'other', and adds percent to each, then stores on devices
                 * @private
                 */
                ActivityDevicesController.prototype._digestDevices = function () {
                    var devices;
                    // sort _devices
                    devices = _.orderBy(_.cloneDeep(this._devices), 'count', 'desc');
                    // pluck "other" and push to the end
                    this.deviceUtilsService.repositionOthers(devices);
                    // remove all items with zero count
                    devices = this.deviceUtilsService.removeZeroCount(devices);
                    devices = this.deviceUtilsService.updatePercentageOnDevice(devices);
                    this.devices = devices;
                };
                ActivityDevicesController.prototype._sortDevices = function () {
                    this.devices = _.orderBy(this.devices, [
                        function (userDevice) { return userDevice.deviceName === 'Others'; },
                        'count'
                    ], [
                        'asc',
                        'desc'
                    ]);
                };
                /**
                 * Activates the bars
                 * @private
                 */
                ActivityDevicesController.prototype._activateBars = function () {
                    var _this = this;
                    _.each(this.devices, function (device, index) {
                        _this.$timeout(function () {
                            device.active = true;
                        }, ((_this.devices.length - 1) - index) * 400 + 200);
                    });
                };
                /**
                 * Initiates watch on received source devices
                 * @private
                 */
                ActivityDevicesController.prototype._initDevicesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._devices; }, function (devices) {
                        if (devices && devices.length) {
                            _this._digestDevices();
                            _this._sortDevices();
                            _this._activateBars();
                        }
                        else if (devices) {
                            _this.devices = [];
                        }
                    });
                };
                ActivityDevicesController.prototype.$onInit = function () {
                    this._initDevicesWatch();
                };
                ActivityDevicesController.$inject = ['$scope', '$timeout', 'deviceUtilsService'];
                return ActivityDevicesController;
            }());
            var activityDevicesComponent = {
                controller: ActivityDevicesController,
                templateUrl: 'app/layouts/user/components/user-activity-devices/user-activity-devices.component.html',
                bindings: {
                    _devices: '<devices',
                    description: '@'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userActivityDevices', activityDevicesComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var ActivityDataUsagesController = (function () {
                function ActivityDataUsagesController($scope, $timeout, $filter) {
                    this.$scope = $scope;
                    this.$timeout = $timeout;
                    this.$filter = $filter;
                    this._dataUsages = [];
                    /**
                     * Object used as a map for received values
                     * @type {{[vpn_session.databucket_histogram]: {title: string, icon: string, value: any}, [oracle.db_object_histogram]: {title: string, icon: string, value: any}, [prnlog.file_size_histogram]: {title: string, icon: string, value: any}}}
                     */
                    this.dataUsageMap = {
                        'vpn_session.databucket_histogram': {
                            title: 'VPN',
                            icon: 'data-usage-vpn-icon',
                            value: this._vpnValueProcess.bind(this)
                        },
                        'oracle.db_object_histogram': {
                            title: 'Oracle DB',
                            icon: 'data-usage-oracle-icon',
                            value: this._oracleValueProcess.bind(this)
                        },
                        'prnlog.file_size_histogram': {
                            title: 'Print',
                            icon: 'data-usage-print-icon',
                            value: this._printValueProcess.bind(this)
                        }
                    };
                }
                ActivityDataUsagesController.prototype._prettyBytes = function (val) {
                    var prettyBytesFilter = this.$filter('prettyBytes');
                    return prettyBytesFilter(val);
                };
                ActivityDataUsagesController.prototype._vpnValueProcess = function (val) {
                    return this._prettyBytes(val);
                };
                ActivityDataUsagesController.prototype._oracleValueProcess = function (val) {
                    return val !== 1 ? val + " Accesses" : "1 Access";
                };
                ActivityDataUsagesController.prototype._printValueProcess = function (val) {
                    return this._prettyBytes(val);
                };
                /**
                 * Digests received dataUsages. Uses map to parse received values.
                 * @private
                 */
                ActivityDataUsagesController.prototype._digestDataUsages = function () {
                    var _this = this;
                    this.dataUsages = _.map(this._dataUsages, function (dataUsage) {
                        var dataUsageMap = _this.dataUsageMap[dataUsage.dataEntityId];
                        return {
                            icon: dataUsageMap.icon,
                            title: dataUsageMap.title,
                            value: dataUsageMap.value(dataUsage.value || 0)
                        };
                    });
                    // populate missing rows
                    // Iterate through the keys, and find if any are missing, if so populate with zero value
                    _.each(['vpn_session.databucket_histogram', 'oracle.db_object_histogram', 'prnlog.file_size_histogram'], function (dataEntityId) {
                        if (!_.some(_this._dataUsages, function (dataUsage) { return dataUsage.dataEntityId === dataEntityId; })) {
                            var dataUsageMap = _this.dataUsageMap[dataEntityId];
                            _this.dataUsages.push({
                                icon: dataUsageMap.icon,
                                title: dataUsageMap.title,
                                value: dataUsageMap.value(0)
                            });
                        }
                    });
                };
                /**
                 * Initiates watch on received dataUsages
                 * @private
                 */
                ActivityDataUsagesController.prototype._initDataUsagesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._dataUsages; }, function () {
                        if (_this._dataUsages && _.isArray(_this._dataUsages)) {
                            _this._digestDataUsages();
                        }
                    });
                };
                ActivityDataUsagesController.prototype.$onInit = function () {
                    this._initDataUsagesWatch();
                };
                ActivityDataUsagesController.$inject = ['$scope', '$timeout', '$filter'];
                return ActivityDataUsagesController;
            }());
            var activityDataUsagesComponent = {
                controller: ActivityDataUsagesController,
                templateUrl: 'app/layouts/user/components/user-activity-data-usage/user-activity-data-usage.component.html',
                bindings: {
                    _dataUsages: '<ddataUsages'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userActivityDataUsages', activityDataUsagesComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var RiskScoreController = (function () {
                function RiskScoreController($scope, $timeout, $stateParams, $element, $q, userIndicatorsUtils) {
                    this.$scope = $scope;
                    this.$timeout = $timeout;
                    this.$stateParams = $stateParams;
                    this.$element = $element;
                    this.$q = $q;
                    this.userIndicatorsUtils = userIndicatorsUtils;
                    this.USER_RISK_SCORE_LIST_SELECTOR_NAME = '.user-risk-score-list';
                    this.ALERT_SELECTOR_PREFIX = '.alert-id-';
                    this.INDICATOR_SELECTOR_PREFIX = '.indicator-id-';
                    this.INDICATORS_LIST_SELECTOR = '.indicators-list-wrapper';
                    this.INDICATORS_MASK_SELECTOR = '.indicators-list-mask';
                    this.SCROLL_ANIMATION_TIME = 300;
                    this.OPEN_INDICATOR_ANIMATION_TIME = 300;
                    this.CLOSE_INDICATOR_ANIMATION_TIME = 300;
                    this.alertSortBys = [
                        {
                            text: 'Severity',
                            value: 'severity'
                        },
                        {
                            text: 'Date',
                            value: 'date'
                        }
                    ];
                }
                /**
                 * Returns the risk score element
                 * @returns {ng.IAugmentedJQuery}
                 * @private
                 */
                RiskScoreController.prototype._getUserRiskScoreElement = function () {
                    if (!this._userRiskScoreElement) {
                        this._userRiskScoreElement = this.$element.find(this.USER_RISK_SCORE_LIST_SELECTOR_NAME);
                    }
                    return this._userRiskScoreElement;
                };
                /**
                 * Returns an alert element
                 * @param alertId
                 * @returns {any}
                 * @private
                 */
                RiskScoreController.prototype._getAlertElement = function (alertId) {
                    // return a specific alert element (not the active one)
                    if (alertId) {
                        return this.$element.find(this.ALERT_SELECTOR_PREFIX + alertId);
                    }
                    if (!this.activeAlertId) {
                        return null;
                    }
                    if (!this._alertElement) {
                        this._alertElement = this.$element.find(this.ALERT_SELECTOR_PREFIX + this.activeAlertId);
                    }
                    return this._alertElement;
                };
                /**
                 * Returns an indicators list element
                 * @returns {JQuery}
                 * @private
                 */
                RiskScoreController.prototype._getIndicatorsListElement = function () {
                    if (!this._getAlertElement()) {
                        return null;
                    }
                    if (!this._indicatorsListElement) {
                        this._indicatorsListElement = this._getAlertElement().find(this.INDICATORS_LIST_SELECTOR);
                    }
                    return this._indicatorsListElement;
                };
                RiskScoreController.prototype._getIndicatorElement = function () {
                    if (!this._getIndicatorsListElement() || !this.activeIndicatorId) {
                        return null;
                    }
                    if (!this._indicatorElement) {
                        this._indicatorElement = this._getIndicatorsListElement().find(this.INDICATOR_SELECTOR_PREFIX + this.activeIndicatorId);
                    }
                    return this._indicatorElement;
                };
                /**
                 * Returns an indicators list mask element
                 * @param alertElement
                 * @returns {any}
                 * @private
                 */
                RiskScoreController.prototype._getIndicatorsMaskElement = function (alertElement) {
                    // return a specific mask element and not the active alert element
                    if (alertElement) {
                        return alertElement.find(this.INDICATORS_MASK_SELECTOR);
                    }
                    if (!this._getAlertElement()) {
                        return null;
                    }
                    if (!this._indicatorsMaskElement) {
                        this._indicatorsMaskElement = this._getAlertElement().find(this.INDICATORS_MASK_SELECTOR);
                    }
                    return this._indicatorsMaskElement;
                };
                /**
                 * Calculates an offset between two element
                 * @param targetElement
                 * @param containerElement
                 * @returns {number}
                 * @private
                 */
                RiskScoreController.prototype._calcTopOffsetInContainer = function (targetElement, containerElement) {
                    var childPos = targetElement.offset();
                    var parentPos = containerElement.offset();
                    return childPos.top - parentPos.top;
                };
                RiskScoreController.prototype._isIndicatorElementOutOfBounds = function () {
                    var userRiskElement = this._getUserRiskScoreElement();
                    var indicatorElement = this._getIndicatorElement();
                    var offset = this._calcTopOffsetInContainer(indicatorElement, userRiskElement);
                    return (offset < 0 || offset + indicatorElement.outerHeight() > userRiskElement.outerHeight());
                };
                /**
                 * Animates indicators open.
                 * @private
                 */
                RiskScoreController.prototype._animateOpenIndicators = function () {
                    var _this = this;
                    return this.$q(function (resolve, reject) {
                        // Get alert element and stop animation if alert does not exist
                        var alertElement = _this._getAlertElement();
                        if (!alertElement) {
                            return;
                        }
                        // Get Elements
                        var indicatorsListElement = _this._getIndicatorsListElement();
                        var indicatorsMaskElement = _this._getIndicatorsMaskElement();
                        // Do not open if mask element already open
                        if (indicatorsMaskElement.outerHeight() > 0) {
                            return resolve();
                        }
                        //calc height
                        var height = indicatorsListElement.outerHeight();
                        // animate height
                        indicatorsMaskElement.animate({ height: height }, _this.OPEN_INDICATOR_ANIMATION_TIME, function () {
                            resolve();
                        });
                    });
                };
                /**
                 * Animates indicators list close
                 * @param alertId
                 * @private
                 */
                RiskScoreController.prototype._animateCloseIndicators = function (alertId) {
                    var alertElement = this._getAlertElement(alertId);
                    var indicatorsMaskElement = this._getIndicatorsMaskElement(alertElement);
                    indicatorsMaskElement.animate({ height: 0 }, this.CLOSE_INDICATOR_ANIMATION_TIME);
                };
                /**
                 * Animates a scroll to alert in the list
                 * @returns {IPromise<void>}
                 * @private
                 */
                RiskScoreController.prototype._animateActiveAlert = function () {
                    var _this = this;
                    return this.$q(function (resolve, reject) {
                        var userRiskElement = _this._getUserRiskScoreElement();
                        var alertElement = _this._getAlertElement();
                        userRiskElement.animate({ scrollTop: _this._calcTopOffsetInContainer(alertElement, userRiskElement) }, _this.SCROLL_ANIMATION_TIME, function () {
                            resolve();
                        });
                    });
                };
                /**
                 * Animates an active indicator
                 * @param cb
                 * @returns {IPromise<T>}
                 * @private
                 */
                RiskScoreController.prototype._animateActiveIndicator = function () {
                    var _this = this;
                    return this.$q(function (resolve, reject) {
                        var userRiskElement = _this._getUserRiskScoreElement();
                        var alertElement = _this._getAlertElement();
                        var indicatorsListElement = _this._getIndicatorsListElement();
                        var indicatorElement = _this._getIndicatorElement();
                        var offset;
                        //find offset of indicator item in indicators list
                        var indicatorInIndicatorsListOffset = _this._calcTopOffsetInContainer(indicatorElement, indicatorsListElement);
                        // if the indicator top plus height plus alert element height fits in the user risk element
                        // then scroll to alert
                        var indicatorBottom = indicatorInIndicatorsListOffset + indicatorElement.outerHeight() +
                            alertElement.find('.alert-item-inner-wrapper').outerHeight();
                        if (indicatorBottom <= userRiskElement.outerHeight()) {
                            offset = _this._calcTopOffsetInContainer(alertElement, userRiskElement);
                        }
                        else {
                            // If the indicator bottom is greater then risk element height then scroll to indicator element
                            offset = _this._calcTopOffsetInContainer(indicatorElement, userRiskElement);
                        }
                        userRiskElement.animate({ scrollTop: offset + userRiskElement.scrollTop() }, _this.SCROLL_ANIMATION_TIME, function () {
                            resolve();
                        });
                    });
                };
                /**
                 * Renders the sort dropdown control
                 * @private
                 */
                RiskScoreController.prototype._renderSortControlDropdown = function () {
                    var ctrl = this;
                    function onChange(evt) {
                        ctrl.selectedAlertSortBy = evt.sender.dataItem();
                        ctrl.$scope.$applyAsync(function () {
                            ctrl._orderAlerts();
                        });
                    }
                    //Create the drop down
                    $(".sort-drop-down").kendoDropDownList({
                        dataTextField: "text",
                        dataValueField: "value",
                        dataSource: ctrl.alertSortBys,
                        index: 0,
                        change: onChange
                    });
                    //Select the first element
                    ctrl.selectedAlertSortBy = this.alertSortBys[0];
                    ctrl._orderAlerts();
                };
                /**
                 * Initiates a user watch. On new user, clones the user and places on controller
                 * @private
                 */
                RiskScoreController.prototype._initUserWatch = function () {
                    var _this = this;
                    var userWatchUnregister;
                    this.$scope.$watch(function () { return _this._user; }, function (user) {
                        if (user) {
                            _this.user = _.cloneDeep(_this._user);
                            _this._setActiveIds();
                        }
                    });
                };
                /**
                 * Initates an alerts watch. On new alerts, clones, orders, and animates to the relevant alert.
                 * @private
                 */
                RiskScoreController.prototype._initAlertsWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._alerts; }, function (alerts) {
                        if (alerts) {
                            _this.alerts = _.cloneDeep(_this._alerts);
                            _this._orderAlerts();
                            _this._orderIndicators();
                            _this._filterIndicators();
                            _this._emitAlertsChange();
                            _this._setActiveIds();
                            // Scroll to alert if on alert state
                            if (_this.$stateParams.alertId /*&& !this.$stateParams.indicatorId*/) {
                                _this.$scope.$applyAsync(function () {
                                    _this._animateActiveAlert()
                                        .then(function () {
                                        _this._animateOpenIndicators();
                                    });
                                });
                            }
                            // Scroll to indicator if on indicator state
                            if (_this.$stateParams.alertId && _this.$stateParams.indicatorId) {
                                _this.$scope.$applyAsync(function () {
                                    _this._animateOpenIndicators()
                                        .then(function () {
                                        _this._animateActiveIndicator();
                                    });
                                });
                            }
                        }
                    });
                };
                /**
                 * Listener for state changes start. On a change start, sets activeAlertId, and animates.
                 * @private
                 */
                RiskScoreController.prototype._initStateChangeWatch = function () {
                    var _this = this;
                    var ctrl = this;
                    this.$scope.$on('$stateChangeSuccess', function (evt, toState, toParams, fromState, fromParams) {
                        _this._setActiveIds();
                        _this.$scope.$applyAsync(function () {
                            if (_this.$stateParams.alertId /*&& this.$stateParams.indicatorId*/) {
                                _this._animateOpenIndicators()
                                    .then(function () {
                                    if (_this.$stateParams.indicatorId && _this._isIndicatorElementOutOfBounds()) {
                                        _this._animateActiveIndicator();
                                    }
                                });
                            }
                            if (fromParams.alertId && toParams.alertId !== fromParams.alertId) {
                                _this._animateCloseIndicators(fromParams.alertId);
                            }
                        });
                    });
                };
                RiskScoreController.prototype._emitAlertsChange = function () {
                    var _this = this;
                    this.$scope.$applyAsync(function () {
                        _this.$scope.$emit('userRiskScore:AlertsSorted', _this.alerts);
                    });
                };
                /**
                 * Orders alerts and returns an ordered list
                 * @returns {any}
                 * @private
                 */
                RiskScoreController.prototype._orderAlerts = function () {
                    if (!this.alerts || !this.selectedAlertSortBy) {
                        return;
                    }
                    switch (this.selectedAlertSortBy.value) {
                        case 'severity':
                            this.alerts = _.clone(_.orderBy(this.alerts, ['userScoreContributionFlag', 'severityCode', 'startDate'], ['desc', 'asc', 'desc']));
                            this._emitAlertsChange();
                            break;
                        case 'date':
                            this.alerts = _.clone(_.orderBy(this.alerts, ['userScoreContributionFlag', 'startDate', 'severityCode'], ['desc', 'desc', 'asc']));
                            this._emitAlertsChange();
                            break;
                        default:
                            return;
                    }
                };
                RiskScoreController.prototype._orderIndicators = function () {
                    var _this = this;
                    if (!this.alerts) {
                        return;
                    }
                    _.each(this.alerts, function (alert) {
                        alert.evidences = _this.userIndicatorsUtils.orderIndicators(alert.evidences);
                    });
                };
                RiskScoreController.prototype._filterIndicators = function () {
                    var _this = this;
                    if (!this.alerts) {
                        return;
                    }
                    _.each(this.alerts, function (alert) {
                        // filter out 'tag' indicators and save the filtered indicators on tagEvidence attribute
                        alert.tagEvidences = _this.userIndicatorsUtils.getTagsIndicators(alert.evidences);
                        alert.evidences =
                            _this.userIndicatorsUtils.filterIndicators(alert.evidences);
                    });
                };
                RiskScoreController.prototype._setActiveIds = function () {
                    this.activeAlertId = this.$stateParams.alertId || null;
                    this.activeIndicatorId = this.$stateParams.indicatorId || null;
                    // nullify elements
                    this._userRiskScoreElement = null;
                    this._alertElement = null;
                    this._indicatorsListElement = null;
                    this._indicatorElement = null;
                    this._indicatorsMaskElement = null;
                };
                RiskScoreController.prototype.$onInit = function () {
                    this._initUserWatch();
                    this._initAlertsWatch();
                    this._initStateChangeWatch();
                    this._setActiveIds();
                    this._renderSortControlDropdown();
                };
                RiskScoreController.$inject = ['$scope', '$timeout', '$stateParams', '$element', '$q', 'userIndicatorsUtils'];
                return RiskScoreController;
            }());
            var riskScoreComponent = {
                controller: RiskScoreController,
                templateUrl: 'app/layouts/user/components/user-risk-score/user-risk-score.component.html',
                bindings: {
                    _alerts: '<alerts',
                    _user: '<user',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userRiskScore', riskScoreComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserIndicatorController = (function () {
                function UserIndicatorController($scope, $element, $filter) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$filter = $filter;
                }
                UserIndicatorController.prototype._initWatches = function () {
                    var ctrl = this;
                    var deregister;
                    function watchHandler() {
                        if (ctrl._indicator && ctrl._indicatorType && ctrl._alert && ctrl._user) {
                            // Clone alert, indicator and indicator type
                            ctrl.alert = _.cloneDeep(ctrl._alert);
                            ctrl.indicator = _.cloneDeep(ctrl._indicator);
                            ctrl.indicatorType = _.cloneDeep(ctrl._indicatorType);
                            ctrl.user = _.cloneDeep(ctrl._user);
                            // Remove watcher
                            deregister();
                        }
                    }
                    deregister = ctrl.$scope.$watchGroup([
                        function () { return ctrl._alert; },
                        function () { return ctrl._indicator; },
                        function () { return ctrl._indicatorType; },
                        function () { return ctrl._user; }
                    ], watchHandler);
                };
                UserIndicatorController.prototype.$onInit = function () {
                    this._initWatches();
                };
                UserIndicatorController.$inject = ['$scope', '$element', '$filter'];
                return UserIndicatorController;
            }());
            var userIndicatorComponent = {
                controller: UserIndicatorController,
                templateUrl: 'app/layouts/user/components/user-indicator/components/user-indicator/user-indicator.component.html',
                bindings: {
                    _alert: '<alertModel',
                    _indicator: '<indicator',
                    _indicatorType: '<indicatorType',
                    _user: '<userModel'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userIndicator', userIndicatorComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var userIndicatorHeaderController = (function () {
                function userIndicatorHeaderController($scope, $stateParams, userIndicatorsUtils, $state) {
                    this.$scope = $scope;
                    this.$stateParams = $stateParams;
                    this.userIndicatorsUtils = userIndicatorsUtils;
                    this.$state = $state;
                    this._currentIndicatorIndex = null;
                }
                /**
                 * Returns the index of the current indicator in the current alert
                 * @returns {number}
                 */
                userIndicatorHeaderController.prototype.getCurrentIndicatorIndex = function () {
                    var _this = this;
                    if (this._currentIndicatorIndex === null && this.alert) {
                        var index_1 = null;
                        // match the current indicatorId to an indicator in the indicators list
                        _.some(this.alert.evidences, function (indicator, i) {
                            if (indicator.id === _this.$stateParams.indicatorId) {
                                index_1 = i;
                                return true;
                            }
                        });
                        if (this._currentIndicatorIndex !== index_1) {
                            this._currentIndicatorIndex = index_1;
                        }
                    }
                    return this._currentIndicatorIndex;
                };
                userIndicatorHeaderController.prototype._initAlertWatch = function () {
                    var _this = this;
                    var deregister = this.$scope.$watch(function () { return _this._alert; }, function () {
                        if (_this._alert) {
                            // Clone alert, sort and filter indicators, and unregister the watch
                            _this.alert = _.cloneDeep(_this._alert);
                            _this.alert.evidences = _this.userIndicatorsUtils.filterIndicators(_this.userIndicatorsUtils.orderIndicators(_this.alert.evidences));
                            deregister();
                        }
                    });
                };
                /**
                 * Transition to a new indicator state
                 * @param step
                 */
                userIndicatorHeaderController.prototype.transitionIndicator = function (step) {
                    var futureIndex = this.getCurrentIndicatorIndex() + step;
                    // make sure it doesn't exceed the list's range
                    if (futureIndex < 0 || futureIndex > this.alert.evidences.length - 1) {
                        return;
                    }
                    this.$state.go(this.$state.current.name, { alertId: this.$stateParams.alertId, indicatorId: this.alert.evidences[futureIndex].id });
                };
                userIndicatorHeaderController.prototype.$onInit = function () {
                    this._initAlertWatch();
                };
                userIndicatorHeaderController.$inject = ['$scope', '$stateParams', 'userIndicatorsUtils', '$state'];
                return userIndicatorHeaderController;
            }());
            var userIndicatorHeaderComponent = {
                controller: userIndicatorHeaderController,
                templateUrl: 'app/layouts/user/components/user-indicator/components/user-indicator-header/user-indicator-header.component.html',
                bindings: {
                    _alert: '<alertModel',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userIndicatorHeader', userIndicatorHeaderComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserIndicatorDescriptionController = (function () {
                function UserIndicatorDescriptionController($scope, userIndicatorsUtils) {
                    this.$scope = $scope;
                    this.userIndicatorsUtils = userIndicatorsUtils;
                }
                UserIndicatorDescriptionController.prototype._initIndicatorWatch = function () {
                    var _this = this;
                    var unregister = this.$scope.$watch(function () { return _this.indicator; }, function () {
                        if (_this.indicator) {
                            _this.indicatorDescription = _this.userIndicatorsUtils.getIndicatorDescription(_this.indicator);
                            unregister();
                        }
                    });
                };
                UserIndicatorDescriptionController.prototype.$onInit = function () {
                    this._initIndicatorWatch();
                };
                UserIndicatorDescriptionController.$inject = ['$scope', 'userIndicatorsUtils'];
                return UserIndicatorDescriptionController;
            }());
            var userIndicatorDescriptionComponent = {
                controller: UserIndicatorDescriptionController,
                templateUrl: 'app/layouts/user/components/user-indicator/components/user-indicator-description/user-indicator-description.component.html',
                bindings: {
                    indicator: '<indicator',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userIndicatorDescription', userIndicatorDescriptionComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserIndicatorEventsController = (function () {
                function UserIndicatorEventsController($scope, $location, nanobarAutomationService, dataEntities, $http, BASE_URL, tableSettingsUtil, utils) {
                    this.$scope = $scope;
                    this.$location = $location;
                    this.nanobarAutomationService = nanobarAutomationService;
                    this.dataEntities = dataEntities;
                    this.$http = $http;
                    this.BASE_URL = BASE_URL;
                    this.tableSettingsUtil = tableSettingsUtil;
                    this.utils = utils;
                    this.NANOBAR_ID = 'user-page';
                    // The next two functions are on the constructor to lock the this.state
                    var ctrl = this;
                    /**
                     * Returns the state of the table
                     * @returns {IEventsTableState}
                     */
                    ctrl.fetchTableState = function () {
                        return ctrl.state.eventsTable;
                    };
                    /**
                     * Updates the state of the table and reloads events
                     * @param state
                     */
                    ctrl.updateTableState = function (state) {
                        ctrl.state.eventsTable = state.value;
                        ctrl._loadEvents();
                    };
                    this._initStateObject();
                    this._initTableSettings();
                    this._initTableAdapter();
                }
                /**
                 * This method fetch the score field of the events dataEntity
                 * The score field if configured on the dataEntity metadata
                 * under the "performanceField" details. (Shay Schwartz)
                 * @param entityId
                 * @returns {*}The id of the score field.
                 * @private
                 */
                UserIndicatorEventsController.prototype._getDefaultScoreField = function (entityId) {
                    var dataEntityId = this.indicator.dataEntitiesIds[0];
                    if (!dataEntityId) {
                        return null;
                    }
                    var entityMetadata = this.dataEntities.getEntityById(dataEntityId);
                    if (!entityMetadata) {
                        return null;
                    }
                    var performanceField = entityMetadata.performanceField;
                    if (!performanceField) {
                        return null;
                    }
                    return performanceField.field.id || null;
                };
                /**
                 * Load events and digest response
                 * @returns {IPromise<TResult>}
                 * @private
                 */
                UserIndicatorEventsController.prototype._loadEvents = function () {
                    var _this = this;
                    var httpPromise;
                    httpPromise = this.$http.get(this.BASE_URL + "/evidences/" + this.indicator.id + "/events", {
                        params: {
                            page: this.state.eventsTable.page || 1,
                            size: this.state.eventsTable.pageSize || 100,
                            sort_direction: this.state.eventsTable.sortDirection || 'DESC',
                            sort_field: this.state.eventsTable.sortBy
                        }
                    })
                        .then(function (res) {
                        _this.events = res.data.data || [];
                        _this.tableModel = _this.events;
                        _this.tableModel._meta = {
                            offset: res.data.offset || 0,
                            total: res.data.total || 0
                        };
                    })
                        .catch(function (err) {
                        console.error('There was a problem loading events.', err);
                        _this.events = [];
                        _this.tableModel = _this.events;
                        _this.tableModel._meta = {
                            offset: 0,
                            total: 0
                        };
                    });
                    this.nanobarAutomationService.addPromise(this.NANOBAR_ID, httpPromise);
                    return httpPromise;
                };
                /**
                 * Returns the relevant entity fields for the data entity.
                 * @param indicator
                 * @returns {T[]}
                 * @private
                 */
                UserIndicatorEventsController.prototype._getEntityFields = function (indicator) {
                    var dataEntityId = indicator.dataEntitiesIds[0];
                    var fieldsArray = this.dataEntities.getEntityById(dataEntityId).fieldsArray;
                    return _.filter(fieldsArray, { isDefaultEnabled: true });
                };
                /**
                 * Initiates indicator watch. Once received it gets the 'sortBy' filed, the columns defs and loads the events.
                 * @private
                 */
                UserIndicatorEventsController.prototype._initIndicatorWatch = function () {
                    var _this = this;
                    // deregister once an indicator is received. There should be only one indicator in the lifetime of this component.
                    var deregister;
                    deregister = this.$scope.$watch(function () { return _this.indicator; }, function () {
                        if (_this.indicator) {
                            // get default sort
                            _this.state.eventsTable.sortBy =
                                _this._getDefaultScoreField(_this.indicator.dataEntitiesIds[0]);
                            _this.state.eventsTable = _.clone(_this.state.eventsTable);
                            // get columns definition
                            _this.tableSettings.columns = _this.tableSettingsUtil
                                .getColumnsByEntityFields(_this._getEntityFields(_this.indicator), _this.tableAdapter);
                            // get events
                            _this._loadEvents();
                            deregister();
                        }
                    });
                };
                /**
                 * Translate the event to the explore url and redirect to explore
                 * @param event
                 */
                UserIndicatorEventsController.prototype.transitionToExplore = function (event) {
                    var _this = this;
                    var username = event.username;
                    var time = event.end_time ? event.end_time : event.event_time;
                    var aMonthBefore = this.utils.date.getMoment(time)
                        .endOf('day').subtract(1, 'month').startOf('day').valueOf();
                    var dataEntity = this.dataEntities.getEntityById(this.indicator.dataEntitiesIds[0]);
                    var datasource = dataEntity.id;
                    var timeField = (dataEntity.fields.get("event_time_utc") || dataEntity.fields.get("session_time_utc")).id;
                    var scoreField = dataEntity.performanceField.field.id;
                    var url = "/d/explore/" + datasource + "?filters=" + datasource + ".username=" + username + "&default_filters=" + datasource + "." + timeField + "=:" + aMonthBefore + "::" + time + "," + datasource + "." + scoreField + "=>=0";
                    this.$scope.$applyAsync(function () {
                        _this.$location.url(url);
                    });
                };
                /**
                 * Initiates the controller's state
                 * @private
                 */
                UserIndicatorEventsController.prototype._initStateObject = function () {
                    this.state = {
                        eventsTable: {
                            page: 1,
                            pageSize: 100,
                            sortBy: null,
                            sortDirection: 'DESC'
                        }
                    };
                };
                /**
                 * Initiates a table settings
                 * @private
                 */
                UserIndicatorEventsController.prototype._initTableSettings = function () {
                    this.tableSettings = {
                        scrollable: false,
                        groupable: false,
                        sortable: {
                            mode: 'single'
                        },
                        'alwaysPageable': true
                    };
                };
                /**
                 * Adds a table adapter
                 * @private
                 */
                UserIndicatorEventsController.prototype._initTableAdapter = function () {
                    this.tableAdapter = {
                        ids: {
                            event_time: {
                                field: 'event_time',
                                template: '{{ dataItem.event_time | date:\"MM/dd/yyyy HH\\:mm\\:ss\":\"UTC\"}}'
                            },
                            start_time: {
                                field: 'start_time',
                                template: '{{ dataItem.start_time | date:\"MM/dd/yyyy HH\\:mm\\:ss\":\"UTC\"}}'
                            },
                            end_time: {
                                field: 'end_time',
                                template: '{{ dataItem.end_time | date:\"MM/dd/yyyy HH\\:mm\\:ss\":\"UTC\"}}'
                            },
                            duration: {
                                field: 'duration',
                                template: '{{ dataItem.duration | durationToPrettyTime}}'
                            },
                            data_bucket: {
                                field: 'data_bucket',
                                template: '{{dataItem.data_bucket | prettyBytes}}/s'
                            },
                            username: {
                                field: 'username',
                                template: '<a ng-click="$ctrl.transitionToExplore(dataItem)">{{dataItem.username}}</a>'
                            }
                        }
                    };
                };
                UserIndicatorEventsController.prototype.$onInit = function () {
                    this._initIndicatorWatch();
                };
                UserIndicatorEventsController.$inject = ['$scope', '$location', 'fsNanobarAutomationService', 'dataEntities', '$http', 'BASE_URL',
                    'tableSettingsUtil', 'utils'];
                return UserIndicatorEventsController;
            }());
            var UserIndicatorEventsComponent = {
                controller: UserIndicatorEventsController,
                templateUrl: 'app/layouts/user/components/user-indicator/components/user-indicator-events/user-indicator-events.component.html',
                bindings: {
                    indicator: '<',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userIndicatorEvents', UserIndicatorEventsComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));
// evidences/22960e66-eff9-4f7d-a2b1-b3a2eaa1d4e6/events?page=1&size=10&sort_direction=DESC&sort_field=session_score

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserIndicatorChartsController = (function () {
                function UserIndicatorChartsController($scope, $element, $templateCache, $compile) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$templateCache = $templateCache;
                    this.$compile = $compile;
                }
                /**
                 * Get the template indicated by the indicator type
                 * @private
                 */
                UserIndicatorChartsController.prototype._getTemplate = function () {
                    this._template = this.$templateCache.get(this.indicatorType.templateUrl);
                };
                /**
                 * Renders the template indicated by the indicator type
                 * @private
                 */
                UserIndicatorChartsController.prototype._renderTemplate = function () {
                    this._getTemplate();
                    if (this._template) {
                        this.$element.append(this.$compile(angular.element(this._template))(this.$scope));
                    }
                };
                /**
                 * Initiates watch on indicatr and indicator type. Once both are received, a rendering process begins.
                 * @private
                 */
                UserIndicatorChartsController.prototype._initWatches = function () {
                    var ctrl = this;
                    var deregister;
                    function watchHandler() {
                        if (ctrl._indicator && ctrl._indicatorType) {
                            // Clone alert, indicator and indicator type
                            ctrl.indicator = _.cloneDeep(ctrl._indicator);
                            ctrl.indicatorType = _.cloneDeep(ctrl._indicatorType);
                            ctrl._renderTemplate();
                            // Remove watcher
                            deregister();
                        }
                    }
                    deregister = ctrl.$scope.$watchGroup([
                        function () { return ctrl._indicator; },
                        function () { return ctrl._indicatorType; }
                    ], watchHandler);
                };
                UserIndicatorChartsController.prototype.$onInit = function () {
                    this._initWatches();
                };
                UserIndicatorChartsController.$inject = ['$scope', '$element', '$templateCache', '$compile'];
                return UserIndicatorChartsController;
            }());
            var userIndicatorChartsComponent = {
                controller: UserIndicatorChartsController,
                bindings: {
                    _indicator: '<indicator',
                    _indicatorType: '<indicatorType',
                    user: '<userModel'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('userIndicatorCharts', userIndicatorChartsComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsAmChartComponent;
            (function (fsAmChartComponent) {
                var AmChartController = (function () {
                    function AmChartController($scope, $element, $http, BASE_URL, interpolation, $interpolate, fsNanobarAutomationService) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$http = $http;
                        this.BASE_URL = BASE_URL;
                        this.interpolation = interpolation;
                        this.$interpolate = $interpolate;
                        this.fsNanobarAutomationService = fsNanobarAutomationService;
                        this._INDICATORS_DATA_PATH_NAME = 'evidences';
                        this._HISTORICAL_DATA_PATH_NAME = 'historical-data';
                        this._NANOBAR_ID = 'user-page';
                        this._ERR_MSG = 'AmChartComponent: ';
                        this._renderReady = false;
                    }
                    /**
                     * Finds the chart's container element and stores it. Returns the element.
                     * @returns {ng.IAugmentedJQuery}
                     * @private
                     */
                    AmChartController.prototype._getContainerElement = function () {
                        if (!this.containerElement) {
                            this.containerElement = this.$element.find('.chart-container');
                        }
                        return this.containerElement;
                    };
                    /**
                     * Returns a promise that resolves on fetched data from the server
                     * @returns {IHttpPromise<T>}
                     * @private
                     */
                    AmChartController.prototype._fetchData = function () {
                        var params = this.interpolation.interpolate(this.settings.params, this.indicator);
                        return this.$http.get(this.BASE_URL + "/" + this._INDICATORS_DATA_PATH_NAME + "/" + this.indicator.id + "/" + this._HISTORICAL_DATA_PATH_NAME, { params: params })
                            .then(function (res) {
                            return res.data;
                        });
                    };
                    /**
                     * Takes received data and applies sorting, and adapter. Returns a list ready for use on amCharts
                     * @param response
                     * @private
                     */
                    AmChartController.prototype._digestData = function (response) {
                        if (this.settings.preProcessData) {
                            response = this.settings.preProcessData(response, this.indicator);
                        }
                        // sort data if sorter provided by settings
                        var list = this.settings.sortData ? this.settings.sortData(response.data) : response.data;
                        // digest data if adapter provided by settings
                        this.settings.chartSettings.dataProvider =
                            this.settings.dataAdapter ? _.map(list, this.settings.dataAdapter.bind(this, this.indicator)) : list;
                    };
                    AmChartController.prototype._augmentSettings = function () {
                        this._addTitles();
                        this._addListeners();
                    };
                    /**
                     * Adds chart listeners
                     * @private
                     */
                    AmChartController.prototype._addListeners = function () {
                        var ctrl = this;
                        this.settings.chartSettings.listeners = [{
                                "event": "clickGraphItem",
                                "method": function (graphItem) {
                                    if (ctrl.settings.handlers && ctrl.settings.handlers.clickGraphItem) {
                                        ctrl.settings.handlers.clickGraphItem(ctrl.indicator, graphItem);
                                    }
                                }
                            }];
                    };
                    /**
                     * Adds a title to the chart if listed in this.settings.templates.titles
                     * @private
                     */
                    AmChartController.prototype._addTitles = function () {
                        var _this = this;
                        if (this.settings.templates && this.settings.templates.titles) {
                            _.each(this.settings.templates.titles, function (value, key) {
                                var titleObj = _.find(_this.settings.chartSettings.titles, { id: key });
                                titleObj.text = _this.$interpolate(value)(_this.indicator);
                            });
                        }
                        if (this.settings.templates && this.settings.templates.valueAxes) {
                            _.each(this.settings.templates.valueAxes, function (value, key) {
                                var titleObj = _.find(_this.settings.chartSettings.valueAxes, { id: key });
                                titleObj.title = _this.$interpolate(value)(_this.indicator);
                            });
                        }
                    };
                    /**
                     * Renders a chart
                     * @private
                     */
                    AmChartController.prototype._renderChart = function () {
                        if (this._renderReady) {
                            this.chart = AmCharts.makeChart(this._getContainerElement()[0], this.settings.chartSettings);
                        }
                    };
                    /**
                     * Sets watch on settings. When settings received, data is fetched and processed, and chart is rendered.
                     * @private
                     */
                    AmChartController.prototype._initSettingsWatch = function () {
                        var _this = this;
                        this.$scope.$watch(function () { return _this.settings; }, function () {
                            if (_this.settings) {
                                _this._renderReady = false;
                                var promise = _this._fetchData()
                                    .then(function (data) {
                                    _this._digestData(data);
                                    _this._augmentSettings();
                                    _this._renderReady = true;
                                    _this._renderChart();
                                })
                                    .catch(function (err) {
                                    console.error(_this._ERR_MSG + 'There was a problem loading data', err);
                                });
                                _this.fsNanobarAutomationService.addPromise(_this._NANOBAR_ID, promise);
                            }
                        });
                    };
                    AmChartController.prototype.$onInit = function () {
                        this._initSettingsWatch();
                    };
                    AmChartController.$inject = ['$scope', '$element', '$http', 'BASE_URL', 'interpolation', '$interpolate',
                        'fsNanobarAutomationService'];
                    return AmChartController;
                }());
                var AmChartComponent = {
                    controller: AmChartController,
                    bindings: {
                        settings: '<',
                        indicator: '<',
                        _events: '<events'
                    },
                    template: '<div class="chart-container" style="position: absolute; width: 100%; height: 100%;"></div>'
                };
                angular.module('Fortscale.shared.components')
                    .component('fsIndicatorAmChart', AmChartComponent);
            })(fsAmChartComponent = components.fsAmChartComponent || (components.fsAmChartComponent = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            'use strict';
            var eEntityType = Fortscale.shared.services.entityActivityUtils.eEntityType;
            var ActivityCountriesController = (function () {
                function ActivityCountriesController($scope, $element, countryCodesUtil, amMapsUtils, entityActivityUtils, interpolation, $http, BASE_URL, fsNanobarAutomationService) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.countryCodesUtil = countryCodesUtil;
                    this.amMapsUtils = amMapsUtils;
                    this.entityActivityUtils = entityActivityUtils;
                    this.interpolation = interpolation;
                    this.$http = $http;
                    this.BASE_URL = BASE_URL;
                    this.fsNanobarAutomationService = fsNanobarAutomationService;
                    this.areasOn = true;
                    this.imagesOn = true;
                    this._INDICATORS_DATA_PATH_NAME = 'evidences';
                    this._HISTORICAL_DATA_PATH_NAME = 'historical-data';
                    this.NANOBAR_ID = 'user-page';
                }
                /**
                 * Adds percent to each user-country
                 * @returns {IAugmentedActivityUserCountry[]}
                 * @private
                 */
                ActivityCountriesController.prototype._AugmentUserCountries = function () {
                    var _this = this;
                    var userCountries = _.cloneDeep(this._userCountries);
                    var sum = _.sumBy(userCountries, 'count');
                    var percentSum = 0;
                    _.each(userCountries, function (userCountry, index, userCountries) {
                        userCountry.alpha2 = _this.countryCodesUtil.getAlpha2ByCountryName(userCountry.country);
                        if (userCountries.length - 1 === index) {
                            // Last item should always complete to 100%
                            userCountry.percent = Math.round((100 - percentSum) * 100) / 100;
                        }
                        else {
                            userCountry.percent = Math.round(userCountry.count / sum * 10000) / 100;
                            percentSum += userCountry.percent;
                        }
                    });
                    return userCountries;
                };
                ActivityCountriesController.prototype._sortUserCountries = function () {
                    return _.orderBy(this.userCountries, [
                        function (userCountry) { return userCountry.country === 'Others'; },
                        function (userCountry) { return userCountry.count; }
                    ], [
                        'asc',
                        'desc'
                    ]);
                };
                /**
                 * Returns a list of areas to be used in the map
                 * @returns {Array<{id: string, color: string}>}
                 * @private
                 */
                ActivityCountriesController.prototype._getAreasForMapDataProvider = function () {
                    var _this = this;
                    return _.map(this.organizationCountries, function (orgCountry) {
                        return {
                            id: _this.countryCodesUtil.getAlpha2ByCountryName(orgCountry.country),
                            color: '#024d88'
                        };
                    });
                };
                /**
                 * Returns a list of image map config objects.
                 * @returns {IAmMapsUtilsBubbleConfig[]}
                 * @private
                 */
                ActivityCountriesController.prototype._getBubbles = function () {
                    return this.amMapsUtils.getBubbles({
                        // Filter out countries without alpha2 (i.e. others) and map to return map config objects
                        countries: _.map(_.filter(this.userCountries, 'alpha2'), function (userCountry) {
                            return {
                                alpha2: userCountry.alpha2,
                                name: userCountry.country,
                                value: userCountry.percent,
                                color: userCountry.anomaly ? 'rgba(255, 0, 0, 0.7)' : 'rgba(83, 194, 228, 0.5)',
                                anomaly: userCountry.anomaly
                            };
                        })
                    });
                };
                ActivityCountriesController.prototype._getPlaneBubbles = function () {
                    return this.amMapsUtils.getBubbles({
                        // Filter out countries without alpha2 (i.e. others) and map to return map config objects
                        countries: _.map(_.filter(this.eventCountries, 'alpha2'), function (eventCoutnry) {
                            return {
                                alpha2: eventCoutnry.alpha2,
                                name: eventCoutnry.name,
                                value: eventCoutnry.percent,
                                color: 'rgba(255, 0, 0, 0.6)'
                            };
                        })
                    });
                };
                /**
                 * Returns a list of image map config objects.
                 * @returns {IAmMapsUtilsBubbleConfig[]}
                 * @private
                 */
                ActivityCountriesController.prototype._getLines = function () {
                    return this.amMapsUtils.getLines({
                        // Filter out countries without alpha2 (i.e. others) and map to return map config objects
                        countries: _.map(_.filter(this.eventCountries, 'alpha2'), function (eventCountry) {
                            return {
                                alpha2: eventCountry.alpha2,
                            };
                        })
                    });
                };
                /**
                 * Returns a list of relevant map objects to be used as a zoom group
                 * @param {{}} map
                 * @param {boolean=} withoutOrganization
                 * @param {boolean=} withoutUser
                 * @returns {Array<{}>}
                 * @private
                 */
                ActivityCountriesController.prototype._getRelevantMapObjects = function (map, withoutOrganization, withoutUser) {
                    var _this = this;
                    var zoomToAreasIds;
                    // Add organization map ids (if not withoutOrganization)
                    if (withoutOrganization) {
                        zoomToAreasIds = [];
                    }
                    else {
                        zoomToAreasIds = _.map(this.organizationCountries, function (oCountry) { return _this.countryCodesUtil.getAlpha2ByCountryName(oCountry.country); });
                    }
                    // Add user map ids (if not withoutUser)
                    if (!withoutUser) {
                        _.each(this.userCountries, function (userCountry) { return zoomToAreasIds.push(userCountry.alpha2); });
                    }
                    //Add event countries
                    _.each(this.eventCountries, function (eventCountry) { return zoomToAreasIds.push(eventCountry.alpha2); });
                    // take ids and get map objects. Push map object to zoomToAreas.
                    var zoomToAreas = [];
                    _.each(zoomToAreasIds, function (id) {
                        if (id) {
                            var area = map.getObjectById(id);
                            if (area) {
                                zoomToAreas.push(area);
                            }
                        }
                    });
                    return zoomToAreas;
                };
                /**
                 * Initiates the amMap map object
                 * @private
                 */
                ActivityCountriesController.prototype._initMap = function () {
                    if (!this.userCountries || !this.organizationCountries || !this.eventCountries || this.map) {
                        return;
                    }
                    var ctrl = this;
                    var settings = {
                        listeners: [
                            {
                                event: 'rendered',
                                method: function (evt) {
                                    ctrl.mapOriginalZoomX = evt.chart.zoomX();
                                    ctrl.mapOriginalZoomY = evt.chart.zoomY();
                                    if (ctrl.settings.usePlanes) {
                                        evt.chart.zoomDuration = 0;
                                        evt.chart.zoomToGroup(ctrl._getRelevantMapObjects(evt.chart));
                                        setTimeout(function () {
                                            evt.chart.zoomDuration = 1;
                                        }, 1500);
                                    }
                                    else {
                                        setTimeout(function () {
                                            evt.chart.zoomToGroup(ctrl._getRelevantMapObjects(evt.chart));
                                        }, 500);
                                    }
                                }
                            }
                        ],
                        dataProvider: {
                            areas: this._getAreasForMapDataProvider(),
                            images: this.settings.usePlanes ? this._getPlaneBubbles() : this._getBubbles(),
                        }
                    };
                    if (this.settings.usePlanes) {
                        settings.dataProvider.lines = this._getLines();
                        settings.dataProvider.images = _.concat(settings.dataProvider.images, this.amMapsUtils.getPlaneImage());
                    }
                    settings = _.merge({}, this.settings.mapSettings, settings);
                    // Create a map
                    this.map = AmCharts.makeChart('top-countries-map', settings);
                };
                /**
                 * Rerenders the map in the previous zoom level and position
                 * @private
                 */
                ActivityCountriesController.prototype._rerenderMap = function () {
                    this.map.dataProvider.zoomLevel = this.map.zoomLevel();
                    this.map.dataProvider.zoomLatitude = this.map.zoomLatitude();
                    this.map.dataProvider.zoomLongitude = this.map.zoomLongitude();
                    this.map.validateData();
                    var groups = this._getRelevantMapObjects(this.map, !this.areasOn, !this.imagesOn);
                    if (groups.length) {
                        this.map.zoomToGroup(groups);
                    }
                    else {
                        this.map.zoomTo(1, this.mapOriginalZoomX, this.mapOriginalZoomY);
                    }
                };
                /**
                 * Initiates user countries watch
                 * @private
                 */
                ActivityCountriesController.prototype._initUserCountriesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._userCountries; }, function () {
                        if (_this._userCountries) {
                            _this.userCountries = _this._AugmentUserCountries();
                            _this.userCountries = _this._sortUserCountries();
                            _this._initMap();
                        }
                    });
                };
                /**
                 * Initiates watch on _organizationCountries. Clones it when arrives (for immutability)
                 * @private
                 */
                ActivityCountriesController.prototype._initOrganizationCountriesWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this._organizationCountries; }, function () {
                        if (_this._organizationCountries) {
                            _this.organizationCountries =
                                _.cloneDeep(_this._organizationCountries);
                            _this.mapAreas = _this._getAreasForMapDataProvider();
                            _this._initMap();
                        }
                    });
                };
                /**
                 * Resize handler. Will redraw the map on a resize.
                 *
                 * @private
                 */
                ActivityCountriesController.prototype._initResizeWatch = function () {
                    var ctrl = this;
                    function resizeHandler() {
                        ctrl.map.clear();
                        ctrl.map = null;
                        delete ctrl["map"];
                        ctrl._initMap();
                    }
                    window.addEventListener('resize', resizeHandler, false);
                    this.$scope.$on('$destroy', function () {
                        window.removeEventListener('resize', resizeHandler, false);
                    });
                };
                /**
                 * A cb function that is used in a filter to remove out any members with a count of zero
                 * @param {IActivityUserCountry} userCountry
                 * @returns {boolean}
                 */
                ActivityCountriesController.prototype.hideZeroCountFilter = function (userCountry) {
                    return userCountry.count !== 0;
                };
                /**
                 * Changes the state of the map's Areas (i.e. organization).
                 */
                ActivityCountriesController.prototype.toggleAreas = function () {
                    if (!this.areasOn) {
                        this.map.dataProvider.areas = this._getAreasForMapDataProvider();
                    }
                    else {
                        this.map.dataProvider.areas = [];
                    }
                    this.areasOn = !this.areasOn;
                    this._rerenderMap();
                };
                /**
                 * Changes the state of the map's images (i.e. user bubbles)
                 */
                ActivityCountriesController.prototype.toggleImages = function () {
                    if (!this.imagesOn) {
                        this.map.dataProvider.images = this._getBubbles();
                    }
                    else {
                        this.map.dataProvider.images = [];
                    }
                    this.imagesOn = !this.imagesOn;
                    this._rerenderMap();
                };
                /**
                 * Start the user top countries load
                 * @returns {IPromise<void>}
                 * @private
                 */
                ActivityCountriesController.prototype._initLoadUserTopCountriesActivity = function () {
                    var _this = this;
                    var params = this.interpolation.interpolate(this.settings.params, this.indicator);
                    return this.$http.get(this.BASE_URL + "/" + this._INDICATORS_DATA_PATH_NAME + "/" + this.indicator.id + "/" + this._HISTORICAL_DATA_PATH_NAME, { params: params })
                        .then(function (res) {
                        _this._userCountries = _.filter(_.map(res.data.data, function (countryItem) {
                            return { country: countryItem.keys[0], count: countryItem.value, anomaly: countryItem.anomaly };
                        }), function (countryItem) {
                            // filter out all elements without a country
                            return !!countryItem.country;
                        });
                        var eventCountriesTemp = [];
                        _.each(res.data.info && res.data.info.countries, function (country) {
                            var eventCountry = {};
                            eventCountry.name = country;
                            eventCountry.percent = 50;
                            eventCountry.alpha2 = _this.countryCodesUtil.getAlpha2ByCountryName(country);
                            eventCountriesTemp.push(eventCountry);
                        });
                        _this.eventCountries = eventCountriesTemp;
                        return _this._userCountries;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading organization top countries.', err);
                        _this._userCountries = [];
                    });
                };
                /**
                 * Starts the organization top countries load
                 * @returns {IPromise<void>}
                 * @private
                 */
                ActivityCountriesController.prototype._initLoadOrganizationTopCountriesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getTopCountries(eEntityType.ORGANIZATION)
                        .then(function (countries) {
                        _this._organizationCountries = countries;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading organization top countries.', err);
                        _this._organizationCountries = [];
                    });
                };
                ActivityCountriesController.prototype.$onInit = function () {
                    var _this = this;
                    this._initUserCountriesWatch();
                    this._initOrganizationCountriesWatch();
                    this._initResizeWatch();
                    //this._initEventsLoadedWatch();
                    this.$scope.$watch(function () { return _this.indicator; }, function (indicator) {
                        if (indicator) {
                            // let promiseUser = this._initLoadUserTopCountriesActivity();
                            _this.fsNanobarAutomationService.addPromises(_this.NANOBAR_ID, [
                                _this._initLoadUserTopCountriesActivity(),
                                _this._initLoadOrganizationTopCountriesActivity()
                            ]);
                        }
                    });
                };
                ActivityCountriesController.$inject = ['$scope', '$element', 'countryCodesUtil', 'amMapsUtils', 'entityActivityUtils',
                    'interpolation', '$http', 'BASE_URL', 'fsNanobarAutomationService'];
                return ActivityCountriesController;
            }());
            var indicatorAmGeoLocationComponent = {
                controller: ActivityCountriesController,
                templateUrl: 'app/layouts/user/components/user-indicator/components/fs-indicator-am-geo-location/fs-indicator-am-geo-location.component.html',
                bindings: {
                    indicator: '<',
                    user: '<userModel',
                    settings: '<'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('fsIndicatorAmGeoLocation', indicatorAmGeoLocationComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsActivityTimeAnomalyComponent;
            (function (fsActivityTimeAnomalyComponent) {
                var ActivityTimeAnomalyController = (function () {
                    function ActivityTimeAnomalyController($scope, $element, $http, BASE_URL, interpolation, $interpolate, fsNanobarAutomationService, $timeout) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$http = $http;
                        this.BASE_URL = BASE_URL;
                        this.interpolation = interpolation;
                        this.$interpolate = $interpolate;
                        this.fsNanobarAutomationService = fsNanobarAutomationService;
                        this.$timeout = $timeout;
                        this.weekDaysUS = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'];
                        this.HoursInDay = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23];
                        this._INDICATORS_DATA_PATH_NAME = 'evidences';
                        this._HISTORICAL_DATA_PATH_NAME = 'historical-data';
                        this._NANOBAR_ID = 'user-page';
                        this._ERR_MSG = 'ActivityTimeAnomalyComponent: ';
                        this._renderReady = false;
                        this.gridModel = {};
                    }
                    /**
                     * Returns a promise that resolves on fetched data from the server
                     * @returns {IHttpPromise<T>}
                     * @private
                     */
                    ActivityTimeAnomalyController.prototype._fetchData = function () {
                        var params = this.interpolation.interpolate(this.settings.params, this.indicator);
                        return this.$http.get(this.BASE_URL + "/" + this._INDICATORS_DATA_PATH_NAME + "/" + this.indicator.id + "/" + this._HISTORICAL_DATA_PATH_NAME, { params: params })
                            .then(function (res) {
                            return res.data;
                        });
                    };
                    ActivityTimeAnomalyController.prototype._digestData = function (data) {
                        var _this = this;
                        // sort by day of week and hour
                        var sortedData = _.orderBy(data, [
                            function (timeAnomaly) {
                                // return index of day
                                return _this.weekDaysUS.indexOf(timeAnomaly.keys[0]);
                            },
                            function (timeAnomaly) {
                                // return hour as number
                                return parseInt(timeAnomaly.keys[1], 10);
                            }
                        ], ['asc', 'asc']);
                        _.each(sortedData, function (timeAnomalyResponse, index) {
                            if (!_this.gridModel[timeAnomalyResponse.keys[0]]) {
                                _this.gridModel[timeAnomalyResponse.keys[0]] = {};
                            }
                            // Create a cascading effect of painting the active hours.
                            _this.$timeout(function () {
                                _this.gridModel[timeAnomalyResponse.keys[0]][timeAnomalyResponse.keys[1]] = {
                                    value: timeAnomalyResponse.value,
                                    anomaly: timeAnomalyResponse.anomaly
                                };
                            }, index * 40);
                        });
                    };
                    /**
                     * Renders a chart
                     * @private
                     */
                    ActivityTimeAnomalyController.prototype._renderGrid = function () {
                        if (this._renderReady) {
                            this._digestData(this._response.data);
                        }
                    };
                    /**
                     * Sets watch on settings. When settings received, data is fetched and processed, and chart is rendered.
                     * @private
                     */
                    ActivityTimeAnomalyController.prototype._initSettingsWatch = function () {
                        var _this = this;
                        this.$scope.$watch(function () { return _this.settings; }, function () {
                            if (_this.settings) {
                                _this._renderReady = false;
                                var promise = _this._fetchData()
                                    .then(function (response) {
                                    _this._renderReady = true;
                                    _this._response = response;
                                    _this._renderGrid();
                                })
                                    .catch(function (err) {
                                    console.error(_this._ERR_MSG + 'There was a problem loading data', err);
                                });
                                _this.fsNanobarAutomationService.addPromise(_this._NANOBAR_ID, promise);
                            }
                        });
                    };
                    ActivityTimeAnomalyController.prototype.$onInit = function () {
                        this._initSettingsWatch();
                    };
                    ActivityTimeAnomalyController.$inject = ['$scope', '$element', '$http', 'BASE_URL', 'interpolation', '$interpolate',
                        'fsNanobarAutomationService', '$timeout'];
                    return ActivityTimeAnomalyController;
                }());
                var ActivityTimeAnomalyComponent = {
                    controller: ActivityTimeAnomalyController,
                    bindings: {
                        settings: '<',
                        indicator: '<'
                    },
                    templateUrl: 'app/layouts/user/components/user-indicator/components/fs-indicator-activity-time-anomaly/fs-indicator-activity-time-anomaly.component.html'
                };
                angular.module('Fortscale.shared.components')
                    .component('fsIndicatorActivityTimeAnomaly', ActivityTimeAnomalyComponent);
            })(fsActivityTimeAnomalyComponent = components.fsActivityTimeAnomalyComponent || (components.fsActivityTimeAnomalyComponent = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var AlertCommentsController = (function () {
                function AlertCommentsController($scope, authService, alertUpdatesService, toastrService, $element, $timeout) {
                    this.$scope = $scope;
                    this.authService = authService;
                    this.alertUpdatesService = alertUpdatesService;
                    this.toastrService = toastrService;
                    this.$element = $element;
                    this.$timeout = $timeout;
                    //This object bound to comment which currently edited. Undefined or Null if no comment currently edited.
                    this.currentUpdatedComment = null;
                    this.analystMap = {};
                    this.COMMENT_EDIT_AREA_SELECTOR_PREFIX = '.comment-edit-area-';
                }
                /**
                 * Sending the comment from to the backend using alertUpdatesService,
                 * and when done, trigger addAlertComment to update the whole state.
                 */
                AlertCommentsController.prototype.addComment = function () {
                    var _this = this;
                    if (!this.newCommentText) {
                        return;
                    }
                    //Get current user from auth service before update the alert
                    this.authService.getCurrentUser().then(function (result) {
                        //Create the comment object
                        var analystName = result.userName;
                        var newComment = {
                            commentText: _this.newCommentText,
                            analystUserName: analystName,
                            updateDate: new Date(),
                            commentId: ""
                        };
                        _this.alertUpdatesService.addComment(_this.alert.id, newComment).then(function (response) {
                            //When server update success, clear the current text, and
                            _this.newCommentText = "";
                            if (response.status === 201) {
                                _this.addAlertComment({ "alertId": _this.alert.id, "comment": response.data });
                            }
                            else {
                            }
                        })
                            .catch(function (err) {
                            _this.toastrService.error("There was an error trying to add comment. ");
                        });
                    });
                };
                /**
                 * Sending the comment delete request to backend using alertUpdatesService,
                 * and when done, trigger deleteAlertComment to update the whole state.
                 */
                AlertCommentsController.prototype.deleteComment = function (comment) {
                    var _this = this;
                    this.alertUpdatesService.deleteComment(this.alert.id, comment).then(function (response) {
                        if (response.status === 200) {
                            _this.deleteAlertComment({ "alertId": _this.alert.id, "commentId": comment.commentId });
                        }
                        else {
                            alert("return error: " + response.status);
                        }
                    })
                        .catch(function (err) {
                        _this.toastrService.error("There was an error trying to delete comment. ");
                    });
                };
                /**
                 * Sending the comment update request to backend using alertUpdatesService,
                 * and when done, trigger updateAlertComment to update the whole state.
                 */
                AlertCommentsController.prototype.updateComment = function () {
                    var _this = this;
                    this.authService.getCurrentUser().then(function (result) {
                        _this.alertUpdatesService.updateComment(_this.alert.id, _this.currentUpdatedComment)
                            .then(function (response) {
                            if (response.status === 200) {
                                _this.currentUpdatedComment = null;
                                _this.updateAlertComment({ "alertId": _this.alert.id, "comment": response.data });
                            }
                            else {
                                alert("return error: " + response.status);
                            }
                        })
                            .catch(function (err) {
                            _this.toastrService.error("There was an error trying to update comment. ");
                        });
                    });
                };
                /**
                 * Listen to key press event on edited comment.
                 * If the key is enter - trigger updateComment
                 * @param keyEvent - the key event
                 */
                AlertCommentsController.prototype.commentEditingKeyPressHandler = function (keyEvent) {
                    if (keyEvent.which === 13) {
                        this.updateComment();
                    }
                };
                /**
                 * Listen to key press event on new comment.
                 * If the key is enter - trigger addComment
                 * @param keyEvent - the key event
                 */
                AlertCommentsController.prototype.newCommentKeyPressHandler = function (keyEvent) {
                    if (keyEvent.which === 13) {
                        this.addComment();
                    }
                };
                /**
                 * When clicking "update" on any comment, update the state with the clicked comment details
                 * @param comment
                 */
                AlertCommentsController.prototype.setUpdateMode = function (comment) {
                    var _this = this;
                    this.currentUpdatedComment = _.clone(comment);
                    this.currentUpdatedComment.updateDate = null;
                    // Its hard to say exactly when angular will expose the element (that has ng-show), so to get best result,
                    // while planning for a case where it might take longer, there are 3 focus requests, on 50, 100, and 200 ms
                    _.each([50, 100, 200], function (time) {
                        _this.$timeout(function () {
                            _this.$element.find(_this.COMMENT_EDIT_AREA_SELECTOR_PREFIX + comment.commentId).focus();
                        }, time);
                    });
                };
                AlertCommentsController.$inject = ['$scope', 'auth', 'alertUpdatesService', 'toastrService', '$element', '$timeout'];
                return AlertCommentsController;
            }());
            var alertCommentsController = {
                controller: AlertCommentsController,
                templateUrl: 'app/layouts/user/components/user-alert-overview/components/user-alert-overview-comments/user-alert-overview-comments.component.html',
                bindings: {
                    alert: '<alertModel',
                    analystMap: '<analystMap',
                    updateAlertComment: '&',
                    addAlertComment: '&',
                    deleteAlertComment: '&',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('alertComments', alertCommentsController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var AlertFeedback = Fortscale.shared.services.alertUpdatesService.AlertFeedback;
            var AlertStatus = Fortscale.shared.services.alertUpdatesService.AlertStatus;
            var ShrinkExpand;
            (function (ShrinkExpand) {
                ShrinkExpand[ShrinkExpand["Shrink"] = 0] = "Shrink";
                ShrinkExpand[ShrinkExpand["Expand"] = 1] = "Expand";
            })(ShrinkExpand || (ShrinkExpand = {}));
            var AlertFeedbackController = (function () {
                function AlertFeedbackController($scope, $element, alertUpdatesService, toastrService) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.alertUpdatesService = alertUpdatesService;
                    this.toastrService = toastrService;
                    this.AlertFeedback = AlertFeedback;
                    //Constants for animation
                    this.ACTUAL_RISK_UNCHECKED_SELECTOR = '.actual-risk-button-unchecked';
                    this.ACTUAL_RISK_CHECKED_SELECTOR = '.actual-risk-button-checked';
                    this.NOT_RISK_UNCHECKED_SELECTOR = '.not-a-risk-button-unchecked';
                    this.NOT_RISK_CHECKED_SELECTOR = '.not-a-risk-button-checked';
                    this.ANIMATION_TIME = 500;
                }
                /**
                 * Method the change the feedback and status of the alert.
                 * If the want'ed feedback is the same as current alert's feedback the method return the alert to "unresolved" feedback
                 * and "open" status. If the feedback different the current alert's feedback- we set the new feedback and "closed" status.
                 * @param clickedFeedbackStatus
                 */
                AlertFeedbackController.prototype.setFeedback = function (clickedFeedbackStatus) {
                    var _this = this;
                    var currentFeedback = AlertFeedback[this.alert.feedback];
                    //Type script is not understand that AlertFeedback[this.alert.feedback] return AlertFeedback
                    var newFeedback;
                    var newStatus;
                    //If the users click again on already exists status, the alert will be changed to unresolved / open
                    if (currentFeedback === clickedFeedbackStatus) {
                        newFeedback = AlertFeedback.None;
                        newStatus = AlertStatus.Open;
                    }
                    else {
                        //The user selected different status then existing one,
                        //we change the status to closed and send the new feedback
                        newFeedback = clickedFeedbackStatus;
                        newStatus = AlertStatus.Closed;
                    }
                    var feedbackObject = {
                        "feedback": newFeedback,
                        "status": newStatus
                    };
                    this.alertUpdatesService.updateFeedback(this.alert.id, feedbackObject).then(function (response) {
                        if (response.status === 200) {
                            _this.updateFeedbackDelegate({ "alertId": _this.alert.id, "feedbackObject": feedbackObject });
                        }
                        else {
                            _this.toastrService.error("There was an error trying to update alert feedback. ");
                        }
                    })
                        .catch(function (err) {
                        _this.toastrService.error("There was an error trying to update alert feedback. ");
                    });
                };
                /**
                 * Animation methods
                 * @type {string[]}
                 */
                AlertFeedbackController.prototype._shrinkElement = function (element) {
                    element.css('transform', 'scaleY(0)');
                };
                AlertFeedbackController.prototype._expandElement = function (element) {
                    element.css('transform', 'scaleY(1)');
                };
                AlertFeedbackController.prototype._setTransitions = function (shrinkElement, expandElement) {
                    shrinkElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.84, 0.15) 0s";
                    expandElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.5, 1) " + this.ANIMATION_TIME / 2 / 1000 + "s";
                };
                AlertFeedbackController.prototype._applyShrinkExpand = function (condition, expandSelectorIfTrue, expandSelectorIfFalse, expandOnly) {
                    var _this = this;
                    var expandSelector = (condition ? expandSelectorIfTrue : expandSelectorIfFalse);
                    var expandElement = this.$element.find(expandSelector);
                    this._expandElement(expandElement);
                    if (!expandOnly) {
                        var shrinkSelector = (condition ? expandSelectorIfFalse : expandSelectorIfTrue);
                        var shrinkElement_1 = this.$element.find(shrinkSelector);
                        this._shrinkElement(shrinkElement_1);
                        this._setTransitions(shrinkElement_1, expandElement);
                        this.$scope.$applyAsync(function () {
                            _this._shrinkElement(shrinkElement_1);
                            _this._expandElement(expandElement);
                        });
                    }
                };
                AlertFeedbackController.prototype._initialRiskFeedbackButtonsFlip = function () {
                    if (typeof this.alert === "undefined") {
                        //Do nothing
                        return;
                    }
                    var currentFeedback = AlertFeedback[this.alert.feedback];
                    //Calculate "risk button" presentation
                    this._applyShrinkExpand(AlertFeedback.Approved === currentFeedback, this.ACTUAL_RISK_CHECKED_SELECTOR, this.ACTUAL_RISK_UNCHECKED_SELECTOR, true);
                    //Calculate "not a risk button" presentation
                    this._applyShrinkExpand(AlertFeedback.Rejected === currentFeedback, this.NOT_RISK_CHECKED_SELECTOR, this.NOT_RISK_UNCHECKED_SELECTOR, true);
                };
                AlertFeedbackController.prototype._watchRiskFeedbackFlip = function () {
                    if (typeof this.alert === "undefined") {
                        //Do nothing
                        return;
                    }
                    var currentFeedback = AlertFeedback[this.alert.feedback];
                    //Calculate "risk button" presentation
                    this._applyShrinkExpand(AlertFeedback.Approved === currentFeedback, this.ACTUAL_RISK_CHECKED_SELECTOR, this.ACTUAL_RISK_UNCHECKED_SELECTOR, false);
                    //Calculate "not a risk button" presentation
                    this._applyShrinkExpand(AlertFeedback.Rejected === currentFeedback, this.NOT_RISK_CHECKED_SELECTOR, this.NOT_RISK_UNCHECKED_SELECTOR, false);
                };
                AlertFeedbackController.prototype.$onInit = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.alert && _this.alert.feedback; }, function (feedback) {
                        if (_this.alert && _this.alert.feedback !== undefined) {
                            _this._watchRiskFeedbackFlip();
                        }
                        else {
                            _this._initialRiskFeedbackButtonsFlip();
                        }
                    });
                };
                AlertFeedbackController.$inject = ['$scope', '$element', 'alertUpdatesService', 'toastrService'];
                return AlertFeedbackController;
            }());
            var alertFeedbackController = {
                controller: AlertFeedbackController,
                templateUrl: 'app/layouts/user/components/user-alert-overview/components/user-alert-overview-feedback/user-alert-overview-feedback.component.html',
                bindings: {
                    alert: '<alertModel',
                    updateFeedbackDelegate: '&'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('alertFeedback', alertFeedbackController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var AlertFeedbackController = (function () {
                function AlertFeedbackController($scope, userAlertsUtils) {
                    this.$scope = $scope;
                    this.userAlertsUtils = userAlertsUtils;
                }
                /**
                 * Extract the list of data sources from any of current alert's indicator
                 * Return data sources names as string with separators
                 * If the alert is still not loaded, return empty string
                 * @returns {String}
                 */
                AlertFeedbackController.prototype.getDataSources = function () {
                    if (typeof this.alert === "undefined") {
                        return "";
                    }
                    var evidencesList = this.alert.evidences;
                    return this.userAlertsUtils.getDataSources(evidencesList);
                };
                /**
                 * Extract the list of tags from any of current alert's indicator
                 * Return tag names as string with separators
                 * If the alert is still not loaded, return empty string
                 * @returns {String}
                 */
                AlertFeedbackController.prototype.getTags = function () {
                    var _this = this;
                    if (typeof this.alert === "undefined") {
                        return;
                    }
                    //Because evidences list filtered to contain only the untags evidences,
                    //The tags evidences stored in tagEvidences
                    var tagEvidencesList = this.alert.tagEvidences;
                    this.userAlertsUtils.getTags(tagEvidencesList).then(function (tagNames) {
                        _this.tagsPrettyNames = tagNames;
                    });
                };
                /**
                 * Read the description of the alert from messages.
                 * @returns {any}
                 */
                AlertFeedbackController.prototype.getAlertDescription = function () {
                    if (typeof this.alert === "undefined") {
                        return "";
                    }
                    return this.userAlertsUtils.getAlertDescription(this.alert);
                };
                /**
                 * Extract all the alerts from user controller, clone it, and
                 * save the cloned object on this controller
                 * @private
                 */
                AlertFeedbackController.prototype._initAlertWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.alert; }, function (alert) {
                        if (alert && alert.tagEvidences) {
                            _this.getTags();
                        }
                    });
                };
                AlertFeedbackController.prototype.$onInit = function () {
                    this._initAlertWatch();
                };
                AlertFeedbackController.$inject = ['$scope', 'userAlertsUtils'];
                return AlertFeedbackController;
            }());
            var alertFeedbackController = {
                controller: AlertFeedbackController,
                templateUrl: 'app/layouts/user/components/user-alert-overview/components/user-alert-overview-description/user-alert-overview-description.component.html',
                bindings: {
                    alert: '<alertModel'
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('alertDescription', alertFeedbackController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var UserAlertOverviewHeaderController = (function () {
                function UserAlertOverviewHeaderController($scope, $stateParams, $state, userIndicatorsUtils) {
                    this.$scope = $scope;
                    this.$stateParams = $stateParams;
                    this.$state = $state;
                    this.userIndicatorsUtils = userIndicatorsUtils;
                    this._currentAlertIndex = null;
                }
                /**
                 * Returns the index of the current indicator in the current alert
                 * @returns {number}
                 */
                UserAlertOverviewHeaderController.prototype.getCurrentAlertIndex = function () {
                    var _this = this;
                    if (this._currentAlertIndex === null && this.alerts) {
                        var index_1 = null;
                        // match the current indicatorId to an indicator in the indicators list
                        _.some(this.alerts, function (alert, i) {
                            if (alert.id === _this.$stateParams.alertId) {
                                index_1 = i;
                                return true;
                            }
                        });
                        if (this._currentAlertIndex !== index_1) {
                            this._currentAlertIndex = index_1;
                        }
                    }
                    return this._currentAlertIndex;
                };
                /**
                 * Transition to a new indicator state
                 * @param step
                 */
                UserAlertOverviewHeaderController.prototype.transitionAlert = function (step) {
                    var futureIndex = this.getCurrentAlertIndex() + step;
                    // make sure it doesn't exceed the list's range
                    if (futureIndex < 0 || futureIndex > this.alerts.length - 1) {
                        return;
                    }
                    this.$state.go(this.$state.current.name, { alertId: this.alerts[futureIndex].id });
                };
                /**
                 * Transition to first indicator on the current alert
                 */
                UserAlertOverviewHeaderController.prototype.transitionIndicator = function () {
                    var alert = _.find(this.alerts, { id: this.$stateParams.alertId });
                    var indicators = this.userIndicatorsUtils.orderIndicators(alert.evidences);
                    this.$state.go('user.indicator', { alertId: alert.id, indicatorId: indicators[0].id });
                };
                UserAlertOverviewHeaderController.prototype.$onInit = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.alerts; }, function (alerts) {
                        if (alerts) {
                            _this._currentAlertIndex = null;
                            _this._currentAlertIndex = _this.getCurrentAlertIndex();
                            _this.currentAlert = _this.alerts[_this._currentAlertIndex];
                        }
                    });
                };
                UserAlertOverviewHeaderController.$inject = ['$scope', '$stateParams', '$state', 'userIndicatorsUtils'];
                return UserAlertOverviewHeaderController;
            }());
            var userAlertOverviewHeaderComponent = {
                controller: UserAlertOverviewHeaderController,
                templateUrl: 'app/layouts/user/components/user-alert-overview/components/user-alert-overview-header/user-alert-overview-header.component.html',
                bindings: {
                    alerts: '<alerts',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('fsUserAlertOverviewHeader', userAlertOverviewHeaderComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var indicatorSlideTemplate = "\n<div class=\"indicator-slide\" ng-repeat=\"indicator in $ctrl.indicators\"  ng-class=\"{'last-slide': $last}\">\n    <div class=\"upper-row\">\n        <div class=\"indicator-icon-container\" ui-sref=\"user.indicator({alertId: $ctrl.alert.id, indicatorId: indicator.id})\">\n            <fs-svg-icon symbol-name=\"{{::indicator.symbolName}}\"></fs-svg-icon>\n\n        </div>\n        <div class=\"slide-separator\"></div>\n    </div>\n    <div class=\"slide-description\" ui-sref=\"user.indicator({alertId: $ctrl.alert.id, indicatorId: indicator.id})\">\n        {{indicator.timeLineDescription}}\n    </div>\n    <div class=\"slide-date-time\" ui-sref=\"user.indicator({alertId: $ctrl.alert.id, indicatorId: indicator.id})\">\n        {{indicator.startDate | date:\"MM/dd/yyyy | hh\\:mm a\":\"UTC\"}}\n    </div>\n</div>";
            var UserAlertFlowController = (function () {
                function UserAlertFlowController($scope, $element, $compile, $q, userIndicatorUtils) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.$compile = $compile;
                    this.$q = $q;
                    this.userIndicatorUtils = userIndicatorUtils;
                    this._swiperWrapperOffset = 0;
                    this.currentIndex = 0;
                    this.SWIPER_CONTAINER_SELECTOR = '.swiper-container';
                    this.SWIPER_WRAPPER_SELECTOR = '.swiper-wrapper';
                    this.INDICATOR_SLIDER_SELECTOR = '.indicator-slide';
                    this.WRAPPER_TRANSITION = 'transform 1s cubic-bezier(0.68, 0.1, 0.27, 0.98)';
                }
                /**
                 * Takes an index number and performs a slide animation to that index.
                 * @param index
                 * @param doNotExecute
                 * @returns {IPromise<TResult>}
                 */
                UserAlertFlowController.prototype.scrollToSlideIndex = function (index, doNotExecute) {
                    var _this = this;
                    if (!!doNotExecute) {
                        return;
                    }
                    if (index > this._getNumberOfIndicators() - 1) {
                        index = this._getNumberOfIndicators() - 1;
                    }
                    if (index < 0) {
                        index = 0;
                    }
                    // get slide offset.
                    var offset = this._IndicatorSlidesBounds[index].offsetLeft;
                    if ((this._getTotalIndicatorsWidth() > this._getSwiperContainer().width()) && (this._getTotalIndicatorsWidth() - offset) < this._getSwiperWrapper().parent().width()) {
                        offset = this._getTotalIndicatorsWidth() - this._getSwiperWrapper().parent().width();
                    }
                    // set _swiperWrapperOffset.
                    this._swiperWrapperOffset = offset;
                    // set swiper offset
                    return this._updateSwiperWrapperElementOffset()
                        .then(function () {
                        return _this._findCurrentIndex();
                    })
                        .then(function (currentIndex) {
                        _this.currentIndex = currentIndex;
                        return _this._findIfLastPossibleIndex();
                    })
                        .then(function (isLast) {
                        _this.isLastIndicator = isLast;
                    });
                };
                UserAlertFlowController.prototype._getNumberOfIndicators = function () {
                    return this.indicators.length;
                };
                /**
                 * Finds the current index of slides.
                 * The heuristics: the first indicator that has both edges in the space
                 * @returns {IPromise<TResult>}
                 * @private
                 */
                UserAlertFlowController.prototype._findCurrentIndex = function () {
                    var _this = this;
                    // iterate through slides and find which one has one side before and on side after the left container side
                    return this._getIndicatorSlidesAsync()
                        .then(function (slides) {
                        var containerBounds = _this._getSwiperContainer()[0].getBoundingClientRect();
                        var currentIndex = _this.currentIndex;
                        _.some(slides, function (slide, index) {
                            var slideBoundingRect = slide.getBoundingClientRect();
                            if (slideBoundingRect.left >= containerBounds.left) {
                                currentIndex = index;
                                return true;
                            }
                        });
                        return currentIndex;
                    });
                };
                /**
                 * Returns a promise that resolves on a boolean that states if the current index is the right most index
                 * (which means that scrolling to the next index will cause the inner scroll to move too far to the left)
                 * The heuristics: If the last indicator's right is less than container's element right.
                 * @private
                 */
                UserAlertFlowController.prototype._findIfLastPossibleIndex = function () {
                    var _this = this;
                    return this._getIndicatorSlidesAsync()
                        .then(function (slides) {
                        var containerBounds = _this._getSwiperContainer()[0].getBoundingClientRect();
                        var slideBoundingRect = slides[slides.length - 1].getBoundingClientRect();
                        return slideBoundingRect.right <= containerBounds.right;
                    });
                };
                /**
                 * Returns a promise. Animates the slider-wrapper (translate3d) and resolves the promise when animation has finished.
                 * @returns {IPromise<T>}
                 * @private
                 */
                UserAlertFlowController.prototype._updateSwiperWrapperElementOffset = function () {
                    var _this = this;
                    var ctrl = this;
                    return ctrl.$q(function (resolve, reject) {
                        function transitionEndHandler() {
                            ctrl._getSwiperWrapper()[0].removeEventListener('transitionend', transitionEndHandler);
                            resolve();
                        }
                        ctrl._getSwiperWrapper()[0].addEventListener('transitionend', transitionEndHandler);
                        ctrl._getSwiperWrapper().css({ 'transform': "translate3d(" + -_this._swiperWrapperOffset + "px, 0px, 0px)" });
                    });
                };
                /**
                 * Returns a sum of all indicators width
                 * @returns {number}
                 * @private
                 */
                UserAlertFlowController.prototype._getTotalIndicatorsWidth = function () {
                    return _.sumBy(this._IndicatorSlidesBounds, function (indicatorSlideBound) { return indicatorSlideBound.width; });
                };
                /**
                 * Returns the swiper container element
                 * @returns {ng.IAugmentedJQuery}
                 * @private
                 */
                UserAlertFlowController.prototype._getSwiperContainer = function () {
                    if (!this._swiperContainer) {
                        this._swiperContainer = this.$element.find(this.SWIPER_CONTAINER_SELECTOR);
                    }
                    return this._swiperContainer;
                };
                /**
                 * Sets the swiper wrapper element to _swiperWrapper (if needed) and returns it
                 * @returns {ng.IAugmentedJQuery}
                 * @private
                 */
                UserAlertFlowController.prototype._getSwiperWrapper = function () {
                    if (!this._swipperWrapperElement) {
                        this._swipperWrapperElement = this.$element.find(this.SWIPER_WRAPPER_SELECTOR);
                    }
                    return this._swipperWrapperElement;
                };
                /**
                 * Return (Asynchronously) the list of indicator slides. It counts the amount of times it tries to find the
                 * slides. It will try 10 times before throwing.
                 * @param {number=} iteration
                 * @returns {IPromise<any>}
                 * @private
                 */
                UserAlertFlowController.prototype._getIndicatorSlidesAsync = function (iteration) {
                    var _this = this;
                    if (iteration === void 0) { iteration = 0; }
                    return this.$q(function (resolve, reject) {
                        if (iteration > 10) {
                            reject('Could not find indicator slides even after 10 iterations.');
                        }
                        _this.$scope.$applyAsync(function () {
                            if (!_this._indicatorSlidesElement || !_this._indicatorSlidesElement.length) {
                                _this._indicatorSlidesElement =
                                    Array.from(_this._getSwiperWrapper().find(_this.INDICATOR_SLIDER_SELECTOR));
                                if (_this._indicatorSlidesElement.length) {
                                    resolve(_this._indicatorSlidesElement);
                                }
                                else {
                                    resolve(null);
                                }
                            }
                            else {
                                resolve(_this._indicatorSlidesElement);
                            }
                        });
                    })
                        .then(function (indicatorSlidesElement) {
                        if (indicatorSlidesElement === null) {
                            iteration += 1;
                            return _this._getIndicatorSlidesAsync(iteration);
                        }
                        else {
                            return indicatorSlidesElement;
                        }
                    });
                };
                /**
                 * Renders the swiper element and appends it to its container element
                 * @private
                 */
                UserAlertFlowController.prototype._renderSwiper = function () {
                    var _this = this;
                    this.$compile(indicatorSlideTemplate)(this.$scope, function (clonedElement, scope) {
                        //cleanup (if not first time alert is rendered)
                        _this._getSwiperWrapper().empty();
                        _this._indicatorSlidesElement = null;
                        // Create content
                        _this._swiperElement = clonedElement;
                        _this._getSwiperWrapper().append(_this._swiperElement);
                    });
                };
                /**
                 * Iterates through all the slides and marks the bounds
                 * @private
                 */
                UserAlertFlowController.prototype._markSlidesBounds = function () {
                    var _this = this;
                    return this._getIndicatorSlidesAsync()
                        .then(function (slides) {
                        _this._IndicatorSlidesBounds = _.map(slides, function (slide) {
                            return {
                                offsetLeft: slide.offsetLeft - slide.parentElement.offsetLeft,
                                width: slide.offsetWidth
                            };
                        });
                    })
                        .catch(function (err) {
                        throw err;
                    });
                };
                /**
                 * Takes the received alert, finds the indicators, and digests them.
                 * @private
                 */
                UserAlertFlowController.prototype._digestAlert = function () {
                    var _this = this;
                    // Filter and sort indicators
                    this.indicators = this.userIndicatorUtils.filterIndicators(this.alert.evidences);
                    this.indicators = this.userIndicatorUtils.orderIndicators(this.indicators);
                    // Duplicate for immutability
                    this.indicators = _.cloneDeep(this.indicators);
                    // Add symbolName (for svg icon) and time line description to each indicator
                    _.each(this.indicators, function (indicator) {
                        indicator.symbolName = _this.userIndicatorUtils.getIndicatorSymbolName(indicator);
                        indicator.timeLineDescription = _this.userIndicatorUtils.getIndicatorTimelineDescription(indicator);
                    });
                };
                UserAlertFlowController.prototype._initAlertWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.alert; }, function (alert) {
                        if (alert) {
                            _this._digestAlert();
                            _this._renderSwiper();
                            _this._markSlidesBounds()
                                .then(function () {
                                return _this._findCurrentIndex();
                            })
                                .then(function (currentIndex) {
                                _this.currentIndex = currentIndex;
                                return _this._findIfLastPossibleIndex();
                            })
                                .then(function (isLastIndicator) {
                                _this.isLastIndicator = isLastIndicator;
                            });
                        }
                    });
                };
                UserAlertFlowController.prototype._initContainerDragWatch = function () {
                    var _this = this;
                    var ctrl = this;
                    var originalX;
                    var xDelta = 0;
                    var wrapperHasMoved = false;
                    /**
                     * Handler for mouse move
                     * @param evt
                     */
                    function mousemoveHandler(evt) {
                        // Raise move flag;
                        wrapperHasMoved = true;
                        // prevent movement when indicators width is less than the container
                        if (ctrl._getTotalIndicatorsWidth() < ctrl._getSwiperContainer().width()) {
                            return;
                        }
                        // Calc movement delta
                        xDelta = originalX - evt.pageX;
                        // Move wrapper
                        ctrl._getSwiperWrapper().css('transform', "translate3d(" + -(ctrl._swiperWrapperOffset + xDelta) + "px, 0px, 0px)");
                    }
                    /**
                     * Handler for mouse click up
                     * @param evt
                     */
                    function mouseupHandler(evt) {
                        // Remove handler for mouse move
                        ctrl._getSwiperContainer().off('mousemove', mousemoveHandler);
                        // Enter delta into current offset and zero delta
                        ctrl._swiperWrapperOffset += xDelta;
                        xDelta = 0;
                        // Start sequence that will scroll back to first or last indicator if the wrapper
                        // is too far to the left or right.
                        ctrl._findIfLastPossibleIndex()
                            .then(function (isLast) {
                            ctrl.isLastIndicator = isLast;
                            return ctrl._findCurrentIndex();
                        })
                            .then(function (currentIndex) {
                            // put current index on the controller
                            ctrl.currentIndex = currentIndex;
                            // Change scroll time to 0.3 so the pull back will be fast
                            ctrl._getSwiperWrapper().css('transition', 'transform 0.3s ease-in-out');
                            // if current index is 0 than scroll back to first indicator
                            if (currentIndex === 0) {
                                return ctrl.scrollToSlideIndex(ctrl.currentIndex);
                            }
                            else if (ctrl.isLastIndicator) {
                                return ctrl.scrollToSlideIndex(ctrl._getNumberOfIndicators() - 1);
                            }
                        })
                            .then(function () {
                            // Place the original transition back on the wrapper
                            ctrl._getSwiperWrapper().css('transition', ctrl.WRAPPER_TRANSITION);
                        });
                    }
                    /**
                     * Handler for mouse down
                     * @param evt
                     */
                    function mousedownHandler(evt) {
                        // Set listener for mousemove
                        ctrl._getSwiperContainer().on('mousemove', mousemoveHandler);
                        // Find the original mouse location for future delta calculation
                        originalX = evt.pageX;
                        // Remove transition time so all transition (while in move) will be immediate.
                        ctrl._getSwiperWrapper().css('transition', 'all 0s');
                    }
                    /**
                     * Handler for mouse click. It was set on the container, on Capture-Phase. When wrapperHasMoved flag is on
                     * (which means that move process was made on this particular mouse click sequence) then propagation
                     * is stopped, so it will not fire the ui-sref change.
                     * @param evt
                     */
                    function mouseClickHandler(evt) {
                        if (wrapperHasMoved) {
                            evt.stopImmediatePropagation();
                        }
                        // After flag was evaluated, put it down.
                        wrapperHasMoved = false;
                    }
                    // Add up down and click listeners
                    ctrl._getSwiperContainer().on('mousedown', mousedownHandler);
                    ctrl._getSwiperContainer().on('mouseup', mouseupHandler);
                    ctrl._getSwiperContainer()[0].addEventListener('click', mouseClickHandler, true);
                    // Cleanup listeners on scope destroy
                    ctrl.$scope.$on('$destory', function () {
                        _this._getSwiperContainer().off('mousedown', mousedownHandler);
                        _this._getSwiperContainer().off('mouseup', mouseupHandler);
                        ctrl._getSwiperContainer()[0].removeEventListener('click', mouseClickHandler, true);
                    });
                };
                UserAlertFlowController.prototype.$onInit = function () {
                    this._initAlertWatch();
                    this._initContainerDragWatch();
                };
                UserAlertFlowController.$inject = ['$scope', '$element', '$compile', '$q', 'userIndicatorsUtils'];
                return UserAlertFlowController;
            }());
            var fsUserAlertFlowComponent = {
                controller: UserAlertFlowController,
                templateUrl: 'app/layouts/user/components/user-alert-overview/components/user-alert-flow/user-alert-flow.component.html',
                bindings: {
                    alert: '<alertModel',
                }
            };
            angular.module('Fortscale.layouts.user')
                .component('fsUserAlertFlow', fsUserAlertFlowComponent);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var LOADING_PROGRESS_PROPERTY_NAME = 'loadingProgress';
            var UserController = (function () {
                function UserController(scope, element, $http, $stateParams, fsNanobarAutomationService, userUtils, userTagsUtils, tagsUtils, userWatchUtil, toastrService, $state, BASE_URL) {
                    this.scope = scope;
                    this.element = element;
                    this.$http = $http;
                    this.$stateParams = $stateParams;
                    this.fsNanobarAutomationService = fsNanobarAutomationService;
                    this.userUtils = userUtils;
                    this.userTagsUtils = userTagsUtils;
                    this.tagsUtils = tagsUtils;
                    this.userWatchUtil = userWatchUtil;
                    this.toastrService = toastrService;
                    this.$state = $state;
                    this.BASE_URL = BASE_URL;
                    this.NANOBAR_ID = 'user-page';
                    this._init();
                }
                /**
                 * Removes a tag from a user,
                 * @param tag
                 */
                UserController.prototype.removeTag = function (tag) {
                    var _this = this;
                    this.userTagsUtils.removeTag(tag, this.user)
                        .then(function (user) {
                        _this.user = _.cloneDeep(user);
                    });
                };
                /**
                 * Adds a tag to the user
                 * @param {ITagDefinition} tag
                 */
                UserController.prototype.addTag = function (tag) {
                    var _this = this;
                    var ctrl = this;
                    this.userTagsUtils.addTag(tag.name, this.user, tag.displayName ? tag.displayName : tag.name)
                        .then(function (user) {
                        //If tag is new - reload tags list
                        var tagFromTagsList = _.find(_this.tags, { "name": tag.name });
                        if (!tagFromTagsList) {
                            ctrl._initLoadingTags();
                        }
                        ctrl.user = _.cloneDeep(user);
                    });
                };
                /**
                 * Adds a new tag to system and to user
                 * @param {string} tagName
                 */
                //addNewTag (tagName:string):void {
                //    this.userTagsUtils.addNewTag(tagName, this.tags, _.cloneDeep(this.user))
                //        .then(({user: user, tags: tags}:{user:any, tags:ITagDefinition[]})=> {
                //            if (user) {
                //                this.user = _.cloneDeep(user);
                //            }
                //
                //            if (tags) {
                //                this.tags = tags;
                //            }
                //
                //        });
                //}
                /**
                 * Start of delegate methods of alert update (add comment, update comment, delete comment amd update feedbacka and status
                 */
                UserController.prototype.addComment = function (alertId, comment) {
                    var alert = _.find(this.alerts, { id: alertId });
                    alert.comments.unshift(comment);
                    this.alerts = _.cloneDeep(this.alerts); //Change the referench to trigger watchers
                };
                UserController.prototype.updateComment = function (alertId, comment) {
                    var alert = _.find(this.alerts, { id: alertId });
                    _.remove(alert.comments, function (commentInArray) {
                        return commentInArray.commentId === comment.commentId;
                    });
                    alert.comments.unshift(comment);
                    this.alerts = _.cloneDeep(this.alerts); //Change the referench to trigger watchers
                };
                UserController.prototype.deleteComment = function (alertId, commentId) {
                    var alert = _.find(this.alerts, { id: alertId });
                    _.remove(alert.comments, function (commentInArray) {
                        return commentInArray.commentId === commentId;
                    });
                    this.alerts = _.cloneDeep(this.alerts); //Change the referench to trigger watchers
                };
                UserController.prototype.updateFeedback = function (alertId, feedbackObject) {
                    //On feedback update we need to reload the whole user
                    this._initLoadingSequence();
                };
                /**
                 * End of delegate methods of alert update (add comment, update comment, delete comment amd update feedbacka and status
                 */
                UserController.prototype.toggleUserWatch = function () {
                    var _this = this;
                    this.userWatchUtil.changeUserWatchState(this.user, !this.user.followed)
                        .then(function (user) { return _this.user = user; })
                        .catch(function (err) {
                        console.error(err);
                        _this.toastrService.error("There was an error trying to change user's " + _this.user.fallbackDisplayName + " watch state.<br>Please try again later.");
                    });
                };
                UserController.prototype._initLoadingTags = function () {
                    var _this = this;
                    var promise = this.tagsUtils.getTags()
                        .then(function (res) {
                        _this.tags = res.data;
                    })
                        .catch(function (err) {
                        console.error('There was an error fetching tags.', err);
                        _this.tags = [];
                    });
                    this.fsNanobarAutomationService.addPromise(this.NANOBAR_ID, promise);
                    return promise;
                };
                /**
                 * Start the load user sequence
                 * @private
                 */
                UserController.prototype._initLoadUser = function () {
                    var _this = this;
                    var promise = this.userUtils.getUsersDetails([this.$stateParams.userId])
                        .then(function (users) {
                        if (!users.length) {
                            _this._goBackHistoryOrHome("No user was returned for id " + _this.$stateParams.userId + " .");
                            return;
                        }
                        _this.userUtils.setFallBackDisplayNames(users);
                        _this.userUtils.setUsersFullAddress(users);
                        _this.user = users[0];
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user.', err);
                        _this.user = {};
                    });
                    this.fsNanobarAutomationService.addPromise(this.NANOBAR_ID, promise);
                    return promise;
                };
                /**
                 * Loads a user's alerts
                 * @returns {IPromise<TResult>}
                 * @private
                 */
                UserController.prototype._initLoadingAlerts = function () {
                    var _this = this;
                    var promise = this.$http.get(this.BASE_URL + "/alerts", {
                        params: {
                            entity_id: this.$stateParams.userId
                        }
                    })
                        .then(function (res) {
                        _this.alerts = res.data.data;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user alerts.', err);
                        _this.alerts = [];
                    });
                    this.fsNanobarAutomationService.addPromise(this.NANOBAR_ID, promise);
                    return promise;
                };
                /**
                 * Initiates assets loading sequence
                 *
                 * @private
                 */
                UserController.prototype._initLoadingSequence = function () {
                    var _this = this;
                    var promiseTags = this._initLoadingTags();
                    this.fsNanobarAutomationService.addPromise(this.NANOBAR_ID, promiseTags);
                    var promiseUser = this._initLoadUser()
                        .then(function () {
                        if (!_this.user) {
                            return;
                        }
                        _this._initLoadingAlerts();
                    });
                    this.fsNanobarAutomationService.addPromise(this.NANOBAR_ID, promiseUser);
                };
                UserController.prototype._goBackHistoryOrHome = function (warnMsg) {
                    if (window.history.length) {
                        console.warn(warnMsg + ' Going back to previous page.');
                        // We use the applyAsync here to give angular a chance to complete the transition and register to the history.
                        this.scope.$applyAsync(function () {
                            window.history.back();
                        });
                    }
                    else {
                        console.warn(warnMsg + ' Redirecting to Overview.');
                        this.$state.go('overview');
                    }
                    return;
                };
                UserController.prototype._init = function () {
                    var _this = this;
                    if (!this.$stateParams.userId) {
                        this._goBackHistoryOrHome('No user id was provided in the url.');
                        return;
                    }
                    this.activities = new user_1.Activities();
                    // Start loading assets
                    this._initLoadingSequence();
                    this.scope.$on('userRiskScore:AlertsSorted', function (evt, sortedAlerts) {
                        if (sortedAlerts) {
                            _this.scope.$applyAsync(function () {
                                _this.sortedAlerts = sortedAlerts;
                            });
                        }
                    });
                };
                UserController.$inject = ['$scope', '$element', '$http', '$stateParams', 'fsNanobarAutomationService', 'userUtils',
                    'userTagsUtils', 'tagsUtils', 'userWatchUtil', 'toastrService', '$state',
                    'BASE_URL'];
                return UserController;
            }());
            angular.module('Fortscale.layouts.user')
                .controller('UserController', UserController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var eEntityType = Fortscale.shared.services.entityActivityUtils.eEntityType;
            var NUMBER_OF_TICKS = 11;
            var UserAttributesController = (function () {
                function UserAttributesController($scope, entityActivityUtils, fsNanobarAutomationService, page) {
                    this.$scope = $scope;
                    this.entityActivityUtils = entityActivityUtils;
                    this.fsNanobarAutomationService = fsNanobarAutomationService;
                    this.page = page;
                    this._init();
                }
                /**
                 * Start the user top countries load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadUserTopCountriesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getTopCountries(eEntityType.USER, this.user)
                        .then(function (countries) {
                        _this.activities.user.topCountries = countries;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading organization top countries.', err);
                        _this.activities.user.topCountries = [];
                    });
                };
                /**
                 * Starts the organization top countries load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadOrganizationTopCountriesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getTopCountries(eEntityType.ORGANIZATION)
                        .then(function (countries) {
                        _this.activities.organization.topCountries = countries;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading organization top countries.', err);
                        _this.activities.organization.topCountries = [];
                    });
                };
                /**
                 * Start the user's authentications load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadingAuthenticationsActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getAuthentications(eEntityType.USER, this.user)
                        .then(function (authentications) {
                        _this.activities.user.authentications = authentications;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user authentications.', err);
                        _this.activities.user.authentications = {
                            success: 0,
                            failed: 0
                        };
                    });
                };
                /**
                 * Start the user's working hours load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadingWorkingHourActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getWorkingHours(eEntityType.USER, this.user)
                        .then(function (workingHours) {
                        _this.activities.user.workingHours = workingHours;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user working-hours.', err);
                        _this.activities.user.workingHours = [];
                    });
                };
                /**
                 * Start the user's source devices load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadingSourceDevicesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getSourceDevices(eEntityType.USER, this.user)
                        .then(function (sourceDevices) {
                        _this.activities.user.sourceDevices = sourceDevices;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user source devices.', err);
                        _this.activities.user.sourceDevices = [];
                    });
                };
                /**
                 * Start the user's target devices load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadingTargetDevicesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getTargetDevices(eEntityType.USER, this.user)
                        .then(function (targetDevices) {
                        _this.activities.user.targetDevices = targetDevices;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user source devices.', err);
                        _this.activities.user.targetDevices = [];
                    });
                };
                /**
                 * Start the user's data usages load
                 * @returns {IPromise<void>}
                 * @private
                 */
                UserAttributesController.prototype._initLoadingDataUsagesActivity = function () {
                    var _this = this;
                    return this.entityActivityUtils.getDataUsages(eEntityType.USER, this.user)
                        .then(function (dataUsages) {
                        _this.activities.user.dataUsages = dataUsages;
                    })
                        .catch(function (err) {
                        console.error('There was an error loading user data usages.', err);
                        _this.activities.user.dataUsages = [];
                    });
                };
                UserAttributesController.prototype._initLoadingSequence = function () {
                    var promises = [
                        this._initLoadUserTopCountriesActivity(),
                        this._initLoadOrganizationTopCountriesActivity(),
                        this._initLoadingAuthenticationsActivity(),
                        this._initLoadingWorkingHourActivity(),
                        this._initLoadingSourceDevicesActivity(),
                        this._initLoadingTargetDevicesActivity(),
                        this._initLoadingDataUsagesActivity()
                    ];
                    this.fsNanobarAutomationService.addPromises('user-page', promises);
                };
                UserAttributesController.prototype._initUserWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.$scope.userCtrl.user; }, function (user) {
                        if (user) {
                            _this.user = user;
                            _this._initLoadingSequence();
                            _this.page.setPageTitle(user.username + " - User Profile");
                        }
                    });
                };
                UserAttributesController.prototype._init = function () {
                    this.activities = new user_1.Activities();
                    this._initUserWatch();
                };
                UserAttributesController.$inject = ['$scope', 'entityActivityUtils', 'fsNanobarAutomationService', 'page'];
                return UserAttributesController;
            }());
            angular.module('Fortscale.layouts.user')
                .controller('userAttributesController', UserAttributesController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            var userAlertOverviewViewController = (function () {
                function userAlertOverviewViewController($scope, $stateParams, authService, toastrService, page) {
                    this.$scope = $scope;
                    this.$stateParams = $stateParams;
                    this.authService = authService;
                    this.toastrService = toastrService;
                    this.page = page;
                    this.alertId = null;
                    this.userAlerts = null;
                    this.userCtrl = null;
                    this.analystMap = {}; //Map the analyst name as retrived from the API to analyst object
                    this.alerts = null;
                    this.alertId = $stateParams.alertId;
                    this.userCtrl = $scope.userCtrl;
                    this._init();
                }
                /**
                 * Extract the active alert from the state params, clone it, and store it
                 * on the conrollter
                 * @private
                 */
                userAlertOverviewViewController.prototype._getActiveAlert = function () {
                    if (this.$stateParams.alertId) {
                        this.alert = _.cloneDeep(_.find(this.userAlerts, { id: this.$stateParams.alertId }));
                    }
                };
                /**
                 * Extract all the alerts from user controller, clone it, and
                 * save the cloned object on this controller
                 * @private
                 */
                userAlertOverviewViewController.prototype._initAlertsWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.$scope.userCtrl.sortedAlerts; }, function (alerts) {
                        if (alerts && alerts.length) {
                            _this.userAlerts = _.cloneDeep(alerts);
                            _this._getActiveAlert();
                            _this.page.setPageTitle(_this.userAlerts[0].entityName + " - Alert Overview");
                        }
                    });
                };
                /**
                 * When component loaded, we load a map from each analyst names as apear on the comment, to full display name.
                 * @private
                 */
                userAlertOverviewViewController.prototype._initAnalystFullNames = function () {
                    var _this = this;
                    var ctrl = this;
                    this.authService.getAllUsers().then(function (result) {
                        _.forEach(result, function (value, key) {
                            ctrl.analystMap[value.emailAddress] = value.fullName;
                        });
                    })
                        .catch(function (err) {
                        _this.toastrService.warning("Can't load analyst full names ");
                    });
                };
                /**
                 * Extract delegated methods from user controller and save it on this controller
                 * @private
                 */
                userAlertOverviewViewController.prototype._initPopulatedFunctions = function () {
                    this.updateComment = this.userCtrl.updateComment.bind(this.userCtrl);
                    this.addComment = this.userCtrl.addComment.bind(this.userCtrl);
                    this.deleteComment = this.userCtrl.deleteComment.bind(this.userCtrl);
                    this.updateFeedback = this.userCtrl.updateFeedback.bind(this.userCtrl);
                };
                userAlertOverviewViewController.prototype._init = function () {
                    this._initAlertsWatch();
                    this._initAnalystFullNames();
                    this._initPopulatedFunctions();
                };
                userAlertOverviewViewController.$inject = ['$scope', '$stateParams', 'auth', 'toastrService', 'page'];
                return userAlertOverviewViewController;
            }());
            angular.module('Fortscale.layouts.user')
                .controller('userAlertOverviewController', userAlertOverviewViewController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user_1) {
            var userIndicatorViewController = (function () {
                function userIndicatorViewController($scope, $stateParams, indicatorTypeMapper) {
                    this.$scope = $scope;
                    this.$stateParams = $stateParams;
                    this.indicatorTypeMapper = indicatorTypeMapper;
                    this.alerts = null;
                    this.alert = null;
                    this.indicator = null;
                    this.indicatorType = null;
                    this._init();
                }
                userIndicatorViewController.prototype._getActiveAlert = function () {
                    if (this.$stateParams.alertId) {
                        this.alert = _.cloneDeep(_.find(this.alerts, { id: this.$stateParams.alertId }));
                    }
                };
                userIndicatorViewController.prototype._getActiveIndicator = function () {
                    if (this.$stateParams.indicatorId && this.alert) {
                        this.indicator = _.cloneDeep(_.find(this.alert.evidences, { id: this.$stateParams.indicatorId }));
                    }
                };
                userIndicatorViewController.prototype._getIndicatorType = function () {
                    if (this.indicator) {
                        this.indicatorType = this.indicatorTypeMapper.getType(this.indicator);
                    }
                };
                userIndicatorViewController.prototype._initAlertsWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.$scope.userCtrl.alerts; }, function (alerts) {
                        if (alerts) {
                            _this.alerts = _.cloneDeep(alerts);
                            _this._getActiveAlert();
                            _this._getActiveIndicator();
                            _this._getIndicatorType();
                        }
                    });
                };
                userIndicatorViewController.prototype._initUserWatch = function () {
                    var _this = this;
                    this.$scope.$watch(function () { return _this.$scope.userCtrl.user; }, function (user) {
                        if (user) {
                            _this.user = _.cloneDeep(user);
                        }
                    });
                };
                userIndicatorViewController.prototype._init = function () {
                    this._initAlertsWatch();
                    this._initUserWatch();
                };
                userIndicatorViewController.$inject = ['$scope', '$stateParams', 'indicatorTypeMapper'];
                return userIndicatorViewController;
            }());
            angular.module('Fortscale.layouts.user')
                .controller('userIndicatorController', userIndicatorViewController);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * Created by shays on 01/08/2016.
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var user;
        (function (user) {
            angular.module('Fortscale.layouts.users', []);
        })(user = layouts.user || (layouts.user = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * Created by shays on 07/09/2016.
 * This class contain different object types which can be stored on the state,
 * and implement the converting methods (to csv, to post request representation or to get requests representation
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var types;
            (function (types) {
                var NumberState = (function () {
                    function NumberState() {
                    }
                    NumberState.prototype.getAsStateSeperatedValues = function (value) {
                        return value + "";
                    };
                    NumberState.prototype.getObjectForPostRequest = function (value) {
                        return value;
                    };
                    NumberState.prototype.getObjectForGetRequest = function (value) {
                        return value;
                    };
                    return NumberState;
                }());
                var StringState = (function () {
                    function StringState() {
                    }
                    StringState.prototype.getAsStateSeperatedValues = function (value) {
                        return value;
                    };
                    StringState.prototype.getObjectForPostRequest = function (value) {
                        return value;
                    };
                    StringState.prototype.getObjectForGetRequest = function (value) {
                        return value;
                    };
                    return StringState;
                }());
                var BooleanState = (function () {
                    function BooleanState() {
                    }
                    BooleanState.prototype.getAsStateSeperatedValues = function (value) {
                        return value.toString();
                    };
                    BooleanState.prototype.getObjectForPostRequest = function (value) {
                        return value;
                    };
                    BooleanState.prototype.getObjectForGetRequest = function (value) {
                        return value;
                    };
                    return BooleanState;
                }());
                var AlertTypesState = (function () {
                    function AlertTypesState() {
                    }
                    /**
                     *  The rest return array of strings (alert type name]
                     *  The state/combobox need to get those ids as seperated string,
                     *  for example: "VPN_lateral_movement , brute_force_normalized_username_hourly@@@brute_force_normalized_username_daily".
                     *  The reason is the that "@@@" use as seperater between few alert types which are displayed and choosed together in the combobox
            
                     * @param key
                     * @param value
                     * @param allAlertTypes - the ids list all the exists alertTypes
                     * @returns {string}
                     * @private
                     */
                    AlertTypesState.prototype.getAsStateSeperatedValues = function (values, listOfOptions) {
                        if (_.isNil(values)) {
                            return;
                        }
                        var response = [];
                        _.each(values, function (value) {
                            //If anomaly type not empty - look for match key with can have single anomalyType
                            // or a few anomaly types seperated by "@@"
                            _.each(listOfOptions, function (alertKey) {
                                var keyParts = alertKey.id.split("@@@");
                                var index = _.findIndex(keyParts, function (keyPart) { return keyPart === value; });
                                if (index >= 0) {
                                    //value match one of the key parts
                                    //So we add the alertKey to the response of keys
                                    response.push(alertKey.id);
                                }
                            });
                        });
                        response = _.uniq(response);
                        return response.join(",");
                    };
                    /**
                     * This method get a string of alert types list keys, seperated by "," and "@@@"
                     * If this is for get request - convert it to string seperated by "," only.
                     * If this is for post request we need to generate an object for the response
                     * @param value
                     * @param isPostPut
                     * @returns {string[] or String}
                     * @private
                     */
                    AlertTypesState.prototype.getObjectForPostRequest = function (value) {
                        var SEPERATPR = "@@@";
                        if (_.isNil(value)) {
                            return value;
                        }
                        var alertTypessAsStrings = value.split(",");
                        if (alertTypessAsStrings.length === 0) {
                            return null;
                        }
                        var response = [];
                        _.each(alertTypessAsStrings, function (alertTypesParseAsString) {
                            //If alert types is list of alerts types seperated by "@@@" - split it into array of string
                            //and add each item in the list to the response
                            var parts = alertTypesParseAsString.split(SEPERATPR);
                            //add parts to the response
                            response = _.union(response, parts);
                        });
                        return response;
                    };
                    AlertTypesState.prototype.getObjectForGetRequest = function (value) {
                        return _.replace(value, "@@@", ",");
                    };
                    return AlertTypesState;
                }());
                var IndicatorTypesState = (function () {
                    function IndicatorTypesState() {
                    }
                    /**
                     *  The rest return array of object [{dataSource: string, anomalyType string},{{dataSource: string, anomalyType string}}]
                     *  The state/combobox need to get those ids as seperated string,
                     *  for example: "gwame , kerberos_login@@@time_anomaly , ssh@@@high_number_hourly@@high_number_daiy.
                     *  The reason is the that "@@@" use as seperater between the data source and anomaly type,
                     *  while the "@@" used to diffriniate two indicators that have the same pretty name, and will display only once
                     *  in the combo. for example high_number_hourly@@high_number_daiy will have only one entry in the combo box.
                     *
            
                     * @param key
                     * @param value
                     * @param allIndicatorTypes - the ids list all the exists indicators
                     * @returns {string}
                     * @private
                     */
                    IndicatorTypesState.prototype.getAsStateSeperatedValues = function (value, listOfOptions) {
                        if (value.anomalyList) {
                            var dataSources_1 = [];
                            _.each(value.anomalyList, function (singleRow) {
                                //If anomaly type not empty - look for match key with can have single anomalyType
                                // or a few anomaly types seperated by "@@"
                                if (singleRow.anomalyType) {
                                    _.each(listOfOptions, function (indicatorKey) {
                                        var keyParts = indicatorKey.id.split("@@@");
                                        if (singleRow.dataSource === keyParts[0] && keyParts.length > 1) {
                                            var anomalyParts = keyParts[1].split("@@");
                                            var keyIndex = _.indexOf(anomalyParts, singleRow.anomalyType);
                                            if (keyIndex > -1) {
                                                dataSources_1.push(indicatorKey.id);
                                            }
                                        }
                                    });
                                }
                                else {
                                    dataSources_1.push(singleRow.dataSource);
                                }
                            });
                            dataSources_1 = _.uniqBy(dataSources_1, function (indicatorKey) {
                                return indicatorKey;
                            });
                            return dataSources_1.join(",");
                        }
                        return;
                    };
                    /**
                     * This method get a string of indicators list keys
                     * If this is for get request - do nothing. Return the string.
                     * If this is for post request we need to generate a body of the form
                     * anomalyList:{dataSource:string, anomalyType?:string}[]}
                     * @param value
                     * @param isPostPut
                     * @returns {anomalyList:{dataSource:string, anomalyType?:string}[]} or String
                     * @private
                     */
                    IndicatorTypesState.prototype.getObjectForPostRequest = function (value) {
                        if (_.isNil(value)) {
                            return value;
                        }
                        var indicatorsAsStrings = value.split(",");
                        ;
                        if (indicatorsAsStrings.length === 0) {
                            return null;
                        }
                        var response = { anomalyList: [] };
                        _.each(indicatorsAsStrings, function (indicatorParseAsString) {
                            var parts = indicatorParseAsString.split("@@@");
                            if (parts.length === 1) {
                                var indicator = { dataSource: parts[0] };
                                response.anomalyList.push(indicator);
                            }
                            else if (parts.length > 1) {
                                _.each(parts[1].split('@@'), function (indicatorsOfDataSource) {
                                    var indicator = {
                                        dataSource: parts[0],
                                        anomalyType: indicatorsOfDataSource
                                    };
                                    response.anomalyList.push(indicator);
                                });
                            }
                        });
                        return response;
                    };
                    IndicatorTypesState.prototype.getObjectForGetRequest = function (value) {
                        return value;
                    };
                    return IndicatorTypesState;
                }());
                var StringsArrayState = (function () {
                    function StringsArrayState() {
                    }
                    StringsArrayState.prototype.getAsStateSeperatedValues = function (value, listOfOptions) {
                        return value.join(",");
                    };
                    StringsArrayState.prototype.getObjectForPostRequest = function (value) {
                        if (_.isNil(value)) {
                            return value;
                        }
                        return value.split(",");
                    };
                    StringsArrayState.prototype.getObjectForGetRequest = function (value) {
                        return value;
                    };
                    return StringsArrayState;
                }());
                types.STATE_TYPES = {
                    "NumberState": new NumberState(),
                    "StringState": new StringState(),
                    "BooleanState": new BooleanState(),
                    "IndicatorTypesState": new IndicatorTypesState(),
                    "AlertTypesState": new AlertTypesState(),
                    "StringsArrayState": new StringsArrayState()
                };
            })(types = users.types || (users.types = {}));
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * Attributes of the users state has several possible format.
 * Each value should might have different represntations for:
 * - How it stored on the state
 * - How it sent on the url to get & delete requests
 * - How it sent in the body for post / fetch / put request.
 *
 * The goals of this service is to convert any of the types between the different representations.
 * The list of types and implementations defined in app/app/layouts/users/services/users-state-types.ts
 *
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var STATE_TYPES = Fortscale.layouts.users.types.STATE_TYPES;
            var ConvertUsersStateUtils = (function () {
                function ConvertUsersStateUtils(attributeToTypeMap) {
                    this.attributeToTypeMap = attributeToTypeMap;
                }
                /**
                 * Helper method which convert the object value into seperated comma string
                 * @param key
                 * @param value
                 * @param allIndicatorTypes
                 * @param allAlertTypes
                 */
                ConvertUsersStateUtils.prototype.getAsStateSeperatedValues = function (key, value, allOptionsList) {
                    //If no values return null
                    if (!value) {
                        return;
                    }
                    //Return the value as string.
                    var stateTypeImplementation = STATE_TYPES[this.attributeToTypeMap[key]];
                    //If this attribute need the list for possible to build the values (I.E. all indicator types, all alert types)
                    //It might be empty
                    var optionsListForAttribute = allOptionsList[key];
                    return stateTypeImplementation.getAsStateSeperatedValues(value, optionsListForAttribute);
                };
                /**
                 * Helper method which coverte the seperated comma string from objectData[key] to the get/delete representation or to
                 * post / put representation
                 * @param objectData
                 * @param key the key of the attribute on the objectData
                 * @param isPostPut - if true the string will converted to the post / put representation
                 */
                ConvertUsersStateUtils.prototype.buildParam = function (objectData, key, isPostPut) {
                    var value = objectData[key];
                    if (_.isNil(value)) {
                        return value;
                    }
                    var stateTypeImplementation = STATE_TYPES[this.attributeToTypeMap[key]];
                    if (!isPostPut) {
                        return stateTypeImplementation.getObjectForGetRequest(value);
                    }
                    else {
                        return stateTypeImplementation.getObjectForPostRequest(value);
                    }
                };
                ConvertUsersStateUtils.$inject = [];
                return ConvertUsersStateUtils;
            }());
            var ConvertUsersStateUtilsFactory = (function () {
                function ConvertUsersStateUtilsFactory() {
                }
                ConvertUsersStateUtilsFactory.prototype.getConvertUsersStateUtil = function (attributeToTypeMap) {
                    return new ConvertUsersStateUtils(attributeToTypeMap);
                };
                return ConvertUsersStateUtilsFactory;
            }());
            // ********************************** End of Factory
            angular.module('Fortscale.layouts.users')
                .service('convertUsersStateUtilsFactory', ConvertUsersStateUtilsFactory);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * This service is a util service for high risk users asset
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var UsersPage = (function () {
                function UsersPage(data, total) {
                    this.data = data;
                    this.total = total;
                }
                return UsersPage;
            }());
            users.UsersPage = UsersPage;
            var UsersUtils = (function () {
                function UsersUtils(BASE_URL, $http, $log, $httpParamSerializerJQLike, convertUsersStateUtilsFactory, $q) {
                    this.BASE_URL = BASE_URL;
                    this.$http = $http;
                    this.$log = $log;
                    this.$httpParamSerializerJQLike = $httpParamSerializerJQLike;
                    this.$q = $q;
                    this.convertUsersStateUtils = convertUsersStateUtilsFactory.getConvertUsersStateUtil(TYPE_OF_KEY);
                }
                /**
                 *
                 * @param userFilter - the filter
                 * @param askForAllWatchedCount - flag which indicate if the server should count how many watched user
                 *                                  relevant to filter and return it on the info.
                 * @returns {IPromise<TResult>}
                 */
                UsersUtils.prototype.getUsers = function (userFilter, askForAllWatchedCount) {
                    var _this = this;
                    var extraData = {
                        addAllWatched: askForAllWatchedCount
                    };
                    return this.$http.get(this.BASE_URL + "/user", {
                        params: this._buildUserFilterParams(userFilter, true, false, extraData)
                    })
                        .then(function (res) {
                        // Validate data
                        if (!res.data.data) {
                            throw new ReferenceError("getUsers: The was no \"data\" property in the response body.");
                        }
                        var page = new UsersPage(res.data.data, res.data.total);
                        page.allWatchedCount = askForAllWatchedCount && res.data.info ? res.data.info.allWatched : null;
                        return page;
                    })
                        .catch(function (err) {
                        _this.$log.error("getUsers: Couldn't get users data", err);
                        return null;
                    });
                };
                UsersUtils.prototype.getUsersExportUrl = function (userFilter, topResultsLimit) {
                    var filterClone = _.cloneDeep(userFilter);
                    //Set page and size only for the clone so it will not affect the original objecr
                    filterClone.page = 1;
                    filterClone.pageSize = topResultsLimit || 999999;
                    var url = this.BASE_URL + '/user/export?' +
                        this.$httpParamSerializerJQLike(this._buildUserFilterParams(filterClone, true, false));
                    return url;
                };
                /**
                 * Gets the top scored users.
                 *
                 * @returns {IPromise<TResult>}
                 */
                UsersUtils.prototype.countUsers = function (isWatched, userTags, minScore) {
                    var _this = this;
                    return this.$http.get(this.BASE_URL + "/user/count", {
                        params: {
                            user_tags: userTags ? "any" : "",
                            is_watched: isWatched ? isWatched : "",
                            min_score: _.isNil(minScore) ? "" : minScore
                        }
                    })
                        .then(function (res) {
                        // Validate data
                        if (typeof res.data.dataBean === "undefined" || typeof res.data.dataBean.data === "undefined") {
                            throw new ReferenceError("getUsers: The was no \"data\" property in the response body.");
                        }
                        var count = res.data.dataBean.data;
                        return count;
                    })
                        .catch(function (err) {
                        _this.$log.error("getUsers: Couldn't get users data", err);
                        return 0;
                    });
                };
                /**
                * Gets the users count according to the filter received.
                *
                * @returns {IPromise<TResult>}
                */
                UsersUtils.prototype.countUsersByFilter = function (userFilter) {
                    var _this = this;
                    return this.$http.get(this.BASE_URL + "/user/count", {
                        params: this._buildUserFilterParams(userFilter, false, false)
                    })
                        .then(function (res) {
                        // Validate data
                        if (typeof res.data.dataBean === "undefined" || typeof res.data.dataBean.data === "undefined") {
                            throw new ReferenceError("getUsers: The was no \"data\" property in the response body.");
                        }
                        var count = res.data.dataBean.data;
                        return count;
                    })
                        .catch(function (err) {
                        _this.$log.error("getUsers: Couldn't get users data", err);
                        return 0;
                    });
                };
                /**
                 * This method return the status code (success / error).
                 * 400 - The user name already exists
                 * 500 - Server side error
                 * 200 - Sucess
                 *
                 * @param userFilter
                 * @param filterName
                 * @returns {IPromise<TResult>}
                 */
                UsersUtils.prototype.saveUsersFilter = function (userFilter, filterName) {
                    var clonedFilter = _.clone(userFilter);
                    delete clonedFilter.searchValue;
                    return this.$http.post(this.BASE_URL + "/user/" + filterName + "/favoriteFilter", this._buildUserFilterParams(clonedFilter, true, true));
                };
                /**
                 * getUsersFilters the all the possible filters
                 * listOfAllOptionsListPromisses is array of promisses.
                 * Is promise, after it resolved, should return object {attributeName, listOfOtpions}
                 * while list of options is array of object, each of the object should contain member named id.
                 * In other words, each promise should return: {attributeName:string, listOfOptions:{id:any}[]}
                 *
                 * @returns {IPromise<TResult>}
                 */
                UsersUtils.prototype.getUsersFilters = function (listOfAllOptionsListPromisses) {
                    //listOfAllOptionsListPromisses:ng.IPromise<{attributeName:string, listOfOptions:{id:any}[]}>[]
                    var _this = this;
                    //Set the get favoriteFilter promisess firts, and add any addition promisses from listOfAllOptionsListPromisses
                    var promisses = [this.$http.get(this.BASE_URL + "/user/favoriteFilter")];
                    _.each(listOfAllOptionsListPromisses, function (promiss) {
                        promisses.push(promiss);
                    });
                    return this.$q.all(promisses)
                        .then(function (res) {
                        // Validate data
                        var favoriteUserFilters = res[0].data.dataBean.data;
                        if (!favoriteUserFilters) {
                            throw new ReferenceError("getUsersFilters: The was no \"data\" property in the response body.");
                        }
                        var allOptionsList = {};
                        for (var i = 1; i < res.length; i++) {
                            allOptionsList[res[i].attributeName] = res[i].listOfOptions;
                        }
                        _this._usersFiltersAdaptorFromRest(favoriteUserFilters, allOptionsList);
                        return favoriteUserFilters;
                    })
                        .catch(function (err) {
                        _this.$log.error("getUsersFilters: Couldn't get users data", err);
                        return null;
                    });
                };
                UsersUtils.prototype.getUsersSeveritiesCounts = function (userFilter) {
                    var _this = this;
                    return this.$http.get(this.BASE_URL + "/user/severityBar", {
                        params: this._buildUserFilterParams(userFilter, false, false, { severity: null })
                    })
                        .then(function (res) {
                        // Validate data
                        var data = res.data.data;
                        var severities = data ? data : {};
                        severities.total = data ? res.data.total : 0;
                        return severities;
                    })
                        .catch(function (err) {
                        _this.$log.error("getUsersSeveritiesCounts: Couldn't get severities data", err);
                        return null;
                    });
                };
                /**
                 * Delete the favorite filter by id from server
                 * @param filterId
                 * @returns {IHttpPromise<T>}
                 */
                UsersUtils.prototype.deleteUsersFilter = function (filterId) {
                    return this.$http.delete(this.BASE_URL + "/user/favoriteFilter/" + filterId);
                };
                UsersUtils.prototype.watchUsers = function (watch, userFilter) {
                    return this.$http.post(this.BASE_URL + "/user/" + watch + "/followUsers", this._buildUserFilterParams(userFilter, false, true));
                };
                UsersUtils.prototype.addTags = function (userFilter, tagIds) {
                    return this.$http.post(this.BASE_URL + "/user/true/" + tagIds.join(",") + "/tagUsers", this._buildUserFilterParams(userFilter, false, true));
                };
                UsersUtils.prototype.removeTags = function (userFilter, tagIds) {
                    return this.$http.post(this.BASE_URL + "/user/false/" + tagIds.join(",") + "/tagUsers", this._buildUserFilterParams(userFilter, false, true));
                };
                ///////////////////////////////////////////////**********************************//////////////////////////////
                //
                //                Internal helper methods
                //
                ///////////////////////////////////////////////**********************************//////////////////////////////
                /**
                 *
                 * @param userFilter - current user\ filter
                 * @param includePageDetails - indicator if we need to include the paging details (page and page size)
                 * @param isPostPut - if true, all the fields that should be arrays converted from seperated string to array,
                 *                  if false, the fields are not converted into array
                 * @param additionalData - if we need to merge another data on the object other then the filter
                 * @returns {any} OBJECT OF {PARAMS:...}
                 * @private
                 */
                UsersUtils.prototype._buildUserFilterParams = function (userFilter, includePageDetails, isPostPut, additionalData) {
                    var _this = this;
                    //Convert filter attributes to param object for get or post response
                    var params = {};
                    _.each(PARAMS_REQUEST_TO_FILTER_ATTRIBUTE_NAME, function (attribute, paramName) {
                        params[paramName] = _this.convertUsersStateUtils.buildParam(userFilter, attribute, isPostPut);
                    });
                    //Page number and page size - optional
                    if (includePageDetails) {
                        _.merge(params, {
                            size: userFilter.pageSize,
                            fromPage: userFilter.page,
                        });
                    }
                    //Add additional data if needed
                    _.merge(params, additionalData);
                    return params;
                };
                UsersUtils.prototype.freeTextSearch = function (userFilter, searchTaxt) {
                    var extraData = {
                        searchValue: searchTaxt
                    };
                    userFilter.sortByField = "name";
                    userFilter.page = 1;
                    userFilter.pageSize = 6;
                    return this.$http.get(this.BASE_URL + "/user/extendedSearch", {
                        params: this._buildUserFilterParams(userFilter, true, false, extraData)
                    });
                };
                /**
                 * This method iterate all the filters responsed from server and convert the values as arrive in rest
                 * to the values that the state familiar with.
                 * @param favoriteUserFilters
                 * @param allOptionsList - a dictionary from attribute name (I.E. alertTypes) to list of options of the attribute.
                 *                          each option is an object that must have id member.
                 * @private
                 */
                UsersUtils.prototype._usersFiltersAdaptorFromRest = function (favoriteUserFilters, allOptionsList) {
                    var _this = this;
                    //For each favorite filter
                    _.each(favoriteUserFilters, function (favoriteUserFilter) {
                        //For each attribute in the filter
                        _.each(favoriteUserFilter.filter, function (value, key) {
                            //Convert and replace the new value
                            var convertedValue = _this.convertUsersStateUtils.getAsStateSeperatedValues(key, value, allOptionsList);
                            if (typeof convertedValue !== "undefined") {
                                favoriteUserFilter.filter[key] = convertedValue;
                            }
                        });
                    });
                };
                UsersUtils.$inject = ['BASE_URL', '$http', '$log', '$httpParamSerializerJQLike', 'convertUsersStateUtilsFactory', '$q'];
                return UsersUtils;
            }());
            var TYPE_OF_KEY = {
                page: "NumberState",
                pageSize: "NumberState",
                sortByField: "StringState",
                sortDirection: "StringState",
                addAlertsAndDevices: "BooleanState",
                isWatched: "BooleanState",
                userTags: "StringsArrayState",
                minScore: "NumberState",
                alertTypes: "AlertTypesState",
                indicatorTypes: "IndicatorTypesState",
                locations: "StringsArrayState",
                severity: "StringState",
                searchValue: "StringState",
                positions: "StringsArrayState",
                departments: "StringsArrayState"
            };
            var PARAMS_REQUEST_TO_FILTER_ATTRIBUTE_NAME = {
                sortField: "sortByField",
                sortDirection: "sortDirection",
                addAlertsAndDevices: "addAlertsAndDevices",
                userTags: "userTags",
                isWatched: "isWatched",
                minScore: "minScore",
                alertTypes: "alertTypes",
                indicatorTypes: "indicatorTypes",
                locations: "locations",
                severity: "severity",
                searchValue: "searchValue",
                positions: "positions",
                departments: "departments"
            };
            //End of UserFilter, TYPE_OF_KEY, PARAMS_REQUEST_TO_FILTER_ATTRIBUTE_NAME
            angular.module('Fortscale.layouts.users')
                .service('usersUtils', UsersUtils);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsUserTooltip;
            (function (fsUserTooltip) {
                var TEMPLATE_URL = 'app/layouts/users/components/users-search-popup/users-search-popup-internal.template.html';
                var KEY_ARROW_UP = 38;
                var KEY_ARROW_DOWN = 40;
                var NO_CURRENT_INDEX = -1;
                var UsersSearchPopupComponentController = (function () {
                    function UsersSearchPopupComponentController($scope, $element, $templateCache, $compile, $window, $timeout, $state, stateManagementService) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$templateCache = $templateCache;
                        this.$compile = $compile;
                        this.$window = $window;
                        this.$timeout = $timeout;
                        this.$state = $state;
                        this.stateManagementService = stateManagementService;
                        this.attributeName = "searchValue";
                        //If the we hover a user using mouse or arrows the index should be 0 or greater.
                        //If the user is on the search text input the index should be -1.
                        this.currentHoverIndex = NO_CURRENT_INDEX;
                        /**
                         * Tooltip local settings object
                         *
                         * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                         * @private
                         */
                        this._tooltipSettings = {
                            className: 'users-search-tooltip',
                            showOn: 'creation',
                            hideOn: 'tip',
                            stem: true,
                            stemLength: 8,
                            stemBase: 12,
                            hideDelay: 0.3,
                            tipJoint: 'top',
                            fixed: true,
                            removeElementsOnHide: true,
                            group: 'users-search-popup',
                            background: '#f0f7f8',
                            borderRadius: 3,
                            borderColor: '#f0f7f8',
                            shadow: true,
                            shadowBlur: 15,
                            shadowOffset: [0, 0],
                            shadowColor: 'rgba(0, 0, 0, 0.5)',
                            containInViewport: true,
                            offset: [0, 0]
                        };
                    }
                    /**
                     * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                     *
                     * @returns {HTMLElement|null}
                     * @private
                     */
                    UsersSearchPopupComponentController.prototype._getTargetElement = function () {
                        if (this.tooltipTargetSelector) {
                            var closest = this.$element.closest(this.tooltipTargetSelector);
                            var inner = this.$element.find(this.tooltipTargetSelector);
                            return closest.length ? closest[0] :
                                inner.length ? inner[0] : null;
                        }
                        return null;
                    };
                    /**
                     * Set the current index for selected user
                     */
                    UsersSearchPopupComponentController.prototype.updateIndex = function (newIndex) {
                        this.currentHoverIndex = newIndex;
                    };
                    UsersSearchPopupComponentController.prototype.onSearchActive = function () {
                        var searchActive = this.searchText ? this.searchText.length > 0 : false;
                        if (this.timer) {
                            this.$timeout.cancel(this.timer);
                        }
                        if (searchActive) {
                            this.timer = this.$timeout(this._loadUsers.bind(this), 500);
                        }
                        else {
                            this._safeHide();
                        }
                    };
                    //Get the users, clear the timer, and display / hide the list off users
                    UsersSearchPopupComponentController.prototype._loadUsers = function () {
                        var _this = this;
                        var ctrl = this;
                        ctrl.timer = null;
                        ctrl.searchTriggeredDelegate({ "searchText": this.searchText }).then(function (users) {
                            ctrl.users = users;
                            _this._safeHide();
                            if (users.length > 0) {
                                ctrl._initTooltip();
                            }
                        });
                    };
                    /**
                     * Return true if the tooltip displayed
                     * @returns {boolean|string}
                     * @private
                     */
                    UsersSearchPopupComponentController.prototype._isVisible = function () {
                        return this._tooltip != null && this._tooltip.visible;
                    };
                    UsersSearchPopupComponentController.prototype._safeHide = function () {
                        if (this._isVisible()) {
                            this._tooltip.hide();
                        }
                        ;
                        this.currentHoverIndex = NO_CURRENT_INDEX;
                    };
                    UsersSearchPopupComponentController.prototype.deleteSearchText = function () {
                        this.searchText = null;
                        this.currentHoverIndex = NO_CURRENT_INDEX;
                        this.applyFilter();
                    };
                    UsersSearchPopupComponentController.prototype.submitWithKeypress = function (e) {
                        if (e.keyCode === 13) {
                            //Key press happens before angular populate the value into the model
                            var newValue = e.target.value;
                            this.applyFilter(newValue);
                        }
                        else if ((this._isKeyUpPressed(e.keyCode, e.shiftKey) || e.keyCode === KEY_ARROW_DOWN) && this.users) {
                            if (this._isKeyUpPressed(e.keyCode, e.shiftKey)) {
                                this.currentHoverIndex > 0 ? this.currentHoverIndex-- : this.currentHoverIndex = NO_CURRENT_INDEX;
                            }
                            else if (e.keyCode === KEY_ARROW_DOWN) {
                                this.currentHoverIndex < this.users.length - 1 ? this.currentHoverIndex++ : this.currentHoverIndex = this.users.length - 1;
                            }
                            this.stopEvent(e);
                        }
                        else if (e.keyCode === 27) {
                            this._safeHide();
                        }
                    };
                    /**
                     * We need to prevent input curesur to move when arrow up or down. Submit with key press handle the actual event.
                     * stop event should prevent keypress
                     * @param e
                     */
                    UsersSearchPopupComponentController.prototype.stopEvent = function (e) {
                        if (this._isKeyUpPressed(e.keyCode, e.shiftKey)) {
                            e.stopPropagation();
                            e.preventDefault();
                        }
                        else if (e.keyCode === KEY_ARROW_DOWN) {
                            e.stopPropagation();
                            e.preventDefault();
                        }
                    };
                    /**
                     * Initiates the tooltip settings (creates an instance settings)
                     *
                     * @private
                     */
                    UsersSearchPopupComponentController.prototype._initSettings = function () {
                        this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                            target: this._getTargetElement(),
                        });
                    };
                    /**
                     * Renders the tooltip
                     *
                     * @private
                     */
                    UsersSearchPopupComponentController.prototype._initTooltip = function () {
                        // Set this as ctrl for the callbacks
                        var ctrl = this;
                        var template = this.$templateCache.get(TEMPLATE_URL);
                        var tooltipContent = this.$compile(angular.element(template))(ctrl.$scope);
                        ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                        ctrl._tooltip.setContent(tooltipContent);
                        // Prevent close on mouseover tooltip
                        ctrl._tooltip.content.on({
                            mouseenter: function () {
                                ctrl._tooltip._abortHiding();
                            },
                            mouseleave: function () {
                                ctrl._tooltip.prepareToHide();
                                //ctrl._tooltip._abortHiding(); //If you want to show on leave
                            }
                        });
                    };
                    /**
                     * Cleansup the tooltip when the scope is destroyed
                     *
                     * @private
                     */
                    UsersSearchPopupComponentController.prototype._initCleanup = function () {
                        var _this = this;
                        this.$scope.$on('$destroy', function () {
                            if (_this._tooltip != null) {
                                _this._tooltip.adapter.remove(_this._tooltip.container);
                                _this._tooltip.container = null;
                                _this._tooltip.tooltipElement = null;
                                _this._tooltip = null;
                            }
                        });
                    };
                    UsersSearchPopupComponentController.prototype._initCloseOnWindowSizeChange = function () {
                        var ctrl = this;
                        angular.element(this.$window).bind('resize', function () {
                            ctrl.closePopup();
                        });
                    };
                    //Close the popup and reset the search text
                    UsersSearchPopupComponentController.prototype.closePopup = function () {
                        this.searchText = null;
                        this._safeHide();
                    };
                    UsersSearchPopupComponentController.prototype.$onInit = function () {
                        this.tooltipTargetSelector = "users-search-popup";
                        this._initSettings();
                        //this._initTooltip();
                        this._initCleanup();
                        this._initCloseOnWindowSizeChange();
                        this.$scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
                        this.stateManagementService.registerToStateChanges(this.stateId, this._safeHide.bind(this));
                    };
                    //Apply filter actually affect the state
                    UsersSearchPopupComponentController.prototype.applyFilter = function (differentSeachText) {
                        if (this.currentHoverIndex > NO_CURRENT_INDEX) {
                            this._gotoUserPage();
                        }
                        else {
                            var finalSearchString = differentSeachText ? differentSeachText : this.searchText;
                            //Update the filter
                            this._safeHide();
                            this.updateStateDelegate({
                                id: this.attributeName,
                                type: 'DATA',
                                value: finalSearchString,
                                immediate: true
                            });
                        }
                    };
                    UsersSearchPopupComponentController.prototype._gotoUserPage = function () {
                        //Redirect to profile page of specific user
                        if (!_.isNil(this.currentHoverIndex) && this.currentHoverIndex >= 0) {
                            this.$state.go("user.baseline", { "userId": this.users[this.currentHoverIndex].id });
                            this._safeHide();
                        }
                        else {
                            console.error("Cannot go to user page if currentHoverIndex is smaller then 0 ");
                        }
                    };
                    UsersSearchPopupComponentController.prototype._stateWatchFn = function () {
                        if (this.fetchStateDelegate) {
                            return this.fetchStateDelegate(this.attributeName);
                        }
                    };
                    UsersSearchPopupComponentController.prototype._isKeyUpPressed = function (keyCode, isShiftClicked) {
                        return keyCode === KEY_ARROW_UP && !isShiftClicked;
                    };
                    UsersSearchPopupComponentController.prototype.isRoleFilterTurnedOn = function () {
                        var userFilter = this.stateManagementService.readCurrentState(this.stateId);
                        return !_.isNil(userFilter.positions) && userFilter.positions != '';
                    };
                    UsersSearchPopupComponentController.prototype.isDepartmentFilterTurnedOn = function () {
                        var userFilter = this.stateManagementService.readCurrentState(this.stateId);
                        return !_.isNil(userFilter.departments) && userFilter.departments != '';
                    };
                    /**
                     * Watch action function . Set the value for the searchTaxt from outside
                     *
                     * @param {string|number} value
                     */
                    UsersSearchPopupComponentController.prototype._stateWatchActionFn = function (value) {
                        this._safeHide();
                        this.searchText = value;
                    };
                    UsersSearchPopupComponentController.$inject = ['$scope', '$element', '$templateCache', '$compile', '$window', '$timeout', '$state', 'stateManagementService'];
                    return UsersSearchPopupComponentController;
                }());
                var UsersSearchPopupComponent = {
                    controller: UsersSearchPopupComponentController,
                    controllerAs: '$ctrl',
                    templateUrl: 'app/layouts/users/components/users-search-popup/users-search-popup.template.html',
                    bindings: {
                        searchTriggeredDelegate: "&",
                        fetchStateDelegate: '=',
                        updateStateDelegate: '=',
                        stateId: '<',
                    }
                };
                angular.module('Fortscale.shared.components')
                    .component('usersSearchPopup', UsersSearchPopupComponent);
            })(fsUserTooltip = components.fsUserTooltip || (components.fsUserTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var ATTRIBUTE_NAME = "severity";
            var UsersSeverityStackedBarComponentController = (function () {
                function UsersSeverityStackedBarComponentController(scope, stateManagementService, usersUtils, $element, $timeout) {
                    this.scope = scope;
                    this.stateManagementService = stateManagementService;
                    this.usersUtils = usersUtils;
                    this.$element = $element;
                    this.$timeout = $timeout;
                    this.filterByValue = null; //Could be High, Critical, Low, Medium
                    this.attributeName = ATTRIBUTE_NAME;
                }
                /**
                 * Returns the value of the the state by the id
                 * @returns {*}
                 * @private
                 */
                UsersSeverityStackedBarComponentController.prototype._stateWatchFn = function () {
                    if (this.fetchStateDelegate) {
                        return this.fetchStateDelegate(this.attributeName);
                    }
                };
                UsersSeverityStackedBarComponentController.prototype.updateChange = function (selectedSeverity) {
                    this.filterByValue = selectedSeverity !== this.filterByValue ? selectedSeverity : null;
                    this.updateStateDelegate({
                        id: this.attributeName,
                        type: 'DATA',
                        value: this.filterByValue,
                        immediate: true
                    });
                };
                /**
                 * Watch action function . Sets the value to the picker if state has changed.
                 *
                 * @param {string|number} value
                 */
                UsersSeverityStackedBarComponentController.prototype._stateWatchActionFn = function (value) {
                    if (value === undefined) {
                        this.filterByValue = null;
                    }
                    else {
                        this.filterByValue = value;
                    }
                };
                /**
                 * Initiates state watch
                 *
                 * @returns {*|function()}
                 * @private
                 */
                UsersSeverityStackedBarComponentController.prototype._initStateWatch = function () {
                    this.scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
                };
                UsersSeverityStackedBarComponentController.prototype._initSeveritiesCounts = function () {
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    this._updateSeveritiesCounts(state);
                };
                UsersSeverityStackedBarComponentController.prototype._updateSeveritiesCounts = function (state) {
                    var _this = this;
                    this.usersUtils.getUsersSeveritiesCounts(state).then(function (res) {
                        _this.severities = res;
                        if (res.total === 0) {
                            return;
                        }
                        var ctrl = _this;
                        _.each(['Critical', 'High', 'Medium', 'Low'], function (key) {
                            var severityDiv = _this.$element.find("." + key.toLowerCase());
                            var value = res[key];
                            if (value && value.userCount > 0) {
                                var percents = value.userCount / res.total * 100;
                                severityDiv.css("display", "flex");
                                severityDiv.width(percents + '%');
                                ctrl.$timeout(function () {
                                    var spansUnderSeverityDiv = severityDiv.find("span");
                                    var finalParentWidth = severityDiv.width();
                                    if (finalParentWidth < spansUnderSeverityDiv.first().width()) {
                                        spansUnderSeverityDiv.css("display", "none"); //hide all spans
                                    }
                                    else {
                                        spansUnderSeverityDiv.css("display", "flex"); //hide all spans
                                    }
                                }, 100);
                            }
                            else {
                                severityDiv.css("display", "none");
                            }
                        });
                    });
                };
                UsersSeverityStackedBarComponentController.prototype.$onInit = function () {
                    this.filterByValue = this.fetchStateDelegate(this.attributeName);
                    this.stateManagementService.registerToStateChanges(this.stateId, this._updateSeveritiesCounts.bind(this));
                    this._initSeveritiesCounts();
                    this._initStateWatch();
                };
                UsersSeverityStackedBarComponentController.$inject = ['$scope', 'stateManagementService', 'usersUtils', '$element', '$timeout'];
                return UsersSeverityStackedBarComponentController;
            }());
            var UsersSeverityStackedBarComponent = {
                controller: UsersSeverityStackedBarComponentController,
                templateUrl: 'app/layouts/users/components/users-severities-stacked-bar/users-severities-stacked-bar.component.html',
                bindings: {
                    stateId: '<',
                    //Optional. If empty use STATE_ID constant
                    fetchStateDelegate: '=',
                    updateStateDelegate: '='
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersSeverityStackedBar', UsersSeverityStackedBarComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users_1) {
            'use strict';
            //Manage the actions bar above the users grid
            var UsersActionsBarController = (function () {
                function UsersActionsBarController($scope, stateManagementService, usersUtils, fsDownloadFile, toastrService, $element) {
                    this.$scope = $scope;
                    this.stateManagementService = stateManagementService;
                    this.usersUtils = usersUtils;
                    this.fsDownloadFile = fsDownloadFile;
                    this.toastrService = toastrService;
                    this.$element = $element;
                    this.allUsersFollowed = false;
                    this.isWatchRequestPending = false;
                    this.tags = [];
                    //Selectors for watch users
                    this.WATCH_BUTTON_SELECTOR = '.watch-user-button-watch';
                    this.UNWATCH_BUTTON_SELECTOR = '.watch-user-button-unwatch';
                    this.ANIMATION_TIME = 500;
                }
                /*
                Export to csv
                 */
                UsersActionsBarController.prototype.exportCSV = function () {
                    if (!this.usersCount || this.usersCount === 0) {
                        return;
                    }
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    //Init the filter
                    var filter = _.clone(state);
                    filter.addAlertsAndDevices = true;
                    var src = this.usersUtils.getUsersExportUrl(filter, this.usersCount);
                    this.fsDownloadFile.openIFrame(src);
                };
                /**
                 * Watch action
                 * Trigger update watch for all users which match to the filter,
                 * and reload grid and counts
                 */
                UsersActionsBarController.prototype.watchAction = function () {
                    var _this = this;
                    if (!this.usersCount || this.usersCount === 0) {
                        return;
                    }
                    //If already action execution - stop execute
                    if (this.isWatchRequestPending) {
                        return;
                    }
                    this.isWatchRequestPending = true;
                    //Get the state and call watchUsers with the RELEVANT FILTER filter
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    var filter = _.clone(state);
                    filter.addAlertsAndDevices = false;
                    this.usersUtils.watchUsers(!this.allUsersFollowed, filter).then(function () {
                        //When sucess - update the flag, reload the grid and upfate predefined watch filter with the new count
                        _this.allUsersFollowed = !_this.allUsersFollowed;
                        _this.reloadDelegate(true, false, true, false, false);
                        _this.isWatchRequestPending = false;
                    }).catch(function (err) {
                        //If error take place- shouw toast
                        _this.isWatchRequestPending = false;
                        _this.toastrService.error("Could not add users to watchlist - please try again.");
                        return null;
                    });
                };
                /**
                 * this method add tag(s) to all the users matching to current filter.
                 * In addition, after operation success, we update the state with the new selected tags,
                 * and relaod the complete tags list (because if add not existing tag it should refresh the tags list.
                 *
                 * @param tagIds
                 * @returns {IPromise<TResult>}
                 */
                UsersActionsBarController.prototype.addTagsDelegate = function (tagIds) {
                    var _this = this;
                    if (!this.usersCount || this.usersCount === 0) {
                        return;
                    }
                    //Get the current filter, update it, and call "add tags".
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    //Init the filter
                    var filter = _.clone(state);
                    filter.addAlertsAndDevices = false;
                    return this.usersUtils.addTags(filter, tagIds).then(function (res) {
                        //Refresh the list of tags because add tag to user may add it to the system
                        _this._updateStateTagsWithNewTags(tagIds, null);
                        _this.reloadDelegate(false, false, false, true, true);
                        _this.toastrService.success(_this._getTagsSuccessMessage(tagIds.length, res.data.count, "assigned to"));
                    }).catch(function (err) {
                        _this.toastrService.error("Failed to tag users. Please try again later.");
                    });
                };
                UsersActionsBarController.prototype._getTagsSuccessMessage = function (tagCount, usersAffected, addedOrRemoved) {
                    var message = tagCount + " tag";
                    message += tagCount > 1 ? "s" : "";
                    message += " have been " + addedOrRemoved + " ";
                    message += usersAffected + " user";
                    message += usersAffected > 1 ? "s" : "";
                    return message;
                };
                UsersActionsBarController.prototype.removeTagsDelegate = function (tagIds) {
                    var _this = this;
                    if (!this.usersCount || this.usersCount === 0) {
                        return;
                    }
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    //Init the filter
                    var filter = _.clone(state);
                    filter.addAlertsAndDevices = false;
                    return this.usersUtils.removeTags(filter, tagIds).then(function (res) {
                        _this._updateStateTagsWithNewTags(null, tagIds);
                        _this.reloadDelegate(false, false, false, true, false);
                        _this.toastrService.success(_this._getTagsSuccessMessage(tagIds.length, res.data.count, "removed from"));
                    }).catch(function (err) {
                        _this.toastrService.error("Add tags to all users failed");
                    });
                };
                /**
                 *
                 *
                 * @param addedTags- list of tag ids to add. Might be empty or null.
                 * @param removedTags list of tag ids to remove. Might be empty or null.
                 * @private
                 */
                UsersActionsBarController.prototype._updateStateTagsWithNewTags = function (addedTags, removedTags) {
                    //Get current filter tags:
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    var filterTagIds;
                    //If no current tags -
                    if (_.isNil(state.userTags)) {
                        if (addedTags && addedTags.length > 0) {
                            filterTagIds = _.clone(addedTags);
                        }
                        else {
                            //Do nothing. Remove all
                            filterTagIds = null;
                        }
                    }
                    else {
                        //Update current list of tags for the state
                        filterTagIds = state.userTags.split(",");
                        _.remove(filterTagIds, function (value) {
                            return value === 'any' || value === 'none';
                        });
                        _.each(addedTags, function (tagId) {
                            filterTagIds.push(tagId);
                        });
                        _.each(removedTags, function (tagId) {
                            filterTagIds = _.remove(filterTagIds, tagId);
                        });
                    }
                    //Update state userTags seperated string from the filterTagsIds arrays
                    if (filterTagIds === null || filterTagIds.length === 0) {
                        state.userTags = null;
                    }
                    else {
                        //Remove duplicates if any
                        filterTagIds = _.uniq(filterTagIds);
                        state.userTags = filterTagIds.join(",");
                    }
                    //State always need to be update, so the gird will be refreshed
                    this.stateManagementService.updateState(this.stateId, state);
                };
                UsersActionsBarController.prototype.searchTriggeredDelegate = function (searchText) {
                    //Get the state and call freeTextSearch with the RELEVANT FILTER filter
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    var filter = _.clone(state);
                    filter.addAlertsAndDevices = true;
                    return this.usersUtils.freeTextSearch(filter, searchText).then(function (res) {
                        //When sucess - update the flag return the data
                        if (res.data.data) {
                            var users_2 = res.data.data;
                            return users_2; //Extrace the list of users and return it
                        }
                    }).catch(function (err) {
                        return null;
                    });
                };
                UsersActionsBarController.prototype.$onInit = function () {
                    var _this = this;
                    //Init the button. The button has 2 states  - "watched / unwatched". Each time that allUserFollowed update it should flip to the other state
                    this.$scope.$watch(function () { return _this.allUsersFollowed; }, function (allUsersFollowed) {
                        if (allUsersFollowed !== undefined) {
                            _this.isWatchRequestPending = false;
                            if (_this.allUsersFollowed !== undefined) {
                                _this.allUsersFollowed = allUsersFollowed;
                                _this._watchButtonFlip();
                            }
                            else {
                                _this.allUsersFollowed = allUsersFollowed;
                                _this._initialWatchButtonFlip();
                            }
                        }
                    });
                };
                /**
                 * All follwing method handle the button flip flop
        
                 */
                UsersActionsBarController.prototype._shrinkElement = function (element) {
                    element.css('transform', 'scaleY(0)');
                };
                UsersActionsBarController.prototype._expandElement = function (element) {
                    element.css('transform', 'scaleY(1)');
                };
                UsersActionsBarController.prototype._setTransitions = function (shrinkElement, expandElement) {
                    shrinkElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.84, 0.15) 0s";
                    expandElement[0].style['WebkitTransition'] = "transform " + this.ANIMATION_TIME / 2 / 1000 + "s cubic-bezier(0, 0, 0.5, 1) " + this.ANIMATION_TIME / 2 / 1000 + "s";
                };
                UsersActionsBarController.prototype._initialWatchButtonFlip = function () {
                    var selector = this.allUsersFollowed ? this.UNWATCH_BUTTON_SELECTOR : this.WATCH_BUTTON_SELECTOR;
                    var element = this.$element.find(selector);
                    this._expandElement(element);
                };
                UsersActionsBarController.prototype._watchButtonFlip = function () {
                    var _this = this;
                    var shrinkSelector = this.allUsersFollowed ? this.WATCH_BUTTON_SELECTOR : this.UNWATCH_BUTTON_SELECTOR;
                    var expandSelector = this.allUsersFollowed ? this.UNWATCH_BUTTON_SELECTOR : this.WATCH_BUTTON_SELECTOR;
                    var shrinkElement = this.$element.find(shrinkSelector);
                    var expandElement = this.$element.find(expandSelector);
                    this._setTransitions(shrinkElement, expandElement);
                    this.$scope.$applyAsync(function () {
                        _this._shrinkElement(shrinkElement);
                        _this._expandElement(expandElement);
                    });
                };
                /**
                 * End of button flip flop
                 */
                UsersActionsBarController.$inject = ['$scope', 'stateManagementService', 'usersUtils', 'fsDownloadFile', 'toastrService', '$element'];
                return UsersActionsBarController;
            }());
            var UsersActionsBarComponent = {
                controller: UsersActionsBarController,
                templateUrl: 'app/layouts/users/components/users-action-bar/users-action-bar.view.html',
                bindings: {
                    stateId: '<',
                    usersCount: '<',
                    reloadDelegate: '=',
                    allUsersFollowed: '<',
                    tags: '<',
                    fetchStateDelegate: '=',
                    updateStateDelegate: '='
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersActionBar', UsersActionsBarComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var shared;
    (function (shared) {
        var components;
        (function (components) {
            var fsUserTooltip;
            (function (fsUserTooltip) {
                var TEMPLATE_URL = 'app/layouts/users/components/users-tag-all-popup/users-tag-all-popup-internal.template.html';
                var UsersTagAllPopupComponentController = (function () {
                    function UsersTagAllPopupComponentController($scope, $element, $templateCache, $compile, $window, toastrService) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$templateCache = $templateCache;
                        this.$compile = $compile;
                        this.$window = $window;
                        this.toastrService = toastrService;
                        /**
                         * The alerts list to be displayed in the tooltip
                         */
                        this.tags = [];
                        this.checked = {};
                        /**
                         * Tooltip local settings object
                         *
                         * @type {{className: string, stem: boolean, stemLength: number, stemBase: number, hideDelay: number, tipJoint: string, fixed: boolean, removeElementsOnHide: boolean, group: string, background: string, borderRadius: number, borderColor: string, shadow: boolean, shadowBlur: number, shadowOffset: number[], shadowColor: string, containInViewport: boolean, offset: number[]}}
                         * @private
                         */
                        this._tooltipSettings = {
                            className: 'users-tag-all-tooltip',
                            showOn: 'click',
                            hideOn: 'tip',
                            stem: true,
                            stemLength: 8,
                            stemBase: 12,
                            hideDelay: 0.3,
                            tipJoint: 'top',
                            fixed: true,
                            removeElementsOnHide: false,
                            group: 'users-tag-all-popup',
                            background: '#f0f7f8',
                            borderRadius: 3,
                            borderColor: '#f0f7f8',
                            shadow: true,
                            shadowBlur: 15,
                            shadowOffset: [0, 0],
                            shadowColor: 'rgba(0, 0, 0, 0.5)',
                            containInViewport: true,
                            offset: [0, 0],
                        };
                    }
                    /**
                     * If tooltipTargetSelector was provided, this method returns the element the selector refers to.
                     *
                     * @returns {HTMLElement|null}
                     * @private
                     */
                    UsersTagAllPopupComponentController.prototype._getTargetElement = function () {
                        if (this.tooltipTargetSelector) {
                            var closest = this.$element.closest(this.tooltipTargetSelector);
                            var inner = this.$element.find(this.tooltipTargetSelector);
                            return closest.length ? closest[0] :
                                inner.length ? inner[0] : null;
                        }
                        return null;
                    };
                    /**
                     * Initiates the tooltip settings (creates an instance settings)
                     *
                     * @private
                     */
                    UsersTagAllPopupComponentController.prototype._initSettings = function () {
                        this._tooltipSettings = _.merge({}, this._tooltipSettings, {
                            target: this._getTargetElement(),
                        });
                    };
                    /**
                     * Renders the tooltip
                     *
                     * @private
                     */
                    UsersTagAllPopupComponentController.prototype._initTooltip = function () {
                        // Set this as ctrl for the callbacks
                        var ctrl = this;
                        var template = this.$templateCache.get(TEMPLATE_URL);
                        var tooltipContent = this.$compile(angular.element(template))(ctrl.$scope);
                        ctrl._tooltip = new Opentip(ctrl.$element, ctrl._tooltipSettings);
                        ctrl._tooltip.setContent(tooltipContent);
                        // Prevent close on mouseover tooltip
                        ctrl._tooltip.content.on({
                            mouseenter: function () {
                                ctrl._tooltip._abortHiding();
                            },
                            mouseleave: function () {
                                ctrl._tooltip.prepareToHide();
                                //ctrl._tooltip._abortHiding(); //If you want to show on leave
                            }
                        });
                    };
                    /**
                     * Cleansup the tooltip when the scope is destroyed
                     *
                     * @private
                     */
                    UsersTagAllPopupComponentController.prototype._initCleanup = function () {
                        var _this = this;
                        this.$scope.$on('$destroy', function () {
                            if (_this._tooltip != null) {
                                _this._tooltip.adapter.remove(_this._tooltip.container);
                                _this._tooltip.container = null;
                                _this._tooltip.tooltipElement = null;
                                _this._tooltip = null;
                            }
                        });
                    };
                    UsersTagAllPopupComponentController.prototype.addTags = function () {
                        var _this = this;
                        var tagIds = this._getCheckedTagsIgs();
                        if (this.newTagName && this.newTagName.length > 0) {
                            var isNewTag_1 = true;
                            _.each(this.tags, function (tag) {
                                // Tag with the same name already exists
                                if (tag.value.toLowerCase() === _this.newTagName.toLowerCase()) {
                                    _this.toastrService.error("A tag with the name " + tag.value + " already exists; please select a different name.");
                                    isNewTag_1 = false;
                                }
                            });
                            if (!isNewTag_1) {
                                this.closeTagPopup();
                                return;
                            }
                            tagIds.push(this.newTagName);
                        }
                        this.addTagsDelegate({ "tagIds": tagIds }).then(function () {
                            if (_this.newTagName) {
                                _this.newTagName = "";
                            }
                            _this.closeTagPopup();
                        }).catch(function () {
                            _this.closeTagPopup();
                        });
                    };
                    UsersTagAllPopupComponentController.prototype.removeTags = function () {
                        var _this = this;
                        var tagIds = this._getCheckedTagsIgs();
                        this.removeTagsDelegate({ "tagIds": tagIds }).then(function () {
                            _this.closeTagPopup();
                        }).catch(function () {
                            _this.closeTagPopup();
                        });
                    };
                    UsersTagAllPopupComponentController.prototype._getCheckedTagsIgs = function () {
                        var checkedTags = _.pickBy(this.checked, function (value) {
                            return value; //Only if the value of the key is true
                        });
                        return _.keys(checkedTags);
                    };
                    UsersTagAllPopupComponentController.prototype.closeTagPopup = function () {
                        this.checked = {};
                        this._tooltip.hide();
                    };
                    UsersTagAllPopupComponentController.prototype._initCloseOnWindowSizeChange = function () {
                        var ctrl = this;
                        angular.element(this.$window).bind('resize', function () {
                            ctrl.closeTagPopup();
                        });
                    };
                    UsersTagAllPopupComponentController.prototype.$onInit = function () {
                        this.tooltipTargetSelector = "users-tags-all-popup";
                        this._initSettings();
                        this._initTooltip();
                        this._initCleanup();
                        this._initCloseOnWindowSizeChange();
                    };
                    UsersTagAllPopupComponentController.$inject = ['$scope', '$element', '$templateCache', '$compile', '$window', 'toastrService'];
                    return UsersTagAllPopupComponentController;
                }());
                var UsersTagAllPopupComponent = {
                    controller: UsersTagAllPopupComponentController,
                    controllerAs: '$ctrl',
                    templateUrl: 'app/layouts/users/components/users-tag-all-popup/users-tag-all-popup.template.html',
                    bindings: {
                        tags: '<',
                        removeTagsDelegate: '&',
                        addTagsDelegate: '&'
                    }
                };
                angular.module('Fortscale.shared.components')
                    .component('usersTagsAllPopup', UsersTagAllPopupComponent);
            })(fsUserTooltip = components.fsUserTooltip || (components.fsUserTooltip = {}));
        })(components = shared.components || (shared.components = {}));
    })(shared = Fortscale.shared || (Fortscale.shared = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var UsersGridComponentController = (function () {
                function UsersGridComponentController($scope, usersUtils, tagsUtils, stateManagementService, $element, $filter) {
                    this.$scope = $scope;
                    this.usersUtils = usersUtils;
                    this.tagsUtils = tagsUtils;
                    this.stateManagementService = stateManagementService;
                    this.$element = $element;
                    this.$filter = $filter;
                    this.tagListAsIdNValueList = [];
                    this.allUsersFollwoed = false;
                    this.usersCount = 0;
                    //List of sorting by options
                    this.sortByPropertyMap = {
                        score: "Risk Score",
                        name: "Name",
                        alertsCount: "Alerts"
                    };
                    //Prevent send to calls at the same time
                    this.loadingNow = false;
                    this.currentPage = 1;
                    this.pageSize = 25;
                    this.usersPages = [];
                    this.stateDifferentThenOriginal = false;
                    this.indicatorsTypes = [];
                }
                UsersGridComponentController.prototype.getStateId = function () {
                    return this.stateId;
                };
                /*****************************************************************************************************
                 *      Methods which responsible for translating the filters values, into list of pretty values
                 *****************************************************************************************************/
                /**
                 * Translate indicators list to pretty display name
                 * @returns {any}
                 */
                UsersGridComponentController.prototype.getPrettifyIndicatorTypes = function () {
                    var _this = this;
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    if (_.isNil(state.indicatorTypes)) {
                        return "";
                    }
                    else {
                        var values_1 = [];
                        _.each(state.indicatorTypes.split(","), function (value) {
                            var indicatorType = _.find(_this.indicatorsTypes, { "id": value });
                            if (!_.isNil(indicatorType)) {
                                values_1.push(indicatorType.value);
                            }
                        });
                        return values_1.join(", ");
                    }
                };
                UsersGridComponentController.prototype.getValueFromState = function (key) {
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    if (_.isNil(state[key])) {
                        return "";
                    }
                    else {
                        return state[key].split(",").join(", ");
                    }
                };
                /**
                 * Translate seperated string of tags list to pretty tags list
                 * @returns {any}
                 */
                UsersGridComponentController.prototype.getPrettifyTags = function () {
                    var _this = this;
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    if (_.isNil(state.userTags)) {
                        return "";
                    }
                    else {
                        var hideValue_1 = false;
                        var values_2 = [];
                        _.each(state.userTags.split(","), function (value) {
                            var prettyValue;
                            if (value === "none") {
                                prettyValue = "No Tags";
                            }
                            else if (value === "any") {
                                hideValue_1 = true;
                            }
                            else {
                                var tagObject = _.find(_this.tags, { 'name': value });
                                if (tagObject) {
                                    prettyValue = tagObject.displayName;
                                }
                            }
                            if (_.isNil(prettyValue)) {
                                prettyValue = value;
                            }
                            values_2.push(prettyValue);
                        });
                        if (hideValue_1) {
                            return "Tagged Users";
                        }
                        else {
                            return "Tags: " + values_2.join(", ");
                        }
                    }
                };
                UsersGridComponentController.prototype._setTagListAsIdValueList = function () {
                    this.tagListAsIdNValueList = _.map(this.tags, function (tag) {
                        return {
                            id: tag.name,
                            value: tag.displayName
                        };
                    });
                    //return tagsList;
                };
                UsersGridComponentController.prototype.getPrettifySeverity = function () {
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    return state.severity;
                };
                /**
                 * Translate seperated string of alert types list to pretty alert list
                 * @returns {string}
                 */
                UsersGridComponentController.prototype.getPrettifyAlertTypes = function () {
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    if (_.isNil(state.alertTypes)) {
                        return "";
                    }
                    else {
                        var values_3 = [];
                        var prettyAlertNameFunction_1 = this.$filter('prettyAlertName');
                        _.each(state.alertTypes.split(","), function (value) {
                            values_3.push(prettyAlertNameFunction_1({ name: value.split("@@@")[0] }));
                        });
                        return values_3.join(", ");
                    }
                };
                /**
                 * Load next page. Load only if not other loading happening
                 */
                UsersGridComponentController.prototype._loadMore = function () {
                    if (this.usersPages.length * this.pageSize < this.usersCount) {
                        this.readDataDelegate(this.currentPage + 1, this.pageSize, false, false);
                    }
                };
                /**
                 * Register to state trigger
                 * @private
                 */
                UsersGridComponentController.prototype._initStateChangeWatch = function () {
                    this.stateManagementService.registerToStateChanges(this.stateId, this._reload.bind(this));
                    //Check if state already different from original when component loads
                    this.stateDifferentThenOriginal = this.stateManagementService.isStateChanged(this.stateId);
                };
                /**
                 * Clear the page and users data and loading the whole grid again
                 * @private
                 */
                UsersGridComponentController.prototype._reload = function () {
                    this.usersPages = [];
                    this.readDataDelegate(1, this.pageSize, true, true);
                    //Also refresh reset filters
                    this.stateDifferentThenOriginal = this.stateManagementService.isStateChanged(this.stateId);
                };
                /**
                 * reloadDelegate called from outside, and render the grid + trigger the delegate method
                 * which reload the count of predefined filters (one or more)
                 *
                 * reloadUsersData:boolean - reload the grid
                 * riskyUsersCount - reload count for riskyUsers predefined filter
                 * watchedUsersCount - reload count for watchedUsers predefined filter
                 * taggedUserCount - reload count for riskyUsers taggedUser filter
                 * tagsList - reload the list of tags from server
                 *
                 * @private
                 */
                UsersGridComponentController.prototype._initAndbindReloadFunction = function () {
                    var ctrl = this;
                    this.reloadDelegate = function (reloadUsersData, riskyUsersCount, watchedUsersCount, taggedUserCount, tagsList) {
                        if (reloadUsersData) {
                            ctrl._reload();
                        }
                        ctrl.reloadPredefinedFiltersUsersCount(riskyUsersCount, watchedUsersCount, taggedUserCount, tagsList);
                    };
                };
                /**
                 * This method passed as delegate to the grid itself.
                 * Each time the grid ask for new page it called this method and pass the page number and size.
                 *
                 * @param pageNumber
                 * @param pageSize
                 * @param forceReload - false, if we want to disable loading when loadingNow = true,
                 *                      ture if we want to wait and trigger the loading after loading now will finish
                 * @returns {ng.IPromise<Fortscale.layouts.users.UsersPage>}
                 */
                UsersGridComponentController.prototype.readDataDelegate = function (pageNumber, pageSize, forceReload, askForAllWatchedCount) {
                    var _this = this;
                    //Waiting call - if we are doing paging, and there is page in loading, we ignore any new paging
                    //request. If there is not paging, but change in filter, already loadingNow = true (some other request running)
                    //we store the new request in the waitingCall and trigger it after the old request finish.
                    //If we already have waiting call, we override it, so only the last waiting will actual trigger
                    var waitingCall = null;
                    if (!this.loadingNow) {
                        this.loadingNow = true;
                        var filter = this._prepareFilterForGetUser(pageNumber, pageSize);
                        return this.usersUtils.getUsers(filter, askForAllWatchedCount)
                            .then(function (page) {
                            _this._updatePageDataAfterDataRefreshed(page, pageNumber, askForAllWatchedCount);
                            _this._triggerPendingCallOrFinishLoading(waitingCall);
                            return page;
                        });
                    }
                    else if (forceReload) {
                        waitingCall = {
                            page: pageNumber,
                            pageSize: pageSize
                        };
                    }
                };
                /**
                 * Merge state and additional data into filter request for the server
                 * @param pageNumber
                 * @param pageSize
                 * @returns {UserFilter}
                 * @private
                 */
                UsersGridComponentController.prototype._prepareFilterForGetUser = function (pageNumber, pageSize) {
                    var ctrl = this;
                    var state = this.stateManagementService.readCurrentState(ctrl.getStateId());
                    //Init the filter
                    var filter = _.clone(state);
                    filter.page = pageNumber;
                    filter.pageSize = pageSize;
                    filter.addAlertsAndDevices = true;
                    return filter;
                };
                /**
                 * Update users to display, counts, pageNumber, and so own.
                 * @param page
                 * @param pageNumber
                 * @param askForAllWatchedCount
                 * @private
                 */
                UsersGridComponentController.prototype._updatePageDataAfterDataRefreshed = function (page, pageNumber, askForAllWatchedCount) {
                    var ctrl = this;
                    if (page !== null) {
                        ctrl.usersCount = page.total;
                        ctrl.usersPages[pageNumber - 1] = page.data;
                    }
                    else {
                        ctrl.usersCount = 0;
                        ctrl.users = [];
                    }
                    if (askForAllWatchedCount) {
                        ctrl.allUsersFollwoed = page.allWatchedCount;
                    }
                    //After loading success, reset the page number and loadingNow flag
                    ctrl.currentPage = pageNumber;
                };
                /**
                 *
                 * @param waitingCall
                 * @private
                 */
                UsersGridComponentController.prototype._triggerPendingCallOrFinishLoading = function (waitingCall) {
                    //If some other call waiting, trigger it
                    var ctrl = this;
                    if (waitingCall) {
                        ctrl.readDataDelegate(waitingCall.page, waitingCall.pageSize);
                        waitingCall = null;
                    }
                    else {
                        ctrl.loadingNow = false;
                    }
                };
                UsersGridComponentController.prototype.$onInit = function () {
                    var _this = this;
                    var ctrl = this;
                    this._initStateChangeWatch();
                    this._initAndbindReloadFunction();
                    this.readDataDelegate(this.currentPage, this.pageSize, false, true);
                    this.$scope.$watch(function () { return _this.tags; }, this._setTagListAsIdValueList.bind(this));
                    //Listen to grid scroller, if arrive to end - load more data
                    function listenScroll(e) {
                        var targetEl = $(e.target);
                        if (targetEl.scrollTop() + targetEl.innerHeight() >= targetEl[0].scrollHeight - 100) {
                            ctrl._loadMore();
                        }
                    }
                    //Register scroll event and de-register
                    this.$element.find(".grid-wrapper").scroll(listenScroll);
                    this.$scope.$on('$destroy', function () {
                        ctrl.$element.off('scroll', listenScroll);
                    });
                };
                UsersGridComponentController.$inject = ['$scope', 'usersUtils', 'tagsUtils', 'stateManagementService', '$element', '$filter'];
                return UsersGridComponentController;
            }());
            var UsersGridComponent = {
                controller: UsersGridComponentController,
                templateUrl: 'app/layouts/users/components/users-grid/users-grid.component.html',
                bindings: {
                    stateId: '<',
                    //Optional. If empty use STATE_ID constant
                    fetchStateDelegate: '=',
                    updateStateDelegate: '=',
                    clearStateDelegate: "=",
                    indicatorsTypes: "=",
                    reloadPredefinedFiltersUsersCount: "=",
                    tags: '<'
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersGrid', UsersGridComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            'use strict';
            var MAX_DEVICE_TO_DISPLAY = 3;
            var UsersGridUserController = (function () {
                function UsersGridUserController(scope, tagsUtils, userTagUtils, deviceUtilsService, userUtils, $timeout) {
                    this.scope = scope;
                    this.tagsUtils = tagsUtils;
                    this.userTagUtils = userTagUtils;
                    this.deviceUtilsService = deviceUtilsService;
                    this.userUtils = userUtils;
                    this.$timeout = $timeout;
                    this.userTags = [];
                    //if miniView-true show only partial user-row.
                    this.miniView = false;
                }
                /**
                 * Delegate to remove the tag from the user and refresh the userTags list
                 * @param tag
                 */
                UsersGridUserController.prototype.removeTagDelegate = function (tag) {
                    var ctrl = this;
                    this.userTagUtils.removeTag(tag, this.user).then(function () {
                        ctrl.tagsUtils.getTagsFromCacheOnly().then(function (tagsPromise) {
                            ctrl._initUserTags(tagsPromise.data);
                        });
                    });
                };
                /**
                 * This method counts the number of devices up to MAX_DEVICE_TO_DISPLAY
                 * @returns {any} 0 if 0 devices or list is empty, return 3+ if there are more then 3 devices. Return 1-3 if there are 1-3 devices
                 *
                 */
                UsersGridUserController.prototype.getDevicesAmount = function () {
                    if (this.user.sourceMachineCount <= 3) {
                        return this.user.sourceMachineCount;
                    }
                    else {
                        //Return 3+ devices
                        return MAX_DEVICE_TO_DISPLAY + "+";
                    }
                };
                /**
                 * This method prepare the devices list before displaying in the ui:
                 * - Remove devices which not relevant (count  = 0)
                 * - Move the "other devices" to the end of the list
                 * - Add percentage attribute to each device in the list
                 * @private
                 */
                UsersGridUserController.prototype._initEnrichedDevices = function () {
                    var devices = this.deviceUtilsService.removeZeroCount(this.user.devices);
                    this.deviceUtilsService.repositionOthers(devices);
                    if (devices && devices.length > 0) {
                        this.enrichedUserDevices = this.deviceUtilsService.updatePercentageOnDevice(devices);
                    }
                    else {
                        this.enrichedUserDevices = [];
                    }
                };
                UsersGridUserController.prototype.$onInit = function () {
                    var _this = this;
                    this.user = _.cloneDeep(this._user);
                    this.userUtils.setFallBackDisplayNames([this.user]);
                    if (!this.miniView) {
                        //Init following only for full view
                        this._initEnrichedDevices();
                        this.scope.$watch(function () {
                            return _this.tags;
                        }, function () {
                            if (_this.tags && _this.tags.length > 0) {
                                _this._initUserTags(_this.tags);
                            }
                        });
                    }
                };
                /**
                 * Rebuild user tags list, build list of ITagDefinition out of String list
                 * private
                 * private
                 */
                //first:boolean=true;
                UsersGridUserController.prototype._initUserTags = function (allTagsInSystem) {
                    var ctrl = this;
                    var userTagsTemp = [];
                    _.each(ctrl.user.tags, function (tagName) {
                        var tag = _.find(allTagsInSystem, { name: tagName });
                        if (tag) {
                            userTagsTemp.push(tag);
                        }
                    });
                    ctrl.userTags = userTagsTemp;
                };
                UsersGridUserController.$inject = ['$scope', 'tagsUtils', 'userTagsUtils', 'deviceUtilsService', 'userUtils', '$timeout'];
                return UsersGridUserController;
            }());
            var UsersGridRowComponent = {
                controller: UsersGridUserController,
                templateUrl: 'app/layouts/users/components/user-grid-row/user-grid-row.view.html',
                bindings: {
                    _user: '<user',
                    tags: '<?',
                    miniView: '<?',
                    searchText: '<?',
                    rolesFiltered: '<?',
                    departmentFiltered: '<?'
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('userGridRow', UsersGridRowComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var UsersFiltersComponentController = (function () {
                function UsersFiltersComponentController(scope, stateManagementService, usersUtils, $http, BASE_URL, $filter, toastrService, $q) {
                    this.scope = scope;
                    this.stateManagementService = stateManagementService;
                    this.usersUtils = usersUtils;
                    this.$http = $http;
                    this.BASE_URL = BASE_URL;
                    this.$filter = $filter;
                    this.toastrService = toastrService;
                    this.$q = $q;
                    this.saveFavoritesDialogOpened = false;
                    this.favoriteFilters = [];
                    //Arrays for filters input.
                    //Should contain id & value (both can be number or string)
                    //count is optional field
                    this.alertTypes = [];
                    this.locations = [];
                    this.departments = [];
                    this.positions = [];
                    this._tags = []; // Copy of tags with additions.
                }
                UsersFiltersComponentController.prototype.getStateId = function () {
                    return this.stateId;
                };
                UsersFiltersComponentController.prototype._initPresetFilters = function () {
                    this._initDepartmentsList();
                    this._initRolesList();
                    this._initCountriesList();
                    this._initAlertTypesList();
                };
                /**
                 * This method fetch data from url, and build array of "{id:string, value:string}, save it to this.arrayName
                 * @param arrayName - the name of the attribute one "this" which the array will be saved
                 * @param url - the url to being the data from
                 * @param mappingFunction - function which itterate each of the results of the request from the url,
                 *                          and return build object of "{id:string, value:string} for each of the values.
                 * @returns {IPromise<TResult>}
                 * @private
                 */
                UsersFiltersComponentController.prototype._loadFromUrlToArray = function (arrayName, url, mappingFunction) {
                    var ctrl = this;
                    return this.$http
                        .get(this.BASE_URL + url)
                        .then(function (res) {
                        ctrl[arrayName] = _.map(res.data.data, mappingFunction);
                    });
                };
                UsersFiltersComponentController.prototype._initCountriesList = function () {
                    var ctrl = this;
                    this._loadFromUrlToArray('locations', '/organization/activity/locations?time_range=999999&limit=999999', function (country) { return { id: country.country, value: country.country }; }).then(function () {
                        //Sort the countries by the display name
                        ctrl.locations = _.sortBy(ctrl.locations, function (country) { return country.value; });
                    });
                };
                /*
                Load positions and store it on this.positions
                Roles = Positions
                 */
                UsersFiltersComponentController.prototype._initRolesList = function () {
                    this._loadFromUrlToArray("positions", '/user/adInfo.position/distinctValues', function (role) { return { id: role, value: role }; });
                };
                /**
                 * Load depratments and store it on this.departments
                 * @private
                 */
                UsersFiltersComponentController.prototype._initDepartmentsList = function () {
                    this._loadFromUrlToArray("departments", '/user/adInfo.department/distinctValues', function (role) { return { id: role, value: role }; });
                };
                UsersFiltersComponentController.prototype._initAlertTypesList = function () {
                    var _this = this;
                    var prettyAlertNameFunction = this.$filter('prettyAlertName');
                    this.$http.get(this.BASE_URL + "/user/exist-alert-types?ignore_rejected=true")
                        .then(function (data) {
                        _this.alertTypes = [];
                        _.each(data.data.data, function (dataType) {
                            var alertName = prettyAlertNameFunction({ name: dataType.alertTypes[0] });
                            _this.alertTypes.push({
                                'id': dataType.alertTypes.join('@@@'),
                                'value': alertName,
                                'count': dataType.count
                            });
                        });
                    });
                };
                //Init favorites can take place only after alertTypes and indicatorTypes initiated,
                //so I have initiated two promiseses which deffered when alertTypes and indicatorTypes deffered
                UsersFiltersComponentController.prototype._initPreconditionsToBeforeGetFavorites = function () {
                    var _this = this;
                    //Initiate the deffer objects
                    var alertTypesDeffer = this.$q.defer();
                    var indicatorTypesDeffer = this.$q.defer();
                    //Save the promises on this
                    this.alertTypesPromise = alertTypesDeffer.promise;
                    this.indicatorTypesPromise = indicatorTypesDeffer.promise;
                    //Init one time watched to resolve the promise
                    var unwatchAlertsTypes = this.scope.$watch(this._alertTypesWatchFn.bind(this), function () {
                        if (_this.alertTypes && _this.alertTypes.length > 0) {
                            alertTypesDeffer.resolve({ attributeName: "alertTypes", listOfOptions: _this.alertTypes });
                            unwatchAlertsTypes();
                        }
                    });
                    var unwatchIndicatorsTypes = this.scope.$watch(this._indicatorsTypesWatchFn.bind(this), function () {
                        if (_this.indicatorsTypes && _this.indicatorsTypes.length > 0) {
                            indicatorTypesDeffer.resolve({ attributeName: "indicatorTypes", listOfOptions: _this.indicatorsTypes });
                            unwatchIndicatorsTypes();
                        }
                    });
                };
                UsersFiltersComponentController.prototype._watchTagChanges = function () {
                    var _this = this;
                    var ctrl = this;
                    var unwatchIndicatorsTypes = this.scope.$watch(function () { return ctrl.tags; }, function () {
                        if (ctrl.tags && ctrl.tags.length > 0) {
                            ctrl._tags = _.map(ctrl.tags, function (tag) {
                                return {
                                    id: tag.name,
                                    value: tag.displayName
                                };
                            });
                            //this._tags=_.clone(this.tags);
                            _this._tags.splice(0, 0, {
                                id: "any",
                                value: "Tagged Users"
                            });
                            _this._tags.splice(0, 0, {
                                id: "none",
                                value: "No Tags"
                            });
                        }
                    });
                };
                UsersFiltersComponentController.prototype.$onInit = function () {
                    this._initPreconditionsToBeforeGetFavorites();
                    this._initPresetFilters();
                    this._initFavorites();
                    this._watchTagChanges();
                };
                UsersFiltersComponentController.prototype._indicatorsTypesWatchFn = function () {
                    return this.indicatorsTypes;
                };
                UsersFiltersComponentController.prototype._alertTypesWatchFn = function () {
                    return this.alertTypes;
                };
                /**
                 * Send favorite to server. Present error if status is not 200.
                 * @param filterName
                 * @returns {IPromise<Error>} - so if some other method need to do something after save finished
                 * it could be do so
                 *
                 */
                UsersFiltersComponentController.prototype.saveFavorite = function (filterName) {
                    var _this = this;
                    var state = this.stateManagementService.readCurrentState(this.stateId);
                    return this.usersUtils.saveUsersFilter(state, filterName).then(function (res) {
                        _this._initFavorites();
                        _this.saveFavoritesDialogOpened = false;
                        return res;
                    }).catch(function (res) {
                        //Display error res.statusText
                        if (res.status === 409) {
                        }
                        else {
                            //Other error
                            _this.toastrService.error("Failed to save new filter. Please try again later.");
                        }
                        return res;
                    });
                };
                /**
                 * Delete filter by id and show error if such exists
                 * @param filterId
                 */
                UsersFiltersComponentController.prototype.deleteFilter = function (filter) {
                    var _this = this;
                    if (this.activeFilterId === filter.id) {
                        this.activeFilterUpdateDelegate(null);
                    }
                    this.usersUtils.deleteUsersFilter(filter.id).then(function (res) {
                        //Success
                        _this._initFavorites();
                        _this.toastrService.success("Removed " + filter.filterName + " from Favorites.");
                    }).catch(function (res) {
                        _this.toastrService.error("Failed to remove filter from Favorites. Please try again later.");
                        return res;
                    });
                };
                //Hide the favorite popup
                UsersFiltersComponentController.prototype.cancelFavoriteSaving = function () {
                    this.saveFavoritesDialogOpened = false;
                };
                //Set the new favorite filter and activate the filter id
                UsersFiltersComponentController.prototype.applyFilter = function (filter) {
                    this.clearStateDelegate(filter.filter);
                    this.activeFilterUpdateDelegate(filter.id);
                };
                /**
                 * Load favotires list and display them
                 * @private
                 */
                UsersFiltersComponentController.prototype._initFavorites = function () {
                    var _this = this;
                    this.usersUtils.getUsersFilters([this.alertTypesPromise, this.indicatorTypesPromise]).then(function (res) {
                        _this.favoriteFilters = res;
                    });
                };
                UsersFiltersComponentController.$inject = ['$scope', 'stateManagementService', 'usersUtils', '$http', 'BASE_URL', '$filter', 'toastrService', '$q'];
                return UsersFiltersComponentController;
            }());
            var UsersFilterComponent = {
                controller: UsersFiltersComponentController,
                templateUrl: 'app/layouts/users/components/users-filters/users-filters.component.html',
                bindings: {
                    stateId: '<',
                    //Optional. If empty use STATE_ID constant
                    indicatorsTypes: '=',
                    activeFilterUpdateDelegate: '=',
                    fetchStateDelegate: '=',
                    updateStateDelegate: '=',
                    clearStateDelegate: "=",
                    activeFilterId: '=',
                    riskyUsersCount: '<',
                    watchedUsersCount: '<',
                    taggedUsersCount: '<',
                    tags: '<'
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersFilters', UsersFilterComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var UsersPredefineFilterComponentController = (function () {
                function UsersPredefineFilterComponentController(scope, stateManagementService) {
                    this.scope = scope;
                    this.stateManagementService = stateManagementService;
                    this.isCountConfigured = false;
                    this.isActive = false;
                }
                UsersPredefineFilterComponentController.prototype.getStateId = function () {
                    return this.stateId;
                };
                /**
                 * Returns the value of the the state by the id
                 * @returns {*}
                 * @private
                 */
                UsersPredefineFilterComponentController.prototype._stateWatchFn = function () {
                    if (this.fetchStateDelegate) {
                        return this.fetchStateDelegate(this.attributeName);
                    }
                };
                UsersPredefineFilterComponentController.prototype.updateChange = function () {
                    this.isActive = !this.isActive;
                    var stateValue = this.isActive ? this.activeValue : this.inactiveValue;
                    this.updateStateDelegate({
                        id: this.attributeName,
                        type: 'DATA',
                        value: stateValue,
                        immediate: true
                    });
                };
                /**
                 * Watch action function . Sets the value to the picker if state has changed.
                 *
                 * @param {string|number} value
                 */
                UsersPredefineFilterComponentController.prototype._stateWatchActionFn = function (value) {
                    if (value === undefined) {
                        this.isActive = false;
                    }
                    else {
                        this.isActive = value === this.activeValue;
                    }
                };
                /**
                 * Initiates state watch
                 *
                 * @returns {*|function()}
                 * @private
                 */
                UsersPredefineFilterComponentController.prototype._initStateWatch = function () {
                    this.scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
                };
                UsersPredefineFilterComponentController.prototype._initCountWatch = function () {
                    var _this = this;
                    var ctrl = this;
                    //Pay attantion that the watch will happen only once.
                    //If we need to continue listen to after changes on the count field, we should remove the unwach()
                    var unwatch = this.scope.$watch(function () { return ctrl.count; }, function () {
                        if (typeof _this.count != "undefined") {
                            _this.isCountConfigured = typeof (_this.count) !== "undefined";
                            unwatch();
                        }
                    });
                };
                UsersPredefineFilterComponentController.prototype.$onInit = function () {
                    //Init the active value
                    if (typeof this.activeValue === "undefined" || this.activeValue === "") {
                        this.activeValue = "true";
                    }
                    //Init the inactive value
                    if (_.isNil(this.inactiveValue)) {
                        this.inactiveValue = null;
                    }
                    var value = this.fetchStateDelegate(this.attributeName);
                    this.isActive = value === this.activeValue;
                    this._initStateWatch();
                    this._initCountWatch();
                };
                UsersPredefineFilterComponentController.$inject = ['$scope', 'stateManagementService'];
                return UsersPredefineFilterComponentController;
            }());
            var UsersPredefinedFilterComponent = {
                controller: UsersPredefineFilterComponentController,
                templateUrl: 'app/layouts/users/components/users-predefined-filter/users-predefined-filter.component.html',
                bindings: {
                    stateId: '<',
                    //Optional. If empty use STATE_ID constant
                    fetchStateDelegate: '=',
                    updateStateDelegate: '=',
                    attributeName: '@',
                    svgIcon: '@',
                    text: '@',
                    activeValue: '<?',
                    inactiveValue: '@?',
                    count: '<?'
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersPredefinedFilter', UsersPredefinedFilterComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var UsersFilterInUserComponentController = (function () {
                function UsersFilterInUserComponentController(scope, stateManagementService) {
                    this.scope = scope;
                    this.stateManagementService = stateManagementService;
                    this.isActive = false;
                }
                UsersFilterInUserComponentController.prototype.getStateId = function () {
                    return this.stateId;
                };
                /**
                 * Returns the value of the the state by the id
                 * @returns {*}
                 * @private
                 */
                UsersFilterInUserComponentController.prototype._stateWatchFn = function () {
                    if (this.fetchStateDelegate) {
                        return this.fetchStateDelegate(this.attributeName);
                    }
                };
                /**
                 * Change the state value to value which represent the inactive,
                 * this will be set when the X is clicked
                 */
                UsersFilterInUserComponentController.prototype.clearFilter = function () {
                    this.isActive = false;
                    this.updateStateDelegate({
                        id: this.attributeName,
                        type: 'DATA',
                        value: this.inactiveValue,
                        immediate: true
                    });
                };
                /**
                 * Watch action function . Sets the value to the picker if state has changed.
                 *
                 * @param {string|number} value
                 */
                UsersFilterInUserComponentController.prototype._stateWatchActionFn = function (value) {
                    if (value === undefined) {
                        this.isActive = false;
                    }
                    else {
                        this.isActive = value !== this.inactiveValue;
                    }
                };
                /**
                 * Initiates state watch
                 *
                 * @returns {*|function()}
                 * @private
                 */
                UsersFilterInUserComponentController.prototype._initStateWatch = function () {
                    this.scope.$watch(this._stateWatchFn.bind(this), this._stateWatchActionFn.bind(this));
                };
                UsersFilterInUserComponentController.prototype.$onInit = function () {
                    //Init the inactive value
                    if (_.isNil(this.inactiveValue)) {
                        this.inactiveValue = null;
                    }
                    var value = this.fetchStateDelegate(this.attributeName);
                    this.isActive = typeof value !== "undefined" && value !== this.inactiveValue;
                    this._initStateWatch();
                };
                UsersFilterInUserComponentController.$inject = ['$scope', 'stateManagementService'];
                return UsersFilterInUserComponentController;
            }());
            var UsersInUserFilterComponent = {
                controller: UsersFilterInUserComponentController,
                templateUrl: 'app/layouts/users/components/users-filter-in-use/users-filter-in-use.component.html',
                bindings: {
                    stateId: '<',
                    //Optional. If empty use STATE_ID constant
                    fetchStateDelegate: '=',
                    updateStateDelegate: '=',
                    attributeName: '@',
                    inactiveValue: '<?',
                    text: '@'
                }
            };
            angular.module('Fortscale.layouts.users')
                .component('usersFilterInUse', UsersInUserFilterComponent);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var Users;
    (function (Users) {
        var layouts;
        (function (layouts) {
            var usersFavortiePopup;
            (function (usersFavortiePopup) {
                var FILTER_NAME_FIELD_SELECTOR = "#filterName";
                var UsersAddFavoritesPopupController = (function () {
                    function UsersAddFavoritesPopupController($scope, $element, $timeout) {
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$timeout = $timeout;
                        //Name exists - boolean for error message.
                        this.nameExists = false;
                    }
                    /**
                     * Try to save filter. Listen to respone from delegate.
                     * If name exists- display the error, else - clear the error
                     */
                    UsersAddFavoritesPopupController.prototype.saveFilter = function () {
                        var ctrl = this;
                        this.onSave({ filterName: this.models.filterName }).then(function (res) {
                            if (res.status === 409) {
                                ctrl.nameExists = true;
                            }
                            else {
                                ctrl.nameExists = false;
                            }
                        });
                    };
                    /**
                     * On cancel always clear the nameExists error flag
                     */
                    UsersAddFavoritesPopupController.prototype.cancelFilterSaving = function () {
                        this.nameExists = false;
                        this.onCancel();
                    };
                    UsersAddFavoritesPopupController.prototype.$onInit = function () {
                        var _this = this;
                        this.$timeout(function () {
                            _this.$element.addClass('enter-active');
                        }, 50);
                        this.$scope.$watch(function () { return _this.visible; }, function (visible) {
                            //When chenged to visible, the focus should take place
                            if (_this.visible) {
                                _this._focusDefaultField();
                            }
                        });
                    };
                    UsersAddFavoritesPopupController.prototype._focusDefaultField = function () {
                        var ctrl = this;
                        this.$timeout(function () {
                            var inputField = ctrl.$element.find(FILTER_NAME_FIELD_SELECTOR);
                            ctrl.$timeout(function () {
                                // inputField.focus();
                                inputField[0].focus();
                                inputField.select();
                            });
                        }, 400);
                    };
                    UsersAddFavoritesPopupController.prototype.submitWithKeypress = function (e) {
                        if (e.keyCode === 13) {
                            this.saveFilter();
                        }
                    };
                    UsersAddFavoritesPopupController.$inject = ['$scope', '$element', '$timeout'];
                    return UsersAddFavoritesPopupController;
                }());
                var usersAddFavoritesPopup = {
                    controller: UsersAddFavoritesPopupController,
                    templateUrl: 'app/layouts/users/components/users-save-favorites-filter/users-save-favorites-filter.component.html',
                    bindings: {
                        onSave: '&',
                        onCancel: '&',
                        visible: '<'
                    }
                };
                angular.module('Fortscale.layouts.users')
                    .component('usersAddFavoritesPopup', usersAddFavoritesPopup);
            })(usersFavortiePopup = layouts.usersFavortiePopup || (layouts.usersFavortiePopup = {}));
        })(layouts = Users.layouts || (Users.layouts = {}));
    })(Users = Fortscale.Users || (Fortscale.Users = {}));
})(Fortscale || (Fortscale = {}));

/**
 * Created by shays on 01/08/2016.
 * Main controller for users page
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var users;
        (function (users) {
            var STATE_ID = "users-page";
            var UsersController = (function () {
                function UsersController(stateManagementService, fsIndicatorTypes, usersUtils, $http, BASE_URL, page) {
                    this.stateManagementService = stateManagementService;
                    this.fsIndicatorTypes = fsIndicatorTypes;
                    this.usersUtils = usersUtils;
                    this.$http = $http;
                    this.BASE_URL = BASE_URL;
                    this.page = page;
                    this.indicatorTypes = [];
                    this.tags = [];
                    /**
                     * This state contains all the attributes required to filter and sort the grid
                     * @type {{sortByField: string}}
                     */
                    this.initialState = {
                        sortByField: "score",
                        sortDirection: "DESC",
                        minScore: 0
                    };
                    this.currentState = {};
                    this._init();
                }
                UsersController.prototype.getStateId = function () {
                    return STATE_ID;
                };
                /******************************************************************************************************
                 *                      Methods which releate to state change / update / clert etc...
                 ******************************************************************************************************/
                /**
                 * Reset the current state.
                 * If filter given - the old state will be replace by the given state.
                 * If no filter given - the old state will be replace by the initial state
                 * @param filter
                 * @private
                 */
                UsersController.prototype._clearState = function (filter) {
                    var ctrl = this;
                    var fieldsToKeep = this._getSortingFields();
                    if (filter) {
                        var newState = _.clone(filter);
                        _.merge(newState, fieldsToKeep);
                        this.stateManagementService.updateState(this.getStateId(), newState);
                    }
                    else {
                        this.stateManagementService.clearState(this.getStateId(), fieldsToKeep);
                        this.activeFilterId = "";
                    }
                    //Apply the new filter
                    this.currentState = this.stateManagementService.readCurrentState(this.getStateId());
                };
                UsersController.prototype._getSortingFields = function () {
                    return this._getBackupFiedls(["sortByField", "sortDirection"]); //Keep old sorting
                };
                UsersController.prototype._getBackupFiedls = function (fieldNames) {
                    var _this = this;
                    var objectWithFields = {};
                    _.each(fieldNames, function (fieldName) {
                        objectWithFields[fieldName] = _this.currentState[fieldName];
                    });
                    return objectWithFields;
                };
                /**
                 * Get state change param
                 * @param change (id - attribute name, value- the new value)
                 * @private
                 */
                UsersController.prototype._updateStateChanges = function (change) {
                    var attributeName = change.id;
                    var value = change.value;
                    if (value === null || typeof value !== "object") {
                        var propertyAndValue = {};
                        propertyAndValue[attributeName] = value;
                        _.merge(this.currentState, propertyAndValue);
                    }
                    else {
                        throw new Error("UsersGridComponentController.updateStateChange can get only flat values");
                    }
                    this.stateManagementService.updateState(this.getStateId(), this.currentState);
                    this.activeFilterId = "";
                };
                UsersController.prototype._fetchStateDelegate = function (attributeName) {
                    var state = this.stateManagementService.readCurrentState(this.getStateId());
                    return state[attributeName];
                };
                /******************************************************************************************************
                 *                      Methods which bind delegators to this
                 ******************************************************************************************************/
                /*
                 the update state function called from controls, so it must contain the state
                 of this component controller.
                 That's why updateStateChanges must call _updateStateChanges with the current this.
        
                 */
                UsersController.prototype._initAndbindUpdateStateFunction = function () {
                    var ctrl = this;
                    //updateStateChanges get stateChange and call the internal method bound to this
                    this.updateStateChanges = function (stateChange) {
                        ctrl._updateStateChanges(stateChange);
                    };
                };
                /*
                 the fetch state function called from controls, so it must contain the state
                 of this component controller.
                 That's why updateStateChanges must call _fetchStateDelegate with the current this.
        
                 */
                UsersController.prototype._initAndbindFetchStateFunction = function () {
                    var ctrl = this;
                    //fetchStateDelegate get stateChange and call the internal method bound to this
                    this.fetchStateDelegate = function (attributeName) {
                        return ctrl._fetchStateDelegate(attributeName);
                    };
                };
                UsersController.prototype._initAndbindClearStateFunction = function () {
                    var ctrl = this;
                    //fetchStateDelegate get stateChange and call the internal method bound to this
                    this.clearStateDelegate = function (filter) {
                        return ctrl._clearState(filter);
                    };
                };
                UsersController.prototype._initAndbindActiveFilterUpdateFunction = function () {
                    var ctrl = this;
                    //fetchStateDelegate get stateChange and call the internal method bound to this
                    this.activeFilterUpdateDelegate = function (filterId) {
                        this.activeFilterId = filterId;
                    };
                };
                UsersController.prototype._initAndBindReloadPredefinedFiltersUsersCountFunction = function () {
                    var ctrl = this;
                    this.reloadPredefinedFiltersUsersCount = function (riskyUsers, watchedUsers, taggedUser, tagsList) {
                        return ctrl._initPredefinedFiltersUsersCount(riskyUsers, watchedUsers, taggedUser, tagsList);
                    };
                };
                /******************************************************************************************************
                 *                      Methods which loads/init data from the server
                 ******************************************************************************************************/
                //Load list of indicators
                UsersController.prototype._initIndicatorsList = function () {
                    var _this = this;
                    var indicatorsList = this.fsIndicatorTypes.getIndicatorsList()
                        .then(function (data) {
                        _this.indicatorTypes = data;
                    });
                };
                //Load list of tags
                UsersController.prototype._initTagsPreset = function () {
                    var ctrl = this;
                    return this.$http
                        .get(this.BASE_URL + '/tags/user_tags')
                        .then(function (res) {
                        ctrl.tags = _.filter(res.data.data, { active: true });
                        //let activeTags:ITagDefinition[] = <ITagDefinition[]>_.filter(res.data.data,{active:true});
                        //ctrl.tags = _.map(activeTags, function (tag:ITagDefinition) {
                        //    return {
                        //        id: tag.name,
                        //        value: tag.displayName
                        //    };
                        //});
                    });
                };
                /**
                 * Init or reload predefined filters count, and reload filter values for multi select according to configuration
                 * @param riskyUsers - if true, reload the count of risky users
                 * @param watchedUsers - if true, reload the count of watched users
                 * @param taggedUser - if true, reload the count of tagged users
                 * @param tagsList - if true, reload the list of tags for the tags multi select
                 * @private
                 */
                UsersController.prototype._initPredefinedFiltersUsersCount = function (riskyUsers, watchedUsers, taggedUser, tagsList) {
                    var _this = this;
                    //Init risky users
                    if (riskyUsers) {
                        this.usersUtils.countUsers(false, false, 0).then(function (count) {
                            _this.riskyUsersCount = count;
                        });
                    }
                    if (watchedUsers) {
                        //Init watched users
                        this.usersUtils.countUsers(true, false, null).then(function (count) {
                            _this.watchedUsersCount = count;
                        });
                    }
                    //Init tagged users
                    if (taggedUser) {
                        this.usersUtils.countUsers(false, true, null).then(function (count) {
                            _this.taggedUsersCount = count;
                        });
                    }
                    if (tagsList) {
                        this._initTagsPreset();
                    }
                };
                UsersController.prototype._init = function () {
                    this.page.setPageTitle("Users");
                    //Init and bind methods
                    this._initAndbindUpdateStateFunction();
                    this._initAndbindFetchStateFunction();
                    this._initAndbindClearStateFunction();
                    this._initAndbindActiveFilterUpdateFunction();
                    this._initAndBindReloadPredefinedFiltersUsersCountFunction();
                    this._initPredefinedFiltersUsersCount(true, true, true, true);
                    this._initIndicatorsList();
                    this.currentState = this.stateManagementService.initState(this.getStateId(), this.initialState);
                };
                UsersController.$inject = ['stateManagementService', 'fsIndicatorTypes', 'usersUtils', '$http', 'BASE_URL', 'page'];
                return UsersController;
            }());
            angular.module('Fortscale.layouts.users')
                .controller('UsersController', UsersController);
        })(users = layouts.users || (layouts.users = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            'use strict';
            angular.module('Fortscale.layouts.overview', []);
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            'use strict';
            angular.module('Fortscale.layouts.overview')
                .config([
                '$stateProvider',
                function ($stateProvider, overviewPageResolve) {
                    $stateProvider
                        .state('overview', {
                        url: '/overview',
                        templateUrl: 'app/layouts/overview/overview.view.html',
                        controller: 'OverviewController',
                        controllerAs: 'overviewCtrl'
                    });
                }
            ]);
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * This service is a util service for high risk users asset
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var services;
            (function (services) {
                var highRiskUsersUtils;
                (function (highRiskUsersUtils) {
                    var ERR_MSG = 'Fortscale.layouts.overview: highRiskUsersUtils: ';
                    // const TOP_USERS_AMOUNT = 5;
                    var TOP_USERS_SORT_FIELD_NAME = 'score';
                    var TOP_USERS_SORT_DIRECTION = 'DESC';
                    var HighRiskUsersUtils = (function () {
                        function HighRiskUsersUtils(BASE_URL, $http, $log, appConfig) {
                            this.BASE_URL = BASE_URL;
                            this.$http = $http;
                            this.$log = $log;
                            this.appConfig = appConfig;
                        }
                        /**
                         * Gets the top scored users.
                         *
                         * @returns {IPromise<TResult>}
                         */
                        HighRiskUsersUtils.prototype.getUsers = function () {
                            var _this = this;
                            return this.$http.get(this.BASE_URL + "/user", {
                                params: {
                                    size: this.appConfig.getConfigValue('ui.overview', 'numberOfRiskUsers'),
                                    sort_field: TOP_USERS_SORT_FIELD_NAME,
                                    sort_direction: TOP_USERS_SORT_DIRECTION,
                                    min_score: 0
                                }
                            })
                                .then(function (res) {
                                // Validate data
                                if (!res.data.data) {
                                    throw new ReferenceError(ERR_MSG + "getUsers: The was no \"data\" property in the response body.");
                                }
                                return res.data.data;
                            })
                                .catch(function (err) {
                                _this.$log.error(ERR_MSG + "getUsers: Couldn't get users data", err);
                                return null;
                            });
                        };
                        ;
                        HighRiskUsersUtils.$inject = ['BASE_URL', '$http', '$log', 'appConfig'];
                        return HighRiskUsersUtils;
                    }());
                    angular.module('Fortscale.layouts.overview')
                        .service('highRiskUsersUtils', HighRiskUsersUtils);
                })(highRiskUsersUtils = services.highRiskUsersUtils || (services.highRiskUsersUtils = {}));
            })(services = overview.services || (overview.services = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * This service is a util service for top alerts
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var services;
            (function (services) {
                var topAlertsUtil;
                (function (topAlertsUtil) {
                    var ERR_MSG = 'Fortscale.layouts.overview: topAlertsUtil: ';
                    var PAGE_NUMBER = 1;
                    var SIZE = 10;
                    var SORT_DIRECTION = 'DESC';
                    var SORT_FIELD = 'score';
                    var STATUS = 'open';
                    var TopAlertsUtilService = (function () {
                        function TopAlertsUtilService(BASE_URL, $http, appConfig, dateRanges, $log) {
                            this.BASE_URL = BASE_URL;
                            this.$http = $http;
                            this.appConfig = appConfig;
                            this.dateRanges = dateRanges;
                            this.$log = $log;
                        }
                        /**
                         * Returns a csv representing epoch date range
                         * @returns {string}
                         * @private
                         */
                        TopAlertsUtilService.prototype._getAlertsStartRange = function () {
                            var daysRange = this.appConfig.getConfigValue('overview', 'daysRange');
                            return this.dateRanges.getByDaysRange(daysRange);
                        };
                        /**
                         * Returns the params for the GET alerts call.
                         * @returns {{alert_start_range: string, page: number, size: number, sort_direction: string, sort_field: string, status: string}}
                         * @private
                         */
                        TopAlertsUtilService.prototype._getParams = function () {
                            return {
                                alert_start_range: this._getAlertsStartRange(),
                                page: PAGE_NUMBER,
                                size: SIZE,
                                sort_direction: SORT_DIRECTION,
                                sort_field: SORT_FIELD,
                                status: STATUS
                            };
                        };
                        /**
                         * Returns a promise that resolves on the alerts
                         *
                         * @returns {IPromise<TResult>}
                         */
                        TopAlertsUtilService.prototype.getAlerts = function () {
                            var _this = this;
                            return this.$http.get(this.BASE_URL + "/alerts", { params: this._getParams() })
                                .then(function (res) {
                                // Validate data
                                if (!res.data.data) {
                                    throw new ReferenceError(ERR_MSG + "getAlerts: The was no \"data\" property in the response body.");
                                }
                                return res.data.data;
                            })
                                .catch(function (err) {
                                _this.$log.error(ERR_MSG + "getAlerts: Couldn't get alerts data", err);
                                return null;
                            });
                        };
                        ;
                        TopAlertsUtilService.$inject = ['BASE_URL', '$http', 'appConfig', 'dateRanges', '$log'];
                        return TopAlertsUtilService;
                    }());
                    angular.module('Fortscale.layouts.overview')
                        .service('topAlertsUtils', TopAlertsUtilService);
                })(topAlertsUtil = services.topAlertsUtil || (services.topAlertsUtil = {}));
            })(services = overview.services || (overview.services = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

/**
 * This service is a util service for top alerts
 */
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var services;
            (function (services) {
                var alertStatsUtils;
                (function (alertStatsUtils) {
                    var ALERTS_STATUS_URL = 'alerts/statistics';
                    var ALERTS_SEVERITIES_BY_DAY = 'alerts/alert-by-day-and-severity';
                    var START_RANGE_PARAM_NAME = 'start_range';
                    var ALERTS_SEVERITIES_START_RANGE_PARAM_NAME = 'alert_start_range';
                    var ERR_MSG = 'alertStatsUtils.service: ';
                    var AlertStatsUtils = (function () {
                        function AlertStatsUtils(appConfig, BASE_URL, $http, $log, dateRanges) {
                            this.appConfig = appConfig;
                            this.BASE_URL = BASE_URL;
                            this.$http = $http;
                            this.$log = $log;
                            this.dateRanges = dateRanges;
                        }
                        Object.defineProperty(AlertStatsUtils.prototype, "_errMsg", {
                            get: function () {
                                return ERR_MSG + "Controller: ";
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(AlertStatsUtils.prototype, "shortDaysRange", {
                            /**
                             * Returns the config value for shortDaysRange.
                             *
                             * @returns {number}
                             * @private
                             */
                            get: function () {
                                return this.appConfig.getConfigValue('ui.overview', 'shortDaysRange');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(AlertStatsUtils.prototype, "longDaysRange", {
                            /**
                             * Returns the config value for longDaysRange.
                             *
                             * @returns {number}
                             * @private
                             */
                            get: function () {
                                return this.appConfig.getConfigValue('ui.overview', 'longDaysRange');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(AlertStatsUtils.prototype, "shortDateRange", {
                            /**
                             * Returns a CSV string representing a short date range.
                             * @returns {string}
                             * @private
                             */
                            get: function () {
                                return this.dateRanges.getByDaysRange(this.shortDaysRange, 'short');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(AlertStatsUtils.prototype, "longDateRange", {
                            /**
                             * Returns a CSV string representing a long date range.
                             * @returns {string}
                             * @private
                             */
                            get: function () {
                                return this.dateRanges.getByDaysRange(this.longDaysRange, 'short');
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Returns a promise that resolves on alerts stats.
                         *
                         * @param {string} range
                         * @param {string} errMsg
                         * @returns {IPromise<{alert_status: {}, alert_open_severity: {}}>}
                         * @private
                         */
                        AlertStatsUtils.prototype._getAlertStatus = function (range, errMsg) {
                            var _this = this;
                            // Make the http call and return the stats
                            return this.$http.get(this.BASE_URL + "/" + ALERTS_STATUS_URL, {
                                params: (_a = {},
                                    _a[START_RANGE_PARAM_NAME] = range,
                                    _a
                                )
                            })
                                .then(function (res) {
                                if (!res.data || !res.data.data) {
                                    throw new ReferenceError(errMsg + "Server responded without data.");
                                }
                                return res.data.data;
                            })
                                .catch(function (err) {
                                _this.$log.error(err);
                                return {
                                    alert_status: {},
                                    alert_open_severity: {}
                                };
                            });
                            var _a;
                        };
                        /**
                         * Returns a promise that resolves on IAlertStatus for short range received from the server
                         *
                         * @returns {IPromise<IAlertStatus>}
                         */
                        AlertStatsUtils.prototype.getShortAlertsStatus = function () {
                            return this._getAlertStatus(this.shortDateRange, this._errMsg + "getShortAlertsStatus: ");
                        };
                        /**
                         * Returns a promise that resolves on IAlertStatus for long range received from the server
                         *
                         * @returns {IPromise<IAlertStatus>}
                         */
                        AlertStatsUtils.prototype.getLongAlertsStatus = function () {
                            return this._getAlertStatus(this.longDateRange, this._errMsg + "getLongAlertsStatus: ");
                        };
                        /**
                         * Returns a promise that resolves on a list of IAlertSeverityByDay
                         *
                         * @returns {IPromise<IAlertSeverityByDay[]>}
                         */
                        AlertStatsUtils.prototype.getAlertsSeverityByDay = function () {
                            var _this = this;
                            // Make the http call and return the stats
                            return this.$http.get(this.BASE_URL + "/" + ALERTS_SEVERITIES_BY_DAY, {
                                params: (_a = {},
                                    _a[ALERTS_SEVERITIES_START_RANGE_PARAM_NAME] = this.longDateRange,
                                    _a
                                )
                            })
                                .then(function (res) {
                                if (!res.data || !_.isArray(res.data)) {
                                    throw new ReferenceError(_this._errMsg + "getAlertsSeverityByDay: Server responded without data.");
                                }
                                return res.data;
                            })
                                .catch(function (err) {
                                _this.$log.error(err);
                                return [];
                            });
                            var _a;
                        };
                        AlertStatsUtils.$inject = ['appConfig', 'BASE_URL', '$http', '$log', 'dateRanges'];
                        return AlertStatsUtils;
                    }());
                    angular.module('Fortscale.layouts.overview')
                        .service('alertStatsUtils', AlertStatsUtils);
                })(alertStatsUtils = services.alertStatsUtils || (services.alertStatsUtils = {}));
            })(services = overview.services || (overview.services = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var highRiskUsers;
                (function (highRiskUsers) {
                    var HighRiskUsersController = (function () {
                        function HighRiskUsersController() {
                        }
                        HighRiskUsersController.prototype.$onInit = function () {
                        };
                        return HighRiskUsersController;
                    }());
                    var highRiskUsersComponent = {
                        controller: HighRiskUsersController,
                        bindings: {
                            users: '<',
                            tags: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/high-risk-users/high-risk-users.component.html'
                    };
                    angular.module('Fortscale.layouts.overview')
                        .component('overviewHighRiskUsers', highRiskUsersComponent);
                })(highRiskUsers = components.highRiskUsers || (components.highRiskUsers = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var alertsSeverityByDay;
                (function (alertsSeverityByDay) {
                    function alertSeverityByDayDirectiveFn() {
                        var CHART_CONTAINER_SELECTOR = '.alert-severity-by-day-chart-container';
                        var STATUS_FILTER_KEY = 'ad.status_filter';
                        var SEVERITY_FILTER_KEY = 'ad.severity_filter';
                        var DATE_RANGE_FILTER_KEY = 'ad.date_range_filter';
                        var AlertSeverityByDayController = (function () {
                            function AlertSeverityByDayController($location, appConfig, $scope, alertStatsUtils, $filter) {
                                this.$location = $location;
                                this.appConfig = appConfig;
                                this.$scope = $scope;
                                this.alertStatsUtils = alertStatsUtils;
                                this.$filter = $filter;
                            }
                            /**
                             * Receives an epch start of day and returns a range of that day to one day forward.
                             *
                             * @param {number} day
                             * @returns {string}
                             * @private
                             */
                            AlertSeverityByDayController.prototype._getDateRangeByDay = function (day) {
                                var startRange = Math.floor(day / 1000);
                                var endRange = moment(day).utc().endOf('day').unix();
                                return startRange + "," + endRange;
                            };
                            /**
                             * Takes recieved response from the server, and converts it to an am-chart graph base list of objects.
                             *
                             * @returns {{day: number, dateRange: string, category: (any|string|Format|(function(number): string)|void),
                             * Critical: any, High: any, Medium: any, Low: any}[]|boolean[]}
                             * @private
                             */
                            AlertSeverityByDayController.prototype._digestAlertsSeverity = function () {
                                var _this = this;
                                return _.map(this.alertsSeverity, function (alertSeverity) {
                                    var severityGroups = _.keyBy(alertSeverity.severities, 'severity');
                                    return {
                                        day: alertSeverity.day,
                                        dateRange: _this._getDateRangeByDay(alertSeverity.day),
                                        category: moment(alertSeverity.day).format('DD-MM-YYYY'),
                                        Critical: severityGroups["Critical"] ? severityGroups["Critical"].count : 0,
                                        High: severityGroups["High"] ? severityGroups["High"].count : 0,
                                        Medium: severityGroups["Medium"] ? severityGroups["Medium"].count : 0,
                                        Low: severityGroups["Low"] ? severityGroups["Low"].count : 0
                                    };
                                });
                            };
                            /**
                             * alertSeverity change handler. When alertsSeverity has an object, a graph will be rendered.
                             * @param deregister
                             * @private
                             */
                            AlertSeverityByDayController.prototype._alertSeverityByDayChangeHandler = function (deregister) {
                                var _this = this;
                                if (!this.alertsSeverity) {
                                    return;
                                }
                                var dataProvider = this._digestAlertsSeverity();
                                var chart = AmCharts.makeChart(this.containerElement[0], {
                                    "type": "serial",
                                    "categoryField": "category",
                                    "columnWidth": 0.48,
                                    "dataDateFormat": "DD-MM-YYYY",
                                    "autoMargins": false,
                                    "marginBottom": 30,
                                    "marginLeft": 20,
                                    "marginRight": 30,
                                    "marginTop": 40,
                                    "colors": [
                                        "#fb2b19",
                                        "#fea700",
                                        "#2592a5",
                                        "#61aa02"
                                    ],
                                    "startDuration": 1,
                                    "fontFamily": "'Open Sans', sans-serif",
                                    "categoryAxis": {
                                        "dateFormats": [
                                            {
                                                "period": "fff",
                                                "format": "JJ:NN:SS"
                                            },
                                            {
                                                "period": "ss",
                                                "format": "JJ:NN:SS"
                                            },
                                            {
                                                "period": "mm",
                                                "format": "JJ:NN"
                                            },
                                            {
                                                "period": "hh",
                                                "format": "JJ:NN"
                                            },
                                            {
                                                "period": "DD",
                                                "format": "MMM DD"
                                            },
                                            {
                                                "period": "WW",
                                                "format": "MMM DD"
                                            },
                                            {
                                                "period": "MM",
                                                "format": "MMM"
                                            },
                                            {
                                                "period": "YYYY",
                                                "format": "YYYY"
                                            }
                                        ],
                                        "gridPosition": "start",
                                        "parseDates": true,
                                        "gridColor": "#ffffff"
                                    },
                                    "graphs": [
                                        {
                                            "balloonText": "[[value]] [[title]] alerts on  [[category]]",
                                            "fillAlphas": 1,
                                            "id": "CriticalColumn",
                                            "severity": "critical",
                                            "title": "Critical",
                                            "type": "column",
                                            "valueField": "Critical",
                                            "showHandOnHover": true
                                        },
                                        {
                                            "balloonText": "[[value]] [[title]] alerts on  [[category]]",
                                            "fillAlphas": 1,
                                            "id": "HighColumn",
                                            "severity": "high",
                                            "title": "High",
                                            "type": "column",
                                            "valueField": "High",
                                            "showHandOnHover": true
                                        },
                                        {
                                            "balloonText": "[[value]] [[title]] alerts on  [[category]]",
                                            "fillAlphas": 1,
                                            "id": "MediumColumn",
                                            "severity": "medium",
                                            "title": "Medium",
                                            "type": "column",
                                            "valueField": "Medium",
                                            "showHandOnHover": true
                                        },
                                        {
                                            "balloonText": "[[value]] [[title]] alerts on  [[category]]",
                                            "fillAlphas": 1,
                                            "id": "LowColumn",
                                            "severity": "low",
                                            "title": "Low",
                                            "type": "column",
                                            "valueField": "Low",
                                            "showHandOnHover": true
                                        }
                                    ],
                                    "guides": [],
                                    "valueAxes": [
                                        {
                                            "id": "ValueAxis-1",
                                            "stackType": "regular",
                                            "title": "",
                                            "labelsEnabled": false,
                                            "axisAlpha": 0
                                        }
                                    ],
                                    "balloon": {},
                                    "dataProvider": dataProvider
                                });
                                // Add click handler
                                chart.addListener("clickGraphItem", function (chartObj) {
                                    _this.transitionToAlerts(chartObj.item.dataContext.dateRange, chartObj.graph.severity);
                                });
                                // Remove listener (so the chart will only be rendered once)
                                deregister();
                            };
                            /**
                             * Transition to alerts page.
                             *
                             * @param {string} duration
                             * @param {string} severity
                             */
                            AlertSeverityByDayController.prototype.transitionToAlerts = function (duration, severity) {
                                var _this = this;
                                var url = "alerts?" + STATUS_FILTER_KEY + "=_ALL_&" + SEVERITY_FILTER_KEY + "=" + severity + "&" + DATE_RANGE_FILTER_KEY + "=" + duration;
                                this.$scope.$applyAsync(function () {
                                    _this.$location.url(url);
                                });
                            };
                            /**
                             * Init watcher on alertsSeverity
                             * @param {IScope} scope
                             */
                            AlertSeverityByDayController.prototype.initAlertSeverityByDayWatch = function (scope) {
                                var _this = this;
                                var deregister = scope.$watch(function () {
                                    return _this.alertsSeverity;
                                }, function () {
                                    _this._alertSeverityByDayChangeHandler(deregister);
                                });
                            };
                            AlertSeverityByDayController.$inject = ['$location', 'appConfig', '$scope', 'alertStatsUtils', '$filter'];
                            return AlertSeverityByDayController;
                        }());
                        function preLinkFn(scope, instanceElement, instanceAttributes, controller, transclude) {
                            // find container elements
                            controller.containerElement = instanceElement.find(CHART_CONTAINER_SELECTOR);
                            // init watches
                            controller.initAlertSeverityByDayWatch(scope);
                        }
                        var directive = {
                            controller: AlertSeverityByDayController,
                            controllerAs: '$ctrl',
                            bindToController: {
                                alertsSeverity: '<',
                                timeFrame: '@'
                            },
                            scope: true,
                            link: {
                                pre: preLinkFn,
                            },
                            templateUrl: 'app/layouts/overview/components/overview-alerts-severity-by-day/overview-alerts-severity-by-day.component.html'
                        };
                        return directive;
                    }
                    angular.module('Fortscale.layouts.overview')
                        .directive('overviewAlertSeverityByDay', alertSeverityByDayDirectiveFn);
                })(alertsSeverityByDay = components.alertsSeverityByDay || (components.alertsSeverityByDay = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var alertStatus;
                (function (alertStatus_1) {
                    function alertStatusDirectiveFn() {
                        var CHART_SELECTOR_SHORT = '.alert-status-short-chart-container';
                        var CHART_SELECTOR_LONG = '.alert-status-long-chart-container';
                        var AlertStatusController = (function () {
                            function AlertStatusController($location, $scope, appConfig, alertStatsUtils) {
                                this.$location = $location;
                                this.$scope = $scope;
                                this.appConfig = appConfig;
                                this.alertStatsUtils = alertStatsUtils;
                            }
                            AlertStatusController.prototype._alertStatusChangeHandler = function (alertStatus, dateRange, containerElement, deregister) {
                                var _this = this;
                                if (!alertStatus) {
                                    return;
                                }
                                var chart = AmCharts.makeChart(containerElement[0], {
                                    "type": "serial",
                                    "categoryField": "category",
                                    "columnWidth": 0.47,
                                    "colors": [],
                                    "startDuration": 1,
                                    "fontFamily": "Open Sans",
                                    "color": "#01294A",
                                    "categoryAxis": {
                                        "autoRotateAngle": 1.8,
                                        "gridPosition": "start",
                                        "gridColor": "#ffffff"
                                    },
                                    "trendLines": [],
                                    "autoMargins": false,
                                    "marginBottom": 30,
                                    "marginLeft": 0,
                                    marginTop: 5,
                                    marginRight: 0,
                                    "graphs": [
                                        {
                                            "colorField": "color",
                                            "fillAlphas": 1,
                                            "id": "AmGraph-1",
                                            "lineColorField": "color",
                                            "title": "graph 1",
                                            "type": "column",
                                            "valueField": 'count',
                                            "lineThickness": 2,
                                            showHandOnHover: true
                                        }
                                    ],
                                    "guides": [],
                                    "valueAxes": [
                                        {
                                            "id": "ValueAxis-1",
                                            "integersOnly": true,
                                            "minimum": 0,
                                            "title": null,
                                            "labelsEnabled": false,
                                            "axisAlpha": 0
                                        }
                                    ],
                                    "allLabels": [],
                                    "balloon": {},
                                    "titles": [
                                        {
                                            "alpha": 0,
                                            "id": "Title-1",
                                            "size": 15,
                                            "text": "Chart Title"
                                        }
                                    ],
                                    "dataProvider": [
                                        {
                                            "category": "Reviewed",
                                            "count": alertStatus.alert_status.Closed || 0,
                                            "dateRange": dateRange,
                                            "color": "#35a6da",
                                            "feedbackFilterValues": "approved,rejected"
                                        },
                                        {
                                            "category": "Unreviewed",
                                            "count": alertStatus.alert_status.Open || 0,
                                            "dateRange": dateRange,
                                            "color": "#024d89",
                                            "feedbackFilterValues": "none"
                                        }
                                    ]
                                });
                                chart.addListener("clickGraphItem", function (chartObj) {
                                    _this.transitionToAlerts(chartObj.item.dataContext.dateRange, chartObj.item.dataContext.feedbackFilterValues);
                                });
                                deregister();
                            };
                            AlertStatusController.prototype.initAlertStatusShortWatch = function ($scope) {
                                var _this = this;
                                var deregister = $scope.$watch(function () {
                                    return _this.alertStatusShort;
                                }, function (alertStatus) {
                                    _this._alertStatusChangeHandler(alertStatus, _this.alertStatsUtils.shortDateRange, _this.containerElementShort, deregister);
                                });
                            };
                            AlertStatusController.prototype.initAlertStatusLongWatch = function ($scope) {
                                var _this = this;
                                var deregister = $scope.$watch(function () {
                                    return _this.alertStatusLong;
                                }, function (alertStatus) {
                                    _this._alertStatusChangeHandler(alertStatus, _this.alertStatsUtils.longDateRange, _this.containerElementLong, deregister);
                                });
                            };
                            AlertStatusController.prototype.transitionToAlerts = function (duration, feedbackFilterValues) {
                                var _this = this;
                                var feedbackFilterKey = 'ad.feedback_filter';
                                var dateRangeFilterKey = 'ad.date_range_filter';
                                var url = "alerts?" + feedbackFilterKey + "=" + feedbackFilterValues + "&" + dateRangeFilterKey + "=" + duration;
                                this.$scope.$applyAsync(function () {
                                    _this.$location.url(url);
                                });
                            };
                            AlertStatusController.$inject = ['$location', '$scope', 'appConfig', 'alertStatsUtils'];
                            return AlertStatusController;
                        }());
                        function preLinkFn(scope, instanceElement, instanceAttributes, controller, transclude) {
                            // find container elements
                            controller.containerElementShort = instanceElement.find(CHART_SELECTOR_SHORT);
                            controller.containerElementLong = instanceElement.find(CHART_SELECTOR_LONG);
                            // init watches
                            controller.initAlertStatusShortWatch(scope);
                            controller.initAlertStatusLongWatch(scope);
                        }
                        var directive = {
                            controller: AlertStatusController,
                            controllerAs: '$ctrl',
                            bindToController: {
                                alertStatusShort: '<',
                                alertStatusLong: '<'
                            },
                            scope: true,
                            link: {
                                pre: preLinkFn,
                            },
                            templateUrl: 'app/layouts/overview/components/overview-alerts-status/overview-alert-status.component.html'
                        };
                        return directive;
                    }
                    angular.module('Fortscale.layouts.overview')
                        .directive('overviewAlertStatus', alertStatusDirectiveFn);
                })(alertStatus = components.alertStatus || (components.alertStatus = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var highRiskUsers;
                (function (highRiskUsers) {
                    var HighRiskUserController = (function () {
                        function HighRiskUserController(userUtils, $scope) {
                            this.userUtils = userUtils;
                            this.$scope = $scope;
                        }
                        HighRiskUserController.prototype._setUserTags = function () {
                            var _this = this;
                            this.userTags = [];
                            _.each(this.user.tags, function (tag) {
                                var tagObj = _.find(_this.tags, { name: tag });
                                if (tagObj) {
                                    _this.userTags.push(tagObj);
                                }
                            });
                        };
                        HighRiskUserController.prototype._initUserWatch = function () {
                            var _this = this;
                            var deregister = this.$scope.$watch(function () { return _this.user; }, function (user) {
                                if (user) {
                                    _this.userUtils.setFallBackDisplayNames([user]);
                                    deregister();
                                }
                            });
                        };
                        HighRiskUserController.prototype._initTagsWatch = function () {
                            var _this = this;
                            var deregister = this.$scope.$watch(function () { return _this.tags; }, function () {
                                if (_this.user && _this.tags) {
                                    _this._setUserTags();
                                    deregister();
                                }
                            });
                        };
                        HighRiskUserController.prototype._initWatches = function () {
                            this._initUserWatch();
                            this._initTagsWatch();
                        };
                        HighRiskUserController.prototype.$onInit = function () {
                            this._initWatches();
                        };
                        HighRiskUserController.$inject = ['userUtils', '$scope'];
                        return HighRiskUserController;
                    }());
                    var HighRiskUserComponent = {
                        controller: HighRiskUserController,
                        bindings: {
                            user: '<',
                            tags: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/overview-high-risk-user/overview-high-risk-user.component.html'
                    };
                    angular.module('Fortscale.layouts.overview')
                        .component('overviewHighRiskUser', HighRiskUserComponent);
                })(highRiskUsers = components.highRiskUsers || (components.highRiskUsers = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var topAlerts;
                (function (topAlerts) {
                    var TopAlertsController = (function () {
                        function TopAlertsController() {
                        }
                        TopAlertsController.prototype.$onInit = function () {
                        };
                        return TopAlertsController;
                    }());
                    var TopAlertsComponent = {
                        controller: TopAlertsController,
                        bindings: {
                            alerts: '<',
                            users: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/overview-top-alerts/overview-top-alerts.component.html'
                    };
                    angular.module('Fortscale.layouts.overview')
                        .component('overviewTopAlerts', TopAlertsComponent);
                })(topAlerts = components.topAlerts || (components.topAlerts = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var alert;
                (function (alert) {
                    var AlertController = (function () {
                        function AlertController($scope, userIndicatorUtils) {
                            this.$scope = $scope;
                            this.userIndicatorUtils = userIndicatorUtils;
                        }
                        AlertController.prototype.$onInit = function () {
                            this.numberOfNotTagIndicators =
                                this.userIndicatorUtils.filterIndicators(this.overviewAlert.evidences).length;
                        };
                        AlertController.$inject = ['$scope', 'userIndicatorsUtils'];
                        return AlertController;
                    }());
                    var AlertComponent = {
                        controller: AlertController,
                        bindings: {
                            overviewAlert: '<',
                            overviewUser: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/overview-alert/overview-alert.component.html'
                    };
                    angular.module('Fortscale.layouts.overview')
                        .component('overviewAlert', AlertComponent);
                })(alert = components.alert || (components.alert = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var components;
            (function (components) {
                var usersTagsCount;
                (function (usersTagsCount) {
                    var UsersTagsCountController = (function () {
                        function UsersTagsCountController() {
                            this.itemsSettings = {
                                risky: {
                                    displayName: 'Risky',
                                    displayNameSingle: 'Risky',
                                    icon: 'bell-icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'risky',
                                    defaultValue: 0,
                                    href: '#/users?',
                                    query: {
                                        minScore: 0,
                                    }
                                },
                                admins: {
                                    displayName: 'Admin',
                                    displayNameSingle: 'Admin',
                                    icon: 'user-admins-icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'admin',
                                    defaultValue: 0,
                                    href: '#/users?users-page.minScore=&users-page.userTags=admin',
                                    query: {
                                        userTags: "admin"
                                    }
                                },
                                watched: {
                                    displayName: 'Watched',
                                    displayNameSingle: 'Watched',
                                    icon: 'watch-icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'watched',
                                    defaultValue: 0,
                                    href: '#/users?users-page.minScore=&users-page.isWatched=true',
                                    query: {
                                        isWatched: true
                                    }
                                },
                                executives: {
                                    displayName: 'Executive',
                                    displayNameSingle: 'Executive',
                                    icon: 'user-executive-icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'executive',
                                    defaultValue: 0,
                                    href: '#/users?users-page.minScore=&users-page.userTags=executive',
                                    query: {
                                        userTags: "executive"
                                    }
                                },
                                service: {
                                    displayName: 'Service',
                                    displayNameSingle: 'Service',
                                    icon: 'user-service-icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'service',
                                    defaultValue: 0,
                                    href: '#/users?users-page.minScore=&users-page.userTags=service',
                                    query: {
                                        userTags: "service"
                                    }
                                },
                                tagged: {
                                    displayName: 'Tagged',
                                    displayNameSingle: 'Tagged',
                                    icon: 'tag_icon',
                                    iconWidth: 36,
                                    iconHeight: 36,
                                    tagKey: 'Tagged',
                                    defaultValue: 0,
                                    href: '#/users?users-page.minScore=&users-page.userTags=any',
                                    query: {
                                        userTags: "any"
                                    }
                                }
                            };
                        }
                        UsersTagsCountController.prototype.$onInit = function () {
                        };
                        return UsersTagsCountController;
                    }());
                    var UsersTagsCountItemController = (function () {
                        function UsersTagsCountItemController(usersUtils) {
                            this.usersUtils = usersUtils;
                        }
                        UsersTagsCountItemController.prototype.getCount = function () {
                            var _this = this;
                            var query = this.itemSettings.query;
                            this.usersUtils.countUsersByFilter(query).then(function (res) {
                                _this.count = res;
                            });
                        };
                        UsersTagsCountItemController.prototype.$onInit = function () {
                            this.getCount();
                        };
                        UsersTagsCountItemController.$inject = ['usersUtils'];
                        return UsersTagsCountItemController;
                    }());
                    var UsersTagsCountComponent = {
                        controller: UsersTagsCountController,
                        bindings: {
                            usersTagsCount: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/overview-users-tags-count/overview-users-tags-count.component.html'
                    };
                    var UsersTagsCountItemComponent = {
                        controller: UsersTagsCountItemController,
                        bindings: {
                            itemSettings: '<'
                        },
                        templateUrl: 'app/layouts/overview/components/overview-users-tags-count/users-tags-count-item.component.html'
                    };
                    angular.module('Fortscale.layouts.overview')
                        .component('overviewUsersTagsCount', UsersTagsCountComponent)
                        .component('overviewUsersTagsCountItem', UsersTagsCountItemComponent);
                })(usersTagsCount = components.usersTagsCount || (components.usersTagsCount = {}));
            })(components = overview.components || (overview.components = {}));
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var overview;
        (function (overview) {
            var OverviewController = (function () {
                function OverviewController(scope, element, fsNanobarAutomationService, highRiskUsersUtils, topAlertsUtils, userUtils, alertStatsUtils, page, tagsUtils) {
                    this.scope = scope;
                    this.element = element;
                    this.fsNanobarAutomationService = fsNanobarAutomationService;
                    this.highRiskUsersUtils = highRiskUsersUtils;
                    this.topAlertsUtils = topAlertsUtils;
                    this.userUtils = userUtils;
                    this.alertStatsUtils = alertStatsUtils;
                    this.page = page;
                    this.tagsUtils = tagsUtils;
                    this.NANOBAR_ID = 'overview-page';
                    this._init();
                }
                OverviewController.prototype._enrichUsers = function (users) {
                    this.userUtils.setFallBackDisplayNames(users);
                    this.userUtils.setUsersFullAddress(users);
                };
                OverviewController.prototype._initLoadingAlertUsers = function (ids) {
                    var _this = this;
                    if (ids && ids.length) {
                        this.userUtils.getUsersDetails(ids)
                            .then(function (users) {
                            _this.users = _.keyBy(users, 'id');
                            _this._enrichUsers(_this.users);
                        });
                    }
                    else {
                        this.users = {};
                    }
                };
                /**
                 * Initiates high risk users asset loading
                 * @private
                 */
                OverviewController.prototype._initLoadingHighRiskUsers = function () {
                    var _this = this;
                    return this.highRiskUsersUtils.getUsers()
                        .then(function (users) {
                        _this.highRiskUsers = users;
                        _this._enrichUsers(_this.highRiskUsers);
                    })
                        .catch(function (err) {
                        _this.highRiskUsers = null;
                    });
                };
                /**
                 * Initiates top ten alerts asset loading
                 * @private
                 */
                OverviewController.prototype._initLoadingTopAlerts = function () {
                    var _this = this;
                    return this.topAlertsUtils.getAlerts()
                        .then(function (topAlerts) {
                        _this.topAlerts = topAlerts;
                        return _.uniq(_.map(_this.topAlerts, 'entityId'));
                    })
                        .then(function (userIds) {
                        _this._initLoadingAlertUsers(userIds);
                    })
                        .catch(function (err) {
                        _this.highRiskUsers = null;
                    });
                };
                /**
                 * Initiates loading of system tags count
                 * @private
                 */
                OverviewController.prototype._initLoadingUsersTagsStatistics = function () {
                    var _this = this;
                    return this.userUtils.getUsersTagsCount()
                        .then(function (usersTagsCount) {
                        _this.usersTagsCount = usersTagsCount;
                    })
                        .catch(function (err) {
                        _this.usersTagsCount = {};
                    });
                };
                /**
                 * Initiates loading of alert stats short and long
                 *
                 * @private
                 */
                OverviewController.prototype._initLoadingAlertStats = function () {
                    var _this = this;
                    return [
                        this.alertStatsUtils.getShortAlertsStatus()
                            .then(function (alertStatus) {
                            _this.alertStatusShort = alertStatus;
                        })
                            .catch(function (err) {
                            _this.alertStatusShort = {
                                alert_status: {},
                                alert_open_severity: {}
                            };
                        }),
                        this.alertStatsUtils.getLongAlertsStatus()
                            .then(function (alertStatus) {
                            _this.alertStatusLong = alertStatus;
                        })
                            .catch(function (err) {
                            _this.alertStatusLong = {
                                alert_status: {},
                                alert_open_severity: {}
                            };
                        })
                    ];
                };
                /**
                 * Initiates loading of alert severity by day
                 *
                 * @private
                 */
                OverviewController.prototype._initLoadingAlertsSeverityByDay = function () {
                    var _this = this;
                    return this.alertStatsUtils.getAlertsSeverityByDay()
                        .then(function (alertsSeverityByDay) {
                        _this.alertsSeverityByDay = alertsSeverityByDay;
                    })
                        .catch(function (err) {
                        _this.alertsSeverityByDay = [];
                    });
                };
                OverviewController.prototype._initLoadingTags = function () {
                    var _this = this;
                    return this.tagsUtils.getTags()
                        .then(function (res) {
                        _this.tags = res.data;
                    })
                        .catch(function (err) {
                        console.error('There was an error fetching tags.', err);
                        _this.tags = [];
                    });
                };
                /**
                 * Initiates assets loading sequence
                 *
                 * @private
                 */
                OverviewController.prototype._initLoadingSequence = function () {
                    var promises = [
                        this._initLoadingTags(),
                        this._initLoadingHighRiskUsers(),
                        this._initLoadingTopAlerts(),
                        this._initLoadingUsersTagsStatistics()
                    ].concat(this._initLoadingAlertStats(), [
                        this._initLoadingAlertsSeverityByDay()
                    ]);
                    this.fsNanobarAutomationService.addPromises(this.NANOBAR_ID, promises);
                };
                /**
                 * Controller's init function
                 * @private
                 */
                OverviewController.prototype._init = function () {
                    // Start loading assets
                    this._initLoadingSequence();
                    this.page.setPageTitle('Overview');
                };
                OverviewController.$inject = ['$scope', '$element', 'fsNanobarAutomationService', 'highRiskUsersUtils',
                    'topAlertsUtils', 'userUtils', 'alertStatsUtils', 'page', 'tagsUtils'];
                return OverviewController;
            }());
            angular.module('Fortscale.layouts.overview')
                .controller('OverviewController', OverviewController);
        })(overview = layouts.overview || (layouts.overview = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    angular.module('Fortscale.layouts.reports', []);
}());

(function () {
    'use strict';
    angular.module("Fortscale.layouts.reports")
        .config([
        '$stateProvider',
        'reportsResolve',
        'staleAccountsMonitoringResolve',
        'staleAccountsMonitoringData',
        'deviceMonitoringResolve',
        'deviceMonitoringData',
        'suspiciousUsersResolve',
        'suspiciousUsersData',
        'externalAccessToNetworkResolve',
        'externalAccessToNetworkData',
        function ($stateProvider, reportsResolve, staleAccountsMonitoringResolve, staleAccountsMonitoringData, deviceMonitoringResolve, deviceMonitoringData, suspiciousUsersResolve, suspiciousUsersData, externalAccessToNetworkResolve, externalAccessToNetworkData) {
            $stateProvider
                .state('reports', {
                url: '/reports',
                templateUrl: 'app/layouts/reports/reports.view.html',
                controller: 'ReportsController',
                controllerAs: 'reports',
                resolve: reportsResolve
            })
                .state('reports.staleAccountsMonitoring', {
                url: '/stale_accounts_monitoring',
                abstract: true,
                template: '<ui-view></ui-view>',
                resolve: staleAccountsMonitoringResolve.resolve
            })
                .state('reports.staleAccountsMonitoring.disabledUserAccounts', {
                url: '/disabled_users_status',
                templateUrl: 'app/layouts/reports/layouts/stale-accounts-monitoring/' +
                    'disabled-user-accounts.view.html',
                resolve: staleAccountsMonitoringResolve.disabledUserAccountsResolve,
                data: staleAccountsMonitoringData.disabledUserAccountsData,
                controller: 'DisabledUserAccountsController',
                controllerAs: 'report'
            })
                .state('reports.staleAccountsMonitoring.inactiveUserAccounts', {
                url: '/inactive_users_status',
                templateUrl: 'app/layouts/reports/layouts/stale-accounts-monitoring/' +
                    'inactive-user-accounts.view.html',
                resolve: staleAccountsMonitoringResolve.inactiveUserAccountsResolve,
                data: staleAccountsMonitoringData.inactiveUserAccountsData,
                controller: 'InactiveUserAccountsController',
                controllerAs: 'report'
            })
                .state('reports.staleAccountsMonitoring.disabledUserWithNetwork', {
                url: '/disabled_users_with_network',
                templateUrl: 'app/layouts/reports/layouts/stale-accounts-monitoring/' +
                    'disabled-user-with-network.view.html',
                resolve: staleAccountsMonitoringResolve.disabledUserWithNetworkResolve,
                data: staleAccountsMonitoringData.disabledUserWithNetworkData,
                controller: 'DisabledUserWithNetworkController',
                controllerAs: 'report'
            })
                .state('reports.staleAccountsMonitoring.terminatedUserWithNetwork', {
                url: '/terminated_users_with_network',
                templateUrl: 'app/layouts/reports/layouts/stale-accounts-monitoring/' +
                    'terminated-user-with-network.view.html',
                resolve: staleAccountsMonitoringResolve.terminatedUserWithNetworkResolve,
                data: staleAccountsMonitoringData.terminatedUserWithNetworkData,
                controller: 'TerminatedUserWithNetworkController',
                controllerAs: 'report'
            })
                .state('reports.deviceMonitoring', {
                url: '/device_monitoring',
                abstract: true,
                template: '<ui-view></ui-view>',
                resolve: deviceMonitoringResolve.resolve
            })
                .state('reports.deviceMonitoring.IPInvestigation', {
                url: '/ip_investigation',
                templateUrl: 'app/layouts/reports/layouts/device-monitoring/' +
                    'ip-investigation.view.html',
                resolve: deviceMonitoringResolve.ipInvestigationResolve,
                data: deviceMonitoringData.ipInvestigationData,
                controller: 'IPInvestigationController',
                controllerAs: 'report'
            })
                .state('reports.deviceMonitoring.suspiciousEndpointAccess', {
                url: '/suspicious_endpoint_access',
                templateUrl: 'app/layouts/reports/layouts/device-monitoring/' +
                    'suspicious-endpoint-access.view.html',
                resolve: deviceMonitoringResolve.suspiciousEndpointAccessResolve,
                data: deviceMonitoringData.suspiciousEndpointAccessData,
                controller: 'SuspiciousEndpointAccessController',
                controllerAs: 'report'
            })
                .state('reports.deviceMonitoring.sensitiveResourcesMonitoring', {
                url: '/sensitive_resources_monitoring',
                templateUrl: 'app/layouts/reports/layouts/device-monitoring/' +
                    'sensitive-resources-monitoring.view.html',
                resolve: deviceMonitoringResolve.sensitiveResourcesMonitoringResolve,
                data: deviceMonitoringData.sensitiveResourcesMonitoringData,
                controller: 'SensitiveResourcesMonitoringController',
                controllerAs: 'report'
            })
                .state('reports.topRiskyTagged', {
                url: '/top_risky_tagged/:tagName',
                templateUrl: 'app/layouts/reports/layouts/suspicious-users/suspicious-users.view.html',
                resolve: suspiciousUsersResolve,
                data: suspiciousUsersData,
                controller: 'RiskyTaggedUsersController',
                controllerAs: 'report'
            })
                .state('reports.externalAccessToNetwork', {
                url: '/external_access_to_network',
                abstract: true,
                template: '<ui-view></ui-view>',
                resolve: externalAccessToNetworkResolve.resolve
            })
                .state('reports.externalAccessToNetwork.suspiciousVPNDataAmount', {
                url: '/suspicious_vpn_data_amount',
                templateUrl: 'app/layouts/reports/layouts/external-access-to-network/' +
                    'suspicious-vpn-data-amount.view.html',
                resolve: externalAccessToNetworkResolve.suspiciousVPNDataAmount,
                data: externalAccessToNetworkData.suspiciousVPNDataAmount,
                controller: 'suspiciousVPNDataAmountController',
                controllerAs: 'report'
            })
                .state('reports.externalAccessToNetwork.VPNGeoHopping', {
                url: '/vpn_geo_hopping',
                templateUrl: 'app/layouts/reports/layouts/external-access-to-network/' +
                    'vpn-geo-hopping.view.html',
                resolve: externalAccessToNetworkResolve.VPNGeoHopping,
                data: externalAccessToNetworkData.VPNGeoHopping,
                controller: 'VPNGeoHoppingController',
                controllerAs: 'report'
            });
            // END OF External access to network
        }
    ]);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var reportsResolve = {
        navBarSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/reports/settings/nav-bar-settings.json');
            }
        ],
        dataEntitiesList: [
            function () {
                return [
                    {
                        id: 'ssh',
                        name: 'SSH'
                    },
                    {
                        id: 'vpn',
                        name: 'VPN'
                    },
                    {
                        id: 'auth',
                        name: 'Kerberos'
                    }
                ];
            }
        ]
    };
    angular.module('Config')
        .constant('reportsResolve', reportsResolve);
}());

(function () {
    'use strict';
    //var GDS_BASE_ENTITY = 'scored_access_event';
    function ReportsController($element, navBarSettings, dataEntities, dataEntitiesList, page, $uiViewScroll, $timeout, $state) {
        page.setPageTitle('Reports');
        this.$element = $element;
        this.dataEntities = dataEntities;
        this.navBarSettingsMaster = _.merge({}, navBarSettings);
        this.dataEntitiesList = _.merge({}, dataEntitiesList);
        this.$uiViewScroll = $uiViewScroll;
        this.$timeout = $timeout;
        this.$state = $state;
        this.init();
    }
    _.merge(ReportsController.prototype, {
        /**
         * Populates Suspicious Users menu
         *
         * @private
         */
        _populateNavBarsSuspiciousUsers: function (suspiciousUsersNavItem) {
            // get leaf entities
            /** UPDATE: It was decided that this report will not be GDS. It will only have ssh, vpn, and kerberos.
             * For that resource, the following code is commented out, and there's a new code to replace it.
             * This commented code might be some day returned.
             */
            //var entities = this.dataEntities.getExtendingEntities('scored_access_event');
            var tags = [{
                    "name": "Admin",
                    "id": "admin"
                },
                {
                    "name": "Executive",
                    "id": "executive"
                },
                {
                    "name": "Service",
                    "id": "service"
                }];
            suspiciousUsersNavItem.items = _.map(tags, function (tag) {
                var navItem = {};
                navItem.html = tag.name + " Accounts";
                navItem.sref = 'reports.topRiskyTagged({tagName:"' + tag.id + '"})';
                navItem.srefActive = 'reports.suspiciousUsers';
                navItem.srefActiveParams = { tagName: tag.id };
                return navItem;
            });
        },
        /**
         * Initiates nav bar settings. Populates suspicious users section.
         * @private
         */
        _initNavBarSettings: function () {
            this.navBarSettings = _.merge({}, this.navBarSettingsMaster);
            this._populateNavBarsSuspiciousUsers(_.filter(this.navBarSettings, { 'html': 'High Privileged Accounts' })[0]);
        },
        _scrollToElement: function () {
            var _this = this;
            this.$timeout(function () {
                // find active element
                var el = _this.$element.find('li.active');
                // find container element
                var containerEl = _this.$element.find('.nav-bar-container--groups-list-container');
                // if container element height is smalled than active element bottom (top+height) then scroll to it
                if (el[0] && containerEl[0] && (containerEl.height() <= el[0].offsetTop + el[0].offsetHeight)) {
                    _this.$uiViewScroll(el);
                }
            }, 200);
        },
        isReportSelected: function () {
            return this.$state.is('reports');
        },
        init: function () {
            this._initNavBarSettings();
            this._scrollToElement();
        }
    });
    ReportsController.$inject =
        ['$element', 'navBarSettings', 'dataEntities', 'dataEntitiesList', 'page', '$uiViewScroll',
            '$timeout', '$state'];
    angular.module('Fortscale.layouts.reports')
        .controller('ReportsController', ReportsController);
}());

/**
 * This directive adds a validator to the attached ngModel. This validator is an ip validator.
 */
(function () {
    'use strict';
    function fsValidatorIp() {
        function linkFn($scope, $element, attrs, ngModel) {
            ngModel.$validators.ip = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                /*jslint maxlen: 200 */
                return /^(\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))\.(\d|[1-9]\d|1\d\d|2([0-4]\d|5[0-5]))$/.test(value);
            };
        }
        return {
            restrict: 'A',
            link: linkFn,
            require: 'ngModel'
        };
    }
    fsValidatorIp.$inject = [];
    angular.module('Fortscale.layouts.reports')
        .directive('fsValidatorIp', fsValidatorIp);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var staleAccountsMonitoringResolve = {
        resolve: {
            tableInitialSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'table-initial.settings.json');
                }
            ],
            terminatedTableInitialSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'table-terminated-initial.settings.json');
                }
            ],
            tableInitialState: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'table-initial.state.json');
                }
            ]
        },
        disabledUserAccountsResolve: {
            disabledUsersStatusResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'disabled-users-status.resource.json');
                }
            ]
        },
        inactiveUserAccountsResolve: {
            inactiveUsersStatusResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'inactive-users-status.resource.json');
                }
            ]
        },
        disabledUserWithNetworkResolve: {
            disabledUsersWithNetworkResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'disabled-users-with-network.resource.json');
                }
            ]
        },
        terminatedUserWithNetworkResolve: {
            terminatedUsersWithNetworkResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/stale-accounts-monitoring/settings/' +
                        'terminated-users-with-network.resource.json');
                }
            ]
        }
    };
    angular.module('Config')
        .constant('staleAccountsMonitoringResolve', staleAccountsMonitoringResolve);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var staleAccountsMonitoringData = {
        disabledUserAccountsData: {
            reportTitle: 'Disabled Accounts',
            reportDescription: 'Investigate accounts registered as disabled in Active Directory.',
            reportClass: 'regular'
        },
        inactiveUserAccountsData: {
            reportTitle: 'Inactive Accounts',
            reportDescription: 'Investigate inactive accounts that are NOT disabled in Active Directory.',
            reportClass: 'regular'
        },
        disabledUserWithNetworkData: {
            reportTitle: 'Disabled Accounts with Network Activity',
            reportDescription: 'Investigate active accounts registered as disabled in Active Directory.',
            reportClass: 'regular'
        },
        terminatedUserWithNetworkData: {
            reportTitle: 'Terminated Accounts with Network Activity',
            reportDescription: 'Investigate active accounts registered as terminated in Active Directory.',
            reportClass: 'regular'
        }
    };
    angular.module('Config')
        .constant('staleAccountsMonitoringData', staleAccountsMonitoringData);
}());

(function () {
    'use strict';
    function DisabledUserAccountsController(appConfig, $state, dateRanges, tableInitialState, tableInitialSettings, disabledUsersStatusResource, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this.disabledUsersStatusResource = _.merge({}, disabledUsersStatusResource);
        this.disabledUsersTableSettings = _.merge({}, tableInitialSettings);
        this._defaultStartOfDayDaysAgo = appConfig.getConfigValue('ui.' + $state.current.name, 'daysAgo');
        this.mainState = {
            disabled_user_table: tableInitialState,
            disabled_since: {
                value: dateRanges.getStartOfDayByDaysAgo(this._defaultStartOfDayDaysAgo)
            }
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(DisabledUserAccountsController.prototype, {
        init: function () {
        }
    });
    DisabledUserAccountsController.$inject =
        ['appConfig', '$state', 'dateRanges', 'tableInitialState', 'tableInitialSettings',
            'disabledUsersStatusResource', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('DisabledUserAccountsController', DisabledUserAccountsController);
}());

(function () {
    'use strict';
    function InactiveUserAccountsController(appConfig, $state, dateRanges, tableInitialState, tableInitialSettings, inactiveUsersStatusResource, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this.inactiveUsersStatusResource = _.merge({}, inactiveUsersStatusResource);
        this.inactiveUsersTableSettings = _.merge({}, tableInitialSettings);
        this._defaultStartOfDayDaysAgo = appConfig.getConfigValue('ui.' + $state.current.name, 'daysAgo');
        this.mainState = {
            inactive_user_table: tableInitialState,
            inactive_since: {
                value: dateRanges.getStartOfDayByDaysAgo(this._defaultStartOfDayDaysAgo)
            }
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(InactiveUserAccountsController.prototype, {
        /**
         * Removes the unneeded (for this report) 'Disabled On' column
         *
         * @private
         */
        _removeDisabledOnColumn: function () {
            this.inactiveUsersTableSettings.columns = _.filter(this.inactiveUsersTableSettings.columns, function (column) {
                return column.title !== 'Disabled On';
            });
        },
        init: function () {
            this._removeDisabledOnColumn();
        }
    });
    InactiveUserAccountsController.$inject =
        ['appConfig', '$state', 'dateRanges', 'tableInitialState', 'tableInitialSettings',
            'inactiveUsersStatusResource', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('InactiveUserAccountsController', InactiveUserAccountsController);
}());

(function () {
    'use strict';
    function DisabledUserWithNetworkController($state, tableInitialState, tableInitialSettings, disabledUsersWithNetworkResource, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this.disabledUsersWithNetworkResource = _.merge({}, disabledUsersWithNetworkResource);
        this.disabledUsersWithNetworkTableSettings = _.merge({}, tableInitialSettings);
        this.mainState = {
            disabled_user_table: tableInitialState
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(DisabledUserWithNetworkController.prototype, {
        init: function () { }
    });
    DisabledUserWithNetworkController.$inject = ['$state', 'tableInitialState', 'tableInitialSettings',
        'disabledUsersWithNetworkResource', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('DisabledUserWithNetworkController', DisabledUserWithNetworkController);
}());

(function () {
    'use strict';
    function TerminatedUserWithNetworkController($state, tableInitialState, terminatedTableInitialSettings, terminatedUsersWithNetworkResource, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this.terminatedUsersWithNetworkResource = _.merge({}, terminatedUsersWithNetworkResource);
        this.terminatedUsersWithNetworkTableSettings = _.merge({}, terminatedTableInitialSettings);
        this.mainState = {
            terminated_users_table: tableInitialState
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(TerminatedUserWithNetworkController.prototype, {
        init: function () { }
    });
    TerminatedUserWithNetworkController.$inject = ['$state', 'tableInitialState', 'terminatedTableInitialSettings',
        'terminatedUsersWithNetworkResource', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('TerminatedUserWithNetworkController', TerminatedUserWithNetworkController);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var deviceMonitoringResolve = {
        resolve: {},
        ipInvestigationResolve: {
            machinesForIpResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/ip-investigation-machines.resource.json');
                }
            ],
            machinesForIpTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/ip-investigation-machines-table.settings.json');
                }
            ],
            usersForIpResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/ip-investigation-users.resource.json');
                }
            ],
            usersForIpTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/ip-investigation-users-table.settings.json');
                }
            ]
        },
        suspiciousEndpointAccessResolve: {
            mainState: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/suspicious-endpoint-access-main-state.json');
                }
            ],
            endpointControlSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/suspicious-endpoint-access-endpoint-control.settings.json');
                }
            ],
            endpointControlResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/suspicious-endpoint-access-endpoint-control.resource.json');
                }
            ],
            resourceSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .loadJsonx('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/suspicious-endpoint-access.resource.jsonx');
                }
            ],
            tableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings' +
                        '/suspicious-endpoint-access-table.settings.json');
                }
            ]
        },
        sensitiveResourcesMonitoringResolve: {
            sensitiveMachinesStatusTableResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'sensitive-machines-status-table.resource.json');
                }
            ],
            sensitiveMachinesStatusTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'sensitive-machines-status-table.settings.json');
                }
            ],
            usersAccessResourcesTableResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'users-access-resources-table.resource.json');
                }
            ],
            usersAccessResourcesTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'users-access-resources-table.settings.json');
                }
            ],
            eventsSensitiveMachinesTableResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'events-sensitive-machines-table.resource.json');
                }
            ],
            eventsSensitiveMachinesTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/device-monitoring/settings/' +
                        'events-sensitive-machines-table.settings.json');
                }
            ]
        }
    };
    angular.module('Config')
        .constant('deviceMonitoringResolve', deviceMonitoringResolve);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var deviceMonitoringData = {
        ipInvestigationData: {
            reportTitle: 'IP Investigation',
            reportDescription: 'Investigate historic risky user behavior originating from an IP Address.',
            reportClass: 'regular',
            ipAddressControlTooltip: 'Please enter a valid IP address.',
            machinesForIpTitle: 'Devices found at this IP Address.',
            machinesForIpNoItems: 'No Devices were found from this IP Address.',
            usersForIpTitle: 'Users found at this IP Address',
            usersForIpNoItems: 'No users were found at this IP Address.'
        },
        suspiciousEndpointAccessData: {
            reportTitle: 'Suspicious Device Access',
            reportDescription: 'Detect historic risky user access to devices.',
            reportClass: 'regular',
            suspiciousEndpointsNoItems: 'No Events Found'
        },
        sensitiveResourcesMonitoringData: {
            reportTitle: 'Sensitive Resources Monitoring',
            reportDescription: 'Investigate historic risky user access to sensitive resources.',
            sensitiveMachinesStatusTableTitle: 'Sensitive Resources Risk History',
            sensitiveMachinesStatusTableDescription: ' Highest scored events observed from sensitive resources.',
            sensitiveMachinesStatusTableNoItems: 'No Events Found',
            usersAccessResourcesTableTitle: 'User Access to Sensitive Resources',
            usersAccessResourcesTableDescription: 'Investigate users who have accessed sensitive resources.',
            usersAccessResourcesTableNoItems: 'No Events Found',
            eventsSensitiveMachinesTableTitle: 'Access to Sensitive Devices',
            eventsSensitiveMachinesTableDescription: ' Investigate all access events targeting sensitive resources.',
            eventsSensitiveMachinesTableNoItems: 'No Events Found'
        }
    };
    angular.module('Config')
        .constant('deviceMonitoringData', deviceMonitoringData);
}());

(function () {
    'use strict';
    var SUSPICIOUS_EVENT_SCORE_FIELD_NAME = 'suspicious_event_score';
    var EVENT_COUNT_FIELD_NAME = 'event_count';
    var TYPE_FIELD_NAME = 'type';
    var EVENT_TIME_FIELD_NAME = 'event_time';
    var NORMALIZED_USERNAME_FIELD_NAME = 'normalized_username';
    var SOURCE_MACHINE_FIELD_NAME = 'source_machine';
    function IPInvestigationController(appConfig, $state, $scope, dateRanges, machinesForIpResource, machinesForIpTableSettings, usersForIpResource, usersForIpTableSettings, fsNanobarAutomationService) {
        var _this = this;
        var ctrl = this;
        // Put injections on instance
        ctrl.state = _.merge({}, $state.current.data);
        ctrl.$scope = $scope;
        ctrl._defaultDaysRange = appConfig.getConfigValue('ui.' + $state.current.name, 'daysRange');
        ctrl.mainState = _.merge({}, {
            events_time: {
                value: dateRanges.getByDaysRange(ctrl._defaultDaysRange, 'short')
            }
        });
        ctrl.machinesForIpResource = _.merge({}, machinesForIpResource);
        ctrl.machinesForIpTableSettingsMaster = _.merge({}, machinesForIpTableSettings);
        ctrl.usersForIpResource = _.merge({}, usersForIpResource);
        ctrl.usersForIpTableSettingsMaster = _.merge({}, usersForIpTableSettings);
        ctrl.ipInvestigationMachinesResourceAdapter = function (dataList) {
            return ctrl._ipInvestigationResourceAdapter(dataList, 'machines');
        };
        ctrl.ipInvestigationUsersResourceAdapter = function (dataList) {
            return ctrl._ipInvestigationResourceAdapter(dataList, 'users');
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        // Init
        this.init();
    }
    _.merge(IPInvestigationController.prototype, {
        /**
         * Extends table settings with GDS columns
         *
         * @param {Array<{type: string, suspicious_event_score: number}>} dataEntitiesSorted
         * @param {{columns: array}} settingsMaster
         * @returns {{}}
         * @private
         */
        _extendTableSettings: function (dataEntitiesSorted, settingsMaster) {
            var settings = _.merge({}, settingsMaster);
            _.each(dataEntitiesSorted, function (dataEntity, index) {
                settings.columns.push({
                    title: 'Suspicious<br>' + dataEntity[TYPE_FIELD_NAME] + '<br>Events',
                    field: 'dataEntities[' + index + '].' + SUSPICIOUS_EVENT_SCORE_FIELD_NAME
                });
            });
            return settings;
        },
        /**
         * Extends MachinesForIp Settings. Adds GDS columns.
         *
         * @param {Array<{type: string, suspicious_event_score: number}>} dataEntitiesSorted
         * @private
         */
        _extendMachinesForIpSettings: function (dataEntitiesSorted) {
            this.machinesForIpTableSettings = this._extendTableSettings(dataEntitiesSorted, this.machinesForIpTableSettingsMaster);
        },
        /**
         * Extends UsersForIp Settings. Adds GDS columns.
         *
         * @param {Array<{type: string, suspicious_event_score: number}>} dataEntitiesSorted
         * @private
         */
        _extendUsersForIpSettings: function (dataEntitiesSorted) {
            this.usersForIpTableSettings = this._extendTableSettings(dataEntitiesSorted, this.usersForIpTableSettingsMaster);
        },
        /**
         * Adds Kedo tooltip to account-control's question mark.
         *
         * @private
         */
        _initIPAddressControlTooltip: function () {
            this.$scope.$applyAsync(function () {
                $('.explain-ip-address').kendoTooltip({
                    position: "bottom",
                    showOn: "mouseenter click",
                    autoHide: true,
                    content: this.state.ipAddressControlTooltip,
                    width: "15em",
                    animation: {
                        close: {
                            effects: "fade:out",
                            duration: 500
                        },
                        open: {
                            effects: "fade:in",
                            duration: 500
                        }
                    }
                });
            }.bind(this));
        },
        /**
         * Takes an old object and a new object and transfers all properties directly or via an adapter function.
         * adapterFn will be invoked (if provided) with oldValue, newValue, oldObject, newObject
         *
         * @param {Array<{sourceProperty: string, targetProperty:string=, adapterFn:function=}>} propertiesConfList
         * @param {object} newObj
         * @param {object} oldObj
         * @param {boolean=} isOnce
         * @private
         */
        _setProperties: function (propertiesConfList, newObj, oldObj, isOnce) {
            isOnce = !!isOnce;
            _.each(propertiesConfList, function (propertyConf) {
                var sourceProperty = propertyConf.sourceProperty;
                var targetProperty = propertyConf.targetProperty || sourceProperty;
                if ((isOnce && newObj[targetProperty] === undefined) || !isOnce) {
                    newObj[targetProperty] = _.isFunction(propertyConf.adapterFn) ?
                        propertyConf.adapterFn(oldObj[sourceProperty], newObj[targetProperty], oldObj, newObj) :
                        oldObj[sourceProperty];
                }
            });
        },
        /**
         * Takes two values and returns the sum. If both arguments are not numbers, it returns the last argument if
         * its a number, then first argument if its a number, or null.
         *
         * @param {number|*} oldValue
         * @param {number|*} newValue
         * @returns {number|null}
         * @private
         */
        _incrementTentative: function (oldValue, newValue) {
            if (_.isNumber(newValue) && _.isNumber(oldValue)) {
                newValue += oldValue;
                return newValue;
            }
            if (_.isNumber(newValue)) {
                return newValue;
            }
            if (_.isNumber(oldValue)) {
                return oldValue;
            }
            return null;
        },
        /**
         * Takes a dataList, group by type, and return a sorted list by event_score of objects.
         *
         * @param {{type: string, suspicious_event_score: number}} dataList
         * @returns {Array<{type: string, suspicious_event_score: number}>} Sorted by suspicious_event_score
         * @private
         */
        _getDataEntitiesSorted: function (dataList) {
            // Group by type
            var groupByType = _.groupBy(dataList, TYPE_FIELD_NAME);
            // Extract data entities keys
            var dataEntitiesKeys = Object.keys(groupByType);
            // Create data entities sums object
            var dataEntitiesSums = {};
            // Iterate through dataEntitiesKeys and sum by suspicious_event_score and store on dataEntitiesSums
            _.each(dataEntitiesKeys, function (dataEntityName) {
                dataEntitiesSums[dataEntityName] =
                    _.sumBy(groupByType[dataEntityName], SUSPICIOUS_EVENT_SCORE_FIELD_NAME);
            });
            // Return sorted list of data entities: {type: string, suspicious_event_score: integer}
            return _.orderBy(_.map(dataEntitiesSums, function (value, key) {
                var obj = {};
                obj[SUSPICIOUS_EVENT_SCORE_FIELD_NAME] = value;
                obj[TYPE_FIELD_NAME] = key;
                return obj;
            }), SUSPICIOUS_EVENT_SCORE_FIELD_NAME, 'desc');
        },
        /**
         * Populates data entities list in a newDay object
         *
         * @param {array<{type: string, event_count: number, suspicious_event_score: number}>} dayGroup
         * @param {object} newDay
         * @param {{type: string}} dataEntity
         * @returns {{type: string, suspicious_event_score: number}|object}
         * @private
         */
        _populateDataEntities: function (dayGroup, newDay, dataEntity) {
            // Create dataEntities
            var type = dataEntity[TYPE_FIELD_NAME];
            var query = {};
            query[TYPE_FIELD_NAME] = type;
            var oldDay = _.filter(dayGroup, query)[0];
            if (oldDay) {
                // Increment devices_count, users_count, event_count
                this._setProperties([
                    {
                        sourceProperty: EVENT_COUNT_FIELD_NAME,
                        adapterFn: this._incrementTentative
                    }
                ], newDay, oldDay);
            }
            else {
                oldDay = {};
            }
            // Create a returned object
            var obj = {};
            obj[TYPE_FIELD_NAME] = type;
            obj[SUSPICIOUS_EVENT_SCORE_FIELD_NAME] = oldDay[SUSPICIOUS_EVENT_SCORE_FIELD_NAME] || 0;
            return obj;
        },
        /**
         * Populates a newDataObj with adapted items, where each key on the object is a day date.
         *
         * @param {object} newDataObj An object to be populated. From this object the new list will be returned
         * @param {{type: string, suspicious_event_score: number}} dataEntitiesSorted
         * @param {string} subGroupFieldName
         * @param {array<{type: string, event_time: string, source_machine: string, event_count: number,
         * suspicious_event_score: number}>} dayGroup
         * @private
         */
        _populateNewDataObj: function (newDataObj, dataEntitiesSorted, dayGroup) {
            _.each(dayGroup, _.bind(function (subGroup, subGroupName) {
                // Create new object for each day and subgroup if it doesn't exist
                var objKey = subGroup[0][EVENT_TIME_FIELD_NAME] + '_' + subGroupName;
                if (!newDataObj[objKey]) {
                    newDataObj[objKey] = {};
                }
                // Truncate newDay namespace for future reference
                var newDay = newDataObj[objKey];
                // Set source_machine, event_time on newDay object
                this._setProperties([
                    {
                        sourceProperty: SOURCE_MACHINE_FIELD_NAME
                    },
                    {
                        sourceProperty: NORMALIZED_USERNAME_FIELD_NAME
                    },
                    {
                        sourceProperty: EVENT_TIME_FIELD_NAME,
                        adapterFn: function (oldValue) {
                            return new Date(oldValue);
                        }
                    }
                ], newDay, subGroup[0], true);
                // Set event_count (=0), users_count (=0), devices_count (=0)
                newDay[EVENT_COUNT_FIELD_NAME] = newDay[EVENT_COUNT_FIELD_NAME] || 0;
                // populate dataEntities
                newDay.dataEntities =
                    _.map(dataEntitiesSorted, this._populateDataEntities.bind(this, subGroup, newDay));
            }, this));
        },
        /**
         * An adapter for the returned data for ip investigation.
         *
         * @param {{}} dataList
         * @param {string} target
         * @returns {Array}
         * @private
         */
        _ipInvestigationResourceAdapter: function (dataList, target) {
            // Get sorted list of data entities sums
            var dataEntitiesSorted = this._getDataEntitiesSorted(dataList);
            // Extend the tables settings to add columns settings
            if (target === 'machines') {
                this._extendMachinesForIpSettings(dataEntitiesSorted);
            }
            if (target === 'users') {
                this._extendUsersForIpSettings(dataEntitiesSorted);
            }
            // Group dataList by date (by day) to groupObj
            var groupedByDayObj = _.groupBy(dataList, EVENT_TIME_FIELD_NAME);
            // Create sub group by source machine or user name
            var subGroupFieldName = '';
            subGroupFieldName = target === 'machines' ? SOURCE_MACHINE_FIELD_NAME : subGroupFieldName;
            subGroupFieldName = target === 'users' ? NORMALIZED_USERNAME_FIELD_NAME : subGroupFieldName;
            _.each(groupedByDayObj, function (dayObj, key) {
                groupedByDayObj[key] = _.groupBy(dayObj, subGroupFieldName);
            });
            // create new object (keys are event_time)
            // new object scheme: {source_machine: string, event_time: Date, event_count: integer,
            // users_count: integer, devices_count: integer,
            // dataEntities: [{type: string, suspicious_event_score: integer (=0)}]}
            var newDataObj = {};
            // Iterate through days groups and populate newDataObj
            _.each(groupedByDayObj, this._populateNewDataObj.bind(this, newDataObj, dataEntitiesSorted));
            // Return a sorted list of days
            var newDataList = _.orderBy(_.map(newDataObj, function (day) {
                return day;
            }), EVENT_TIME_FIELD_NAME, 'desc');
            newDataList._meta = dataList._meta;
            return newDataList;
        },
        init: function () {
            this._initIPAddressControlTooltip();
        }
    });
    IPInvestigationController.$inject = ['appConfig', '$state', '$scope', 'dateRanges', 'machinesForIpResource',
        'machinesForIpTableSettings', 'usersForIpResource', 'usersForIpTableSettings', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('IPInvestigationController', IPInvestigationController);
}());

(function () {
    'use strict';
    function SensitiveResourcesMonitoringController(appConfig, $state, dateRanges, sensitiveMachinesStatusTableResource, sensitiveMachinesStatusTableSettings, usersAccessResourcesTableResource, usersAccessResourcesTableSettings, eventsSensitiveMachinesTableResource, eventsSensitiveMachinesTableSettings, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this._defaultDaysRange = appConfig.getConfigValue('ui.' + $state.current.name, 'daysRange');
        this.mainState = _.merge({}, {
            min_score: {
                value: 50
            },
            events_time: {
                value: dateRanges.getByDaysRange(this._defaultDaysRange, 'short')
            }
        });
        this.sensitiveMachinesStatusTableResource = _.merge({}, sensitiveMachinesStatusTableResource);
        this.sensitiveMachinesStatusTableSettings = _.merge({}, sensitiveMachinesStatusTableSettings);
        this.usersAccessResourcesTableResource = _.merge({}, usersAccessResourcesTableResource);
        this.usersAccessResourcesTableSettings = _.merge({}, usersAccessResourcesTableSettings);
        this.eventsSensitiveMachinesTableResource = _.merge({}, eventsSensitiveMachinesTableResource);
        this.eventsSensitiveMachinesTableSettings = _.merge({}, eventsSensitiveMachinesTableSettings);
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(SensitiveResourcesMonitoringController.prototype, {
        init: function () {
        }
    });
    SensitiveResourcesMonitoringController.$inject =
        ['appConfig', '$state', 'dateRanges', 'sensitiveMachinesStatusTableResource',
            'sensitiveMachinesStatusTableSettings', 'usersAccessResourcesTableResource',
            'usersAccessResourcesTableSettings', 'eventsSensitiveMachinesTableResource',
            'eventsSensitiveMachinesTableSettings', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('SensitiveResourcesMonitoringController', SensitiveResourcesMonitoringController);
}());

var Fortscale;
(function (Fortscale) {
    'use strict';
    (function () {
        'use strict';
        function SuspiciousEndpointAccessController(appConfig, $state, dateRanges, mainState, endpointControlSettings, endpointControlResource, resourceSettings, tableSettings, userUtils, fsNanobarAutomationService) {
            var _this = this;
            // Put injections on instance
            this.state = _.merge({}, $state.current.data);
            this._defaultDaysRange = appConfig.getConfigValue('ui.' + $state.current.name, 'daysRange');
            this.mainState = _.merge({}, mainState, {
                "events_time": {
                    "value": dateRanges.getByDaysRange(this._defaultDaysRange, 'short')
                }
            });
            this.endpointControlSettings = _.merge({}, endpointControlSettings);
            this.endpointControlResource = _.merge({}, endpointControlResource);
            this.resourceSettings = resourceSettings;
            this.tableSettings = _.merge({}, tableSettings);
            // Add user control settings
            this.userControlSettings = {
                "dataValueField": "username",
                "dataTextField": "fallBackDisplayName",
                /**
                 * Takes received users and creates fallBack display name for each, and prevents duplications.
                 * @param users
                 */
                "dataTextFn": function (users) {
                    userUtils.setFallBackDisplayNames(users);
                    userUtils.preventFallBackDisplayNameDuplications(users);
                },
                "placeholder": "All Users"
            };
            // Add user control resource settings
            this.userControlResource = {
                "entity": "user",
                "params": {
                    "page": 1,
                    "size": 10,
                    "sort_field": "displayName",
                    "sort_direction": "ASC",
                    "search_field_contains": "{{search}}"
                }
            };
            this.init();
            this.NANOBAR_ID = 'reports';
            this.dataFetchDelegate = function (promise) {
                fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
            };
        }
        _.merge(SuspiciousEndpointAccessController.prototype, {
            init: function () {
            }
        });
        SuspiciousEndpointAccessController.$inject =
            ['appConfig', '$state', 'dateRanges', 'mainState', 'endpointControlSettings', 'endpointControlResource',
                'resourceSettings', 'tableSettings', 'userUtils', 'fsNanobarAutomationService'];
        angular.module('Fortscale.layouts.reports')
            .controller('SuspiciousEndpointAccessController', SuspiciousEndpointAccessController);
    }());
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function RiskyTaggedUsersController($state, $stateParams, dataEntities, tableResource, tableSettings, dataEntitiesList, fsNanobarAutomationService) {
        var _this = this;
        // Put injections on instance
        this.state = _.merge({}, $state.current.data);
        this.$stateParams = $stateParams;
        this.tagName = $stateParams.tagName;
        this.mainState = _.merge({
            userTags: {
                value: this.tagName
            },
            users_table: {
                value: {
                    pageSize: 20,
                    page: 1,
                    sortBy: 'score',
                    sortDirection: 'DESC'
                }
            }
        });
        this.tableResource = _.merge({}, tableResource);
        this.tableSettings = _.merge({}, tableSettings);
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        this.init();
    }
    _.merge(RiskyTaggedUsersController.prototype, {
        init: function () {
        }
    });
    RiskyTaggedUsersController.$inject =
        ['$state', '$stateParams', 'dataEntities', 'tableResource', 'tableSettings', 'dataEntitiesList',
            'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('RiskyTaggedUsersController', RiskyTaggedUsersController);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var suspiciousUsersResolve = {
        tableResource: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/reports/layouts/suspicious-users/settings/suspicious-users-table.resource.json');
            }
        ],
        tableSettings: [
            'jsonLoader',
            function (jsonLoader) {
                return jsonLoader
                    .load('app/layouts/reports/layouts/suspicious-users/settings/suspicious-users-table.settings.json');
            }
        ]
    };
    angular.module('Config')
        .constant('suspiciousUsersResolve', suspiciousUsersResolve);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var suspiciousUsersData = {
        reportTitle: 'Accounts',
        reportDescription: 'The following report lists Privileged Users With high-risk scores. Click a username To drill-down into score breakdown and investigate anomalous behaviors.',
        reportClass: 'regular',
        noItems: 'No Users Found'
    };
    angular.module('Config')
        .constant('suspiciousUsersData', suspiciousUsersData);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var externalAccessToNetworkResolve = {
        resolve: {},
        VPNGeoHopping: {
            userControlSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'vpn-geo-hopping-user-control.settings.json');
                }
            ],
            userControlResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'vpn-geo-hopping-user-control.resource.json');
                }
            ],
            VPNGeoHoppingResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'vpn-geo-hopping.resource.json');
                }
            ],
            VPNGeoHoppingTableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'vpn-geo-hopping-table.settings.json');
                }
            ],
            VPNGeoHoppingChartSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'vpn-geo-hopping-chart.settings.json');
                }
            ]
        },
        suspiciousVPNDataAmount: {
            userControlSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'suspicious-vpn-data-amount-user-control.settings.json');
                }
            ],
            userControlResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'suspicious-vpn-data-amount-user-control.resource.json');
                }
            ],
            tableResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .loadJsonx('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'suspicious-vpn-data-amount-table.resource.jsonx');
                }
            ],
            tableSettings: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .load('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'suspicious-vpn-data-amount-table.settings.json');
                }
            ],
            chartResource: [
                'jsonLoader',
                function (jsonLoader) {
                    return jsonLoader
                        .loadJsonx('app/layouts/reports/layouts/external-access-to-network/settings/' +
                        'suspicious-vpn-data-amount-chart.resource.jsonx');
                }
            ]
        }
    };
    angular.module('Config')
        .constant('externalAccessToNetworkResolve', externalAccessToNetworkResolve);
}());

/**
 * Resolve object for alerts
 */
(function () {
    'use strict';
    var externalAccessToNetworkData = {
        VPNGeoHopping: {
            reportTitle: 'VPN Anomalous Geolocation Sequences',
            reportDescription: 'Investigate VPN connections coming from distant locations in an unrealistically ' +
                'short time frames.',
            sessionPerUserWidgetTitle: 'Users',
            sessionPerUserWidgetNoItems: 'No Sessions Found.',
            sessionPerUserTableDescription: 'VPN Events'
        },
        suspiciousVPNDataAmount: {
            reportTitle: 'VPN Anomalous Data Usage',
            reportDescription: 'Investigate excessive data usage over VPN.',
            sessionPerTimeChartTitle: 'Sessions',
            sessionPerTimeChartNoItems: 'No Events Found',
            sessionPerTimeChartNoTable: 'No Events Found'
        }
    };
    angular.module('Config')
        .constant('externalAccessToNetworkData', externalAccessToNetworkData);
}());

(function () {
    'use strict';
    var START_TIME_FIELD_NAME = 'start_time';
    var USERNAME_FIELD_NAME = 'username';
    var END_TIME_FIELD_NAME = 'end_time';
    var DURATION_FIELD_NAME = 'duration';
    var DATA_USAGE_FIELD_NAME = 'data_bucket';
    var DATA_USAGE_SCORE_FIELD_NAME = 'data_bucket_score';
    function SuspiciousVPNDataAmountController(appConfig, $state, $scope, dateRanges, SEVERITIES, utils, $filter, userControlSettings, userControlResource, tableResource, tableSettings, chartResource, fsNanobarAutomationService) {
        var _this = this;
        var ctrl = this;
        // Put injections on instance
        ctrl.state = _.merge({}, $state.current.data);
        ctrl.$scope = $scope;
        ctrl.SEVERITIES = SEVERITIES;
        ctrl.utils = utils;
        ctrl.$filters = $filter;
        ctrl.dateRanges = dateRanges;
        ctrl._defaultDaysRange = appConfig.getConfigValue('ui.' + $state.current.name, 'daysRange');
        ctrl.userControlSettings = _.merge({}, userControlSettings);
        ctrl.userControlResource = _.merge({}, userControlResource);
        ctrl.tableResource = tableResource;
        ctrl.tableSettings = _.merge({}, tableSettings);
        ctrl.chartResource = chartResource;
        // Lock in controller as activation context
        ctrl.chartResourceAdapter = function (dataList) {
            return ctrl._chartResourceAdapter(dataList);
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        // Init
        this.init();
    }
    _.merge(SuspiciousVPNDataAmountController.prototype, {
        /**
         * Initiates report main state
         *
         * @private
         */
        _initMainState: function () {
            var ctrl = this;
            ctrl.mainState = _.merge({}, {
                events_time: {
                    value: ctrl.dateRanges.getByDaysRange(ctrl._defaultDaysRange, 'short')
                },
                min_score: {
                    value: 50
                },
                suspicious_vpn_data_amount_table: {
                    value: {
                        pageSize: 20,
                        page: 1,
                        sortDirection: 'DESC',
                        sortBy: 'data_bucket_score'
                    }
                }
            });
        },
        /**
         * Initiates chart settings
         *
         * @private
         */
        _initChartSettings: function () {
            var ctrl = this;
            ctrl.chartSettings = {
                "chart": {
                    "type": "scatter"
                },
                "title": {
                    "text": null
                },
                "xAxis": {
                    "type": "datetime",
                    "dateTimeLabelFormats": {
                        "month": "%e. %b",
                        "year": "%b"
                    },
                    "title": {
                        "text": "Date"
                    },
                    "tickInterval": 1000 * 60 * 60 * 24
                },
                "yAxis": {
                    "type": 'datetime',
                    "tickInterval": 3600 * 1000,
                    min: 0,
                    max: (1000 * 60 * 60 * 24) - 1,
                    labels: {
                        formatter: function () {
                            var hour = this.value / 1000 / 60 / 60;
                            return (hour < 10 ? '0' : '') + hour + ':00';
                        }
                    },
                    "title": {
                        "text": "Hours"
                    }
                },
                "isMultiSeries": true,
                plotOptions: {
                    series: {
                        marker: {
                            radius: 5,
                            symbol: 'circle'
                        }
                    }
                },
                tooltip: {
                    formatter: function () {
                        var s = '';
                        s += '<b>Username: </b>' + this.point.username + '<br>';
                        s += '<b>Start Time: </b>' + moment(this.point.startTime).format("MMM Do YY HH:mm:ss") + '<br>';
                        s += '<b>End Time: </b>' + moment(this.point.endTime).format("MMM Do YY HH:mm:ss") + '<br>';
                        s += '<b>Duration: </b>' + moment(this.point.endTime).format("HH:mm:ss") + '<br>';
                        s += '<b>Data Usage: </b>' + ctrl.$filters('prettyBytes')(this.point.dataUsage) + '/s<br>';
                        s += '<b>Data Usage Score: </b>' + this.point.dataUsageScore + '<br>';
                        return s;
                    }
                },
                legend: {
                    "enabled": true,
                    layout: 'vertical',
                    align: 'right',
                    verticalAlign: 'top',
                    x: 0,
                    y: 40
                }
            };
        },
        /**
         * Initiates chart map settings
         *
         * @private
         */
        _initChartMapSettings: function () {
            var ctrl = this;
            ctrl.chartMapSettings = {
                x: {
                    key: START_TIME_FIELD_NAME,
                    /**
                     * In effect always returns the start of day, so all markers fall on the same line on the x axis.
                     *
                     * @param {number} startDate
                     * @returns {number}
                     */
                    fn: function (startDate) {
                        return ctrl.utils.date.getMoment(startDate).startOf('day').valueOf();
                    }
                },
                y: {
                    key: START_TIME_FIELD_NAME,
                    /**
                     * Returns only the delta between start of day and date, thus producing only the time in day
                     * for the y axis.
                     *
                     * @param {number} startDate
                     * @returns {number}
                     */
                    fn: function (startDate) {
                        var endTime = ctrl.utils.date.getMoment(startDate).valueOf();
                        var startTime = ctrl.utils.date.getMoment(startDate).startOf('day').valueOf();
                        return (endTime - startTime);
                    }
                },
                username: USERNAME_FIELD_NAME,
                startTime: START_TIME_FIELD_NAME,
                endTime: END_TIME_FIELD_NAME,
                duration: DURATION_FIELD_NAME,
                dataUsage: DATA_USAGE_FIELD_NAME,
                dataUsageScore: DATA_USAGE_SCORE_FIELD_NAME
            };
        },
        /**
         * Converts returned data list to series list by severity
         *
         * @param {Array<{data_bucket_score: number}>} dataList
         * @returns {Array<{name: string, color: string, scoreRange: Array<number,number>, data: Array<{}>}>}
         * @private
         */
        _convertToSeries: function (dataList) {
            // Group by severity
            var dataListGrouped = _.groupBy(dataList, _.bind(function (dataItem) {
                return this.SEVERITIES.getByScore(dataItem[DATA_USAGE_SCORE_FIELD_NAME]).id;
            }, this));
            // Create series list
            var series = _.map(dataListGrouped, _.bind(function (group, groupName) {
                var severity = this.SEVERITIES.getById(groupName);
                return {
                    name: severity.displayName,
                    color: severity.color,
                    data: group,
                    scoreRange: severity.scoreRange
                };
            }, this));
            // Sort series list by score range bottom end (should produce low, medium, high, critical)
            return _.orderBy(series, 'scoreRange[0]', 'asc');
        },
        /**
         * Chart resource adapter. Invokes and returns _convertToSeries, which converts data list to list of series.
         *
         * @param {Array<{data_bucket_score: number}>} dataList
         * @returns {*|Array.<{name: string, color: string, scoreRange: Array.<number, number>, data: Array.<{}>}>}
         * @private
         */
        _chartResourceAdapter: function (dataList) {
            return this._convertToSeries(dataList);
        },
        /**
         * Controller's init function
         */
        init: function () {
            this._initMainState();
            this._initChartMapSettings();
            this._initChartSettings();
        }
    });
    SuspiciousVPNDataAmountController.$inject =
        ['appConfig', '$state', '$scope', 'dateRanges', 'SEVERITIES', 'utils', '$filter',
            'userControlSettings', 'userControlResource', 'tableResource', 'tableSettings', 'chartResource',
            'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('suspiciousVPNDataAmountController', SuspiciousVPNDataAmountController);
}());

(function () {
    'use strict';
    var USERNAME_FIELD_NAME = 'username';
    var USER_ID_FIELD_NAME = 'userid';
    var NORMALIZED_USERNAME_FIELD_NAME = 'normalized_username';
    var COUNTRY_FIELD_NAME = 'country';
    var CITY_FIELD_NAME = 'city';
    var EVENT_TIME_FIELD_NAME = 'event_time_utc';
    var CHART_USERS_LIMIT = 10;
    function VPNGeoHoppingController(appConfig, $state, $scope, dateRanges, userUtils, userControlResource, userControlSettings, VPNGeoHoppingResource, VPNGeoHoppingTableSettings, VPNGeoHoppingChartSettings, fsNanobarAutomationService) {
        var _this = this;
        var ctrl = this;
        // Put injections on instance
        ctrl.state = _.merge({}, $state.current.data);
        ctrl.$scope = $scope;
        ctrl.dateRanges = dateRanges;
        ctrl.userUtils = userUtils;
        ctrl.userControlResource = userControlResource;
        ctrl.userControlSettings = userControlSettings;
        ctrl.VPNGeoHoppingResource = VPNGeoHoppingResource;
        ctrl.VPNGeoHoppingTableSettings = VPNGeoHoppingTableSettings;
        ctrl.VPNGeoHoppingChartSettings = VPNGeoHoppingChartSettings;
        ctrl._defaultDaysRange = appConfig.getConfigValue('ui.' + $state.current.name, 'daysRange');
        ctrl.resourceAdapter = function (dataList) {
            return ctrl._resourceAdapter(dataList);
        };
        this.NANOBAR_ID = 'reports';
        this.dataFetchDelegate = function (promise) {
            fsNanobarAutomationService.addPromise(_this.NANOBAR_ID, promise);
        };
        // Init
        this.init();
    }
    _.merge(VPNGeoHoppingController.prototype, {
        /**
         * Initiates report main state
         *
         * @private
         */
        _initMainState: function () {
            var ctrl = this;
            ctrl.mainState = _.merge({}, {
                events_time: {
                    value: ctrl.dateRanges.getByDaysRange(ctrl._defaultDaysRange, 'short')
                },
                min_score: {
                    value: 50
                }
            });
        },
        /**
         * Initiates chart settings. Combines json "dry" settings with functional settings.
         *
         * @private
         */
        _initChartSettings: function () {
            var ctrl = this;
            this.chartSettings = _.merge({}, ctrl.VPNGeoHoppingChartSettings, {
                tooltip: {
                    formatter: function () {
                        var s = '';
                        s += '<b>Username: </b>' + this.point[USERNAME_FIELD_NAME] + '<br>';
                        s += '<b>Normalized Username: </b>' + this.point[NORMALIZED_USERNAME_FIELD_NAME] + '<br>';
                        s += '<b>Country: </b>' + this.point[COUNTRY_FIELD_NAME] + '<br>';
                        s += '<b>City: </b>' + this.point[CITY_FIELD_NAME] + '<br>';
                        s += '<b>Event Time: </b>' + moment(this.point[EVENT_TIME_FIELD_NAME]).utc()
                            .format("MMM Do YY HH:mm:ss") + '<br>';
                        return s;
                    }
                }
            });
        },
        /**
         * Initiates chart map settings.
         *
         * @private
         */
        _initChartMapSettings: function () {
            var ctrl = this;
            ctrl.chartMapSettings = (_a = {
                    x: {
                        key: EVENT_TIME_FIELD_NAME,
                        fn: function (date) {
                            var dt = new Date(date);
                            return dt.valueOf();
                        }
                    },
                    y: {
                        key: USERNAME_FIELD_NAME,
                        fn: function (user) {
                            return ctrl._chartUsersList.indexOf(user);
                        }
                    }
                },
                _a[USERNAME_FIELD_NAME] = USERNAME_FIELD_NAME,
                _a[NORMALIZED_USERNAME_FIELD_NAME] = NORMALIZED_USERNAME_FIELD_NAME,
                _a[EVENT_TIME_FIELD_NAME] = EVENT_TIME_FIELD_NAME,
                _a[COUNTRY_FIELD_NAME] = COUNTRY_FIELD_NAME,
                _a[CITY_FIELD_NAME] = CITY_FIELD_NAME,
                _a[USER_ID_FIELD_NAME] = USER_ID_FIELD_NAME,
                _a
            );
            var _a;
        },
        /**
         * Returns a list of user names from user series.
         *
         * @param {Array<{name: string, data: array}>} userSeries
         * @returns {Array}
         * @private
         */
        _getListOfUserNames: function (userSeries) {
            return _.map(userSeries, 'name');
        },
        /**
         * Takes dataList and returns an object that is grouped by username.
         *
         * @param {Array<{username: string}>} dataList
         * @returns {*}
         * @private
         */
        _groupByUser: function (dataList) {
            return _.groupBy(dataList, USERNAME_FIELD_NAME);
        },
        /**
         * Sorts each user group list (internally) by event time ascending.
         *
         * @param userGroups
         * @private
         */
        _sortUserGroups: function (userGroups) {
            _.each(userGroups, function (userGroup, key) {
                userGroups[key] = _.orderBy(userGroup, EVENT_TIME_FIELD_NAME, 'asc');
            });
        },
        /**
         * Adds mostRecentEvent property to each user group. This property will be later used to sort the groups.
         *
         * @param userGroups
         * @private
         */
        _addMostRecentProperty: function (userGroups) {
            _.each(userGroups, function (userGroup) {
                userGroup.mostRecentEvent = userGroup[userGroup.length - 1][EVENT_TIME_FIELD_NAME];
            });
        },
        /**
         * Takes user groups object and converts to list, sorted by mostRecentEvent.
         *
         * @param userGroups
         * @returns {Array<{name: string, data: Array<{}>}>}
         * @private
         */
        _convertUserGroupsToList: function (userGroups) {
            return _.map(_.sortBy(_.values(userGroups), 'mostRecentEvent').slice(0, CHART_USERS_LIMIT), function (userList) {
                return {
                    name: userList[0][USERNAME_FIELD_NAME],
                    data: userList
                };
            }).reverse();
        },
        /**
         * Takes the data list received from server, and convert it to sorted list of user groups
         *
         * @param dataList
         * @returns {*|Array.<{name: string, data: Array.<{}>}>}
         * @private
         */
        _createUsersSeries: function (dataList) {
            var userGroups = this._groupByUser(dataList);
            this._sortUserGroups(userGroups);
            this._addMostRecentProperty(userGroups);
            return this._convertUserGroupsToList(userGroups);
        },
        /**
         * Intercepts the received resource and creates chart model and table model.
         *
         * @param dataList
         * @returns {*}
         * @private
         */
        _resourceAdapter: function (dataList) {
            // Save reference to original list
            this._sourceDataList = dataList;
            // get list of 10 users by their most recent event
            this.chartModel = this._createUsersSeries(dataList);
            // Get list of user names for y axis categories
            this.chartSettings.yAxis.categories = this._chartUsersList = this._getListOfUserNames(this.chartModel);
            // Set the table model
            this.tableModel = this._sourceDataList.slice(0);
            this.tableModel._meta = this._sourceDataList._meta;
            return dataList;
        },
        /**
         * Handler for users list returned from accounts control. Sets fall back display name, and prevent display
         * name duplications.
         *
         * @param {array<{fallBackDisplayName: string, username: string}>} users
         * @private
         */
        _userControlDataTextFn: function (users) {
            this.userUtils.setFallBackDisplayNames(users);
            this.userUtils.preventFallBackDisplayNameDuplications(users);
        },
        /**
         * Attach handler for users list returned from accounts control. Sets fall back display name, and prevent
         * display name duplications. Handler is bound to the controller's instance.
         *
         * @private
         */
        _enrichUserControlSettings: function () {
            this.userControlSettings.dataTextFn = this._userControlDataTextFn.bind(this);
        },
        /**
         * Controller's init function
         */
        init: function () {
            this._initMainState();
            this._initChartSettings();
            this._initChartMapSettings();
            this._enrichUserControlSettings();
        }
    });
    VPNGeoHoppingController.$inject =
        ['appConfig', '$state', '$scope', 'dateRanges', 'userUtils', 'userControlResource', 'userControlSettings',
            'VPNGeoHoppingResource', 'VPNGeoHoppingTableSettings', 'VPNGeoHoppingChartSettings', 'fsNanobarAutomationService'];
    angular.module('Fortscale.layouts.reports')
        .controller('VPNGeoHoppingController', VPNGeoHoppingController);
}());

(function () {
    'use strict';
    function fsReportHeaderDirective() {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // Link function logic
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsReportHeaderController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsReportHeaderController.prototype, {
            /**
             * Init
             */
            init: function init() {
            }
        });
        FsReportHeaderController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/reports/components/fs-report-header.view.html',
            scope: {},
            link: linkFn,
            controller: FsReportHeaderController,
            controllerAs: 'ctrl',
            bindToController: {
                headerClass: '@',
                headerTitle: '@',
                headerDescription: '@'
            }
        };
    }
    fsReportHeaderDirective.$inject = [];
    angular.module('Fortscale.layouts.reports')
        .directive('fsReportHeader', fsReportHeaderDirective);
    angular.module('Fortscale.layouts.reports')
        .directive('fsTableHeader', fsReportHeaderDirective);
}());

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            'use strict';
            configuration.CONFIG_FORM_STATE_NAME = 'configuration.configForm';
            configuration.NAV_BAR_ELEMENT_SELECTOR = '.menu-pane--menu-container';
            configuration.OPENED_CLASS_NAME = 'opened';
            configuration.CLOSED_CLASS_NAME = 'closed';
            angular.module('Fortscale.layouts.configuration', [
                'Fortscale.shared.services.tagsUtils',
                'Fortscale.shared.services.stringUtils'
            ]);
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var configurationNavigation;
            (function (configurationNavigation) {
                var ConfigurationNavigationService = (function () {
                    function ConfigurationNavigationService(assert, appConfig, $compile, $state) {
                        this.assert = assert;
                        this.appConfig = appConfig;
                        this.$compile = $compile;
                        this.$state = $state;
                        this._errMsg = 'ConfigurationNavigationService: ';
                        this._configurationPages = new Map();
                    }
                    ConfigurationNavigationService.prototype._mergeConfigPagesIntoNodeTree = function (configNodeTree) {
                        var newConfigNodeTree = _.merge({}, configNodeTree);
                        // Iterate through new configuration pages, and create a node for each one (it intentionally overwrites
                        // old nodes).
                        var configurationPages = Array.from(this._configurationPages.values());
                        _.each(configurationPages, function (configurationPage) {
                            // Breakdown namespace (id) into nodes
                            var nodes = configurationPage.id.split('.');
                            // Create paths for each node. For each path sets the configurationPage object and adds nodes object.
                            // for example: a.b.c.d will create a, a.nodes.b, a.nodes.b.nodes.c.nodes, a.nodes.b.nodes.c.nodes.d
                            for (var i = 0; i < nodes.length; i += 1) {
                                var nameSpace = nodes.slice(0, i + 1).join(".nodes.");
                                var localNameSpace = "nodes." + nameSpace;
                                // Find if object exists
                                var configurationPageObject = _.get(newConfigNodeTree, localNameSpace);
                                // If object does not exist, set it in
                                if (!configurationPageObject) {
                                    var displayName = configurationPage.displayName || nodes[i];
                                    var placeholder = i === nodes.length - 1 ? configurationPage : {
                                        id: nodes.slice(0, i + 1).join('.'), configurable: true
                                    };
                                    placeholder.displayName = displayName;
                                    _.set(newConfigNodeTree, localNameSpace, placeholder);
                                    _.set(newConfigNodeTree, localNameSpace + '.nodes', {});
                                }
                            }
                        });
                        return newConfigNodeTree;
                    };
                    /**
                     * Tentativelly builds all the missing configuration pages for the received path
                     *
                     * @param {IConfigurationPageData} configurationPageData
                     * @private
                     */
                    ConfigurationNavigationService.prototype._buildConfigurationPagePath = function (configurationPageData) {
                        var nodes = configurationPageData.id.split('.');
                        for (var i = 0; i < nodes.length; i += 1) {
                            var nameSpace = nodes.slice(0, i + 1).join(".");
                            if (!this._configurationPages.get(nameSpace)) {
                                // If its not the last index then take the node[i] as display name, otherwise take
                                // configurationPageData.displayName as display name or nodes[i] as default.
                                if (i + 1 < nodes.length) {
                                    this._configurationPages.set(nameSpace, {
                                        id: nameSpace,
                                        displayName: nodes[i],
                                        description: null,
                                        component: null,
                                        customPage: false,
                                        configurable: true,
                                        doNotShowHeader: false,
                                        formClassNames: ''
                                    });
                                }
                                else {
                                    this._configurationPages.set(nameSpace, {
                                        id: nameSpace,
                                        displayName: configurationPageData.displayName || nodes[i],
                                        description: configurationPageData.description || null,
                                        component: configurationPageData.component || null,
                                        customPage: true,
                                        configurable: true,
                                        doNotShowHeader: !!configurationPageData.doNotShowHeader,
                                        formClassNames: configurationPageData.formClassNames || ''
                                    });
                                }
                            }
                        }
                    };
                    /**
                     * Adds a custom configuration page
                     *
                     * @param configurationPageData
                     * @returns {ConfigurationNavigationService}
                     */
                    ConfigurationNavigationService.prototype.addConfigurationPage = function (configurationPageData) {
                        // Validations
                        var errMsg = this._errMsg + "addConfigurationPage: ";
                        this.assert.isString(configurationPageData.id, 'configurationPageData.id', errMsg);
                        this.assert.isString(configurationPageData.displayName, 'configurationPageData.displayName', errMsg, true);
                        this.assert.isString(configurationPageData.description, 'configurationPageData.description', errMsg, true);
                        this.assert.isString(configurationPageData.component, 'configurationPageData.component', errMsg, true);
                        this.assert(!this._configurationPages.get(configurationPageData.id), errMsg + "ConfigurationPage id must be unique.", RangeError);
                        this._buildConfigurationPagePath(configurationPageData);
                        return this;
                    };
                    /**
                     * Returns a tree object of configuration pages (containers or customs)
                     * @returns {any}
                     */
                    ConfigurationNavigationService.prototype._getConfigNodesTree = function () {
                        var configNodeTree = this.appConfig.getConfigNodesTree();
                        return this._mergeConfigPagesIntoNodeTree(configNodeTree);
                    };
                    /**
                     * Creates an unordered list
                     *
                     * @returns {JQuery}
                     * @private
                     */
                    ConfigurationNavigationService.prototype._createNavUl = function () {
                        return angular.element('<ul class="menu-pane--sub-menu"></ul>');
                    };
                    /**
                     *
                     * @param {string} currentConfigId
                     * @param {string} targetConfigId
                     * @private
                     */
                    ConfigurationNavigationService.prototype._isParentOfConfigContainer = function (currentConfigId, targetConfigId) {
                        // Check against appConfig if is parent of config container. If not proceed to local check
                        if (this.appConfig.isParentOfConfigContainer(currentConfigId, targetConfigId)) {
                            return true;
                        }
                        // Figure if there are custom config pages declared, and if so check parenthood
                        var currentConfigPage = this._configurationPages.get(currentConfigId);
                        var targetConfigPage = this._configurationPages.get(targetConfigId);
                        return currentConfigPage && targetConfigPage && targetConfigId.indexOf(currentConfigId) === 0;
                    };
                    /**
                     * Creates a navigation item (bullet)
                     *
                     * @param {*} node
                     * @param {number} indentLevel
                     * @param {IScope} $scope
                     * @returns {JQuery}
                     * @private
                     */
                    ConfigurationNavigationService.prototype._createNavLi = function (node, indentLevel, $scope) {
                        var navLi = angular.element("\n                <li>\n                    <a>" + node.displayName + "</a>\n                    <span class=\"open-close-display\">\n                        <i class=\"fa fa-chevron-left closed\"></i>\n                        <i class=\"fa fa-chevron-down opened\"></i>\n                    </span>\n                </li>\n            ");
                        navLi.find('a').attr({
                            'ui-sref': configuration.CONFIG_FORM_STATE_NAME + '({stateName: "' + node.id + '"})'
                        });
                        navLi.attr({
                            'class': 'menu-pane--menu-item', 'ui-sref-active': 'active'
                        });
                        navLi.css({
                            'padding-left': (indentLevel * 10) + 'px'
                        });
                        function openCloseClickHandler() {
                            if (navLi.hasClass(configuration.OPENED_CLASS_NAME)) {
                                navLi.removeClass(configuration.OPENED_CLASS_NAME);
                                navLi.addClass(configuration.CLOSED_CLASS_NAME);
                            }
                            else if (navLi.hasClass(configuration.CLOSED_CLASS_NAME)) {
                                navLi.removeClass(configuration.CLOSED_CLASS_NAME);
                                navLi.addClass(configuration.OPENED_CLASS_NAME);
                            }
                        }
                        // if node has nodes
                        if (node.nodes && Object.keys(node.nodes).length) {
                            // add proper class. closed as default or opened if current state is a child of node.id
                            if (this.$state.params.stateName &&
                                this._isParentOfConfigContainer(node.id, this.$state.params.stateName)) {
                                navLi.addClass(configuration.OPENED_CLASS_NAME);
                            }
                            else if (indentLevel === 1) {
                                navLi.addClass(configuration.OPENED_CLASS_NAME);
                            }
                            else {
                                navLi.addClass(configuration.CLOSED_CLASS_NAME);
                            }
                            // Add click handler
                            navLi.on('click', openCloseClickHandler);
                            // Cleanup
                            $scope.$on('$destroy', function () {
                                navLi.off('click', openCloseClickHandler);
                            });
                        }
                        return navLi;
                    };
                    /**
                     * Renders a single configuration node (bullet). It runs recursively.
                     * @param {{}} node
                     * @param {IScope} $scope
                     * @param {JQuery=} element
                     * @param {number=} indentLevel
                     * @returns {JQuery}
                     * @private
                     */
                    ConfigurationNavigationService.prototype._renderNavNode = function (node, $scope, element, indentLevel) {
                        if (element === void 0) { element = angular.element('<div></div>'); }
                        if (indentLevel === void 0) { indentLevel = 0; }
                        // Create li container if node has displayName and id
                        if (node.id && node.displayName && node.configurable) {
                            element.append(this._createNavLi(node, indentLevel, $scope));
                        }
                        // if nodes keys has length iterate through nodes and run recursively
                        var nodesKeys = node.nodes ? Object.keys(node.nodes) : null;
                        if (node.nodes && nodesKeys.length) {
                            // Create ul
                            var navUl_1 = this._createNavUl();
                            element.append(navUl_1);
                            // For each node run _renderNavNode
                            _.each(node.nodes, _.bind(function (node) {
                                if (node.configurable) {
                                    this._renderNavNode(node, $scope, navUl_1, indentLevel + 1);
                                }
                            }, this));
                        }
                        return element;
                    };
                    /**
                     * Renders navigation bar
                     * @param {jQuery} navContainer
                     * @param {IScope} $scope
                     */
                    ConfigurationNavigationService.prototype.renderNavigation = function (navContainer, $scope) {
                        var configNodeTree = this._getConfigNodesTree();
                        var navElement = this._renderNavNode(configNodeTree, $scope);
                        navElement = this.$compile(navElement)($scope);
                        navContainer.append(navElement);
                    };
                    /**
                     * Returns a configuration page
                     *
                     * @param {string} configurationPageId
                     */
                    ConfigurationNavigationService.prototype.getConfigurationPage = function (configurationPageId) {
                        return this._configurationPages.get(configurationPageId) || null;
                    };
                    ConfigurationNavigationService.$inject = ['assert', 'appConfig', '$compile', '$state'];
                    return ConfigurationNavigationService;
                }());
                configurationNavigation.ConfigurationNavigationService = ConfigurationNavigationService;
                angular.module('Fortscale.layouts.configuration')
                    .service('Fortscale.layouts.configuration.configurationNavigationService', ConfigurationNavigationService);
            })(configurationNavigation = configuration.configurationNavigation || (configuration.configurationNavigation = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var configurationForm;
            (function (configurationForm) {
                'use strict';
                var configurationFormService = (function () {
                    function configurationFormService(assert, $q, stringUtils, $compile, configurationNavigationService) {
                        this.assert = assert;
                        this.$q = $q;
                        this.stringUtils = stringUtils;
                        this.$compile = $compile;
                        this.configurationNavigationService = configurationNavigationService;
                        this._errMsg = 'Fortscale.layouts.configuration.configurationFormService: ';
                    }
                    configurationFormService.prototype.onRenderComplete = function (resolve, reject) {
                    };
                    /**
                     * Renders a custom component/directive
                     *
                     * @param {string} componentName
                     * @param {IScope} $scope
                     * @param {IQResolveReject<JQuery>} resolve
                     * @param {IQResolveReject<any>} reject
                     * @private
                     */
                    configurationFormService.prototype._renderCustomComponent = function (componentName, $scope, resolve, reject) {
                        try {
                            var element = angular.element('<div class="configuration-form-component-wrapper"></div>');
                            var componentSlug = this.stringUtils.toSlugCase(componentName);
                            var component = angular.element("<" + componentSlug + "></" + componentSlug + ">");
                            element.append(component);
                            resolve(this.$compile(element)($scope));
                        }
                        catch (err) {
                            reject(err);
                        }
                    };
                    /**
                     * Checks if a containerId refers to a custom form or a predefined dynamic form
                     *
                     * @param containerId
                     * @returns {any}
                     */
                    configurationFormService.prototype.isCustomForm = function (containerId) {
                        // Validations
                        this.assert.isString(containerId, 'containerId', this._errMsg + "isCustomForm: ");
                        // get configuration page
                        var configurationPage = this.configurationNavigationService.getConfigurationPage(containerId);
                        // if configuration page exists return configurationPage.customPage
                        if (configurationPage) {
                            return !!configurationPage.customPage;
                        }
                        return null;
                    };
                    configurationFormService.prototype.generateConfigContainer = function (containerId) {
                        var configurationPage = this.configurationNavigationService.getConfigurationPage(containerId);
                        if (configurationPage) {
                            return {
                                id: configurationPage.id,
                                displayName: configurationPage.displayName,
                                description: configurationPage.description,
                                doNotShowHeader: configurationPage.doNotShowHeader,
                                formClassNames: configurationPage.formClassNames
                            };
                        }
                        return null;
                    };
                    configurationFormService.prototype.renderCustomPage = function (configurationPageId, $scope) {
                        var _this = this;
                        // Validations
                        var errMsg = this._errMsg + 'renderCustomPage: ';
                        this.assert.isString(configurationPageId, 'configurationPageId', errMsg);
                        this.assert.isObject($scope, '$scope', errMsg);
                        // Create promise and return
                        return this.$q(function (resolve, reject) {
                            // get configuration page
                            var configurationPage = _this.configurationNavigationService.getConfigurationPage(configurationPageId);
                            if (!configurationPage) {
                                return reject("Configuration page for id " + configurationPageId + " was not found.");
                            }
                            // if it has 'component' then render component
                            if (configurationPage.component) {
                                return _this._renderCustomComponent(configurationPage.component, $scope, resolve, reject);
                            }
                        });
                    };
                    ;
                    configurationFormService.$inject = ['assert', '$q', 'stringUtils', '$compile',
                        'Fortscale.layouts.configuration.configurationNavigationService'];
                    return configurationFormService;
                }());
                angular.module('Fortscale.layouts.configuration')
                    .service('Fortscale.layouts.configuration.configurationFormService', configurationFormService);
            })(configurationForm = configuration.configurationForm || (configuration.configurationForm = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                var DecoratorService = (function () {
                    function DecoratorService(assert) {
                        this.assert = assert;
                        // Initialize properties
                        this._decoratorForms = new Map();
                        this._decoratorItems = new Map();
                        this._errMsg = 'Fortscale.layouts.configuration.DecoratorService: ';
                    }
                    /**
                     * Adds a decorator form object
                     * @param {IConfigurationDecoratorService} formDecoratorData
                     * @returns {DecoratorService}
                     */
                    DecoratorService.prototype.addDecoratorForm = function (formDecoratorData) {
                        // Validations
                        var errMsg = this._errMsg + 'addDecoratorForm: ';
                        this.assert.isString(formDecoratorData.containerId, 'formDecoratorData.containerId', errMsg);
                        // Set a new decorator form
                        this._decoratorForms.set(formDecoratorData.containerId, {
                            containerId: formDecoratorData.containerId,
                            showComplex: _.isUndefined(formDecoratorData.showComplex) ? false : !!formDecoratorData.showComplex
                        });
                        return this;
                    };
                    /**
                     * Derives a containerId from config item id by "popping" its last node
                     *
                     * @param {string} itemId
                     * @returns {string}
                     * @private
                     */
                    DecoratorService.prototype._itemIdToFormId = function (itemId) {
                        var nodes = itemId.split('.');
                        nodes.pop();
                        return nodes.join('.');
                    };
                    /**
                     * Returns a form decorator by a config item id
                     *
                     * @param {string} itemId
                     * @returns {IFormDecorator}
                     * @private
                     */
                    DecoratorService.prototype._getFormByItem = function (itemId) {
                        return this.getDecoratorForm(this._itemIdToFormId(itemId));
                    };
                    DecoratorService.prototype._isFormShowComplex = function (itemId) {
                        var formDecorator = this._getFormByItem(itemId);
                        return formDecorator.showComplex;
                    };
                    /**
                     * returns a decorator form object (or null)
                     *
                     * @param containerId
                     * @returns {IFormDecorator|null}
                     */
                    DecoratorService.prototype.getDecoratorForm = function (containerId) {
                        // Validations
                        var errMsg = this._errMsg + 'getDecoratorForm: ';
                        this.assert.isString(containerId, 'containerId', errMsg);
                        return this._decoratorForms.get(containerId) || null;
                    };
                    /**
                     * Adds a decorator item.
                     *
                     * @param {IConfigItemDecoratorData} configItemDecoratorData
                     * @returns {DecoratorService}
                     */
                    DecoratorService.prototype.addDecoratorItem = function (configItemDecoratorData) {
                        // Validations
                        var errMsg = this._errMsg + 'addDecoratorItem: ';
                        this.assert.isString(configItemDecoratorData.id, 'configItemDecoratorData.id', errMsg);
                        this.assert(configItemDecoratorData.id.split(".").length > 1, errMsg +
                            'Config item id have at least two nodes in its namespace, i.e. string.string . Current name: ' +
                            configItemDecoratorData.id);
                        this.assert(this._getFormByItem(configItemDecoratorData.id), errMsg +
                            'Adding config item decorator without first adding a container form decorator is not allowed. id: ' +
                            configItemDecoratorData.id);
                        this.assert.isString(configItemDecoratorData.component, 'configItemDecoratorData.id', errMsg, true);
                        this.assert.isObject(configItemDecoratorData.resolve, 'configItemDecoratorData.resolve', errMsg, true);
                        this.assert.isObject(configItemDecoratorData.data, 'configItemDecoratorData.data', errMsg, true);
                        var id = configItemDecoratorData.id;
                        var containerId = this._itemIdToFormId(id);
                        var showComplex = _.isUndefined(configItemDecoratorData.showComplex) ?
                            this._isFormShowComplex(id) : !!configItemDecoratorData.showComplex;
                        var displayName = configItemDecoratorData.displayName;
                        var description = configItemDecoratorData.description;
                        var component = configItemDecoratorData.component || null;
                        var templateUrl = configItemDecoratorData.templateUrl || null;
                        var replace = !!configItemDecoratorData.replace;
                        var resolve = configItemDecoratorData.resolve || {};
                        var config = configItemDecoratorData.config || {};
                        var data = configItemDecoratorData.data || {};
                        var sort = configItemDecoratorData.sort || 0;
                        var classNames = configItemDecoratorData.classNames || '';
                        var showLoader = _.isUndefined(configItemDecoratorData.showLoader) ? true :
                            !!configItemDecoratorData.showLoader;
                        var decoratorItem = {
                            id: id,
                            containerId: containerId,
                            displayName: displayName,
                            description: description,
                            showComplex: showComplex,
                            component: component,
                            templateUrl: templateUrl,
                            replace: replace,
                            resolve: resolve,
                            config: config,
                            data: data,
                            sort: sort,
                            classNames: classNames,
                            showLoader: showLoader
                        };
                        if (!configItemDecoratorData.displayName) {
                            delete decoratorItem.displayName;
                        }
                        if (!configItemDecoratorData.description) {
                            delete decoratorItem.description;
                        }
                        this._decoratorItems.set(id, decoratorItem);
                        return this;
                    };
                    /**
                     * Returns a decorator item
                     *
                     * @param id
                     * @returns {V|IConfigItemDecorator|null}
                     */
                    DecoratorService.prototype.getDecoratorItem = function (id) {
                        // Validations
                        var errMsg = this._errMsg + 'getDecoratorItem: ';
                        this.assert.isString(id, 'id', errMsg);
                        return this._decoratorItems.get(id) || null;
                    };
                    DecoratorService.prototype.getDecoratedItemsByContainerId = function (containerId) {
                        // Validations
                        var errMsg = this._errMsg + 'getDecoratorForm: ';
                        this.assert.isString(containerId, 'containerId', errMsg);
                        if (!this._decoratorItems.size) {
                            return [];
                        }
                        var configItems = [];
                        var values = Array.from(this._decoratorItems.values());
                        _.each(values, function (value) {
                            if (value.containerId === containerId) {
                                configItems.push(value);
                            }
                        });
                        return configItems;
                    };
                    DecoratorService.$inject = ['assert'];
                    return DecoratorService;
                }());
                angular.module('Fortscale.layouts.configuration')
                    .service('Fortscale.layouts.configuration.decoratorService', DecoratorService);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            'use strict';
            var ConfigurationContoller = (function () {
                function ConfigurationContoller($scope, $element, page, configurationNavigationService, VERSION_NUMBER, VERSION_YEAR, VERSION_COMPANY) {
                    this.$scope = $scope;
                    this.$element = $element;
                    this.page = page;
                    this.configurationNavigationService = configurationNavigationService;
                    this.mainState = {};
                    this.version = {
                        number: VERSION_NUMBER,
                        year: VERSION_YEAR,
                        company: VERSION_COMPANY
                    };
                    this._init();
                }
                ConfigurationContoller.prototype._init = function () {
                    // this._setupSplitterSetting();
                    this.page.setPageTitle('System Configuration');
                    var navContainer = this.$element.find(configuration.NAV_BAR_ELEMENT_SELECTOR); //configuration.scss
                    this.configurationNavigationService.renderNavigation(navContainer, this.$scope);
                };
                ConfigurationContoller.$inject = ['$scope', '$element', 'page',
                    'Fortscale.layouts.configuration.configurationNavigationService',
                    'VERSION_NUMBER', 'VERSION_YEAR', 'VERSION_COMPANY'
                ];
                return ConfigurationContoller;
            }());
            angular.module('Fortscale.layouts.configuration')
                .controller('ConfigurationController', ConfigurationContoller);
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var configurationFormController;
            (function (configurationFormController) {
                'use strict';
                var ConfigurationFormController = (function () {
                    function ConfigurationFormController(appConfig, $scope, $element, $compile, $state, configurationFormService, decoratorService) {
                        var _this = this;
                        this.appConfig = appConfig;
                        this.$scope = $scope;
                        this.$element = $element;
                        this.$compile = $compile;
                        this.$state = $state;
                        this.configurationFormService = configurationFormService;
                        this.decoratorService = decoratorService;
                        // Initialize properties
                        this.configModels = [];
                        this.loader = false;
                        this.error = {
                            display: false, title: '', description: ''
                        };
                        this.submitNewConfig = function () {
                            _this._submitNewConfig();
                        };
                        this._init();
                    }
                    ;
                    /**
                     * Sets the config container and decorated form
                     *
                     * @private
                     */
                    ConfigurationFormController.prototype._setConfigContainer = function () {
                        this.configContainer = this.appConfig.getConfigContainer(this.$state.params['stateName']);
                        this.decoratedForm = this.decoratorService.getDecoratorForm(this.$state.params['stateName']);
                    };
                    /**
                     * returns a list of  IConfigItems relevant to the state
                     * @returns {IConfigItem[]}
                     * @private
                     */
                    ConfigurationFormController.prototype._getConfigItemsByContainer = function () {
                        var _this = this;
                        if (!this.configContainer) {
                            return null;
                        }
                        // Make a list of config item duplications, that belong to this state
                        var configItems = this.appConfig.getConfigItemsByContainer(this.configContainer.id);
                        configItems = _.map(configItems, function (configItem) { return _this.appConfig.duplicateConfigItem(configItem); });
                        return configItems;
                    };
                    /**
                     * Adds derived config item for each config item
                     *
                     * @returns {any[]}
                     * @private
                     */
                    ConfigurationFormController.prototype._populateDerivedConfigItems = function () {
                        var _this = this;
                        if (!this.configItems) {
                            return null;
                        }
                        // Place the derived value config item on each config item. If no config item is found, or its pointing to
                        // itself, derivedConfigItem property will not be set.
                        return _.map(this.configItems, function (configItem) {
                            var derivedConfigItem = _this.appConfig.getDerivedConfigItem(configItem.id);
                            if (derivedConfigItem && configItem.id !== derivedConfigItem.id) {
                                configItem.derivedConfigItem = _.merge({}, derivedConfigItem);
                            }
                            return configItem;
                        });
                    };
                    /**
                     * Merges decorated item into a config items object
                     *
                     * @param {{}} configItemsObject
                     * @param {IConfigItemDecorator} decoratedItem
                     * @private
                     */
                    ConfigurationFormController.prototype._mergeDecoratedFormItem = function (configItemsObject, decoratedItem) {
                        var item = configItemsObject[decoratedItem.id];
                        item = item || { id: decoratedItem.id };
                        _.merge(item, decoratedItem);
                        configItemsObject[item.id] = item;
                    };
                    /**
                     * Merges into config items any decorated items found in decorated form
                     *
                     * @returns {any[]}
                     * @private
                     */
                    ConfigurationFormController.prototype._mergeDecoratedFormItems = function () {
                        var _this = this;
                        if (!this.configItems || !this.configContainer) {
                            return null;
                        }
                        // Merge in decorated items if there's a decorated form
                        var decoratedForm = this.decoratorService.getDecoratorForm(this.configContainer.id);
                        if (decoratedForm) {
                            // Get decorated items
                            var decoratedItems = this.decoratorService.getDecoratedItemsByContainerId(this.configContainer.id);
                            // Convert configItems into an object to make merging in the items easy
                            var configItemsObject_1 = _.keyBy(this.configItems, 'id');
                            // Iterate through decorated items and merge each one into a config item, or a new item.
                            _.each(decoratedItems, function (decoratedItem) { return _this._mergeDecoratedFormItem(configItemsObject_1, decoratedItem); });
                            // Convert configItemsObject back to array
                            return _.values(configItemsObject_1);
                        }
                        return this.configItems;
                    };
                    /**
                     * Adds missing properties to config items, like showComplex and sort
                     *
                     * @returns {any[]}
                     * @private
                     */
                    ConfigurationFormController.prototype._polyfillConfigItems = function () {
                        var _this = this;
                        if (!this.configItems) {
                            return null;
                        }
                        return _.map(this.configItems, function (configItem) {
                            if (_this.decoratedForm) {
                                configItem.showComplex =
                                    _.isUndefined(configItem.showComplex) ? _this.decoratedForm.showComplex : configItem.showComplex;
                            }
                            else {
                                configItem.showComplex = true;
                            }
                            configItem.sort = _.isUndefined(configItem.sort) ? 0 : configItem.sort;
                            return configItem;
                        });
                    };
                    ;
                    /**
                     * Sorts config items by 'sort'
                     *
                     * @returns {any[]}
                     * @private
                     */
                    ConfigurationFormController.prototype._sortConfigItems = function () {
                        if (!this.configItems) {
                            return null;
                        }
                        return _.sortBy(this.configItems, 'sort');
                    };
                    /**
                     * Gets the relevant config items. extracts derived config items. Merges in decorated items.
                     *
                     * @private
                     */
                    ConfigurationFormController.prototype._setConfigItems = function () {
                        this.configItems = this._getConfigItemsByContainer();
                        this.configItems = this._populateDerivedConfigItems();
                        this.configItems = this._mergeDecoratedFormItems();
                        this.configItems = this._polyfillConfigItems();
                        this.configItems = this._sortConfigItems();
                    };
                    ConfigurationFormController.prototype._submitNewConfig = function () {
                        var _this = this;
                        var ctrl = this;
                        ctrl.loader = true;
                        var configItemsList = [];
                        _.each(Object.keys(this.configModels), function (configModelKey) {
                            var value = _this.configModels[configModelKey];
                            var configItem = _this.appConfig.getConfigItem(configModelKey);
                            if (configItem && configItem.value !== value) {
                                var item = { key: configModelKey, value: value };
                                if (configItem.meta) {
                                    item.meta = configItem.meta;
                                }
                                configItemsList.push(item);
                            }
                        });
                        if (configItemsList.length) {
                            this.appConfig.updateConfigItems(configItemsList)
                                .then(function () {
                                ctrl.$state.go(ctrl.$state.current, {
                                    stateName: ctrl.$state.params['stateName']
                                }, { reload: true });
                            })
                                .catch(function (err) {
                                ctrl.loader = false;
                                ctrl.error.display = true;
                                ctrl.error.title = 'Update Error';
                                ctrl.error.description = 'There was an unknown server error. Could not update configuration.';
                                console.error(err);
                            });
                        }
                        else {
                            ctrl.$state.go(ctrl.$state.current, {
                                stateName: ctrl.$state.params['stateName']
                            }, { reload: true });
                        }
                    };
                    ConfigurationFormController.prototype._init = function () {
                        // determine flow
                        var _this = this;
                        // Custom form flow
                        if (this.configurationFormService.isCustomForm(this.$state.params['stateName'])) {
                            // when custom form, generate a logical config container
                            this.configContainer = this.configurationFormService.generateConfigContainer(this.$state.params['stateName']);
                            this.configurationFormService.renderCustomPage(this.$state.params['stateName'], this.$scope)
                                .then(function (component) {
                                var customWrapper = _this.$element.find('.form-pane--custom-form');
                                customWrapper.append(component);
                            })
                                .catch(function (err) {
                                console.error("Failed to render custom form for state: " + _this.$state.params['stateName'], err);
                            });
                        }
                        else {
                            this._setConfigContainer();
                            if (!this.configContainer) {
                                throw new RangeError('Trying to render a form that is not declared dynamically via ' +
                                    'appConfig.provider, and not declared statically via configurationNavigation.service');
                            }
                            this._setConfigItems();
                        }
                    };
                    ConfigurationFormController.$inject = ['appConfig', '$scope', '$element', '$compile', '$state',
                        'Fortscale.layouts.configuration.configurationFormService',
                        'Fortscale.layouts.configuration.decoratorService'];
                    return ConfigurationFormController;
                }());
                angular.module('Fortscale.layouts.configuration')
                    .controller('ConfigurationFormController', ConfigurationFormController);
            })(configurationFormController = configuration.configurationFormController || (configuration.configurationFormController = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    var IS_NOT_OPTIONAL = false;
    function fsConfigAffectedItemsDirective() {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // Link function logic
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsConfigAffectedItemsController($element, $scope, appConfig, assert) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            ctrl.appConfig = appConfig;
            ctrl.assert = assert;
            ctrl.listOpened = false;
            ctrl.toggleList = function (evt) {
                ctrl._toggleList(evt);
            };
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsConfigAffectedItemsController.prototype, {
            _errMsg: 'Fortscale.appConfig: fsConfigAffectedItems.directive: ',
            /**
             * Validates configItem argument. Makes sure it exists, and is instance of ConfigItem.
             *
             * @private
             */
            _validateConfigItem: function () {
                this.assert.isObject(this.configItem, 'configItem', this._errMsg + 'Arguments: ', IS_NOT_OPTIONAL);
                this.assert(this.appConfig.isConfigItem(this.configItem), this._errMsg + 'Arguments: ConfigItem must be an instance of ConfigItem.', TypeError);
            },
            /**
             * Starts validations
             *
             * @private
             */
            _validations: function () {
                this._validateConfigItem();
            },
            /**
             * Initiates affectedItems list.
             *
             * @private
             */
            _initAffectedItemsList: function () {
                this.affectedItems = this.appConfig.getAffectedConfigItems(this.configItem.id);
                this.affectedItems = _.map(this.affectedItems, _.bind(function (configItem) {
                    var dupConfigContainer = this.appConfig.duplicateConfigItem(configItem);
                    dupConfigContainer.derivedFrom = this.appConfig.getDerivedConfigItem(configItem.id);
                    return dupConfigContainer;
                }, this));
            },
            /**
             * Toggles 'closed\ and 'opened' classes
             *
             * @param {jQuery.Event} evt
             */
            _toggleList: function (evt) {
                var el = angular.element(evt.currentTarget);
                if (el.hasClass('closed')) {
                    el.removeClass('closed');
                    el.addClass('opened');
                    this.listOpened = true;
                }
                else {
                    el.removeClass('opened');
                    el.addClass('closed');
                    this.listOpened = false;
                }
            },
            /**
             * Init
             */
            init: function init() {
                // Validations
                this._validations();
                this._initAffectedItemsList();
            }
        });
        FsConfigAffectedItemsController.$inject = ['$element', '$scope', 'appConfig', 'assert'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/configuration/components/fs-config-affected-items.view.html',
            scope: {},
            link: linkFn,
            controller: FsConfigAffectedItemsController,
            controllerAs: 'ctrl',
            bindToController: {
                configItem: '='
            }
        };
    }
    fsConfigAffectedItemsDirective.$inject = [];
    angular.module('Fortscale.appConfig')
        .directive('fsConfigAffectedItems', fsConfigAffectedItemsDirective);
}());

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                angular.module('Fortscale.layouts.configuration')
                    .run(['Fortscale.layouts.configuration.decoratorService', function (decoratorService) {
                        decoratorService
                            .addDecoratorForm({
                            containerId: 'system.logEmail'
                        })
                            .addDecoratorItem({
                            id: 'system.logEmail.subscribers',
                            component: 'usersList'
                        });
                    }]);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                angular.module('Fortscale.layouts.configuration')
                    .run(['Fortscale.layouts.configuration.decoratorService', function (decoratorService) {
                        decoratorService
                            .addDecoratorForm({
                            containerId: 'system.email'
                        })
                            .addDecoratorItem({
                            id: 'system.email.auth',
                            component: 'dropdown',
                            data: {
                                items: [
                                    {
                                        value: 'ssl',
                                        label: 'SSL'
                                    },
                                    {
                                        value: 'tsl',
                                        label: 'TSL'
                                    },
                                    {
                                        value: 'none',
                                        label: 'None'
                                    }
                                ],
                                defaultSelect: 'none'
                            }
                        })
                            .addDecoratorItem({
                            id: 'system.email.test',
                            component: 'testEmail'
                        });
                    }]);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));
/*
 {
 ssl: 'SSL',
 tsl: 'TSL',
 none: 'None'
 }
 */

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                angular.module('Fortscale.layouts.configuration')
                    .run(['Fortscale.layouts.configuration.decoratorService', function (decoratorService) {
                        decoratorService
                            .addDecoratorForm({
                            containerId: 'system.siem'
                        })
                            .addDecoratorItem({
                            id: 'system.siem.type',
                            component: 'dropdown',
                            data: {
                                items: [
                                    {
                                        value: 'splunk',
                                        label: 'Splunk'
                                    },
                                    {
                                        value: 'qradar',
                                        label: 'QRadar'
                                    }
                                ],
                                defaultSelect: 'splunk'
                            }
                        });
                    }]);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                angular.module('Fortscale.layouts.configuration')
                    .run(['Fortscale.layouts.configuration.decoratorService', function (decoratorService) {
                        decoratorService
                            .addDecoratorForm({
                            containerId: 'system.alertsEmail'
                        })
                            .addDecoratorItem({
                            id: 'system.alertsEmail.settings',
                            component: 'alertsEmail',
                            replace: true
                        });
                    }]);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var decorator;
            (function (decorator) {
                'use strict';
                angular.module('Fortscale.layouts.configuration')
                    .run(['Fortscale.layouts.configuration.decoratorService', 'tagsUtils',
                    function (decoratorService, tagsUtils) {
                        decoratorService
                            .addDecoratorForm({
                            containerId: 'system.syslogforwarding'
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.ip',
                            component: 'ip'
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.forwardingtype',
                            component: 'checkbox',
                            config: {
                                radioBox: true,
                                horizontal: true
                            },
                            data: {
                                items: [
                                    {
                                        value: 'ALERT',
                                        label: 'Alerts'
                                    }, {
                                        value: 'ALERT_AND_INDICATORS',
                                        label: 'Alerts and Indicators'
                                    }
                                ],
                                checked: ['ALERT']
                            }
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.messageformat',
                            component: 'checkbox',
                            config: {
                                radioBox: true,
                                horizontal: true
                            },
                            data: {
                                items: [
                                    {
                                        value: 'RFC_3164',
                                        label: 'RFC 3164'
                                    }, {
                                        value: 'RFC_5424',
                                        label: 'RFC 5424'
                                    }
                                ],
                                checked: ['RFC_3164']
                            }
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.usertypes',
                            component: 'checkbox',
                            config: {
                                selectAll: true
                            },
                            resolve: {
                                items: function () {
                                    return tagsUtils.getTags()
                                        .then(function (tags) {
                                        return _.map(tags.data, function (tag) {
                                            return {
                                                value: tag.name,
                                                label: tag.displayName
                                            };
                                        });
                                    })
                                        .catch(function (err) {
                                        console.error('Fortscale.layouts.configuration: There was an error trying to fetch tags', err);
                                        return [];
                                    });
                                }
                            }
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.alertseverity',
                            component: 'severity'
                        })
                            .addDecoratorItem({
                            id: 'system.syslogforwarding.enabled',
                            data: {
                                defaultValue: false,
                                trueLabel: 'Yes',
                                falseLabel: 'No'
                            }
                        });
                        //.addDecoratorItem({
                        //    id: 'system.syslogforwarding.forwardHistoricalAlerts',
                        //    displayName: 'Forward Historical Alerts',
                        //    replace: true,
                        //    component: 'forwardHistoricalAlerts'
                        //});
                    }]);
            })(decorator = configuration.decorator || (configuration.decorator = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                var MAX_ITERATIONS_DEFAULT = 10;
                var ConfigurationRenderer = (function () {
                    function ConfigurationRenderer(MAIN_INPUT_SELECTOR) {
                        this.MAIN_INPUT_SELECTOR = MAIN_INPUT_SELECTOR;
                    }
                    /**
                     * Validates configItem
                     *
                     * @private
                     */
                    ConfigurationRenderer.prototype._validations = function () {
                        if (!this.controllerName) {
                            throw new ReferenceError("ConfigurationRendererClass: controllerName must be instantiated.");
                        }
                        var errMsg = this.controllerName + ": validations: ";
                        if (!this.assert) {
                            throw new ReferenceError(errMsg + "assert service must be injected");
                        }
                        this.assert.isObject(this.configItem, 'configItem', errMsg);
                        this.assert.isObject(this.configItem.data, 'configItem.data', errMsg);
                        this.assert.isObject(this.configItem.config, 'configItem.config', errMsg);
                        this.assert.isObject(this.$scope, '$scope', errMsg, true);
                        this.assert.isObject(this.$element, '$element', errMsg, true);
                        this.assert.isFunction(this.onComponentInit, 'onComponentInit', errMsg);
                        this.assert.isString(this.MAIN_INPUT_SELECTOR, 'MAIN_INPUT_SELECTOR', errMsg);
                    };
                    Object.defineProperty(ConfigurationRenderer.prototype, "ngModel", {
                        /**
                         * Retuns the ngModel of the element's main input. This input is the one attached to the configuration form.
                         *
                         * @returns {ng.INgModelController}
                         * @private
                         */
                        get: function () {
                            if (this._ngModel) {
                                return this._ngModel;
                            }
                            // Get the ngModel
                            var el = this.$element.find(this.MAIN_INPUT_SELECTOR);
                            this._ngModel = el.controller('ngModel');
                            return this._ngModel;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(ConfigurationRenderer.prototype, "configItem", {
                        get: function () {
                            return this._configItem;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ConfigurationRenderer.prototype.setMaxIterations = function (value) {
                        this._maxIterations = value;
                    };
                    /**
                     * A repeater that tries to get the ngModel. Once (iteratively) acquired, it fires local callback,
                     * ond onComponentInit
                     *
                     * @param {Function} cbFn
                     * @param {number=} iter
                     * @private
                     */
                    ConfigurationRenderer.prototype._onInitRepeater = function (cbFn, iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > this._maxIterations) {
                            console.error(this.$element);
                            throw new Error(this.controllerName + ": After " + this._maxIterations + " tries, failed to get ngModel from element.");
                        }
                        this.$scope.$applyAsync(function () {
                            if (!_this.ngModel) {
                                iter++;
                                return _this._onInitRepeater(cbFn, iter);
                            }
                            // Fire callback (if exists)
                            if (cbFn) {
                                cbFn();
                            }
                            // Fire directive callback
                            _this.onComponentInit({ ngModelController: _this.ngModel });
                        });
                    };
                    /**
                     * Updates ng model
                     * @param {*} value
                     * @private
                     */
                    ConfigurationRenderer.prototype._updateNgModel = function (value) {
                        // Set the ng model value
                        this.ngModel.$setViewValue(value);
                        this.ngModel.$setDirty();
                        this.ngModel.$render();
                    };
                    /**
                     * Handler fired by angular as init function.
                     */
                    ConfigurationRenderer.prototype.$onInit = function () {
                        this._validations();
                        // Set defaults
                        this.setMaxIterations(MAX_ITERATIONS_DEFAULT);
                    };
                    /**
                     * Listsener for element ready.
                     *
                     * @param cbFn
                     */
                    ConfigurationRenderer.prototype.onElementReady = function (cbFn) {
                        var _this = this;
                        // Initiate on init repeater which should get the ngModel
                        this.$element.ready(function () {
                            _this._onInitRepeater(cbFn);
                        });
                    };
                    return ConfigurationRenderer;
                }());
                renderer.ConfigurationRenderer = ConfigurationRenderer;
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                function fsConfigRendererDirective($injector, $compile, stringUtils, appConfig, $q) {
                    /**
                     *
                     * @param {object} scope
                     * @param {object} element
                     * @param {object} attrs
                     */
                    function linkFn(scope, element, attrs, ctrl) {
                        ctrl.$scope = scope;
                        ctrl.$element = element;
                        ctrl.linkInit();
                    }
                    var FsConfigRendererController = (function () {
                        function FsConfigRendererController($scope, $element) {
                            this.$scope = $scope;
                            this.$element = $element;
                            this.isLoading = true;
                        }
                        /**
                         * returns the components name (definition)
                         *
                         * @returns {string}
                         * @private
                         */
                        FsConfigRendererController.prototype._getComponentDef = function () {
                            var type = this.configItem.type;
                            var component = this.configItem.component || type;
                            return component || null;
                        };
                        /**
                         * Takes the component definition name and converts it to a directive name (i.e. helloWorld will be
                         * hello-world)
                         *
                         * @param {string} componentDef
                         * @returns {string}
                         * @private
                         */
                        FsConfigRendererController.prototype._getNormalizedComponentName = function (componentDef) {
                            var componentName = 'configurationRenderers' + componentDef.charAt(0).toUpperCase() +
                                componentDef.substring(1);
                            return stringUtils.toSlugCase(componentName);
                        };
                        /**
                         * Creates and compiles a component element
                         *
                         * @param {string} normalizedComponentName
                         * @returns {IAugmentedJQuery}
                         * @private
                         */
                        FsConfigRendererController.prototype._createComponentElement = function (normalizedComponentName) {
                            var componentElement = angular.element("<" + normalizedComponentName + "\n                    config-item=\"::configItem\"\n                    config-form-ctrl=\"::configFormCtrl\"\n                    form-model-ctrl=\"::configFormModel\"\n                    on-component-init=\"::$ctrl.onComponentInit(ngModelController)\"></" + normalizedComponentName + ">");
                            // Create new local scope to pass parameters for the compile method.
                            var localScope = this.$scope.$root.$new();
                            // Items can be derived from scope chain, or supplied directly
                            localScope.configItem = this.configItem || this.$scope.configItem;
                            localScope.configFormCtrl = this.formController || this.$scope.configFormCtrl;
                            localScope.configFormModel = this.formModelController || this.$scope.configFormModel;
                            localScope.$ctrl = this;
                            // Compile element
                            componentElement = $compile(componentElement)(localScope);
                            // Cleanup local scope
                            localScope = null;
                            // Return element.
                            return componentElement;
                        };
                        /**
                         * Adds a formatter to an ngModelController
                         *
                         * @param {INgModelController} ngModelController
                         * @private
                         */
                        FsConfigRendererController.prototype._addFormatter = function (ngModelController) {
                            if (!this.configItem.formatter) {
                                return;
                            }
                            var formatter = appConfig.getFormatter(this.configItem.formatter);
                            // Inject formatter into ngModel
                            if (!formatter) {
                                console.warn('You are trying to add an undeclared formatter: ' + this.configItem.formatter + '\r\n' +
                                    'Please use appConfigProvider.addFormatter to add required validators.');
                                return;
                            }
                            ngModelController.$formatters.push(formatter);
                        };
                        /**
                         * Adds a validator to an ngModelController
                         *
                         * @param {INgModelController} ngModelController
                         * @param {function} formatter
                         * @param {string} validatorName
                         * @private
                         */
                        FsConfigRendererController.prototype._addValidator = function (ngModelController, formatter, validatorName) {
                            var validator = appConfig.getValidator(validatorName);
                            if (validator === null) {
                                console.warn('You are trying to add an undeclared validator: ' + validatorName + '\r\n' +
                                    'Please use appConfigProvider.addValidator to add required validators.');
                                return;
                            }
                            var ctrl = this;
                            // Add validator
                            ngModelController.$validators[validatorName] = function (modelValue, viewValue) {
                                // Value should be modelValue or viewValue or configItem.value
                                var value = modelValue !== undefined ? modelValue : viewValue;
                                value = value !== undefined ? value : ctrl.configItem.value;
                                // run formatter
                                if (formatter) {
                                    value = formatter(value);
                                }
                                // Run validator
                                return validator(value);
                            };
                        };
                        /**
                         * Adds validators to an ngModel controller
                         *
                         * @param {INgModelController} ngModelController
                         * @private
                         */
                        FsConfigRendererController.prototype._addValidators = function (ngModelController) {
                            var _this = this;
                            var formatter = appConfig.getFormatter(this.configItem.formatter);
                            _.each(this.configItem.validators, function (validatorName) { return _this._addValidator(ngModelController, formatter, validatorName); });
                        };
                        /**
                         * Starts loader icon
                         *
                         * @private
                         */
                        FsConfigRendererController.prototype._initLoader = function () {
                            this.isLoading = true;
                        };
                        /**
                         * removes lodeer function
                         *
                         * @private
                         */
                        FsConfigRendererController.prototype._closeLoader = function () {
                            this.isLoading = false;
                        };
                        /**
                         * Iterates through resolve functions and returns an array of key-reolve objects to be digested
                         *
                         * @returns {IPromise<{}>|IPromise<T>}
                         * @private
                         */
                        FsConfigRendererController.prototype._resolveConfigItem = function () {
                            if (this.configItem.resolve && this.configItem.showLoader &&
                                Object.keys(this.configItem.resolve).length) {
                                this._initLoader();
                            }
                            return $q.all(_.map(this.configItem.resolve, function (resolveFn, key) {
                                return resolveFn()
                                    .then(function (resolve) {
                                    return {
                                        key: key, resolve: resolve
                                    };
                                });
                            }));
                        };
                        /**
                         * Takes all resolves and places them on the config item's data object to be passed to the component
                         *
                         * @param {{key: string, resolve: any}[]} resolves
                         * @private
                         */
                        FsConfigRendererController.prototype._digestResolves = function (resolves) {
                            var _this = this;
                            _.each(resolves, function (resolveWrapper) {
                                _this.configItem.data[resolveWrapper.key] = resolveWrapper.resolve;
                            });
                        };
                        /**
                         * Component will use this delegate to inform they are finished
                         * This method adds validators and formatters, and registers with the form
                         *
                         * @param ngModelController
                         * @private
                         */
                        FsConfigRendererController.prototype.onComponentInit = function (ngModelController) {
                            if (ngModelController) {
                                this._addFormatter(ngModelController);
                                this._addValidators(ngModelController);
                                this.formModelController.$addControl(ngModelController);
                                ngModelController.$validate();
                            }
                            this._closeLoader();
                        };
                        /**
                         * Renders a config item component
                         *
                         * @private
                         */
                        FsConfigRendererController.prototype._renderComponent = function () {
                            var _this = this;
                            // Srart the rendering flow
                            return this._resolveConfigItem()
                                .then(this._digestResolves.bind(this))
                                .then(function () {
                                var componentDef = _this._getComponentDef();
                                if (componentDef) {
                                    var normalizedComponentName = _this._getNormalizedComponentName(componentDef);
                                    var componentWrapper = _this.$element.find('.component-wrapper');
                                    var componentElement = _this._createComponentElement(normalizedComponentName);
                                    componentWrapper.append(componentElement);
                                    return componentWrapper;
                                }
                                return null;
                            });
                        };
                        /**
                         * Init
                         */
                        FsConfigRendererController.prototype.linkInit = function () {
                            var _this = this;
                            // We use element.ready and applyAsync to let angular finish its digest cycle so the
                            // template will be rendered.
                            this.$element.ready(function () {
                                _this.$scope.$applyAsync(function () {
                                    // Setup config models list
                                    _this.formController.configModels[_this.configItem.id] = _this.configItem.value;
                                    // render config item component
                                    _this._renderComponent()
                                        .catch(function (err) {
                                        console.log(err);
                                        _this._closeLoader();
                                    });
                                });
                            });
                        };
                        FsConfigRendererController.$inject = ['$scope', '$element'];
                        return FsConfigRendererController;
                    }());
                    FsConfigRendererController.$inject = ['$element', '$scope'];
                    return {
                        restrict: 'E',
                        templateUrl: 'app/layouts/configuration/renderers/fs-config-renderer.view.html',
                        link: linkFn,
                        controller: FsConfigRendererController,
                        controllerAs: '$ctrl',
                        bindToController: {
                            configItem: '<',
                            formController: '<',
                            formModelController: '<'
                        }
                    };
                }
                fsConfigRendererDirective.$inject = ['$injector', '$compile', 'stringUtils', 'appConfig', '$q'];
                angular.module('Fortscale.layouts.configuration')
                    .directive('fsConfigRenderer', fsConfigRendererDirective);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var IntegerRendererController = (function () {
                    function IntegerRendererController($scope, $element) {
                        this.$scope = $scope;
                        this.$element = $element;
                    }
                    IntegerRendererController.prototype._onInitRepeater = function (iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > 10) {
                            console.error(this.$element);
                            throw new Error('configurationRenderersInteger: After 10 tries, failed to get ngModel from element.');
                        }
                        this.$scope.$applyAsync(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            if (!ngModel) {
                                iter++;
                                return _this._onInitRepeater(iter);
                            }
                            _this.onComponentInit({ ngModelController: ngModel });
                        });
                    };
                    IntegerRendererController.prototype.$onInit = function () {
                        var _this = this;
                        this.$element.ready(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            _this._onInitRepeater();
                        });
                    };
                    IntegerRendererController.$inject = ['$scope', '$element'];
                    return IntegerRendererController;
                }());
                var integerRendererComponent = {
                    template: "<input type=\"number\" ng-model=\"$ctrl.configFormCtrl.configModels[$ctrl.configItem.id]\" name=\"fields.{{$ctrl.configItem.id}}\" ng-value=\"$ctrl.configItem.value\" step=\"any\">",
                    controller: IntegerRendererController,
                    bindings: {
                        configItem: '<',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersInteger', integerRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var StringRendererController = (function () {
                    function StringRendererController($scope, $element) {
                        this.$scope = $scope;
                        this.$element = $element;
                    }
                    StringRendererController.prototype._onInitRepeater = function (iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > 10) {
                            console.error(this.$element);
                            throw new Error('configurationRenderersString: After 10 tries, failed to get ngModel from element.');
                        }
                        this.$scope.$applyAsync(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            if (!ngModel) {
                                iter++;
                                return _this._onInitRepeater(iter);
                            }
                            _this.onComponentInit({ ngModelController: ngModel });
                        });
                    };
                    StringRendererController.prototype.$onInit = function () {
                        var _this = this;
                        this.$element.ready(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            _this._onInitRepeater();
                        });
                    };
                    StringRendererController.$inject = ['$scope', '$element'];
                    return StringRendererController;
                }());
                var stringRendererComponent = {
                    template: "<input type=\"text\" ng-model=\"$ctrl.configFormCtrl.configModels[$ctrl.configItem.id]\" name=\"fields.{{$ctrl.configItem.id}}\" ng-value=\"$ctrl.configItem.value\">",
                    controller: StringRendererController,
                    bindings: {
                        configItem: '<',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersString', stringRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var PasswordRendererController = (function () {
                    function PasswordRendererController($scope, $element) {
                        this.$scope = $scope;
                        this.$element = $element;
                    }
                    PasswordRendererController.prototype._onInitRepeater = function (iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > 10) {
                            console.error(this.$element);
                            throw new Error('configurationRenderersPassword: After 10 tries, failed to get ngModel from element.');
                        }
                        this.$scope.$applyAsync(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            if (!ngModel) {
                                iter++;
                                return _this._onInitRepeater(iter);
                            }
                            _this.onComponentInit({ ngModelController: ngModel });
                        });
                    };
                    PasswordRendererController.prototype.$onInit = function () {
                        var _this = this;
                        this.$element.ready(function () {
                            var el = _this.$element.find('input');
                            var ngModel = el.controller('ngModel');
                            _this._onInitRepeater();
                        });
                    };
                    PasswordRendererController.$inject = ['$scope', '$element'];
                    return PasswordRendererController;
                }());
                var passwordRendererComponent = {
                    template: "<input type=\"password\" ng-model=\"$ctrl.configFormCtrl.configModels[$ctrl.configItem.id]\" name=\"fields.{{$ctrl.configItem.id}}\" ng-value=\"$ctrl.configItem.value\">",
                    controller: PasswordRendererController,
                    bindings: {
                        configItem: '<',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersPassword', passwordRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var MAIN_INPUT_SELECTOR = 'input.hidden-input';
                var IpRendererController = (function (_super) {
                    __extends(IpRendererController, _super);
                    function IpRendererController($scope, $element, assert) {
                        _super.call(this, MAIN_INPUT_SELECTOR);
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.controllerName = 'IpRendererController';
                        // Holds tab indices for ip elements
                        this.tabIndices = [0, 1, 2, 3];
                    }
                    Object.defineProperty(IpRendererController.prototype, "_csv", {
                        get: function () {
                            return _.map(this.octets).join('.');
                        },
                        enumerable: true,
                        configurable: true
                    });
                    IpRendererController.prototype._applyConfigItemValue = function () {
                        var _this = this;
                        var octets = this.configItem.value.split('.');
                        _.each(octets, function (octet, index) { return _this.octets[index] = parseInt(octet); });
                    };
                    IpRendererController.prototype._onElementReady = function () {
                        if (this.configItem.value !== undefined && _.isString(this.configItem.value)) {
                            this._applyConfigItemValue();
                        }
                    };
                    IpRendererController.prototype.ipChangeHandler = function () {
                        this._updateNgModel(this._csv);
                    };
                    IpRendererController.prototype.$onInit = function () {
                        _super.prototype.$onInit.call(this);
                        this.onElementReady(this._onElementReady.bind(this));
                    };
                    IpRendererController.$inject = ['$scope', '$element', 'assert'];
                    return IpRendererController;
                }(renderer.ConfigurationRenderer));
                var ipRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/ip/ip.renderer.html',
                    controller: IpRendererController,
                    bindings: {
                        _configItem: '<configItem',
                        configFormCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersIp', ipRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var MAIN_INPUT_SELECTOR = '.hidden-input';
                var SeverityRendererController = (function (_super) {
                    __extends(SeverityRendererController, _super);
                    function SeverityRendererController($scope, $element, assert) {
                        _super.call(this, MAIN_INPUT_SELECTOR);
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.controllerName = 'SeverityRendererController';
                    }
                    /**
                     * Initiates Severities collection
                     * @private
                     */
                    SeverityRendererController.prototype._initSeverities = function () {
                        this.severities = [
                            {
                                value: 'Critical',
                                label: 'Critical'
                            },
                            {
                                value: 'High',
                                label: 'High'
                            },
                            {
                                value: 'Medium',
                                label: 'Medium'
                            },
                            {
                                value: 'Low',
                                label: 'Low'
                            }
                        ];
                    };
                    /**
                     * Iterates all severities. Sets checked to false.
                     * @private
                     */
                    SeverityRendererController.prototype._uncheckAllSeverities = function () {
                        _.each(this.severities, function (severity) { return severity.checked = false; });
                    };
                    /**
                     * If received config item has a (string) value, delimit it and for each item, set Severity to checked-true
                     * @private
                     */
                    SeverityRendererController.prototype._initConfigItemValue = function () {
                        var _this = this;
                        if (_.isString(this.configItem.value) && this.configItem.value) {
                            // Get the checked severity values list
                            var checkedSeverityValues = this.configItem.value.split(',');
                            // Iterate over checkedSeverityValues, find ISeverityRendererItem and change its checked value
                            _.each(checkedSeverityValues, function (checkedSeverityValue) {
                                var severity = _.filter(_this.severities, function (severity) { return severity.value === checkedSeverityValue; });
                                if (severity[0]) {
                                    severity[0].checked = true;
                                }
                            });
                        }
                    };
                    /**
                     * Returns a CSV of the checked items
                     *
                     * @returns {string}
                     * @private
                     */
                    SeverityRendererController.prototype._getCSV = function () {
                        // Return CSV of values
                        return _.map(
                        // Filter in only checked items
                        _.filter(this.severities, function (severity) { return severity.checked; }), 'value').join(',');
                    };
                    ;
                    /**
                     * Gets CSV and updates the ngModel
                     *
                     * @param {ISeverityRendererItem}severity
                     */
                    SeverityRendererController.prototype.changeSeverity = function (severity) {
                        var csv = this._getCSV();
                        this._updateNgModel(csv);
                    };
                    SeverityRendererController.prototype.$onInit = function () {
                        this._initSeverities();
                        this._uncheckAllSeverities();
                        this._initConfigItemValue();
                        _super.prototype.$onInit.call(this);
                        this.onElementReady();
                    };
                    SeverityRendererController.$inject = ['$scope', '$element', 'assert'];
                    return SeverityRendererController;
                }(renderer.ConfigurationRenderer));
                var SeverityRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/severity/severity.renderer.html',
                    controller: SeverityRendererController,
                    bindings: {
                        _configItem: '<configItem',
                        configFormCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersSeverity', SeverityRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var MAIN_INPUT_SELECTOR = 'input.hidden-input';
                var HORIZONTAL_CLASS_NAME = 'horizontal-checkbox';
                /**
                 * CLASS CheckboxRendererController
                 * Renderer for checkboxes
                 */
                var CheckboxRendererController = (function (_super) {
                    __extends(CheckboxRendererController, _super);
                    function CheckboxRendererController($scope, $element, assert) {
                        _super.call(this, MAIN_INPUT_SELECTOR);
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.controllerName = 'CheckboxRendererController';
                    }
                    Object.defineProperty(CheckboxRendererController.prototype, "_isRadioBox", {
                        /**
                         * Returns a boolean value stating if this checkbox is a radio box
                         *
                         * @returns {boolean}
                         * @private
                         */
                        get: function () {
                            return !!this.configItem.config.radioBox;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(CheckboxRendererController.prototype, "_csv", {
                        /**
                         * Extracts the csv by filtering checked items
                         *
                         * @returns {string}
                         * @private
                         */
                        get: function () {
                            return _.map(_.filter(this.items, function (item) { return item.checked; }), function (item) { return item.value; })
                                .join(',');
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * Checks all items that are in the configItem value
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._populateItemsFromCSV = function () {
                        var _this = this;
                        var items = this.configItem.value.split(',');
                        _.each(items, function (item) {
                            var localItem = _.find(_this.items, { value: item.trim() });
                            if (localItem) {
                                localItem.checked = true;
                            }
                        });
                    };
                    /**
                     * Validates configItem
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._checkboxValidations = function () {
                        var _this = this;
                        var errMsg = this.controllerName + ": validations: ";
                        this.assert.isArray(this.configItem.data.items, 'configItem.data.items', errMsg);
                        _.each(this.configItem.data.items, function (item, index) {
                            _this.assert.isString(item.value, "configItem.data.items[" + index + "].value", errMsg);
                            _this.assert.isString(item.label, "configItem.data.items[" + index + "].label", errMsg, true);
                        });
                    };
                    /**
                     * Iterates through all items and sets 'label' and 'checked'
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._normalizeItems = function () {
                        _.each(this.items, function (item) {
                            item.label = item.label || item.value;
                            item.checked = !!item.checked;
                        });
                    };
                    /**
                     * Updates the model
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._updateModel = function () {
                        // Get the csv
                        var csv = this._csv;
                        this._updateNgModel(csv);
                    };
                    /**
                     * Changes items state
                     *
                     * @param {ICheckboxItem} item
                     * @param {boolean} state
                     * @private
                     */
                    CheckboxRendererController.prototype._changeItemState = function (item, state) {
                        item.checked = state;
                    };
                    /**
                     * Unchecks all items
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._uncheckAllItems = function () {
                        var _this = this;
                        _.each(this.items, function (item) {
                            _this._changeItemState(item, false);
                        });
                    };
                    /**
                     * Checks all items.
                     *
                     * @private
                     */
                    CheckboxRendererController.prototype._checkAllItems = function () {
                        var _this = this;
                        _.each(this.items, function (item) {
                            _this._changeItemState(item, true);
                        });
                    };
                    /**
                     * Sets a default value. Should only happen when the config item has no value of its own.
                     * @private
                     */
                    CheckboxRendererController.prototype._setDefaultValue = function () {
                        var _this = this;
                        if (this.configItem.data.checked && this.configItem.data.checked.length) {
                            var itemsToCheck = _.filter(this.items, function (item) {
                                return _this.configItem.data.checked.indexOf(item.value) !== -1;
                            });
                            _.each(itemsToCheck, function (item) {
                                _this.changeItem(item);
                            });
                        }
                        else if (this._isRadioBox) {
                            this.changeItem(this.items[0]);
                        }
                    };
                    CheckboxRendererController.prototype._initConfig = function () {
                        if (this.configItem.config.horizontal) {
                            this.$element.addClass(HORIZONTAL_CLASS_NAME);
                        }
                    };
                    CheckboxRendererController.prototype._isAllSelected = function () {
                        return _.every(this.items, 'checked');
                    };
                    CheckboxRendererController.prototype._setSelectAllCheckboxState = function () {
                        this.allItemsChecked = this._isAllSelected();
                    };
                    /**
                     * Item check handler. Changes model value. Sets the correct csv.
                     * @param {ICheckboxItem} item
                     */
                    CheckboxRendererController.prototype.changeItem = function (item) {
                        if (this._isRadioBox) {
                            this._uncheckAllItems();
                            this._changeItemState(item, true);
                        }
                        this._updateModel();
                        this._setSelectAllCheckboxState();
                    };
                    /**
                     * A handler for Select All checkbox. If on, check all items. If off uncheck all items. Then update model.
                     */
                    CheckboxRendererController.prototype.selectAllHandler = function () {
                        if (this.allItemsChecked) {
                            this._checkAllItems();
                        }
                        else {
                            this._uncheckAllItems();
                        }
                        this._updateModel();
                    };
                    CheckboxRendererController.prototype.$onInit = function () {
                        var _this = this;
                        // Fire onInit of parent
                        _super.prototype.$onInit.call(this);
                        // validations
                        this._checkboxValidations();
                        // clone items
                        this.items = _.cloneDeep(this.configItem.data.items);
                        // normalize items
                        this._normalizeItems();
                        this._initConfig();
                        // Setup on element ready handler
                        this.onElementReady(function () {
                            // populate items
                            if (_this.configItem.value !== null && _this.configItem.value !== '') {
                                _this._populateItemsFromCSV();
                            }
                            else {
                                _this._setDefaultValue();
                            }
                            _this._setSelectAllCheckboxState();
                        });
                    };
                    CheckboxRendererController.$inject = ['$scope', '$element', 'assert'];
                    return CheckboxRendererController;
                }(renderer.ConfigurationRenderer));
                var checkboxRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/checkbox/checkbox.renderer.html',
                    controller: CheckboxRendererController,
                    bindings: {
                        _configItem: '<configItem',
                        configFormCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersCheckbox', checkboxRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var DropdownRendererController = (function () {
                    function DropdownRendererController($scope, $element) {
                        this.$scope = $scope;
                        this.$element = $element;
                    }
                    DropdownRendererController.prototype._onInitRepeater = function (iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > 10) {
                            console.error(this.$element);
                            throw new Error('configurationRenderersDropdown: After 10 tries, failed to get ngModel from element.');
                        }
                        this.$scope.$applyAsync(function () {
                            var selectElement = _this.$element.find('select');
                            var ngModel = selectElement.controller('ngModel');
                            if (!ngModel) {
                                iter++;
                                return _this._onInitRepeater(iter);
                            }
                            if (_this.configItem.data.defaultSelect &&
                                (_this.configItem.value === null || _this.configItem.value === '')) {
                                ngModel.$setViewValue(_this.configItem.data.defaultSelect);
                                ngModel.$setDirty();
                                ngModel.$render();
                            }
                            _this.onComponentInit({ ngModelController: ngModel });
                        });
                    };
                    DropdownRendererController.prototype.$onInit = function () {
                        var _this = this;
                        this.$element.ready(function () {
                            _this._onInitRepeater();
                        });
                    };
                    DropdownRendererController.$inject = ['$scope', '$element'];
                    return DropdownRendererController;
                }());
                var dropdownRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/drop-down/drop-down.renderer.html',
                    controller: DropdownRendererController,
                    bindings: {
                        configItem: '<',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersDropdown', dropdownRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var booleanRendererController = (function () {
                    function booleanRendererController($scope, $element) {
                        this.$scope = $scope;
                        this.$element = $element;
                    }
                    /**
                     * Extracts the ng model controller from an element
                     * @returns {*}
                     * @private
                     */
                    booleanRendererController.prototype._getNgModel = function () {
                        if (this._ngModel) {
                            return this._ngModel;
                        }
                        var element = this.$element.find('input');
                        this._ngModel = element.controller('ngModel');
                        return this._ngModel;
                    };
                    booleanRendererController.prototype._setInitialValue = function () {
                        var ngModel = this._getNgModel();
                        if (this.configItem.value !== null || this.configItem.value !== undefined) {
                            ngModel.$setViewValue(!!this.configItem.value);
                            ngModel.$render();
                        }
                        else if (this.configItem.data && this.configItem.data.defaultValue !== undefined) {
                            ngModel.$setViewValue(!!this.configItem.data.defaultValue);
                            ngModel.$setDirty();
                            ngModel.$render();
                        }
                    };
                    /**
                     * Toggles the state of the model
                     */
                    booleanRendererController.prototype.toggleState = function () {
                        var ngModel = this._getNgModel();
                        ngModel.$setViewValue(!ngModel.$modelValue);
                        ngModel.$setDirty();
                        ngModel.$render();
                    };
                    booleanRendererController.prototype._onInitRepeater = function (iter) {
                        var _this = this;
                        if (iter === void 0) { iter = 0; }
                        if (iter > 10) {
                            console.error(this.$element);
                            throw new Error('configurationRenderersboolean: After 10 tries, failed to get ngModel from element.');
                        }
                        this.$scope.$applyAsync(function () {
                            if (!_this._getNgModel()) {
                                iter++;
                                return _this._onInitRepeater(iter);
                            }
                            _this.onComponentInit({ ngModelController: _this._getNgModel() });
                            _this._setInitialValue();
                        });
                    };
                    booleanRendererController.prototype._setLabels = function () {
                        this.trueLabel = (this.configItem.data && this.configItem.data.trueLabel) || 'true';
                        this.falseLabel = (this.configItem.data && this.configItem.data.falseLabel) || 'false';
                    };
                    booleanRendererController.prototype.$onInit = function () {
                        var _this = this;
                        this._setLabels();
                        this.$element.ready(function () {
                            _this._onInitRepeater();
                        });
                    };
                    booleanRendererController.$inject = ['$scope', '$element'];
                    return booleanRendererController;
                }());
                var booleanRendererComponent = {
                    controller: booleanRendererController,
                    templateUrl: 'app/layouts/configuration/renderers/boolean/boolean.renderer.html',
                    bindings: {
                        configItem: '<',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersBoolean', booleanRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var MAIN_INPUT_SELECTOR = '.hidden-input';
                var EDIT_INPUT_SELECTOR = '.alerts-email-settings--group-item--new-recipient-input';
                var UsersListRendererController = (function (_super) {
                    __extends(UsersListRendererController, _super);
                    function UsersListRendererController($scope, $element, assert) {
                        _super.call(this, MAIN_INPUT_SELECTOR);
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.controllerName = 'UsersListRendererController';
                    }
                    UsersListRendererController.prototype._getCsv = function () {
                        return this.users.join(',');
                    };
                    UsersListRendererController.prototype._getUsers = function () {
                        if (this._configItem.value) {
                            this.users = this._configItem.value.split(',');
                        }
                        else {
                            this.users = [];
                        }
                    };
                    UsersListRendererController.prototype._removeVisibleInputFromForm = function () {
                        var editInputNgModel = this.$element.find(EDIT_INPUT_SELECTOR).controller('ngModel');
                        this.formModelCtrl.$removeControl(editInputNgModel);
                    };
                    UsersListRendererController.prototype.addUser = function (newUser) {
                        if (this.users.indexOf(newUser.trim()) === -1) {
                            this.users.push(newUser.trim());
                            this._updateNgModel(this._getCsv());
                            this.newUsersInput = '';
                        }
                    };
                    UsersListRendererController.prototype.removeUser = function (index) {
                        this.users.splice(index, 1);
                        this._updateNgModel(this._getCsv());
                    };
                    UsersListRendererController.prototype.$onInit = function () {
                        var _this = this;
                        _super.prototype.$onInit.call(this);
                        this.onElementReady(function () {
                            _this._removeVisibleInputFromForm();
                            _this._getUsers();
                        });
                    };
                    UsersListRendererController.$inject = ['$scope', '$element', 'assert'];
                    return UsersListRendererController;
                }(renderer.ConfigurationRenderer));
                var UsersListRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/users-list/users-list.renderer.html',
                    controller: UsersListRendererController,
                    bindings: {
                        _configItem: '<configItem',
                        configFormCtrl: '<',
                        onComponentInit: '&',
                        formModelCtrl: '<'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersUsersList', UsersListRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function fsConfigRendererAlertsMailDirective() {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {FsConfigRendererAlertsMailController} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // set main input to ctrl
            ctrl._mainInput = element.find('#email_config_main_input');
            //set main input controller to ctrl
            ctrl._mainInputNgModel = ctrl._mainInput.controller('ngModel');
            // set ngModel validity to invalid so the form can not be submitted.
            ctrl._mainInputNgModel.$setValidity('emailConfiguration', false);
            ctrl.onComponentInit({ ngModelController: ctrl._mainInputNgModel });
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsConfigRendererAlertsMailController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            ctrl._mainInput = null;
            ctrl._mainInputNgModel = null;
            // add listener to main input
            ctrl.mainInputKeyPress = function (evt, group, newUser) {
                if (evt.which === 13) {
                    return ctrl.addUser(group, newUser);
                }
            };
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsConfigRendererAlertsMailController.prototype, {
            /**
             * List of possible severities
             */
            severities: ['Critical', 'High', 'Medium', 'Low'],
            /**
             * List of possible frequencies
             */
            frequencies: ['Daily', 'Weekly', 'Monthly'],
            /**
             * Validates all groups have users
             *
             * @returns {boolean}
             * @private
             */
            _isUsersGroupsValid: function () {
                return _.every(this.settings, function (group) {
                    return group.users.length > 0;
                });
            },
            /**
             * Validates all groups` Alert Summaries have both severities and frequencies,
             * or have no severities and no frequencies.
             *
             * @returns {boolean}
             * @private
             */
            _isAlertSummaryValid: function () {
                return _.every(this.settings, function (group) {
                    var severitieLength = group.summary.severities.length;
                    var frequenciesLength = group.summary.frequencies.length;
                    return (severitieLength > 0 && frequenciesLength > 0) ||
                        (severitieLength === 0 && frequenciesLength === 0);
                });
            },
            /**
             * Validates that either newAlert severities exist, or Alert Summary have both severities and frequencies.
             *
             * @returns {boolean}
             * @private
             */
            _isNewAlertOrAlertSummaryValid: function () {
                return _.every(this.settings, function (group) {
                    var summarySeveritieLength = group.summary.severities.length;
                    var summaryFrequenciesLength = group.summary.frequencies.length;
                    var newAlertSeveritiesLength = group.newAlert.severities.length;
                    return newAlertSeveritiesLength > 0 ||
                        (summarySeveritieLength > 0 && summaryFrequenciesLength > 0);
                });
            },
            /**
             * Checks all validations return true
             *
             * @returns {*|boolean}
             * @private
             */
            _isValid: function () {
                return this._isUsersGroupsValid() &&
                    this._isAlertSummaryValid() &&
                    this._isNewAlertOrAlertSummaryValid();
            },
            /**
             * Method to cleanup unwanted properties from the object to be stored,
             *
             * @param group
             * @private
             */
            _cleanupGroup: function (group) {
                // Delete $$hashKey from new object (this was added by angular)
                delete group.$$hashKey;
                // Delete severitiesObj
                delete group.newAlert.severitiesObj;
                delete group.summary.severitiesObj;
                // Delete frequenciesObj
                delete group.summary.frequenciesObj;
            },
            /**
             * Builds a severities object for the received group. This object serves as the model for the checkboxes.
             *
             * @param {string} configGroupType should be 'newAlert' or 'summary'
             * @param {object} group {{newAlert: {severities: Array<string>}, summary: {severities: Array<string>}}}}
             * @private
             */
            _digestSeverities: function (configGroupType, group) {
                // Create a new object if one is not found
                group[configGroupType] = group[configGroupType] || {};
                // Create a new list of severities if one is not found.
                group[configGroupType].severities = group[configGroupType].severities || [];
                // Create a new severitiesObj to be used as the model for the
                group[configGroupType].severitiesObj = {};
                // Iterate through group's severities and for each existing severity set a boolean value on
                // severitiesObj set to true
                _.each(group[configGroupType].severities, function (severity) {
                    group[configGroupType].severitiesObj[severity] = true;
                });
            },
            /**
             * Builds a frequencies object for the received group. This object serves as the model for the checkboxes.
             *
             * @param {object} group {{summary: {frequencies: Array<string>}}}
             * @private
             */
            _digestFrequencies: function (group) {
                // Create a new object if one is not found
                group.summary = group.summary || {};
                // Create a new list of frequencies if one is not found.
                group.summary.frequencies = group.summary.frequencies || [];
                // Create a new frequenciesObj to be used as the model for the
                group.summary.frequenciesObj = {};
                // Iterate through group's frequencies and for each existing frequency set a boolean value on
                // frequenciesObj set to true
                _.each(group.summary.frequencies, function (frequency) {
                    group.summary.frequenciesObj[frequency] = true;
                });
            },
            /**
             * Takes a change function, and invokes it. if the new value is different then the old value, it sets view
             * value
             *
             * @param {function} changeFn
             * @private
             */
            _changeAction: function (changeFn) {
                // Create an old value reference
                var oldValue = JSON.stringify(this.settings);
                // Make the change
                changeFn();
                // Create a new value reference
                var newValue = JSON.stringify(this.settings);
                // If the new value is different then the old value then commit the change
                if (newValue !== oldValue) {
                    // Create an object to be cleaned
                    var newValueObj = JSON.parse(newValue);
                    // Clean all the groups
                    _.each(newValueObj, this._cleanupGroup);
                    // Set the new value to the main input model, set valid, and render.
                    this._mainInputNgModel.$setViewValue(JSON.stringify(newValueObj));
                    this._mainInputNgModel.$setValidity('emailConfiguration', this._isValid());
                    this._mainInputNgModel.$render();
                }
            },
            /**
             * Change Adds or removes a severity in a group
             * @param {number} groupIndex
             * @param {string} groupType should be 'newAlert' or 'summary'
             * @param {string} severity
             * @param {boolean} value
             */
            changeSeverity: function (groupIndex, groupType, severity, value) {
                var ctrl = this;
                this._changeAction(function () {
                    // get the relevant group to change
                    var group = ctrl.settings[groupIndex];
                    // Get the severities list from the group
                    var severities = group[groupType].severities;
                    // If value is true then we need to add the severity
                    if (value) {
                        // Make sure we're not adding an existing severity
                        if (severities.indexOf(severity) === -1) {
                            // Add the severity
                            severities.push(severity);
                        }
                    }
                    else {
                        // Filter out all the severities that equal the one received.
                        group[groupType].severities = _.filter(severities, function (_severity) {
                            return _severity !== severity;
                        });
                    }
                });
            },
            /**
             * Adds or removes a frequency in a group
             * @param {number} groupIndex
             * @param {string} frequency
             * @param {boolean} value
             */
            changeFrequency: function (groupIndex, frequency, value) {
                var ctrl = this;
                this._changeAction(function () {
                    // get the relevant group to change
                    var group = ctrl.settings[groupIndex];
                    // Get the frequencies list from the group
                    var frequencies = group.summary.frequencies;
                    // If value is true then we need to add the frequency
                    if (value) {
                        // Make sure we're not adding an existing frequency
                        if (frequencies.indexOf(frequency) === -1) {
                            // Add the frequency
                            frequencies.push(frequency);
                        }
                    }
                    else {
                        // Filter out all the frequencies that equal the one received.
                        group.summary.frequencies = _.filter(frequencies, function (_frequency) {
                            return _frequency !== frequency;
                        });
                    }
                });
            },
            /**
             * Adds a user
             * @param {{users: Array<string>}} group
             * @param {string} newUser
             */
            addUser: function (group, newUser) {
                // Validate value is not an empty string, or an existing value
                if (newUser && newUser !== "" && group.users.indexOf(newUser.trim()) === -1) {
                    this._changeAction(function () {
                        group.users.push(newUser.trim());
                    });
                }
            },
            /**
             * Removes a user
             * @param {{users: Array<string>}} group
             * @param {number} userIndex
             */
            removeUser: function (group, userIndex) {
                this._changeAction(function () {
                    group.users.splice(userIndex, 1);
                });
            },
            /**
             * Removes a group
             * @param {number} groupIndex
             */
            removeGroup: function (groupIndex) {
                var ctrl = this;
                ctrl._changeAction(function () {
                    ctrl.settings.splice(groupIndex, 1);
                });
            },
            /**
             * Duplicates a group
             * @param groupIndex
             */
            duplicateGroup: function (groupIndex) {
                var ctrl = this;
                ctrl._changeAction(function () {
                    // Adds after the member a duplication of the member. JSON.parse/stringify is used for the
                    // duplication
                    ctrl.settings.splice(groupIndex, 0, JSON.parse(JSON.stringify(ctrl.settings[groupIndex])));
                });
            },
            /**
             * Creates a new group
             */
            newGroup: function () {
                var ctrl = this;
                // Create a new settings list if one does not exist
                ctrl.settings = ctrl.settings || [];
                ctrl._changeAction(function () {
                    ctrl.settings.push({
                        users: [],
                        summary: { severities: [], severitiesObj: {}, frequencies: [], frequenciesObj: {} },
                        newAlert: { severities: [], severitiesObj: {} }
                    });
                });
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                // Set base value
                ctrl.settings = JSON.parse(ctrl.configItem.value);
                // digest severities and frequency
                _.each(ctrl.settings, function (group) {
                    ctrl._digestSeverities('newAlert', group);
                    ctrl._digestSeverities('summary', group);
                    ctrl._digestFrequencies(group);
                });
            }
        });
        FsConfigRendererAlertsMailController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/configuration/renderers/alerts-mail/fs-config-renderer-alerts-mail.view.html',
            link: linkFn,
            controller: FsConfigRendererAlertsMailController,
            scope: {},
            controllerAs: '$ctrl',
            bindToController: {
                configItem: '<',
                configFormCtrl: '<',
                formModelCtrl: '<',
                onComponentInit: '&'
            }
        };
    }
    fsConfigRendererAlertsMailDirective.$inject = [];
    angular.module('Fortscale.layouts.configuration')
        .directive('configurationRenderersAlertsEmail', fsConfigRendererAlertsMailDirective);
}());

(function () {
    'use strict';
    function fsConfigRendererForwardHistoricalAlertsDirective(dateRanges, $http, BASE_URL) {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {array<object>|object} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // Link function logic
            //scope.ctrl.formCtrl = ctrl[0];
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsConfigRendererForwardHistoricalAlertsController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            this.dateRange = dateRanges.getByDaysRange(7, 'short');
            this.message = null;
            ctrl.dateChange = function (_a) {
                var value = _a.value;
                return ctrl._dateChange(value);
            };
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsConfigRendererForwardHistoricalAlertsController.prototype, {
            /**
             * Handler for date change
             *
             * @param {string} value
             */
            _dateChange: function (value) {
                var ctrl = this;
                ctrl.dateRange = value;
                var pristineState = ctrl.formModelCtrl.$pristine;
                ctrl.$scope.$applyAsync(function () {
                    if (pristineState) {
                        ctrl.formModelCtrl.$setPristine();
                    }
                });
            },
            /**
             * Handler for forward button. Contacts REST to start a historical alerts forwarding job.
             */
            forward: function () {
                var ctrl = this;
                var dates = this.dateRange.split(',');
                this.isLoading = true;
                this.message = null;
                // Collect the data
                var configModels = ctrl.configFormCtrl.configModels;
                var ip = configModels["system.syslogforwarding.ip"];
                var port = parseInt(configModels["system.syslogforwarding.port"]);
                var forwardingType = configModels["system.syslogforwarding.forwardingtype"];
                var userTagsString = configModels["system.syslogforwarding.usertypes"];
                var userTags = userTagsString ? userTagsString.split(",") : [];
                var alertsSeverityString = configModels["system.syslogforwarding.alertseverity"];
                var alertSeverities = alertsSeverityString ? alertsSeverityString.split(",") : [];
                $http.post(BASE_URL + '/syslogforwarding/forward_alerts', {
                    start_time: parseInt(dates[0]),
                    end_time: parseInt(dates[1]),
                    ip: ip,
                    port: port,
                    forwarding_type: forwardingType,
                    user_tags: userTags,
                    alert_severities: alertSeverities
                })
                    .then(function (res) {
                    ctrl.message = res && res.data && res.data.message;
                    ctrl.isLoading = false;
                })
                    .catch(function (err) {
                    ctrl.message = err.data.message;
                    ctrl.isLoading = false;
                });
            },
            /**
             * Init
             */
            init: function init() {
                this.onComponentInit();
            }
        });
        FsConfigRendererForwardHistoricalAlertsController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/configuration/renderers/forward-historical-alerts/' +
                'fs-config-renderer-forward-historical-alerts.view.html',
            link: linkFn,
            controller: FsConfigRendererForwardHistoricalAlertsController,
            scope: {},
            controllerAs: '$ctrl',
            bindToController: {
                configItem: '<',
                configFormCtrl: '<',
                formModelCtrl: '<',
                onComponentInit: '&'
            }
        };
    }
    fsConfigRendererForwardHistoricalAlertsDirective.$inject = ['dateRanges', '$http', 'BASE_URL'];
    angular.module('Fortscale.layouts.configuration')
        .directive('configurationRenderersForwardHistoricalAlerts', fsConfigRendererForwardHistoricalAlertsDirective);
}());

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var renderer;
            (function (renderer) {
                'use strict';
                var MAIN_INPUT_SELECTOR = '.hidden-input';
                var EMAIL_INPUT_SELECTOR = '.email-input';
                var TestEmailRendererController = (function (_super) {
                    __extends(TestEmailRendererController, _super);
                    function TestEmailRendererController($scope, $element, assert, $http, BASE_URL) {
                        _super.call(this, MAIN_INPUT_SELECTOR);
                        this.$scope = $scope;
                        this.$element = $element;
                        this.assert = assert;
                        this.$http = $http;
                        this.BASE_URL = BASE_URL;
                        this.controllerName = 'TestEmailRendererController';
                    }
                    /**
                     * Submit test email
                     * @param email
                     */
                    TestEmailRendererController.prototype.submitTestEmail = function (email) {
                        var _this = this;
                        if (email) {
                            this.$http.get(this.BASE_URL + "/email/test", { params: { to: email } })
                                .then(function (res) {
                                if (res.data && res.data.message) {
                                    _this.message = res.data.message;
                                }
                            })
                                .catch(function (err) {
                                if (err.data && err.data.message) {
                                    _this.message = err.data.message;
                                }
                            });
                        }
                    };
                    /**
                     * detaches this controller from the parent form
                     * @private
                     */
                    TestEmailRendererController.prototype._deregisterInputElement = function () {
                        var ngModel = this.$element.find(EMAIL_INPUT_SELECTOR).controller('ngModel');
                        this.formModelCtrl.$removeControl(this.ngModel);
                        this.formModelCtrl.$removeControl(ngModel);
                    };
                    TestEmailRendererController.prototype._elementReadyHandler = function () {
                        this._deregisterInputElement();
                    };
                    TestEmailRendererController.prototype.$onInit = function () {
                        _super.prototype.$onInit.call(this);
                        this.onElementReady(this._elementReadyHandler.bind(this));
                    };
                    TestEmailRendererController.$inject = ['$scope', '$element', 'assert', '$http', 'BASE_URL'];
                    return TestEmailRendererController;
                }(renderer.ConfigurationRenderer));
                var TestEmailRendererComponent = {
                    templateUrl: 'app/layouts/configuration/renderers/test-email/test-email.renderer.html',
                    controller: TestEmailRendererController,
                    bindings: {
                        _configItem: '<configItem',
                        configFormCtrl: '<',
                        formModelCtrl: '<',
                        onComponentInit: '&'
                    }
                };
                angular.module('Fortscale.layouts.configuration')
                    .component('configurationRenderersTestEmail', TestEmailRendererComponent);
            })(renderer = configuration.renderer || (configuration.renderer = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    function fsConfigRendererActiveDirectoryDirective() {
        /**
         *
         * @param {object} scope
         * @param {object} element
         * @param {object} attrs
         * @param {FsConfigRendererActiveDirectoryController} ctrl
         */
        function linkFn(scope, element, attrs, ctrl) {
            // set main input to ctrl
            ctrl._mainInput = element.find('#active_directory_main_input');
            //set main input controller to ctrl
            ctrl._mainInputNgModel = ctrl._mainInput.controller('ngModel');
            // set ngModel validity to invalid so the form can not be submitted.
            ctrl._mainInputNgModel.$setValidity('activeDirectoryConfiguration', false);
        }
        /**
         * The directive's controller function
         *
         * @constructor
         */
        function FsConfigRendererActiveDirectoryController($element, $scope) {
            // Put dependencies on the instance
            var ctrl = this;
            ctrl.$element = $element;
            ctrl.$scope = $scope;
            ctrl._mainInput = null;
            ctrl._mainInputNgModel = null;
            // add listener to main input
            ctrl.mainInputKeyPress = function (evt, domain, newDC) {
                if (evt.which === 13) {
                    return ctrl.addDC(domain, newDC);
                }
            };
            // Invoke init
            ctrl.init();
        }
        angular.extend(FsConfigRendererActiveDirectoryController.prototype, {
            /**
             * Validates all domains have dcs
             *
             * @returns {boolean}
             * @private
             */
            _isDCsValid: function () {
                return _.every(this.settings, function (domain) {
                    return domain.dcs.length > 0;
                });
            },
            /**
             * Validates all domains have text in the text boxes
             *
             * @returns {boolean}
             * @private
             */
            _isTextBoxesValid: function () {
                return _.every(this.settings, function (domain) {
                    return domain.domainBaseSearch !== "" && domain.domainPassword !== "" && domain.domainUser !== "";
                });
            },
            /**
             * Checks all validations return true
             *
             * @returns {*|boolean}
             * @private
             */
            _isValid: function () {
                return this._isDCsValid() && this._isTextBoxesValid();
            },
            /**
             * Method to cleanup unwanted properties from the object to be stored,
             *
             * @param domain
             * @private
             */
            _cleanupDomain: function (domain) {
                // Delete $$hashKey from new object (this was added by angular)
                delete domain.$$hashKey;
            },
            /**
             * Takes a change function, and invokes it. if the new value is different then the old value, it sets view
             * value
             *
             * @param {function} changeFn
             * @private
             */
            _changeAction: function (changeFn) {
                // Create an old value reference
                var oldValue = JSON.stringify(this.settings);
                // Make the change
                changeFn();
                // Create a new value reference
                var newValue = JSON.stringify(this.settings);
                // If the new value is different then the old value then commit the change
                if (newValue !== oldValue) {
                    // Create an object to be cleaned
                    var newValueObj = JSON.parse(newValue);
                    // Clean all the domains
                    _.each(newValueObj, this._cleanupDomain);
                    // Set the new value to the main input model, set valid, and render.
                    this._mainInputNgModel.$setViewValue(JSON.stringify(newValueObj));
                    this._mainInputNgModel.$setValidity('activeDirectoryConfiguration', this._isValid());
                    this._mainInputNgModel.$render();
                }
            },
            modelChange: function () {
                // Create an object to be cleaned
                var newValueObj = _.cloneDeep(this.settings);
                // Clean all the domains
                _.each(newValueObj, this._cleanupDomain);
                // Set the new value to the main input model, set valid, and render.
                this._mainInputNgModel.$setViewValue(JSON.stringify(newValueObj));
                this._mainInputNgModel.$setValidity('activeDirectoryConfiguration', this._isValid());
                this._mainInputNgModel.$render();
            },
            /**
             * Adds a DC
             * @param {{users: Array<string>}} domain
             * @param {string} newDC
             */
            addDC: function (domain, newDC) {
                // Validate value is not an empty string, or an existing value
                if (newDC && newDC !== "" && domain.dcs.indexOf(newDC.trim()) === -1) {
                    this._changeAction(function () {
                        domain.dcs.push(newDC.trim());
                    });
                }
            },
            /**
             * Removes a DC
             * @param {{users: Array<string>}} domain
             * @param {number} dcIndex
             */
            removeDC: function (domain, dcIndex) {
                this._changeAction(function () {
                    domain.dcs.splice(dcIndex, 1);
                });
            },
            /**
             * Removes a domain
             * @param {number} domainIndex
             */
            removeDomain: function (domainIndex) {
                var ctrl = this;
                ctrl._changeAction(function () {
                    ctrl.settings.splice(domainIndex, 1);
                });
            },
            /**
             * Duplicates a domain
             * @param domainIndex
             */
            duplicateDomain: function (domainIndex) {
                var ctrl = this;
                ctrl._changeAction(function () {
                    // Adds after the member a duplication of the member. JSON.parse/stringify is used for the
                    // duplication
                    ctrl.settings.splice(domainIndex, 0, JSON.parse(JSON.stringify(ctrl.settings[domainIndex])));
                });
            },
            /**
             * Creates a new domain
             */
            newDomain: function () {
                var ctrl = this;
                // Create a new settings list if one does not exist
                ctrl.settings = ctrl.settings || [];
                ctrl._changeAction(function () {
                    ctrl.settings.push({
                        dcs: [],
                        domainBaseSearch: "",
                        domainPassword: "",
                        domainUser: ""
                    });
                });
            },
            /**
             * Init
             */
            init: function init() {
                var ctrl = this;
                // Set base value
                ctrl.settings = JSON.parse(ctrl.configItem.value);
                // digest severities and frequency
                _.each(ctrl.settings, function (domain) {
                });
                ctrl.onComponentInit({ ngModelController: ctrl._mainInputNgModel });
            }
        });
        FsConfigRendererActiveDirectoryController.$inject = ['$element', '$scope'];
        return {
            restrict: 'E',
            templateUrl: 'app/layouts/configuration/renderers/active-directory/' +
                'fs-config-renderer-active-directory.view.html',
            link: linkFn,
            controller: FsConfigRendererActiveDirectoryController,
            scope: {},
            controllerAs: '$ctrl',
            bindToController: {
                configItem: '<',
                configFormCtrl: '<',
                formModelCtrl: '<',
                onComponentInit: '&'
            }
        };
    }
    fsConfigRendererActiveDirectoryDirective.$inject = [];
    angular.module('Fortscale.layouts.configuration')
        .directive('configurationRenderersActiveDirectory', fsConfigRendererActiveDirectoryDirective);
}());

var Fortscale;
(function (Fortscale) {
    var layouts;
    (function (layouts) {
        var configuration;
        (function (configuration) {
            var components;
            (function (components) {
                var batchAlertForwarding;
                (function (batchAlertForwarding) {
                    'use strict';
                    var BatchAlertForwardingController = (function () {
                        function BatchAlertForwardingController(tagsUtils, appConfig, $http, BASE_URL, dateRanges) {
                            var _this = this;
                            this.tagsUtils = tagsUtils;
                            this.appConfig = appConfig;
                            this.$http = $http;
                            this.BASE_URL = BASE_URL;
                            this.dateRanges = dateRanges;
                            // Initialize properties
                            this.isLoading = false;
                            this.models = {};
                            this.configModels = {};
                            this.updateDates = function (res) {
                                return _this._updateDates(res);
                            };
                        }
                        /**
                         * Gets all tags in the system
                         * @returns {IPromise<Array>|Promise<Array>|Promise<T>}
                         * @private
                         */
                        BatchAlertForwardingController.prototype._getTags = function () {
                            var _this = this;
                            return this.tagsUtils.getTags()
                                .then(function (tags) {
                                _this.tagsList = _.map(tags.data, function (tag) {
                                    return {
                                        value: tag.name,
                                        label: tag.displayName
                                    };
                                });
                            })
                                .catch(function (err) {
                                console.error('Fortscale.layouts.configuration: There was an error trying to fetch tags', err);
                                return [];
                            });
                        };
                        /**
                         * Sets the initial dates value. Will be consumed if date range controller is not used.
                         * @private
                         */
                        BatchAlertForwardingController.prototype._setInitialDates = function () {
                            this.dates = this.dateRanges.getByDaysRange(7, 'short');
                        };
                        ;
                        /**
                         * Sets the initial state
                         *
                         * @private
                         */
                        BatchAlertForwardingController.prototype._setInitialState = function () {
                            this._initialState = {
                                'system.syslogforwarding.forwardingtype': {
                                    component: 'checkbox',
                                    config: {
                                        radioBox: true,
                                        horizontal: true
                                    },
                                    data: {
                                        items: [
                                            {
                                                value: 'ALERT',
                                                label: 'Alerts'
                                            }, {
                                                value: 'ALERT_AND_INDICATORS',
                                                label: 'Alerts and Indicators'
                                            }
                                        ],
                                        checked: ['ALERT']
                                    }
                                },
                                'system.syslogforwarding.ip': {
                                    id: 'system.syslogforwarding.ip',
                                    component: 'ip',
                                    data: {},
                                    config: {}
                                },
                                'system.syslogforwarding.port': {},
                                'system.syslogforwarding.alertseverity': {
                                    component: 'severity',
                                    data: {},
                                    config: {}
                                },
                                'system.syslogforwarding.messageformat': {
                                    component: 'checkbox',
                                    config: {
                                        radioBox: true,
                                        horizontal: true
                                    },
                                    data: {
                                        items: [
                                            {
                                                value: 'RFC_3164',
                                                label: 'RFC 3164'
                                            }, {
                                                value: 'RFC_5424',
                                                label: 'RFC 5424'
                                            }
                                        ],
                                        checked: ['RFC_3164']
                                    }
                                },
                                'system.syslogforwarding.usertypes': {
                                    component: 'checkbox',
                                    config: {
                                        selectAll: true
                                    },
                                    data: {
                                        items: this.tagsList
                                    }
                                }
                            };
                        };
                        /**
                         * Sets initial values to all models
                         *
                         * @private
                         */
                        BatchAlertForwardingController.prototype._setInitialValues = function () {
                            var _this = this;
                            this.models = {};
                            this.dates = this.dateRanges.getByDaysRange(7, 'short').split(',');
                            _.each(this._initialState, function (stateItem, stateItemId) {
                                var configItem = _this.appConfig.getConfigItem(stateItemId);
                                _this.models[stateItemId] = _.merge(configItem, stateItem);
                            });
                        };
                        /**
                         * Handler to update dates.
                         *
                         * @param {{value: *}}res
                         * @private
                         */
                        BatchAlertForwardingController.prototype._updateDates = function (res) {
                            this.dates = res.value.split(',');
                        };
                        /**
                         * An action to request forwarding
                         *
                         */
                        BatchAlertForwardingController.prototype.forward = function () {
                            var _this = this;
                            this.isLoading = true;
                            this.$http.post(this.BASE_URL + '/syslogforwarding/forward_alerts', {
                                start_time: parseInt(this.dates[0]),
                                end_time: parseInt(this.dates[1]),
                                ip: this.configModels['system.syslogforwarding.ip'],
                                port: this.configModels['system.syslogforwarding.port'],
                                forwarding_type: this.configModels['system.syslogforwarding.forwardingtype'],
                                message_format: this.configModels['system.syslogforwarding.messageformat'],
                                user_tags: this.configModels['system.syslogforwarding.usertypes'] ?
                                    this.configModels['system.syslogforwarding.usertypes'].split(',') : [],
                                alert_severities: this.configModels['system.syslogforwarding.alertseverity'] ?
                                    this.configModels['system.syslogforwarding.alertseverity'].split(',') : []
                            })
                                .then(function (res) {
                                _this.message = res && res.data && res.data.message;
                                _this.isLoading = false;
                            })
                                .catch(function (err) {
                                _this.message = err.data.message;
                                _this.isLoading = false;
                            });
                        };
                        BatchAlertForwardingController.prototype.$onInit = function () {
                            var _this = this;
                            this.isLoading = true;
                            this._getTags()
                                .then(function () {
                                _this._setInitialDates();
                                _this._setInitialState();
                                _this._setInitialValues();
                                _this.isLoading = false;
                            })
                                .catch(function () {
                                _this.isLoading = false;
                            });
                        };
                        BatchAlertForwardingController.$inject = ['tagsUtils', 'appConfig', '$http', 'BASE_URL', 'dateRanges'];
                        return BatchAlertForwardingController;
                    }());
                    var configurationComponentBatchAlertForwarding = {
                        controller: BatchAlertForwardingController,
                        controllerAs: 'baCtrl',
                        templateUrl: 'app/layouts/configuration/layout-components/batch-alert-forwading/batch-alert-forwarding.html',
                    };
                    angular.module('Fortscale.layouts.configuration')
                        .component('configurationComponentBatchAlertForwarding', configurationComponentBatchAlertForwarding)
                        .run(['Fortscale.layouts.configuration.configurationNavigationService',
                        function (configurationNavigationService) { return configurationNavigationService.addConfigurationPage({
                            id: 'system.syslogforwarding.batchAlertForwarding',
                            displayName: 'Batch Alert Forwarding via Syslog',
                            component: 'configurationComponentBatchAlertForwarding',
                            doNotShowHeader: true,
                            formClassNames: 'batch-alert-forwarding'
                        }); }]);
                })(batchAlertForwarding = components.batchAlertForwarding || (components.batchAlertForwarding = {}));
            })(components = configuration.components || (configuration.components = {}));
        })(configuration = layouts.configuration || (layouts.configuration = {}));
    })(layouts = Fortscale.layouts || (Fortscale.layouts = {}));
})(Fortscale || (Fortscale = {}));

(function () {
    'use strict';
    angular.module('Fortscale.layouts.pxgridConfiguration', []);
}());

(function () {
    'use strict';
    var PXGRID_CONTAINER_ID = 'system.pxgrid';
    function PxgridConfigurationController($scope, dependencyMounter, $stateParams) {
        this.$scope = $scope;
        this.$stateParams = $stateParams;
        this.certificate_form_type = $stateParams.certificateFlow;
        this.generation_form_type = $stateParams.generationFlow;
        dependencyMounter.mountOnConstructor(PxgridConfigurationController, [
            'appConfig', '$http', 'BASE_URL', 'remoteAppConfig', '$state', '$q'
        ]);
        this._init();
    }
    _.merge(PxgridConfigurationController.prototype, {
        /**
         * Get and parse the pxgrid config items.
         *
         * @private
         */
        _getPXGridConfigItems: function () {
            // Get pxgrid config container
            this.pxGridContainer = this.appConfig.getConfigContainer(PXGRID_CONTAINER_ID);
            // Create holder for config items
            this.pxgridItems = {};
            // Iterate through pxgrid config container items, and place items on pxgridItems.
            // Format items values where needed
            _.each(this.appConfig.getConfigItemsByContainer(PXGRID_CONTAINER_ID), _.bind(function (configItem) {
                // Place duplicated item on pxgridItems
                this.pxgridItems[configItem.id] = this.appConfig.duplicateConfigItem(configItem);
                // Convert values to integer when type is pxgridInt. Null value if value is parsed no NaN
                if (configItem.type === "pxgridInt") {
                    this.pxgridItems[configItem.id].value = parseInt(this.pxgridItems[configItem.id].value);
                    if (isNaN(this.pxgridItems[configItem.id].value)) {
                        this.pxgridItems[configItem.id].value = null;
                    }
                }
            }, this));
        },
        /**
         * Used after config change to update the page. Will reload the state.
         *
         * @private
         */
        _reloadSelf: function () {
            var ctrl = this;
            ctrl.$state.go('pxgridConfiguration', {
                certificateFlow: ctrl.certificate_form_type,
                generationFlow: ctrl.generation_form_type
            }, {
                reload: true
            });
        },
        /**
         * Change the state params without reloading the page
         *
         * @private
         */
        _statechangeParams: function () {
            var ctrl = this;
            ctrl.$state.transitionTo('pxgridConfiguration', {
                certificateFlow: ctrl.certificate_form_type,
                generationFlow: ctrl.generation_form_type
            }, { notify: false });
        },
        /**
         * Adds watchers on flows flags.
         *
         * @private
         */
        _addStateWatchers: function () {
            var ctrl = this;
            this.$scope.$watch(function () {
                return ctrl.certificate_form_type;
            }, ctrl._statechangeParams.bind(ctrl));
            this.$scope.$watch(function () {
                return ctrl.generation_form_type;
            }, ctrl._statechangeParams.bind(ctrl));
        },
        /**
         * Handler for pem file input - file change or select
         *
         * @param inputElement
         * @param fileName
         */
        keysFileChange: function (inputElement, fileName) {
            var ctrl = this;
            ctrl.pxgridKeys = ctrl.pxgridKeys || {};
            // Keep reference to ngModel
            var ngModel = angular.element(inputElement).controller('ngModel');
            // Make sure input is a file
            if (inputElement.type === 'file') {
                // If the change yields no files, then nullify model value, set required, set dirty and digest.
                if (inputElement.files.length === 0) {
                    ctrl.pxgridKeys[fileName] = null;
                    ngModel.$setValidity('required', false);
                    ngModel.$setDirty(true);
                    ctrl.$scope.$digest();
                }
                else {
                    var reader = new FileReader();
                    reader.onload = function () {
                        ctrl.pxgridKeys[fileName] = btoa(reader.result);
                        ngModel.$setValidity('required', true);
                        ngModel.$setDirty(true);
                        ctrl.$scope.$digest();
                    };
                    reader.readAsBinaryString(inputElement.files[0]);
                }
            }
        },
        /**
         * Handler for input of type file change. If file is selected, read it and store value as base64 string.
         * If file is not present, nullify value.
         * Each change also triggers setValidity, setDirty and digest
         *
         * @param inputElement
         */
        inputFileChange: function (inputElement) {
            var ctrl = this;
            // Keep reference to ngModel
            var ngModel = angular.element(inputElement).controller('ngModel');
            // Make sure input is a file
            if (inputElement.type === 'file') {
                // If the change yields no files, then nullify model value, set required, set dirty and digest.
                if (inputElement.files.length === 0) {
                    ctrl.pxgridItems[inputElement.id].value = null;
                    ngModel.$setValidity('required', false);
                    ngModel.$setDirty(true);
                    ctrl.$scope.$digest();
                }
                else {
                    var reader = new FileReader();
                    reader.onload = function () {
                        ctrl.pxgridItems[inputElement.id].value = btoa(reader.result);
                        ngModel.$setValidity('required', true);
                        ngModel.$setDirty(true);
                        ctrl.$scope.$digest();
                    };
                    reader.readAsBinaryString(inputElement.files[0]);
                }
            }
        },
        /**
         * Submit pxgrid config flow. Collect values, then use appConfig.updateConfigItems.
         * After submit, form is set to pristine.
         * @returns {Promise.<T>|*}
         */
        submitNewConfig: function () {
            var ctrl = this;
            ctrl.loader = true;
            // Collect config items values into a list of objects {key: string, value: string}
            var configItemsList = _.map(ctrl.pxgridItems, function (configItem) {
                return { key: configItem.id, value: ctrl.pxgridItems[configItem.id].value || "" };
            });
            // Fire update
            return this.appConfig.updateConfigItems(configItemsList)
                .then(function () {
                ctrl.loader = false;
                var formCtrl = angular.element($('#pxgridConfigForm')).controller('form');
                formCtrl.$setPristine();
                ctrl.error = {};
            })
                .catch(function () {
                ctrl.loader = false;
                ctrl.error = {
                    display: true,
                    title: 'Server Error',
                    description: 'An unknown server error has prevented pxGrid configuration update. ' +
                        'Please try again later.'
                };
            });
        },
        /**
         * Used to test the connection to pxgrid
         *
         * @returns {Promise.<T>|*}
         */
        testConnection: function () {
            var ctrl = this;
            ctrl.connectionTest = {
                loader: true
            };
            return this.$http.get(this.BASE_URL + '/pxgrid')
                .then(function (res) {
                ctrl.connectionTest.loader = false;
                ctrl.connectionTest =
                    {
                        success: {
                            message: 'Registered successfully. Registered to server ' + res.data.server
                        }
                    };
            })
                .catch(function (res) {
                ctrl.connectionTest.loader = false;
                switch (res.status) {
                    case 400:
                        ctrl.connectionTest =
                            {
                                error: {
                                    message: res.data.message
                                }
                            };
                        break;
                    default:
                        ctrl.connectionTest =
                            {
                                error: {
                                    message: 'There was an unknown server error. Please try again later.'
                                }
                            };
                        break;
                }
            });
        },
        /**
         * Start loader, creates get request that starts certificate generation. Once approved, config items are
         * loaded and parsed, so change to system.pxgrid.cer will be reflected
         *
         * @returns {Promise.<T>|null}
         */
        generateCertificate: function () {
            var ctrl = this;
            // Create an initial cerGen if one does not exist
            ctrl.cerGen = ctrl.cerGen || {
                loader: false,
                inProgress: false
            };
            // If in progress then do nothing
            if (ctrl.cerGen.inProgress) {
                return null;
            }
            // Start loader and raise inprogress flag
            ctrl.cerGen = {
                loader: true,
                inProgress: true
            };
            // initiate get request to start generation
            return this.$http.get(this.BASE_URL + '/pxgrid/generate_cer')
                .then(function () {
                // Load remote config
                return ctrl.remoteAppConfig.initRemoteAppConfig();
            })
                .then(function () {
                // digest remote config
                return ctrl.appConfig.digestRemoteConfig(ctrl.remoteAppConfig.getRemoteConfigList());
            })
                .then(function () {
                // Turn of loader and inprogress flag
                ctrl.cerGen = {
                    loader: false,
                    inProgress: false
                };
                ctrl._reloadSelf();
            })
                .catch(function (err) {
                // On error turn off loader and inprogress and raise error message
                ctrl.cerGen = {
                    loader: true,
                    inProgress: true
                };
                switch (err.status) {
                    default:
                        ctrl.cerGen =
                            {
                                error: {
                                    message: 'There was an unknown server error. Please try again later.'
                                }
                            };
                        break;
                }
            });
        },
        /**
         * Start loader, creates get request that starts csr generation. Once approved, config items are
         * loaded and parsed, so change to system.pxgrid.csr will be reflected
         *
         * @returns {Promise.<T>|null}
         */
        generateCsr: function () {
            var ctrl = this;
            // Create an initial cerGen if one does not exist
            ctrl.csrGen = ctrl.csrGen || {
                loader: false,
                inProgress: false
            };
            // If in progress then do nothing
            if (ctrl.csrGen.inProgress) {
                return null;
            }
            // Start loader and raise inprogress flag
            ctrl.csrGen = {
                loader: true,
                inProgress: true
            };
            // initiate get request to start generation
            return this.$http.get(this.BASE_URL + '/pxgrid/generate_csr')
                .then(function () {
                // Load remote config
                return ctrl.remoteAppConfig.initRemoteAppConfig();
            })
                .then(function () {
                // digest remote config
                return ctrl.appConfig.digestRemoteConfig(ctrl.remoteAppConfig.getRemoteConfigList());
            })
                .then(function () {
                // Turn of loader and inprogress flag
                ctrl.csrGen = {
                    loader: false,
                    inProgress: false
                };
                ctrl._reloadSelf();
            })
                .catch(function (err) {
                // On error turn off loader and inprogress and raise error message
                ctrl.csrGen = {
                    loader: true,
                    inProgress: true
                };
                switch (err.status) {
                    default:
                        ctrl.csrGen =
                            {
                                error: {
                                    message: 'There was an unknown server error. Please try again later.'
                                }
                            };
                        break;
                }
            });
        },
        saveFile: function (selectorId, url) {
            // Check if element (or its parent in this case) is disabled. Try-catch to protect against misuse.
            var inputEl = document.getElementById(selectorId);
            try {
                var disabled = inputEl.parentElement.attributes.getNamedItem('disabled');
                if (disabled && disabled.value === 'disabled') {
                    return;
                }
            }
            catch (err) {
                return;
            }
            // Open new Iframe to download
            var iframe = document.createElement('iframe');
            iframe.style.display = "none";
            var html = document.getElementsByTagName('html')[0];
            html.appendChild(iframe);
            iframe.src = url;
        },
        // Open a new iframe that saves the certificate file
        saveCertificate: function (selectorId) {
            this.saveFile(selectorId, this.BASE_URL + '/pxgrid/export?fileType=cer');
        },
        // Open a new iframe that saves the csr file
        saveCsr: function (selectorId) {
            this.saveFile(selectorId, this.BASE_URL + '/pxgrid/export?fileType=csr');
        },
        /**
         * Collect the keys data, pushes it on POST, then if ok, config items are
         * loaded and parsed.
         *
         * @returns {Promise.<T>|*}
         */
        submitKeys: function () {
            var ctrl = this;
            ctrl.loader = true;
            ctrl.error = {};
            var base64PemFile = ctrl.pxgridKeys.pemFile;
            var base64CaFile = ctrl.pxgridKeys.caFile;
            var password = ctrl.pxgridKeys.password;
            // Fire update
            var destinationPath;
            var body = {};
            switch (ctrl.generation_form_type) {
                case 'self-signed':
                    destinationPath = ctrl.BASE_URL + '/pxgrid/generate_keys';
                    body = {
                        base64PemFile: base64PemFile,
                        password: password
                    };
                    break;
                case 'ca-keys':
                    destinationPath = ctrl.BASE_URL + '/pxgrid/generate_ca_keys';
                    body = {
                        base64PemFile: base64PemFile,
                        base64CaFile: base64CaFile,
                        password: password
                    };
                    break;
            }
            return this.$http.post(destinationPath, body)
                .then(function () {
                // Load remote config
                return ctrl.remoteAppConfig.initRemoteAppConfig();
            })
                .then(function () {
                // digest remote config
                return ctrl.appConfig.digestRemoteConfig(ctrl.remoteAppConfig.getRemoteConfigList());
            })
                .then(function () {
                ctrl.loader = false;
                ctrl._reloadSelf();
            })
                .catch(function () {
                ctrl.loader = false;
                ctrl.error = {
                    display: true,
                    title: 'Server Error',
                    description: 'An unknown server error has prevented pxGrid keys generation. ' +
                        'Please try again later.'
                };
            });
        },
        /**
         * Uploads a cer file to server
         *
         * @param {HTMLElement} inputElement
         */
        uploadCertFile: function (inputElement) {
            var ctrl = this;
            ctrl.loader = true;
            ctrl.error = {};
            // Make sure a file was chosen
            if (inputElement.files.length !== 0) {
                // Start a promise chain
                ctrl.$q(function (resolve, reject) {
                    // Create a reader to read the file. Resolve on data. Reject on error.
                    var reader = new FileReader();
                    reader.onload = function () {
                        resolve(btoa(reader.result));
                    };
                    reader.onerror = function (err) {
                        console.log(err);
                        reject(err);
                    };
                    reader.readAsBinaryString(inputElement.files[0]);
                })
                    .then(function (data) {
                    // Create a POST request with the data
                    return ctrl.$http.post(ctrl.BASE_URL + '/pxgrid/update_cer', {
                        base64CerFile: data
                    });
                })
                    .then(function () {
                    // Load remote config
                    return ctrl.remoteAppConfig.initRemoteAppConfig();
                })
                    .then(function () {
                    // digest remote config
                    return ctrl.appConfig.digestRemoteConfig(ctrl.remoteAppConfig.getRemoteConfigList());
                })
                    .then(function () {
                    // Turn off loader and reload state
                    ctrl.loader = false;
                    ctrl._reloadSelf();
                })
                    .catch(function (err) {
                    // Turn on error message
                    ctrl.loader = false;
                    ctrl.error = {
                        display: true,
                        title: 'Server Error',
                        description: 'An unknown server error has prevented file upload. ' +
                            'Please try again later.'
                    };
                });
            }
        },
        /**
         * Control's init function
         *
         * @private
         */
        _init: function () {
            //this._setFileInputsInvalid();
            this._getPXGridConfigItems();
            this._addStateWatchers();
        }
    });
    PxgridConfigurationController.$inject = ['$scope', 'dependencyMounter', '$stateParams'];
    angular.module('Fortscale.layouts.pxgridConfiguration')
        .controller('PxgridConfigurationController', PxgridConfigurationController);
}());

(function () {
    'use strict';
    angular.module("Fortscale.layouts.pxgridConfiguration")
        .config([
        '$stateProvider',
        function ($stateProvider) {
            $stateProvider
                .state('pxgridConfiguration', {
                url: '/pxgrid-configuration/:certificateFlow/:generationFlow',
                templateUrl: 'app/layouts/pxgrid-configuration/pxgrid-configuration.html',
                controller: 'PxgridConfigurationController',
                controllerAs: 'pxgridCtrl'
            });
        }
    ]);
}());

(function () {
    'use strict';
    angular.module('Fortscale.analytics', [])
        .run(['fsAnalytics', function (fsAnalytics) {
            fsAnalytics.init();
        }]);
}());

(function () {
    'use strict';
    function FsUUID() {
        this._s4 = function () {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        };
        this.generateUUID = function () {
            return this._s4() + this._s4() + this._s4() + this._s4();
        };
    }
    angular.module('Fortscale.analytics')
        .service('fsUUID', FsUUID);
}());

(function () {
    'use strict';
    /**
     *
     * @param {string} computerId UUID
     * @param {string} tabId UUID
     * @param {string} eventType
     * @param {string} stateName
     * @param {number} timeStamp
     * @constructor
     */
    function AbstractEventDetails(computerId, tabId, eventType, stateName, timeStamp) {
        this.computerId = computerId;
        this.tabId = tabId;
        this.eventType = eventType;
        this.stateName = stateName;
        this.timeStamp = timeStamp;
    }
    /**
     *
     * @param {string} computerId UUID
     * @param {string} tabId UUID
     * @param {string} eventType
     * @param {string} stateName
     * @param {number} timeStamp
     * @param {string} elementSelector
     * @constructor
     */
    function EventDetails(computerId, tabId, eventType, stateName, timeStamp, elementSelector) {
        AbstractEventDetails.call(this, computerId, tabId, eventType, stateName, timeStamp);
        this.elementSelector = elementSelector;
    }
    /**
     *
     * @param {string} computerId UUID
     * @param {string} tabId UUID
     * @param {string} stateName
     * @param {number} timeStamp
     * @param {string} toState
     * @constructor
     */
    function StateChangeDetails(computerId, tabId, stateName, timeStamp, toState) {
        AbstractEventDetails.call(this, computerId, tabId, 'stateChange', stateName, timeStamp);
        this.toState = toState;
    }
    /**
     *
     * @param {string} computerId UUID
     * @param {string} tabId UUID
     * @param {string} stateName
     * @param {number} timeStamp
     * @param {string} fileName
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @param {string} message
     * @param {string} stack
     * @constructor
     */
    function ErrorDetails(computerId, tabId, stateName, timeStamp, fileName, lineNumber, columnNumber, message, stack) {
        AbstractEventDetails.call(this, computerId, tabId, 'error', stateName, timeStamp);
        this.fileName = fileName;
        this.lineNumber = lineNumber;
        this.columnNumber = columnNumber;
        this.message = message;
        this.stack = stack;
    }
    function FsAnalytics($q, $window, $state, fsUUID, $rootScope, fsIndexedDBService, BASE_URL, $http, appConfig) {
        var service = this;
        // Predetermined immutable values
        service._CONFIG_CONTAINER_NAME = 'system.analytics';
        service._CONFIG_ALLOW_NAME = 'allowAnalytics';
        service._CONFIG_UPDATE_EVENTS_NUM_NAME = 'updateEventsNum';
        service._DB_NAME = 'Fortscale';
        service._ANALYTICS_STORE_NAME = 'analytics';
        service._ANALYTICS_STORE_INDEX_NAME = 'timestamp';
        service._ANALYTICS_STORE_DB_CONFIG = { keyPath: 'id', autoIncrement: true };
        service._ANALYTICS_INDICES = [
            { indexName: 'timestamp', keyPath: 'timeStamp', options: { unique: true } }
        ];
        service._ANALYTICS_DB_REV = 251;
        service._ANALYTICS_REST_PATH = BASE_URL + '/analytics';
        service._MAX_ITEMS_BEFORE_UPLOAD_DEFAULT = 10;
        // Predetermined values
        service._isBlocked = true;
        service._actionsQue = [];
        service._isCatastrophicFailure = false;
        service._setServiceBlock = function (state) {
            service._isBlocked = state;
        };
        service._getServiceBlock = function () {
            return service._isBlocked;
        };
        /**
         * Returns the selector of an element. It recursively climbs up until it can find an id on the element,
         * or a two class and up class list.
         *
         * @param {HTMLElement} element
         * @param {string=} selector
         * @returns {string}
         * @private
         */
        service._getElementSelector = function (element, selector) {
            // Initiates selector if required
            selector = selector || '';
            // extract tag
            var tag = element.tagName;
            // extract id
            var id = element.id ? '#' + element.id : '';
            // extract class list
            var classList = Array.from(element.classList);
            // remove all ng class names
            classList = classList.filter(function (classItem) {
                return !/^ng-/.test(classItem);
            });
            // Extract class names
            var className = classList.length ? '.' + classList.join('.') : '';
            // Remove any ids and classes from html
            if (tag.toLowerCase() === 'html') {
                className = '';
                id = '';
            }
            // Predicate for end (or continuation) of recursion
            if (id !== '' || classList.length >= 2 || !element.parentElement) {
                return tag + id + className + selector;
            }
            else {
                return service._getElementSelector(element.parentElement) + '>' + tag + id + className + selector;
            }
        };
        /**
         * Factory. Creates a new EventDetails instance.
         *
         * @param {Event} evt
         * @returns {EventDetails}
         * @private
         */
        service._createEventDetails = function (evt) {
            var element = evt.target;
            var eventType = evt.type;
            var stateName = $state.current.name;
            var timeStamp = moment.utc().valueOf();
            return new EventDetails(service._computerId, service._tabId, eventType, stateName, timeStamp, service._getElementSelector(element));
        };
        /**
         * Factory. Create an ErrorDetails instance.
         *
         * @param {Event|ErrorEvent} evt
         * @returns {ErrorDetails}
         * @private
         */
        service._createErrorDetails = function (evt) {
            return new ErrorDetails(service._computerId, service._tabId, $state.current.name, moment.utc().valueOf(), evt.filename, evt.lineno, evt.colno, evt.message, evt.error.stack);
        };
        /**
         * Factory. Creates a StateChangeDetails instance
         *
         * @param toState
         * @param fromState
         * @returns {StateChangeDetails}
         * @private
         */
        service._createStateChangeDetails = function (toState, fromState) {
            return new StateChangeDetails(service._computerId, service._tabId, fromState.name, moment.utc().valueOf(), toState.name);
        };
        /**
         * Used (usually after each update to db) to count number of elements in table. If number exceeds
         * MAX_ITEMS_BEFORE_UPLOAD, the service is temporarily blocked, and all items in table are uploaded to server.
         * The items are then deleted from table.
         *
         * @returns {Promise.<T>|*}
         * @private
         */
        service._tentativeUpload = function () {
            // Count number of items
            return fsIndexedDBService.count(service._db, service._ANALYTICS_STORE_NAME, service._ANALYTICS_STORE_INDEX_NAME)
                .then(function (count) {
                // find max items
                var maxItems = appConfig.getConfigValue(service._CONFIG_CONTAINER_NAME, service._CONFIG_UPDATE_EVENTS_NUM_NAME) || service._MAX_ITEMS_BEFORE_UPLOAD_DEFAULT;
                // If number of items exceed _MAX_ITEMS_BEFORE_UPLOAD the begin upload flow
                if (maxItems < count) {
                    service._setServiceBlock(true);
                    // Get all items
                    return fsIndexedDBService.findAll(service._db, service._ANALYTICS_STORE_NAME)
                        .then(function (events) {
                        // Upload all items
                        return $http.post(service._ANALYTICS_REST_PATH, { analyticEvents: events });
                    })
                        .then(function (res) {
                        // delete all items from table
                        return fsIndexedDBService.deleteAll(service._db, service._ANALYTICS_STORE_NAME);
                    })
                        .then(function (res) {
                        // Release service and fire _activateActionsQue
                        service._setServiceBlock(false);
                        return service._activateActionsQue();
                    });
                }
                // return null if count is less then _MAX_ITEMS_BEFORE_UPLOAD
                return null;
            })
                .catch(function (err) {
                console.error(err);
                service._setServiceBlock(false);
                return service._activateActionsQue();
            });
        };
        /**
         * Handler for new event details
         * @param evt
         * @returns {boolean}
         * @private
         */
        service._standardHandler = function (evt) {
            if (!appConfig.getConfigValue(service._CONFIG_CONTAINER_NAME, service._CONFIG_ALLOW_NAME)) {
                return false;
            }
            var eventDetails = service._createEventDetails(evt);
            service._writeEventToStore(eventDetails);
            return true;
        };
        /**
         * Handler for new error event details
         * @param evt
         * @returns {boolean}
         * @private
         */
        service._errorHandler = function (evt) {
            if (!appConfig.getConfigValue(service._CONFIG_CONTAINER_NAME, service._CONFIG_ALLOW_NAME)) {
                return false;
            }
            var errorDetails = service._createErrorDetails(evt);
            service._writeEventToStore(errorDetails);
            return true;
        };
        /**
         * Handler for new state change event details
         * @param {angular.Event} evt
         * @param {string} toState
         * @param {Array<*>} toParams
         * @param {string} fromState
         * @returns {boolean}
         * @private
         */
        service._stateChangeHandler = function (evt, toState, toParams, fromState) {
            if (!appConfig.getConfigValue(service._CONFIG_CONTAINER_NAME, service._CONFIG_ALLOW_NAME)) {
                return false;
            }
            var stateChangeDetails = service._createStateChangeDetails(toState, fromState);
            service._writeEventToStore(stateChangeDetails);
            return true;
        };
        /**
         * Adds a click handler
         *
         * @private
         */
        service._addClickListener = function () {
            $window.addEventListener('click', service._standardHandler, true);
        };
        /**
         * Adds a right click handler
         *
         * @private
         */
        service._addContextMenuListener = function () {
            $window.addEventListener('contextmenu', service._standardHandler, true);
        };
        /**
         * Adds an error handler
         *
         * @private
         */
        service._addErrorListener = function () {
            $window.addEventListener('error', service._errorHandler, true);
        };
        /**
         * Adds a state change handler
         *
         * @private
         */
        service._addStateChangeListener = function () {
            $rootScope.$on('$stateChangeSuccess', service._stateChangeHandler);
        };
        /**
         * Opens or creates a database and store.
         *
         * @private
         */
        service._openDB = function () {
            service._setServiceBlock(true);
            fsIndexedDBService.openDb(service._DB_NAME, service._ANALYTICS_STORE_NAME, service._ANALYTICS_STORE_DB_CONFIG, service._ANALYTICS_INDICES, service._ANALYTICS_DB_REV)
                .then(function (db) {
                service._db = db;
            })
                .then(function () {
                service._setServiceBlock(false);
                service._activateActionsQue();
            })
                .catch(function (err) {
                // what you gonna do when they come for you
                service._setServiceBlock(true);
                service._isCatastrophicFailure = true;
                console.warn('Analytics catastrophic failure. DB could not be created. Service dropped.', err);
            });
        };
        /**
         * Takes a function and arguments array and adds to actions que.
         *
         * @param {function} fn
         * @param {array<*>} args
         * @private
         */
        service._addToActionsQue = function (fn, args) {
            service._actionsQue.unshift({ fn: fn, args: args });
        };
        /**
         * Activates the actions que. ACtion is removed from the top (last item) and is invoked with correlating
         * arguments. After promise is resolved, the method is called recursively until the que is empty.
         *
         * @returns {Promise.<T>|*}
         * @private
         */
        service._activateActionsQue = function () {
            // Create and return a promise
            return $q(function (resolve, reject) {
                // Check if que has length ot if service is blocked. If so reject on 'blocked'
                if (!service._actionsQue.length || service._getServiceBlock()) {
                    return reject('blocked');
                }
                // Get the top action
                var actionQue = service._actionsQue.pop();
                // Block service
                service._setServiceBlock(true);
                // Resolve on result of invoked action.
                resolve(actionQue.fn.apply(service, actionQue.args));
            })
                .then(function () {
                // Free service
                service._setServiceBlock(false);
                // Fire the method recursively if there are more actions
                if (service._actionsQue.length) {
                    return service._activateActionsQue();
                }
            })
                .catch(function (err) {
                // If err is 'blocked' then its not a 'real' error, but a way to defer until service will be freed
                if (err !== 'blocked') {
                    // When error is not 'blocked' then free service, log error to console, and fire the method
                    // recursively if there are more actions
                    service._setServiceBlock(false);
                    console.log('fs-analytics: _activateActionsQue: ', err);
                    if (service._actionsQue.length) {
                        return service._activateActionsQue();
                    }
                }
            });
        };
        /**
         * Adds object to database
         *
         * @param evt
         * @returns {Promise}
         * @private
         */
        service._addObjectToDB = function (evt) {
            return fsIndexedDBService.addObject(service._db, service._ANALYTICS_STORE_NAME, evt);
        };
        /**
         * Writes an event to local store
         *
         * @param evt
         * @private
         */
        service._writeEventToStore = function (evt) {
            // When catastrophic failure has occurred (such as no db) then the service is disabled.
            if (service._isCatastrophicFailure) {
                return;
            }
            // Add _addObjectToDB to que
            service._addToActionsQue(service._addObjectToDB, [evt]);
            // Add _tentativeUpload to que
            service._addToActionsQue(service._tentativeUpload, []);
            // If service is not blocked, then fire _activateActionsQue
            if (!service._getServiceBlock()) {
                return service._activateActionsQue();
            }
        };
        /**
         * Creates or returns existing computer id. (Computer id is generated randomly once and stored on localStorage)
         * @private
         */
        service._getComputerId = function () {
            // Create computer id key (to be used in local storage)
            var computerIdKey = [service._DB_NAME, service._ANALYTICS_STORE_NAME, 'computerId'].join('.');
            // Get the computer id
            var computerId = localStorage.getItem(computerIdKey);
            // If no computer id is found, generate one, and store it.
            if (!computerId) {
                computerId = fsUUID.generateUUID();
                localStorage.setItem(computerIdKey, computerId);
            }
            return computerId;
        };
        /**
         * Controller's initiation flow.
         */
        service.init = function () {
            service._computerId = service._getComputerId();
            service._tabId = fsUUID.generateUUID();
            service._addClickListener();
            service._addContextMenuListener();
            service._addErrorListener();
            service._addStateChangeListener();
            service._openDB();
        };
    }
    FsAnalytics.$inject =
        ['$q', '$window', '$state', 'fsUUID', '$rootScope', 'fsIndexedDBService', 'BASE_URL', '$http', 'appConfig'];
    angular.module('Fortscale.analytics')
        .service('fsAnalytics', FsAnalytics);
}());

//# sourceMappingURL=index-main.3.0.0.js.map
