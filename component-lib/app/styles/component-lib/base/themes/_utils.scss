/**
 * @file Themes utilities
 * Functions and mixins useful for supporting multiple themes in Sass.
 * @public
 */

/**
 * Reads a value from a given map and nested map key path.
 * Equivalent to calling the native map-get() multiple times.
 *
 * @example
 * ```
 * $map1: (
 *   foo: 1,
 *   bar: (
 *     baz: 2,
 *     bat: 3
 *   )
 * );
 *
 * // equivalent to map-get($map, 'foo'),
 * // conceptually analogous to `$map1.foo` in javascript:
 * $temp: map-deep-get($map1, 'foo');  // yields 1
 *
 * // conceptually analogous to `$map1.bar.baz` in javascript:
 * $temp: map-deep-get($map1, 'bar', 'baz');  // yields 2
 * ```
 *
 * @param {Map} $map The map to be read.
 * @param {ArgList} $keys One or more map keys which together define the map path to be read.
 * @returns {*} The requested map value.
 * @public
 */
@function map-deep-get($map, $keys...) {
  $val: $map;
  @each $key in $keys {
    @if $val {
      $val: map-get($val, $key);
    }
  }
  @return $val;
}

/**
 * Global storage of all registered theme configurations., keyed by theme id strings.
 *
 * $themes is a map with 2 keys "all" and "current".

 * The value in the "all" key is a nested map which contains all the registered themes. Each key in $themes.all is
 * a theme id string. Each value in $themes.all is a map which defines a set of key-value pairs for the theme.
 * Nested key-value pairs are supported.
 *
 * The value in the "current" key is also a map.  It is a temporary iteration variable that is set at run-time, while SASS generates
 * the output for each of the themes. It is conceptually analogous to the `current` var in the following javascript:
 * ```js
 * for (key in themes.all) {
 *   current = themes.all[key];
 *   ..
 * }
 * ```
 * It is assigned a value at run-time by the `themify` mixin as it iterates over all the registered themes while
 * generating CSS output for each of them. Once `themify` is done iterating, it resets `current` back to `null`.
 *
 * @example
 * ```
 * $themes: (
 *   all: (
 *     light: (
 *       primary: white,
 *       secondary: rgb(153,153,153),
 *       ..,
 *       images: (
 *         logo: url('images/light/logo.png'),
 *         ..
 *       )
 *     ),
 *     dark: (
 *       primary: black,
 *       secondary: rgb(51,51,51),
 *       ..,
 *       images: (
 *         logo: url('images/dark/logo.png'),
 *         ..
 *       )
 *     ),
 *     ..
 *   ),
 *   current: null
 * );
 * ```
 *
 * @type Map
 * @default () empty Map
 * @public
 */
$themes: (
  all: (),
  current: null
);

/**
 * Adds a given theme config inside the global `$themes` under a given id.
 * If a theme config is already found under the given key, the given config will be merged on top of the
 * pre-existing config (common sub-keys will be overwritten).
 * @param {String} $id The key under which to store the given theme config.
 * @param {Map} $config The theme configuration. See `$themes.all` for a sample data structure.
 * @returns null
 * @public
 */
@function register-theme($id, $config) {
  $all: map-get($themes, 'all');

  /* Do we already have a theme under the given id? */
  $old: map-get($themes, $id);
  @if $old {

    /* Yes, previous theme found. Merge on top of it. */
    $config: map-merge($old, $config);
  }

  $all: map-merge($all, ($id: $config));
  $themes: map-merge($themes, (all: $all)) !global;
  @return null;
}

/**
 * Accessor for the current theme being iterated on.
 *
 * Call this function from any content that is passed into `themify` in order to access the values of a theme
 * configuration as `themify` iterates over every one of the registered themes.
 *
 * @assumes `$themes.current` holds a reference to the current theme, which this function will then read from.
 * Calling this function outside of `themify` will fail, as `$themes.current` will be `null`.
 *
 * @param {ArgList} $keys One or more map keys which together define the map path to be read.
 * @returns {*} The requested value from the current theme map.
 * @public
 */
@function theme-get($keys...) {
  $current: map-get($themes, 'current');
  @return map-deep-get($current, $keys...)
}

/**
 * Given a block of CSS content, generates multiple copies of the content, one per registered theme.
 *
 * The generated content will be wrapped in a selector that includes whatever CSS selector was used to
 * wrap the `themify` call.
 *
 * @example
 * The following invocation:
 * ```
 * .my-button {
 *   @include themify() {
 *     color: theme-get('primary');
 *     background-color: theme-get('secondary');
 *     background-image: theme-get('images', 'logo');
 *     font: theme-get('some', 'undefined', 'path');
 *   }
 * }
 * ```
 * would produce the following output if we have previously called `register-theme()` for `light` & `dark`:
 * ```
 * .light .my-button {
 *   color: white;
 *   background-color: rgb(153,153,153);
 *   background-image: url('images/light/logo.png');
 * }
 * .dark .my-button {
 *   color: black;
 *   background-color: rgb(51,51,51);
 *   background-image: url('images/dark/logo.png');
 * }
 * ```
 * Note that `font` was omitted from the output because it called `theme-get` with an undefined path.
 *
 * @assumes All registered themes are at in the global map $themes.all.
 * @assumes The global variable $themes.current should be used to iterate over the registered themes.
 *
 * @warning Since this mixin will output multiple copies of its given content, we should only call it with
 * content that is theme-specific. Avoid calling it with hard-coded content such as properties whose values are
 * constant across all themes, for those values will be repeated once per theme in the output, thus bloating the CSS.
 * @public
 */
@mixin themify($themes: $themes) {
  $all: map-get($themes, 'all');
  @each $themeid, $thememap in $all {
    .#{$themeid} &  {

      // Set global $themes.current
      $themes: map-merge($themes, (current: $thememap)) !global;

      // Yield the consumer's conent
      @content;

      // Reset global $themes.current back to null
      $themes: map-merge($themes, (current: null)) !global;
    }
  }
}