import { lookup } from 'ember-dependency-lookup';
import * as LEXEMES from 'investigate-events/constants/lexemes';
import * as GRAMMAR from 'investigate-events/constants/grammar';
import { relevantOperators } from 'investigate-events/util/possible-operators';

const VALUE_TYPES = [
  LEXEMES.INTEGER,
  LEXEMES.FLOAT,
  LEXEMES.STRING,
  LEXEMES.IPV4_ADDRESS,
  LEXEMES.IPV6_ADDRESS,
  LEXEMES.MAC_ADDRESS
];

const VALUE_TYPE_MAP = {
  UInt8: LEXEMES.INTEGER,
  UInt16: LEXEMES.INTEGER,
  UInt32: LEXEMES.INTEGER,
  UInt64: LEXEMES.INTEGER,
  UInt128: LEXEMES.INTEGER,
  Int8: LEXEMES.INTEGER,
  Int16: LEXEMES.INTEGER,
  Int32: LEXEMES.INTEGER,
  Int64: LEXEMES.INTEGER,
  Float32: LEXEMES.FLOAT,
  Float64: LEXEMES.FLOAT,
  Text: LEXEMES.STRING,
  IPv4: LEXEMES.IPV4_ADDRESS,
  IPv6: LEXEMES.IPV6_ADDRESS,
  MAC: LEXEMES.MAC_ADDRESS
};

/**
 * The Parser takes a list of tokens produced by the scanner and uses that
 * to produce meaningful data.
 */
class Parser {
  /**
   * Returns a new `Parser` based off the provided token list.
   * @param {Array} tokens - The array of tokens generated by the Scanner.
   * @param {Array} availableMeta - The language array defining available meta
   * @public
   */
  constructor(tokens, availableMeta, aliases) {
    // The array of tokens we parse into a structure
    this.tokens = tokens;
    // The list of available meta
    this.availableMeta = availableMeta;
    // The list of aliases which would otherwise break type enforcement
    this.aliases = aliases;
    // Indicates the next token to examine
    this.current = 0;
  }

  /**
   * Use when you expect a certain token or one of a few token typess to be next.
   * If successful, returns that token. Otherwise, throws an error.
   * @param {Array} types - An array containing one or more typess expected next
   * @private
   */
  _consume(types) {
    const typeString = types === LEXEMES.OPERATOR_TYPES ? 'OPERATOR' : types.join(',');
    if (this._isAtEnd()) {
      throw new Error(`Expected token of type ${typeString} but reached the end of the input`);
    }
    const nextTypeIsOk = types.some((type) => {
      return type === this._peek().type;
    });
    if (!nextTypeIsOk) {
      throw new Error(`Expected token of type ${typeString} but got type ${this._peek().type}`);
    }
    return this._advance();
  }

  /**
   * Returns true if any one of the passed in types matches the next token
   * @param {Array} types - An array of lexeme types to check for.
   * @private
   */
  _nextTokenIsOfType(types) {
    if (this._isAtEnd()) {
      return false;
    }
    return types.some((type) => this._peek().type === type);
  }

  /**
   * Returns the next token without advancing `current`.
   * @private
   */
  _peek() {
    return this.tokens[this.current];
  }

  /**
   * Returns the next *next* token without advancing `current`.
   * @private
   */
  _peekNext() {
    return this.tokens[this.current + 1];
  }

  /**
   * Returns the next token and advances `current`.
   * @private
   */
  _advance() {
    return this.tokens[this.current++];
  }

  /**
   * Returns `true` if all tokens have been consumed.
   * @private
   */
  _isAtEnd() {
    return this.current >= this.tokens.length;
  }

  /**
   * Used to pass text that should become complex pills from the parser
   * to outside where the data is turned to pills.
   * @param {string} text The complex filter text
   * @private
   */
  _createComplexString(text) {
    return {
      type: GRAMMAR.COMPLEX_FILTER,
      text
    };
  }

  /**
   * Returns an object that contains the meta and the operator, if they pass
   * validation. Otherwise, return null.
   * @param {Object} meta The meta config object
   * @param {Object} operator The operator object
   * @private
   */
  _validateMetaAndOperator(meta, operator) {
    if (this.availableMeta && this.availableMeta.length > 0) {
      const metaConfig = this.availableMeta.find((m) => {
        return m.metaName === Parser.transformToString(meta);
      });
      if (!metaConfig) {
        // Meta not recognized
        return null;
      // sessionid is a special meta key that should be used even though it is indexed by none
      } else if (metaConfig.isIndexedByNone && metaConfig.metaName !== 'sessionid') {
        // Meta not indexed
        return null;
      } else {
        // Check that the operator applies to the meta
        const possibleOperators = relevantOperators(metaConfig);
        const operatorString = Parser.transformToString(operator);
        const operatorConfig = possibleOperators.find((o) => o.displayName === operatorString);
        if (!operatorConfig) {
          // Operator does not apply to meta
          return null;
        }
        return { metaConfig, operatorConfig };
      }
    }
    // If no availableMeta, return empty object
    return {};
  }

  /**
   * Returns true if the meta value(s) is/are valid, false otherwise. Can also
   * return a validationError object. Does a check of the aliases dictionary to
   * see if the cause of an invalid type is use of an alias.
   * @param {GRAMMAR.META_VALUE_RANGE} range The value range object
   * @param {String} expectedType The expected type of the value range
   * @private
   */
  _isValueTypeInvalid(range, expectedType, meta) {
    const i18n = lookup('service:i18n');
    const { aliases } = this;
    const valuesToCheck = range.value ? [ range.value ] : [ range.from, range.to ];
    let result = null;
    const isInvalid = valuesToCheck.some((value) => {
      if (value.type !== expectedType) {
        if (aliases[meta.text]) {
          // The call to Object.values().some() returns true if the text given is a
          // valid alias. Return the negation of that, because this function
          // returns true if invalid.
          return !Object.values(aliases[meta.text]).some((text) => {
            return value.text.toLowerCase() === text.toLowerCase();
          });
        } else {
          // Type mismatch but no aliases, invalid
          return true;
        }
      }
      // No type mismatch
      if (expectedType === LEXEMES.IPV4_ADDRESS) {
        if (value.cidr === 'empty') {
          result = i18n.t('queryBuilder.validationMessages.cidrBad');
          return true;
        } else if (isNaN(value.cidr)) {
          result = i18n.t('queryBuilder.validationMessages.cidrBad');
          return true;
        } else if (value.cidr < 0 || value.cidr > 32) {
          result = i18n.t('queryBuilder.validationMessages.cidrIpv4OutOfRange');
          return true;
        }
      }
      return false;
    });
    return result || isInvalid;
  }

  /**
   * Returns true if the singular value or both ends of a range are >= 1
   * @param {GRAMMAR.META_VALUE_RANGE} range The value range object
   */
  _isValuePositive(range) {
    if (range.value) {
      return range.value.text[0] !== '-' && parseInt(range.value.text, 10) > 0;
    } else {
      return range.from.text[0] !== '-' || range.to.text[0] !== '-' &&
        parseInt(range.from.text, 10) > 0 && parseInt(range.to.text, 10) > 0;
    }
  }

  /**
   * Parses the list of tokens into a syntax tree.
   * @public
   */
  parse() {
    return this._whereClause();
  }

  // ---------- Nonterminals & Terminals ----------

  /**
   * The top level nonterminal.
   * @private
   */
  _whereClause() {
    const result = this._whereCriteria();
    if (!this._isAtEnd()) {
      // If we come out of whereCriteria and more tokens are still left, they
      // should not be there.
      const unexpectedTokensString = this.tokens
        .slice(this.current)
        .map((t) => t.text)
        .join(' ');
      // Remaining tokens become one complex pill
      result.children.push({ type: LEXEMES.AND, text: '&&' }, this._createComplexString(unexpectedTokensString));
    }
    return result;
  }

  /**
   * Returns a GRAMMAR.WHERE_CRITERIA, which has a property `children` that
   * contains one guaranteed criteria or group, followed optionally by 0 or more
   * groups of logical operators with additional groups or criteria.
   * e.g. (criteriaOrGroup, [logicalOperator, criteriaOrGroup]*) where the group
   * of logicalOperator followed by criteriaOrGroup is repeated 0 or more times.
   * The criteria or group will haves types of GRAMMAR.CRITERIA or GRAMMAR.GROUP
   * respectively, while the logical operators will be of type LEXEMES.OR or LEXEMES.AND.
   * @private
   */
  _whereCriteria() {
    const result = {
      type: GRAMMAR.WHERE_CRITERIA,
      children: [ this._criteriaOrGroupOrTextFilter() ]
    };
    while (this._nextTokenIsOfType([ LEXEMES.AND, LEXEMES.OR ])) {
      const operator = this._advance();
      const nextCriteriaOrGroup = this._criteriaOrGroupOrTextFilter();
      result.children.push(operator, nextCriteriaOrGroup);
    }
    return result;
  }

  /**
   * Returns a GRAMMAR.GROUP if it sees a left paren, otherwise returns
   * a GRAMMAR.CRITERIA.
   * @private
   */
  _criteriaOrGroupOrTextFilter() {
    if (this._nextTokenIsOfType([ LEXEMES.LEFT_PAREN ])) {
      return this._group();
    } else if (this._nextTokenIsOfType([ LEXEMES.TEXT_FILTER ])) {
      // Just return the text filter
      return this._advance();
    } else {
      return this._criteria();
    }
  }

  /**
   * A group is anything in parenthesis, which is then parsed
   * recursively as if it were its own top level element and then
   * placed inside a group.
   * @private
   */
  _group() {
    this._consume([ LEXEMES.LEFT_PAREN ]);
    const inside = this._whereCriteria();
    this._consume([ LEXEMES.RIGHT_PAREN ]);
    return {
      type: GRAMMAR.GROUP,
      group: inside
    };
  }

  /**
   * A criteria is the common "meta operator value" form. If the operator is
   * unary (exists & !exists), no value is present on the returned object.
   * Otherwise, the object contains a meta, operator, and valueRanges.
   * valueRanges is an array of values, where each value can either be
   * a range or a single value. i.e. "medium = 12,50-60,88" would be interpreted
   * as a criteria where the meta is "medium", the operator is "=", and valueRanges
   * is an array with 3 items. The first item is GRAMMAR.META_VALUE with the `value`
   * property of "12", the second is a GRAMMAR.META_VALUE_RANGE with the properties
   * `from: 50` and `to: 60`, and the third item would be another GRAMMAR.META_VALUE
   * with a `value` of 88.
   * @private
   */
  _criteria() {
    let returnComplex = false;
    const meta = this._consume([ LEXEMES.META ]);
    const operator = this._consume(LEXEMES.OPERATOR_TYPES);
    // Check that this is a valid meta key & operator
    const configs = this._validateMetaAndOperator(meta, operator);
    if (configs === null) {
      // Error somewhere in validation, make complex, but wait until we know
      // what kind of value we'll be returning.
      returnComplex = true;
    }
    const { metaConfig, operatorConfig } = configs || {};

    // Unary operators (exists & !exists) do not have values, so push them
    // without a `valueRanges` property
    if (operator.text === 'exists' || operator.text === '!exists') {
      if (this._nextTokenIsOfType(VALUE_TYPES)) {
        // Can't have values after unary operators. Pull them out of the queue
        // and put them in a complex pill
        const metaValueRanges = this._metaValueRanges();
        const { valueRanges } = metaValueRanges;
        const criteria = {
          type: GRAMMAR.CRITERIA,
          meta,
          operator,
          valueRanges
        };
        return this._createComplexString(Parser.transformToString(criteria));
      }
      const criteria = { type: GRAMMAR.CRITERIA, meta, operator };
      // If we need to return a complex pill, take what we read in and transform it back to a string.
      return returnComplex ? this._createComplexString(Parser.transformToString(criteria)) : criteria;
    } else {
      const metaValueRanges = this._metaValueRanges();
      const { valueRanges } = metaValueRanges;
      let { validationError } = metaValueRanges;
      // Check to make sure all the values have the correct type
      let expectedType;
      if (metaConfig) {
        expectedType = VALUE_TYPE_MAP[metaConfig.format];
      }
      // The length operator is the only operator that requires a value of a type
      // different than what is associated with the meta key
      let isLengthOperator = false;
      if (operatorConfig && operatorConfig.displayName === 'length') {
        isLengthOperator = true;
        expectedType = LEXEMES.INTEGER;
      }
      // Find any value that is the incorrect type
      const hasInvalidValue = valueRanges.some((range) => {
        if (!expectedType) {
          return false;
        }
        let isInvalid = this._isValueTypeInvalid(range, expectedType, meta);
        if (typeof isInvalid !== 'boolean') {
          // isValueTypeInvalid will return a validation error if the value is
          // invalid, save it and set isInvalid to true.
          validationError = isInvalid;
          isInvalid = true;
        }
        // If using length & types were valid, check for negative or zero
        if (isLengthOperator && !isInvalid) {
          isInvalid = !this._isValuePositive(range);
        }
        return isInvalid;
      });
      const i18n = lookup('service:i18n');
      if (isLengthOperator && hasInvalidValue) {
        // If the operator is `length` and we saw an invalid value, it was because
        // we did not see an integer, but the normal validation message would say it
        // was expecting a string, so change that.
        validationError = i18n.t('queryBuilder.validationMessages.length');
      }
      if (hasInvalidValue) {
        validationError = validationError || i18n.t(`queryBuilder.validationMessages.${metaConfig.format.toLowerCase()}`);
        const criteria = {
          type: GRAMMAR.CRITERIA,
          meta,
          operator,
          valueRanges,
          isInvalid: true,
          validationError
        };
        return returnComplex ? this._createComplexString(Parser.transformToString(criteria)) : criteria;
      } else {
        const criteria = {
          type: GRAMMAR.CRITERIA,
          meta,
          operator,
          valueRanges
        };
        return returnComplex ? this._createComplexString(Parser.transformToString(criteria)) : criteria;
      }
    }
  }

  /**
   * Parses everything following the operator in a criteria. Makes one call to
   * `_metaValueRange` for everything separated by a comma (`LEXEMES.VALUE_SEPARATOR`).
   * @private
   */
  _metaValueRanges() {
    const valueRanges = [];
    const metaValueRange = this._metaValueRange();
    const { range, validationError } = metaValueRange;
    valueRanges.push(range);
    while (this._nextTokenIsOfType([ LEXEMES.VALUE_SEPARATOR ])) {
      // As long as the UI does not support shorthand, throw this error to get complex pills.
      // Once support is included, uncomment the rest of this block.
      throw new Error('Value shorthand is not yet supported');
      // // Consume the range separator
      // this._advance();
      // // Add the new range to the array
      // const { nextRange, nextValidationError } = this._metaValueRange();
      // validationError = validationError || nextValidationError;
      // valueRanges.push(nextRange);
    }
    return {
      valueRanges,
      validationError
    };
  }

  /**
   * Parses a single value or a single range. If a `-` is present (`LEXEMES.HYPHEN`),
   * return a GRAMMAR.META_VALUE_RANGE with a `from` and `to` field. Otherwise, return
   * a GRAMMAR.META_VALUE with a `value` field.
   * @private
   */
  _metaValueRange() {
    const { value, validationError } = this._metaValue();
    if (this._nextTokenIsOfType([ LEXEMES.HYPHEN ])) {
      // As long as the UI does not support shorthand, throw this error to get complex pills.
      // Once support is included, uncommend the rest of this block.
      throw new Error('Value shorthand is not yet supported');
      // // Consume the range token first
      // this._consume([ LEXEMES.HYPHEN ]);
      // const { to, validationError2 } = this._metaValue();
      // return {
      //   range: {
      //     type: GRAMMAR.META_VALUE_RANGE,
      //     from: value,
      //     to
      //   },
      //   validationError: validationError || validationError2
      // };
    } else {
      return {
        range: {
          type: GRAMMAR.META_VALUE,
          value
        },
        validationError
      };
    }
  }

  /**
   * Parses a single value. Can combine a HYPHEN with an INTEGER or FLOAT to
   * produce a negative number.
   * @private
   */
  _metaValue() {
    let validationError = null;
    let value;
    if (this._nextTokenIsOfType([ LEXEMES.HYPHEN ])) {
      // Hyphen before value is a negative number. Make sure a number is next.
      // Consume hyphen
      this._advance();
      if (!this._nextTokenIsOfType([ LEXEMES.INTEGER, LEXEMES.FLOAT ])) {
        const i18n = lookup('service:i18n');
        validationError = i18n.t('queryBuilder.validationMessages.negative');
      } else {
        // Capture value
        value = this._advance();
        // Make value negative
        value.text = `-${value.text}`;
      }
    } else if (this._nextTokenIsOfType([ LEXEMES.IPV4_ADDRESS ])) {
      value = this._advance();
      // Negative number, amend the token
      if (this._nextTokenIsOfType([ LEXEMES.HYPHEN ]) && this._peekNext() && this._peekNext().type === LEXEMES.INTEGER) {
        this._advance(); // Consume hyphen
        const num = this._advance();
        value.cidr = parseInt(`-${num.text}`, 10);
        value.text += `${value.cidr}`;
      }
    } else {
      value = this._advance();
    }
    return { value, validationError };
  }

  /**
   * Turns any valid structure produced by the Parser back into
   * a query string.
   * @public
   * @static
   */
  static transformToString(tree) {
    // Alias this method so it doesn't create super long expressions inside
    const ts = Parser.transformToString;
    switch (tree.type) {
      case GRAMMAR.WHERE_CRITERIA:
        // Take each child, perform transformToString on them, then join together
        return tree.children.map(ts).join('');
      case GRAMMAR.CRITERIA:
        if (tree.valueRanges) {
          return `${ts(tree.meta)} ${ts(tree.operator)} ${tree.valueRanges.map(ts).join(',')}`;
        } else {
          return `${ts(tree.meta)} ${ts(tree.operator)}`;
        }
      case GRAMMAR.GROUP:
        return `(${ts(tree.group)})`;
      case GRAMMAR.META_VALUE:
        return ts(tree.value);
      case GRAMMAR.META_VALUE_RANGE:
        return `${ts(tree.from)}-${ts(tree.to)}`;
      case LEXEMES.AND:
      case LEXEMES.OR:
        return ` ${tree.text} `;
      case LEXEMES.STRING:
        return `'${tree.text}'`;
      default:
        return tree.text;
    }
  }
}

export default Parser;
